<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ mq-context.xml
  ~ Copyright (c) 2013. Washington University School of Medicine
  ~ All Rights Reserved
  ~
  ~ Released under the Simplified BSD License
  -->

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:amq="http://activemq.apache.org/schema/core"
       xmlns:jms="http://www.springframework.org/schema/jms"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd
			http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd">

    <!-- TODO: Taken from TIP implementation. All comments reference Evan's work there. Make XNAT-y general and remove this TODO. -->

    <!-- embedded ActiveMQ Broker -->
    <amq:broker id="activeMQBroker" brokerName="activeMQBroker" useJmx="false" persistent="true" schedulerSupport="false">
        <amq:persistenceAdapter>
            <!-- We'll use XNAT's data source, make sure the Spring ID matches. (For unit testing it's provided by the Spring test
                context) Also, turning off locking, as we've no need for it with a single broker, and it was causing errors in the ActiveMQ
                cleanup threads. -->
            <amq:jdbcPersistenceAdapter dataSource="#dataSource" useLock="false" />
        </amq:persistenceAdapter>
    </amq:broker>

    <!-- ActiveMQ ConnectionFactory for JMS to use. Spring will find and use the broker we've declared above. -->
    <amq:connectionFactory id="activeMQConnectionFactory" brokerURL="vm://localhost" redeliveryPolicy="#activeMQRedeliveryPolicy" />

    <!-- supposedly you can make this a property on the connection factory or queue, but this way was the only way that worked -->
    <!-- The queue specified in "destination" just has to exist, it will be ignored and the message will go to the default system DLQ -->
    <amq:redeliveryPolicy id="activeMQRedeliveryPolicy" useExponentialBackOff="true"
                          initialRedeliveryDelay="300000" backOffMultiplier="3" maximumRedeliveries="4" destination="#sessionXmlRebuilderRequest" />

    <!-- lets wrap in a pool to avoid creating a connection per send -->
    <bean name="springConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory">
        <property name="targetConnectionFactory" ref="activeMQConnectionFactory" />
    </bean>

    <!-- Spring JMS Template -->
    <bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">
        <property name="connectionFactory" ref="springConnectionFactory" />
    </bean>

    <!-- queues -->
    <amq:queue id="sessionXmlRebuilderRequest" physicalName="sessionXmlRebuilderRequest" />

    <!-- message consumers -->
    <bean id="sessionXmlRebuilderRequestListener" class="org.nrg.xnat.helpers.prearchive.SessionXmlRebuilderRequestListener" />
    <bean id="dlqMessageListener" class="org.nrg.framework.messaging.DlqListener">
        <property name="messageListenerMapping">
            <description>
                This maps MQ request types with the listener class and handler method that should handle that request.
                This lets the dead-letter functionality properly re-try MQ requests. In future versions, we should get
                the per-queue dead-letter handling to work and make the general dead-letter function handle only unknown
                or improperly formed MQ requests.
            </description>
            <map>
                <entry key="org.nrg.xnat.helpers.prearchive.SessionXmlRebuilderRequest" value="org.nrg.xnat.helpers.prearchive.SessionXmlRebuilderRequestListener.onSessionXmlRebuilderRequest"/>
            </map>
        </property>
    </bean>

    <!-- Spring JMS Listener Container -->
    <jms:listener-container connection-factory="springConnectionFactory" concurrency="10" acknowledge="transacted">
        <jms:listener destination="sessionXmlRebuilderRequest" ref="sessionXmlRebuilderRequestListener" method="onSessionXmlRebuilderRequest" />
        <!-- I tried referencing my own DLQ in the redelivery policy but ActiveMQ ignores it and uses the default system DLQ -->
        <!-- So we'll just listen on that queue instead -->
        <jms:listener destination="ActiveMQ.DLQ" ref="dlqMessageListener" method="onReceiveDeadLetter" />
    </jms:listener-container>

</beans>
