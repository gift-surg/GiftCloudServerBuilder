/*
 * org.nrg.xnat.utils.CatalogUtils
 * XNAT http://www.xnat.org
 * Copyright (c) 2013, Washington University School of Medicine
 * All Rights Reserved
 *
 * Released under the Simplified BSD.
 *
 * Last modified 8/19/13 1:47 PM
 */
package org.nrg.xnat.utils;

import com.google.common.collect.Lists;
import com.twmacinta.util.MD5;
import org.apache.log4j.Logger;
import org.nrg.config.entities.Configuration;
import org.nrg.config.exceptions.ConfigServiceException;
import org.nrg.xdat.XDAT;
import org.nrg.xdat.bean.*;
import org.nrg.xdat.bean.base.BaseElement;
import org.nrg.xdat.bean.reader.XDATXMLReader;
import org.nrg.xdat.model.*;
import org.nrg.xdat.om.*;
import org.nrg.xdat.security.XDATUser;
import org.nrg.xft.XFTTable;
import org.nrg.xft.event.EventMetaI;
import org.nrg.xft.event.EventUtils;
import org.nrg.xft.security.UserI;
import org.nrg.xft.utils.FileUtils;
import org.nrg.xft.utils.StringUtils;
import org.nrg.xft.utils.zip.TarUtils;
import org.nrg.xft.utils.zip.ZipI;
import org.nrg.xft.utils.zip.ZipUtils;
import org.nrg.xnat.helpers.resource.XnatResourceInfo;
import org.nrg.xnat.presentation.ChangeSummaryBuilderA;
import org.nrg.xnat.restlet.util.FileWriterWrapperI;
import org.xml.sax.SAXException;

import java.io.*;
import java.net.URI;
import java.net.URLDecoder;
import java.nio.channels.FileLock;
import java.util.*;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipOutputStream;

/**
 * @author timo
 */
@SuppressWarnings("deprecation")
public class CatalogUtils {

    public static boolean DEFAULT_CHECKSUM = true;
    public final static String[] FILE_HEADERS = {"Name", "Size", "URI", "collection", "file_tags", "file_format", "file_content", "cat_ID"};
    public final static String[] FILE_HEADERS_W_FILE = {"Name", "Size", "URI", "collection", "file_tags", "file_format", "file_content", "cat_ID", "file"};

    public static boolean getChecksumConfiguration(final XnatProjectdata project) throws ConfigServiceException {
        Configuration configuration = XDAT.getConfigService().getConfig("checksums", "checksums", (long) (Integer) project.getItem().getProps().get("projectdata_info"));

        if (configuration != null) {
            String checksumProperty = XDAT.getSiteConfigurationProperty("checksums");
            if (!org.apache.commons.lang.StringUtils.isBlank(checksumProperty)) {
                return Boolean.parseBoolean(checksumProperty);
            }
        }

        return getChecksumConfiguration();
    }

    public static boolean getChecksumConfiguration() throws ConfigServiceException {
        String checksumProperty = XDAT.getSiteConfigurationProperty("checksums");
        if (!org.apache.commons.lang.StringUtils.isBlank(checksumProperty)) {
            return Boolean.parseBoolean(checksumProperty);
        }
        return DEFAULT_CHECKSUM;
    }

    public static void calculateResourceChecksums(final CatCatalogI cat, final File f) {
        for (CatEntryI entry : cat.getEntries_entry()) {
        	CatalogUtils.setChecksum(entry, f.getParent());
        }
    }
    
    /**
     * Set digest field on entry with corresponding MD5
     * @param entry CatEntryI for operation
     * @param path Path to catalog (used for relative paths)
     * @return true if entry was modified, false if not.
     */
    private static boolean setChecksum(final CatEntryI entry, final String path){
    	if(StringUtils.IsEmpty(entry.getDigest())){//this should only occur if the MD5 isn't already there.
        	final File file= CatalogUtils.getFile(entry, path);//this will allow absolute paths to be functional.  Catalogs are sometimes generated by client tools. They may not stay relative to the catalog, as XNAT would make them.
        	if(file!=null && file.exists()){//fail safe to missing files, maybe the files haven't been put in place yet...
	            try {
	                String checksum = MD5.asHex(MD5.getHash(file));
	                entry.setDigest(checksum);
	                return true;
	            } catch (IOException e) {
	                //
	            }
        	}
    	}
    	
    	return false;
    }

    public static List<Object[]> getEntryDetails(CatCatalogI cat, String parentPath, String uriPath, XnatResource _resource, boolean includeFile, final CatEntryFilterI filter, XnatProjectdata proj, String locator) {
        final ArrayList<Object[]> al = new ArrayList<Object[]>();
        for (final CatCatalogI subset : cat.getSets_entryset()) {
            al.addAll(getEntryDetails(subset, parentPath, uriPath, _resource, includeFile, filter, proj, locator));
        }

        final int ri = (includeFile) ? 9 : 8;

        //final int ri=(includeFile)?14:13;

        for (final CatEntryI entry : cat.getEntries_entry()) {
            if (filter == null || filter.accept(entry)) {
                final Object[] row = new Object[ri];
                final String entryPath = StringUtils.ReplaceStr(FileUtils.AppendRootPath(parentPath, entry.getUri()), "\\", "/");
                final File f = getFileOnLocalFileSystem(entryPath);
                row[0] = (f.getName());
                if (includeFile) {
                    row[1] = 0;
                } else {
                    row[1] = (f.length());
                }
                if (locator.equalsIgnoreCase("URI")) {
                    if (FileUtils.IsAbsolutePath(entry.getUri())) {
                        row[2] = uriPath + "/" + entry.getId();
                    } else {
                        row[2] = uriPath + "/" + entry.getUri();
                    }
                } else if (locator.equalsIgnoreCase("absolutePath")) {
                    row[2] = entryPath;
                } else if (locator.equalsIgnoreCase("projectPath")) {
                    row[2] = entryPath.substring(proj.getRootArchivePath().substring(0, proj.getRootArchivePath().lastIndexOf(proj.getId())).length());
                }
                row[3] = _resource.getLabel();
                row[4] = "";
                for (CatEntryMetafieldI meta : entry.getMetafields_metafield()) {
                    if (!row[4].equals("")) row[4] = row[4] + ",";
                    row[4] = row[4] + meta.getName() + "=" + meta.getMetafield();
                }
                for (CatEntryTagI tag : entry.getTags_tag()) {
                    if (!row[4].equals("")) row[4] = row[4] + ",";
                    row[4] = row[4] + tag.getTag();
                }
                row[5] = entry.getFormat();
                row[6] = entry.getContent();
                row[7] = _resource.getXnatAbstractresourceId();
                if (includeFile) row[8] = f;
                al.add(row);
            }
        }

        return al;
    }

    /**
     * Takes a size of a file or heap of memory in the form of a long and returns a formatted readable version in the
     * form of byte units. For example, 46 would become 46B, 1,024 would become 1KB, 1,048,576 would become 1MB, etc.
     * @param size    The size in bytes to be formatted.
     * @return A formatted string representing the byte size.
     */
    public static String formatSize(long size) {
        if (size < 1024) {
            return size + " B";
        }
        int exp = (int) (Math.log(size) / Math.log(1024));
        return String.format("%.1f %sB", size / Math.pow(1024, exp), "KMGTPE".charAt(exp - 1));
    }

    /**
     * Formats an object's file statistics for display.
     * @param label        The label of the object (session, scan, resource, etc.)
     * @param fileCount    The number of files that compose the object.
     * @param rawSize      The size of the files that compose the object.
     * @return A formatted display of the file statistics.
     */
    public static String formatFileStats(final String label, final long fileCount, final Object rawSize) {
        long size = 0;
        if (rawSize != null) {
            if (rawSize instanceof Integer) {
                size = (Integer) rawSize;
            } else if (rawSize instanceof Long) {
                size = (Long) rawSize;
            }
        }
        if (label == null || label.equals("") || label.equalsIgnoreCase("total")) {
            return String.format("%s in %s files", formatSize(size), fileCount);
        }
        return String.format("%s: %s in %s files", label, formatSize(size), fileCount);
    }

    public interface CatEntryFilterI {
        public boolean accept(final CatEntryI entry);
    }

    public static CatEntryI getEntryByFilter(final CatCatalogI cat, final CatEntryFilterI filter) {
        CatEntryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getEntryByFilter(subset, filter);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            try {
                if (filter.accept(entry)) {
                    return entry;
                }
            } catch (Exception e1) {
                logger.error(e1);
            }
        }

        return null;
    }

    public static Collection<CatEntryI> getEntriesByFilter(final CatCatalogI cat, final CatEntryFilterI filter) {
        List<CatEntryI> entries = new ArrayList<CatEntryI>();

        for (CatCatalogI subset : cat.getSets_entryset()) {
            entries.addAll(getEntriesByFilter(subset, filter));
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            try {
                if (filter == null || filter.accept(entry)) {
                    entries.add(entry);

                }
            } catch (Exception e1) {
                logger.error(e1);
            }
        }

        return entries;
    }

    public static CatCatalogI getCatalogByFilter(final CatCatalogI cat) {
        CatCatalogI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getCatalogByFilter(subset);
            if (e != null) return e;
        }

        return null;
    }

    public static List<File> getFiles(CatCatalogI cat, String parentPath) {
        List<File> al = new ArrayList<File>();
        for (CatCatalogI subset : cat.getSets_entryset()) {
            al.addAll(getFiles(subset, parentPath));
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            String entryPath = StringUtils.ReplaceStr(FileUtils.AppendRootPath(parentPath, entry.getUri()), "\\", "/");
            File f = getFileOnLocalFileSystem(entryPath);

            if (f != null)
                al.add(f);
        }

        return al;
    }

    /**
     * Gets file from file system.  This method supports relative or absolute paths in the CatEntryI. It also supports files that are gz'd on the file system, but don't include .gz in the catalog URI (this used to be very common).
     * 
     * @param entry Catalog Entry for file to be retrieved
     * @param parentPath Path to catalog file directory
     * @return File object represented by CatEntryI
     */
    public static File getFile(CatEntryI entry, String parentPath) {
        String entryPath = StringUtils.ReplaceStr(FileUtils.AppendRootPath(parentPath, entry.getUri()), "\\", "/");
        return getFileOnLocalFileSystem(entryPath);
    }

    public static Stats getFileStats(CatCatalogI cat, String parentPath) {
        return new Stats(cat, parentPath);
    }

    public static class Stats {
        public int count;
        public long size;

        public Stats(CatCatalogI cat, String parentPath) {
            count = 0;
            size = 0;
            for (final File f : getFiles(cat, parentPath)) {
                if (f != null && f.exists() && !f.getName().endsWith("catalog.xml")) {
                    count++;
                    size += f.length();
                }
            }
        }
    }

    public static Collection<CatEntryI> getEntriesByRegex(final CatCatalogI cat, String regex) {
        List<CatEntryI> entries = new ArrayList<CatEntryI>();
        for (CatCatalogI subset : cat.getSets_entryset()) {
            entries.addAll(getEntriesByRegex(subset, regex));
        }
        for (CatEntryI entry : cat.getEntries_entry()) {
            try {
                if (entry.getUri().matches(regex)) {
                    entries.add(entry);
                }
            } catch (Exception e1) {
                logger.error(e1);
            }
        }
        return entries;
    }

    public static CatEntryI getEntryByURI(CatCatalogI cat, String name) {
        CatEntryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getEntryByURI(subset, name);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            try {
                String decoded = URLDecoder.decode(name);
                if (entry.getUri().equals(name) || entry.getUri().equals(decoded)) {
                    return entry;
                }
            } catch (Exception e1) {
                logger.error(e1);
            }
        }

        return null;
    }

    public static CatEntryI getEntryByName(CatCatalogI cat, String name) {
        CatEntryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getEntryByName(subset, name);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            String decoded = URLDecoder.decode(name);
            if (entry.getName().equals(name) || entry.getName().equals(decoded)) {
                return entry;
            }
        }

        return null;
    }

    public static CatEntryI getEntryById(CatCatalogI cat, String name) {
        CatEntryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getEntryById(subset, name);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            if (entry.getId().equals(name)) {
                return entry;
            }
        }

        return null;
    }

    public static CatDcmentryI getDCMEntryByUID(CatCatalogI cat, String uid) {
        CatDcmentryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getDCMEntryByUID(subset, uid);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            if (entry instanceof CatDcmentryI && ((CatDcmentryI) entry).getUid().equals(uid)) {
                return (CatDcmentryI) entry;
            }
        }

        return null;
    }

    public static CatDcmentryI getDCMEntryByInstanceNumber(CatCatalogI cat, Integer num) {
        CatDcmentryI e;
        for (CatCatalogI subset : cat.getSets_entryset()) {
            e = getDCMEntryByInstanceNumber(subset, num);
            if (e != null) return e;
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            if (entry instanceof CatDcmentryI && ((CatDcmentryI) entry).getInstancenumber().equals(num)) {
                return (CatDcmentryI) entry;
            }
        }

        return null;
    }

    public static File getFileOnLocalFileSystem(String fullPath) {
        File f = new File(fullPath);
        if (!f.exists()) {
            if (!fullPath.endsWith(".gz")) {
                f = new File(fullPath + ".gz");
                if (!f.exists()) {
                    return null;
                }
            } else {
                return null;
            }
        }

        return f;
    }

    public static void configureEntry(final CatEntryBean newEntry, final XnatResourceInfo info, boolean modified) {
        if (info.getDescription() != null) {
            newEntry.setDescription(info.getDescription());
        }
        if (info.getFormat() != null) {
            newEntry.setFormat(info.getFormat());
        }
        if (info.getContent() != null) {
            newEntry.setContent(info.getContent());
        }
        if (info.getTags().size() > 0) {
            for (final String entry : info.getTags()) {
                final CatEntryTagBean t = new CatEntryTagBean();
                t.setTag(entry);
                newEntry.addTags_tag(t);
            }
        }
        if (info.getMeta().size() > 0) {
            for (final Map.Entry<String, String> entry : info.getMeta().entrySet()) {
                final CatEntryMetafieldBean meta = new CatEntryMetafieldBean();
                meta.setName(entry.getKey());
                meta.setMetafield(entry.getValue());
                newEntry.addMetafields_metafield(meta);
            }
        }

        if (modified) {
            if (info.getUser() != null && newEntry.getModifiedby() == null) {
                newEntry.setModifiedby(info.getUser().getUsername());
            }
            if (info.getLastModified() != null) {
                newEntry.setModifiedtime(info.getLastModified());
            }
            if (info.getEvent_id() != null && newEntry.getModifiedeventid() == null) {
                newEntry.setModifiedeventid(info.getEvent_id().toString());
            }
        } else {
            if (info.getUser() != null && newEntry.getCreatedby() == null) {
                newEntry.setCreatedby(info.getUser().getUsername());
            }
            if (info.getCreated() != null && newEntry.getCreatedtime() == null) {
                newEntry.setCreatedtime(info.getCreated());
            }
            if (info.getEvent_id() != null && newEntry.getCreatedeventid() == null) {
                newEntry.setCreatedeventid(info.getEvent_id().toString());
            }
        }

    }

    public static void configureEntry(final XnatResource newEntry, final XnatResourceInfo info, final XDATUser user) throws Exception {
        if (info.getDescription() != null) {
            newEntry.setDescription(info.getDescription());
        }
        if (info.getFormat() != null) {
            newEntry.setFormat(info.getFormat());
        }
        if (info.getContent() != null) {
            newEntry.setContent(info.getContent());
        }
        if (info.getTags().size() > 0) {
            for (final String entry : info.getTags()) {
                final XnatAbstractresourceTag t = new XnatAbstractresourceTag((UserI) user);
                t.setTag(entry);
                newEntry.setTags_tag(t);
            }
        }
        if (info.getMeta().size() > 0) {
            for (final Map.Entry<String, String> entry : info.getMeta().entrySet()) {
                final XnatAbstractresourceTag t = new XnatAbstractresourceTag((UserI) user);
                t.setTag(entry.getValue());
                t.setName(entry.getKey());
                newEntry.setTags_tag(t);
            }
        }
    }

    public static boolean storeCatalogEntry(final FileWriterWrapperI fi, String dest, final XnatResourcecatalog catResource, final XnatProjectdata proj, final boolean extract, final XnatResourceInfo info, final boolean overwrite, final EventMetaI ci) throws Exception {
        final File catFile = catResource.getCatalogFile(proj.getRootArchivePath());
        final String parentPath = catFile.getParent();
        final CatCatalogBean cat = catResource.getCleanCatalog(proj.getRootArchivePath(), false, null, null);

        String filename = fi.getName();

        int index = filename.lastIndexOf('\\');
        if (index < filename.lastIndexOf('/')) {
            index = filename.lastIndexOf('/');
        }

        if (index > 0) {
            filename = filename.substring(index + 1);
        }

        if (StringUtils.IsEmpty(dest)) {
            dest = filename;
        } else if (dest.startsWith("/")) {
            dest = dest.substring(1);
        }

        String compression_method = ".zip";
        if (filename.contains(".")) {
            compression_method = filename.substring(filename.lastIndexOf("."));
        }

        if (extract && (compression_method.equalsIgnoreCase(".tar") || compression_method.equalsIgnoreCase(".gz") || compression_method.equalsIgnoreCase(".zip") || compression_method.equalsIgnoreCase(".zar"))) {
            File destinationDir = catFile.getParentFile();
            final InputStream is = fi.getInputStream();

            ZipI zipper;
            if (compression_method.equalsIgnoreCase(".tar")) {
                zipper = new TarUtils();
            } else if (compression_method.equalsIgnoreCase(".gz")) {
                zipper = new TarUtils();
                zipper.setCompressionMethod(ZipOutputStream.DEFLATED);
            } else {
                zipper = new ZipUtils();
            }

            @SuppressWarnings("unchecked")
            final List<File> files = zipper.extract(is, destinationDir.getAbsolutePath(), overwrite, ci);

            for (final File f : files) {
                if (!f.isDirectory()) {
                    final String relative = destinationDir.toURI().relativize(f.toURI()).getPath();

                    final CatEntryI e = getEntryByURI(cat, relative);

                    if (e == null) {
                        final CatEntryBean newEntry = new CatEntryBean();
                        newEntry.setUri(relative);
                        newEntry.setName(f.getName());

                        configureEntry(newEntry, info, false);

                        cat.addEntries_entry(newEntry);
                    }
                }
            }
        } else {
            File parentFolder = new File(parentPath);
            if (!org.apache.commons.lang.StringUtils.isBlank(fi.getNestedPath())) {
                dest = makePath(fi.getNestedPath(), fi.getName());
            }

            final File saveTo = new File(parentFolder, (dest != null) ? dest : filename);

            if (saveTo.exists() && !overwrite) {
                throw new IOException("File already exists" + saveTo.getCanonicalPath());
            } else if (saveTo.exists()) {
                final CatEntryBean e = (CatEntryBean) getEntryByURI(cat, dest);

                CatalogUtils.moveToHistory(catFile, saveTo, e, ci);
            }

            if (!saveTo.getParentFile().mkdirs() && !saveTo.getParentFile().exists()) {
                throw new Exception("Failed to create required directory: " + saveTo.getParentFile().getAbsolutePath());
            }

            fi.write(saveTo);

            if (saveTo.isDirectory()) {
                @SuppressWarnings("unchecked")
                final Iterator<File> iter = org.apache.commons.io.FileUtils.iterateFiles(saveTo, null, true);
                while (iter.hasNext()) {
                    final File movedF = iter.next();

                    String relativePath = FileUtils.RelativizePath(saveTo, movedF).replace('\\', '/');
                    if (dest != null) {
                        relativePath = dest + "/" + relativePath;
                    }
                    updateEntry(cat, relativePath, movedF, info, ci);
                }

            } else {
                updateEntry(cat, dest, saveTo, info, ci);
            }
        }

        writeCatalogToFile(cat, catFile);

        return true;
    }

    private static String makePath(String nestedPath, String name) {
        String separator = nestedPath.contains("\\") ? "\\" : "/";
        StringBuilder path = new StringBuilder(nestedPath);
        if (!nestedPath.endsWith(separator)) {
            path.append(separator);
        }
        return path.append(name).toString();
    }

    public static void refreshAuditSummary(CatCatalogI cat) {
        CatCatalogMetafieldI field = null;
        for (CatCatalogMetafieldI mf : cat.getMetafields_metafield()) {
            if ("AUDIT".equals(mf.getName())) {
                field = mf;
                break;
            }
        }

        if (field == null) {
            field = new CatCatalogMetafieldBean();
            field.setName("AUDIT");
            try {
                cat.addMetafields_metafield(field);
            } catch (Exception ignored) {
            }
        }


        field.setMetafield(convertAuditToString(buildAuditSummary(cat)));
    }

    public static Map<String, Map<String, Integer>> retrieveAuditySummary(CatCatalogI cat) {
        if (cat == null) return new HashMap<String, Map<String, Integer>>();
        CatCatalogMetafieldI field = null;
        for (CatCatalogMetafieldI mf : cat.getMetafields_metafield()) {
            if ("AUDIT".equals(mf.getName())) {
                field = mf;
                break;
            }
        }

        if (field != null) {
            return convertAuditToMap(field.getMetafield());
        } else {
            return buildAuditSummary(cat);
        }

    }

    public static void addAuditEntry(Map<String, Map<String, Integer>> summary, String key, String action, Integer i) {
        if (!summary.containsKey(key)) {
            summary.put(key, new HashMap<String, Integer>());
        }

        if (!summary.get(key).containsKey(action)) {
            summary.get(key).put(action, 0);
        }

        summary.get(key).put(action, summary.get(key).get(action) + i);
    }

    public static void addAuditEntry(Map<String, Map<String, Integer>> summary, Integer eventId, Object d, String action, Integer i) {
        String key = eventId + ":" + d;
        addAuditEntry(summary, key, action, i);
    }

    public static void writeCatalogToFile(CatCatalogI xml, File dest) throws Exception {
        writeCatalogToFile(xml, dest, DEFAULT_CHECKSUM);
    }

    public static void writeCatalogToFile(CatCatalogI xml, File dest, boolean calculateChecksums) throws Exception {
        if (calculateChecksums) {
            CatalogUtils.calculateResourceChecksums(xml, dest);
        }

        if (!dest.getParentFile().exists()) {
            if (!dest.getParentFile().mkdirs() && !dest.getParentFile().exists()) {
                throw new Exception("Failed to create required directory: " + dest.getParentFile().getAbsolutePath());
            }
        }

        refreshAuditSummary(xml);

        final FileOutputStream fos = new FileOutputStream(dest);
        OutputStreamWriter fw;
        try {
            final FileLock fl = fos.getChannel().lock();
            try {
                fw = new OutputStreamWriter(fos);
                xml.toXML(fw);
                fw.flush();
            } finally {
                fl.release();
            }
        } finally {
            fos.close();
        }
    }

    public static File getCatalogFile(final String rootPath, final XnatResourcecatalogI resource) {
        String fullPath = getFullPath(rootPath, resource);
        if (fullPath.endsWith("\\")) {
            fullPath = fullPath.substring(0, fullPath.length() - 1);
        }
        if (fullPath.endsWith("/")) {
            fullPath = fullPath.substring(0, fullPath.length() - 1);
        }


        File f = new File(fullPath);
        if (!f.exists()) {
            f = new File(fullPath + ".gz");
        }

        if (!f.exists()) {
            f = new File(fullPath);

            CatCatalogBean cat = new CatCatalogBean();
            if (resource.getLabel() != null) {
                cat.setId(resource.getLabel());
            } else {
                cat.setId("" + Calendar.getInstance().getTimeInMillis());
            }

            try {
                if (!f.getParentFile().mkdirs() && !f.getParentFile().exists()) {
                    throw new Exception("Failed to create required directory: " + f.getParentFile().getAbsolutePath());
                }

                FileWriter fw = new FileWriter(f);
                cat.toXML(fw, true);
                fw.close();
            } catch (IOException exception) {
                logger.error("Error writing to the folder: " + f.getParentFile().getAbsolutePath(), exception);
            } catch (Exception exception) {
                logger.error("Error creating the folder: " + f.getParentFile().getAbsolutePath(), exception);
            }
        }

        return f;
    }

    public static CatCatalogBean getCatalog(File catF) {
        if (!catF.exists()) return null;
        try {
            InputStream fis = new FileInputStream(catF);
            if (catF.getName().endsWith(".gz")) {
                fis = new GZIPInputStream(fis);
            }

            BaseElement base;

            XDATXMLReader reader = new XDATXMLReader();
            base = reader.parse(fis);

            if (base instanceof CatCatalogBean) {
                return (CatCatalogBean) base;
            }
        } catch (FileNotFoundException e) {
            logger.error("", e);
        } catch (IOException e) {
            logger.error("", e);
        } catch (SAXException e) {
            logger.error("", e);
        }

        return null;
    }

    /**
     * Parses catalog xml for resource and returns the Bean object.  Returns null if not found.
     * @param rootPath
     * @param resource
     * @return
     */
    public static CatCatalogBean getCatalog(String rootPath, XnatResourcecatalogI resource) {
        File catF = null;
        try {
            catF = CatalogUtils.getCatalogFile(rootPath, resource);
            if (catF.getName().endsWith(".gz")) {
                    FileUtils.GUnzipFiles(catF);
                    catF = CatalogUtils.getCatalogFile(rootPath, resource);
            }
        } catch (FileNotFoundException exception) {
            logger.error("File not found at: " + rootPath, exception);
        } catch (IOException exception) {
            logger.error("Error reading file at: " + rootPath, exception);
        } catch (Exception exception) {
            logger.error("Unknown exception reading file at: " + rootPath, exception);
        }

        return catF != null ? getCatalog(catF) : null;
    }

    public static CatCatalogBean getCleanCatalog(String rootPath, XnatResourcecatalogI resource, boolean includeFullPaths) {
        return getCleanCatalog(rootPath, resource, includeFullPaths, null, null);
    }

    public static CatCatalogBean getCleanCatalog(String rootPath, XnatResourcecatalogI resource, boolean includeFullPaths, UserI user, EventMetaI c) {
        File catF = null;
        try {
            catF = handleCatalogFile(rootPath, resource, catF);

            InputStream fis = new FileInputStream(catF);
            if (catF.getName().endsWith(".gz")) {
                fis = new GZIPInputStream(fis);
            }

            BaseElement base;

            XDATXMLReader reader = new XDATXMLReader();
            base = reader.parse(fis);

            String parentPath = catF.getParent();

            if (base instanceof CatCatalogBean) {
                CatCatalogBean cat = (CatCatalogBean) base;
                formalizeCatalog(cat, parentPath, user, c);

                if (includeFullPaths) {
                    CatCatalogMetafieldBean mf = new CatCatalogMetafieldBean();
                    mf.setName("CATALOG_LOCATION");
                    mf.setMetafield(parentPath);
                    cat.addMetafields_metafield(mf);
                }

                return cat;
            }
        } catch (FileNotFoundException exception) {
            logger.error("Couldn't find file " + (catF != null ? "indicated by " + catF.getAbsolutePath() : "of unknown location"), exception);
        } catch (SAXException exception) {
            logger.error("Couldn't parse file " + (catF != null ? "indicated by " + catF.getAbsolutePath() : "of unknown location"), exception);
        } catch (IOException exception) {
            logger.error("Couldn't parse or unzip file " + (catF != null ? "indicated by " + catF.getAbsolutePath() : "of unknown location"), exception);
        } catch (Exception exception) {
            logger.error("Unknown error handling file " + (catF != null ? "indicated by " + catF.getAbsolutePath() : "of unknown location"), exception);
        }

        return null;
    }
    
    /**
     * Reviews existing catalog and adds any missing fields
     * 
     * @param cat Catalog entry to be cleaned
     * @param catPath Path to catalog file (used to access files with relative paths).
     * @param user User in operation
     * @param now Corresponding event
     * @return true if catalog was modified, otherwise false
     */
    public static boolean formalizeCatalog(final CatCatalogI cat, final String catPath, UserI user, EventMetaI now) {
    	return formalizeCatalog(cat, catPath, user, now,false,false);
    	//default to false for checksums for now.  Maybe it should use the default setting for the server.  But, this runs everytime a catalog xml is loaded.  So, it will get re-run over and over.  Not sure we want to add that amount of processing.
    }

    /**
     * Reviews existing catalog and adds any missing fields
     * 
     * @param cat Catalog entry to be cleaned
     * @param catPath Path to catalog file (used to access files with relative paths).
     * @param user User in operation
     * @param now Corresponding event
     * @param createChecksums Boolean whether or not to generate checksums (if missing)
     * @param removeMissingFiles Boolean whether or not to delete references to missing files
     * @return true if catalog was modified, otherwise false
     */
    public static boolean formalizeCatalog(final CatCatalogI cat, final String catPath, UserI user, EventMetaI now,boolean createChecksums,boolean removeMissingFiles) {
        return formalizeCatalog(cat, catPath, cat.getId(), user, now,createChecksums,removeMissingFiles);
    }

    public static String getFullPath(String rootPath, XnatResourcecatalogI resource) {

        String fullPath = StringUtils.ReplaceStr(FileUtils.AppendRootPath(rootPath, resource.getUri()), "\\", "/");
        while (fullPath.contains("//")) {
            fullPath = StringUtils.ReplaceStr(fullPath, "//", "/");
        }

        if (!fullPath.endsWith("/")) {
            fullPath += "/";
        }

        return fullPath;
    }

    public boolean modifyEntry(CatCatalogI cat, CatEntryI oldEntry, CatEntryI newEntry) {
        for (int i = 0; i < cat.getEntries_entry().size(); i++) {
            CatEntryI e = cat.getEntries_entry().get(i);
            if (e.getUri().equals(oldEntry.getUri())) {
                cat.getEntries_entry().remove(i);
                cat.getEntries_entry().add(newEntry);
                return true;
            }
        }

        for (CatCatalogI subset : cat.getSets_entryset()) {
            if (modifyEntry(subset, oldEntry, newEntry)) {
                return true;
            }
        }

        return false;
    }

    public static List<File> findHistoricalCatFiles(File catFile) {
        final List<File> files = new ArrayList<File>();

        final File historyDir = FileUtils.BuildHistoryParentFile(catFile);

        final String name = catFile.getName();

        final FilenameFilter filter = new FilenameFilter() {
            @Override
            public boolean accept(File arg0, String arg1) {
                return (arg1.equals(name));
            }
        };

        if (historyDir.exists()) {
            final File[] historyFiles = historyDir.listFiles();
            if (historyFiles != null) {
                for (File d : historyFiles) {
                    if (d.isDirectory()) {
                        final File[] matched = d.listFiles(filter);
                        if (matched != null && matched.length > 0) {
                            files.addAll(Arrays.asList(matched));
                        }
                    }
                }
            }
        }

        return files;
    }

    public static boolean removeEntry(CatCatalogI cat, CatEntryI entry) {
        for (int i = 0; i < cat.getEntries_entry().size(); i++) {
            CatEntryI e = cat.getEntries_entry().get(i);
            if (e.getUri().equals(entry.getUri())) {
                cat.getEntries_entry().remove(i);
                return true;
            }
        }

        for (CatCatalogI subset : cat.getSets_entryset()) {
            if (removeEntry(subset, entry)) {
                return true;
            }
        }

        return false;
    }

    public static Boolean maintainFileHistory() {
        if (_maintainFileHistory == null) {
            _maintainFileHistory = XDAT.getBoolSiteConfigurationProperty("audit.maintain-file-history", false);
        }
        return _maintainFileHistory;
    }

    public static void moveToHistory(File catFile, File f, CatEntryBean entry, EventMetaI ci) throws Exception {
        //move existing file to audit trail
        if (CatalogUtils.maintainFileHistory()) {
            final File newFile = FileUtils.MoveToHistory(f, EventUtils.getTimestamp(ci));
            addCatHistoryEntry(catFile, newFile.getAbsolutePath(), entry, ci);
        }
    }

    public static void addCatHistoryEntry(File catFile, String f, CatEntryBean entry, EventMetaI ci) throws Exception {
        //move existing file to audit trail
        CatEntryBean newEntryBean = (CatEntryBean) entry.copy();
        newEntryBean.setUri(f);
        if (ci != null) {
            newEntryBean.setModifiedtime(ci.getEventDate());
            if (ci.getEventId() != null) {
                newEntryBean.setModifiedeventid(ci.getEventId().toString());
            }
            if (ci.getUser() != null) {
                newEntryBean.setModifiedby(ci.getUser().getUsername());
            }
        }

        File newCatFile = FileUtils.BuildHistoryFile(catFile, EventUtils.getTimestamp(ci));
        CatCatalogBean newCat;
        if (newCatFile.exists()) {
            newCat = CatalogUtils.getCatalog(newCatFile);
        } else {
            newCat = new CatCatalogBean();
        }

        newCat.addEntries_entry(newEntryBean);

        CatalogUtils.writeCatalogToFile(newCat, newCatFile);
    }

    public static XFTTable populateTable(XFTTable table, XDATUser user, XnatProjectdata proj, boolean cacheFileStats) {
        XFTTable newTable = new XFTTable();
        String[] fields = {"xnat_abstractresource_id", "label", "element_name", "category", "cat_id", "cat_desc", "file_count", "file_size", "tags", "content", "format"};
        newTable.initTable(fields);
        table.resetRowCursor();
        while (table.hasMoreRows()) {
            Object[] old = table.nextRow();
            Object[] _new = new Object[11];
            if (logger.isDebugEnabled()) {
                logger.debug("Found resource with ID: " + old[0] + "(" + old[1] + ")");
            }
            _new[0] = old[0];
            _new[1] = old[1];
            _new[2] = old[2];
            _new[3] = old[3];
            _new[4] = old[4];
            _new[5] = old[5];

            XnatAbstractresource res = XnatAbstractresource.getXnatAbstractresourcesByXnatAbstractresourceId(old[0], user, false);

            if (cacheFileStats) {
                if (res.getFileCount() == null) {
                    res.setFileCount(res.getCount(proj.getRootArchivePath()));
                }
                if (res.getFileSize() == null) {
                    res.setFileSize(res.getSize(proj.getRootArchivePath()));
                }
                try {
                    res.save(user, true, false, null);
                } catch (Exception e) {
                    if (res instanceof XnatResourcecatalog) {
                        logger.error("Failed to save updates to resource catalog: " + res.getLabel());
                    } else {
                        logger.error("Failed to save updates to abstract resource: " + res.getXnatAbstractresourceId());
                    }
                }
            }

            _new[6] = res.getFileCount();
            _new[7] = res.getFileSize();
            _new[8] = res.getTagString();
            _new[9] = res.getContent();
            _new[10] = res.getFormat();

            newTable.rows().add(_new);
        }

        return newTable;
    }

    public static boolean populateStats(XnatAbstractresource abstractResource, String rootPath) {
        Integer c = abstractResource.getCount(rootPath);
        Long s = abstractResource.getSize(rootPath);

        boolean modified = false;

        if (!c.equals(abstractResource.getFileCount())) {
            abstractResource.setFileCount(c);
            modified = true;
        }

        if (!s.equals(abstractResource.getFileSize())) {
            abstractResource.setFileSize(s);
            modified = true;
        }

        return modified;
    }

    private static void updateEntry(CatCatalogBean cat, String dest, File f, XnatResourceInfo info, EventMetaI ci) {
        final CatEntryBean e = (CatEntryBean) getEntryByURI(cat, dest);

        if (e == null) {
            final CatEntryBean newEntry = new CatEntryBean();
            newEntry.setUri(dest);
            newEntry.setName(f.getName());

            configureEntry(newEntry, info, false);

            cat.addEntries_entry(newEntry);
        } else {
            if (ci != null) {
                if (ci.getUser() != null)
                    e.setModifiedby(ci.getUser().getUsername());
                e.setModifiedtime(ci.getEventDate());
                if (ci.getEventId() != null) {
                    e.setModifiedeventid(ci.getEventId().toString());
                }
            }
        }
    }

    private static String convertAuditToString(Map<String, Map<String, Integer>> summary) {
        StringBuilder sb = new StringBuilder();
        int counter1 = 0;
        for (Map.Entry<String, Map<String, Integer>> entry : summary.entrySet()) {
            if (counter1++ > 0) sb.append("|");
            sb.append(entry.getKey()).append("=");
            int counter2 = 0;
            for (Map.Entry<String, Integer> sub : entry.getValue().entrySet()) {
                sb.append(sub.getKey()).append(":").append(sub.getValue());
                if (counter2++ > 0) sb.append(";");
            }

        }
        return sb.toString();
    }

    private static Map<String, Map<String, Integer>> convertAuditToMap(String audit) {
        Map<String, Map<String, Integer>> summary = new HashMap<String, Map<String, Integer>>();
        for (String changeSet : audit.split("|")) {
            String[] split1 = changeSet.split("=");
            if (split1.length > 1) {
                String key = split1[0];
                Map<String, Integer> counts = new HashMap<String, Integer>();
                for (String operation : split1[1].split(";")) {
                    String[] entry = operation.split(":");
                    counts.put(entry[0], Integer.valueOf(entry[1]));
                }
                summary.put(key, counts);
            }
        }
        return summary;
    }

    private static Map<String, Map<String, Integer>> buildAuditSummary(CatCatalogI cat) {
        Map<String, Map<String, Integer>> summary = new HashMap<String, Map<String, Integer>>();
        buildAuditSummary(cat, summary);
        return summary;
    }

    private static void buildAuditSummary(CatCatalogI cat, Map<String, Map<String, Integer>> summary) {
        for (CatCatalogI subSet : cat.getSets_entryset()) {
            buildAuditSummary(subSet, summary);
        }

        for (CatEntryI entry : cat.getEntries_entry()) {
            addAuditEntry(summary, entry.getCreatedeventid(), entry.getCreatedtime(), ChangeSummaryBuilderA.ADDED, 1);

            if (entry.getModifiedtime() != null) {
                addAuditEntry(summary, entry.getModifiedeventid(), entry.getModifiedtime(), ChangeSummaryBuilderA.REMOVED, 1);
            }
        }
    }

    private static File handleCatalogFile(final String rootPath, final XnatResourcecatalogI resource, File catF) throws Exception {
        catF = CatalogUtils.getCatalogFile(rootPath, resource);
        if (catF.getName().endsWith(".gz")) {
            try {
                FileUtils.GUnzipFiles(catF);
                catF = CatalogUtils.getCatalogFile(rootPath, resource);
            } catch (FileNotFoundException e) {
                logger.error("", e);
            } catch (IOException e) {
                logger.error("", e);
            }
        }
        return catF;
    }
        
    /**
     * Reviews the catalog directory and adds any files that aren't already referenced in the catalog.
     * @param catFile path to catalog xml file
     * @param cat content of catalog xml file
     * @param user user for transaction
     * @param event_id event id for transaction
     * @return true if the cat was modified (and needs to be saved).
     */
    public static boolean addUnreferencedFiles(final File catFile, final CatCatalogI cat, XDATUser user,Number event_id){
    	//list of all files in the catalog folder
    	final Collection<File> files=org.apache.commons.io.FileUtils.listFiles(catFile.getParentFile(), null, true);
    	
    	//verify that there is only one catalog xml in this directory
    	//fail if more then one is present -- otherwise they will be merged.
    	for(final File f: files){
    		if(!f.equals(catFile)){
    			if(f.getName().endsWith(".xml")){
    				//this is a bit heavy handed.  
    				//we could parse the xml and confirm it is a catalog
    				//but storing xmls is really rare, so I'm not sure we need to be that specific.
    				return false;
    			}
    		}
    	}
    	
    	//URI object for the catalog folder (used to generate relative file paths)
    	final URI catFolderURI=catFile.getParentFile().toURI();
    	
    	final Date now= Calendar.getInstance().getTime();
    	
    	boolean modified=false;
    	
    	for(final File f: files){
    		if(!f.equals(catFile)){//don't add the catalog xml to its own list
	    		//relative path is used to compare to existing catalog entries, and add it if its missing.  entry paths are relative to the location of the catalog file.
	    		final String relative = catFolderURI.relativize(f.toURI()).getPath();
	
	    		//
	            final CatEntryI e = getEntryByURI(cat, relative);
	
	            if (e == null) {
	                final CatEntryBean newEntry = new CatEntryBean();
	                newEntry.setUri(relative);
	                newEntry.setName(f.getName());
	
	                //create basic resource info to specify file properties at creation.
	                final XnatResourceInfo info = XnatResourceInfo.buildResourceInfo(null, null, null, null, user, now, now, event_id);
	                configureEntry(newEntry, info, false);
	
	                try {
						cat.addEntries_entry(newEntry);
						modified=true;
					} catch (Exception e1) {
						//this shouldn't happen
						logger.error("",e1);
					}
	            }
    			
    		}
    	}
    	
    	return modified;
    }

    private static boolean formalizeCatalog(final CatCatalogI cat, final String catPath, String header, UserI user, EventMetaI now,final boolean createChecksum, final boolean removeMissingFiles) {
        boolean modified = false;

        for (CatCatalogI subSet : cat.getSets_entryset()) {
            if (formalizeCatalog(subSet, catPath, header + "/" + subSet.getId(), user, now,createChecksum, removeMissingFiles)) {
                modified = true;
            }
        }
        
        List<CatEntryI> toRemove=Lists.newArrayList();
        
        for (CatEntryI entry : cat.getEntries_entry()) {
            if (entry.getCreatedby() == null && user != null) {
                entry.setCreatedby(user.getUsername());
                modified = true;
            }
            if (entry.getCreatedtime() == null && now != null) {
                ((CatEntryBean) entry).setCreatedtime(now.getEventDate());
                modified = true;
            }
            if (entry.getCreatedeventid() == null && now != null && now.getEventId() != null) {
                ((CatEntryBean) entry).setCreatedeventid(now.getEventId().toString());
                modified = true;
            }
            
            if(createChecksum){
            	if(CatalogUtils.setChecksum(entry, catPath)){
            		modified=true;
            	}
            }
            
            if (entry.getId() == null || !entry.getId().equals("")) {
                String entryPath = StringUtils.ReplaceStr(FileUtils.AppendRootPath(catPath, entry.getUri()), "\\", "/");
                File f = getFileOnLocalFileSystem(entryPath);
                if (f != null) {
                    entry.setId(header + "/" + f.getName());
                    modified = true;
                } else {
                	if(removeMissingFiles){
                		toRemove.add(entry);
                		modified=true;
                	}else{
                		logger.error("Missing Resource:" + entryPath);
                	}
                }
            }
        }
        
        if(toRemove.size()>0){
        	for(CatEntryI entry:toRemove){
        		CatalogUtils.removeEntry(cat, entry);
        	}
        }

        return modified;
    }

    private static final Logger logger = Logger.getLogger(CatalogUtils.class);

    private static Boolean _maintainFileHistory = null;
}
