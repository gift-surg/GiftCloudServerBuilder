(function(){

if (!window.qx) window.qx = {};

qx.$$start = new Date();

if (!qx.$$environment) qx.$$environment = {};
var envinfo = {"qx.application":"dicomheaderview.Application","qx.debug":false,"qx.debug.databinding":false,"qx.debug.dispose":false,"qx.optimization.basecalls":true,"qx.optimization.strings":true,"qx.optimization.variables":true,"qx.revision":"","qx.theme":"dicomheaderview.theme.Theme","qx.version":"2.0.4"};
for (var k in envinfo) qx.$$environment[k] = envinfo[k];

if (!qx.$$libraries) qx.$$libraries = {};
var libinfo = {"__out__":{"sourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/script"},"csvparser":{"resourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/resource","sourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/script"},"dicomheaderview":{"resourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/resource","sourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/script"},"dicomtag":{"resourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/resource","sourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/script"},"qx":{"resourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/resource","sourceUri":"../../../../scripts/qooxdoo/dicomheaderview/build/script","sourceViewUri":"https://github.com/qooxdoo/qooxdoo/blob/%{qxGitBranch}/framework/source/class/%{classFilePath}#L%{lineNumber}"}};

/* <------- Start Change ----------> */
libinfo.qx.resourceUri=window.serverRoot + "/scripts/qooxdoo/dicomheaderview/build/resource";
/* <------- End Change ----------> */

for (var k in libinfo) qx.$$libraries[k] = libinfo[k];

qx.$$resources = {};
qx.$$translations = {"C":null,"en":null};
qx.$$locales = {"C":null,"en":null};
qx.$$packageData = {};

qx.$$loader = {
  parts : {"boot":[0]},
  packages : {"0":{"uris":["__out__:dicomheaderview.0ffd48d14314.js"]}},
  urisBefore : [],
  cssBefore : [],
  boot : "boot",
  closureParts : {},
  bootIsInline : true,
  addNoCacheParam : true,

  decodeUris : function(compressedUris)
  {
    var libs = qx.$$libraries;
    var uris = [];
    for (var i=0; i<compressedUris.length; i++)
    {
      var uri = compressedUris[i].split(":");
      var euri;
      if (uri.length==2 && uri[0] in libs) {
        var prefix = libs[uri[0]].sourceUri;
        euri = prefix + "/" + uri[1];
      } else {
        euri = compressedUris[i];
      }
      if (qx.$$loader.addNoCacheParam) {
        euri += "?nocache=" + Math.random();
      }
      
      uris.push(euri);
    }
    return uris;
  }
};

function loadScript(uri, callback) {
  var elem = document.createElement("script");
  elem.charset = "utf-8";
  elem.src = uri;
  elem.onreadystatechange = elem.onload = function() {
    if (!this.readyState || this.readyState == "loaded" || this.readyState == "complete") {
      elem.onreadystatechange = elem.onload = null;
      callback();
    }
  };
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(elem);
}

function loadCss(uri) {
  var elem = document.createElement("link");
  elem.rel = "stylesheet";
  elem.type= "text/css";
  elem.href= uri;
  var head = document.getElementsByTagName("head")[0];
  head.appendChild(elem);
}

var isWebkit = /AppleWebKit\/([^ ]+)/.test(navigator.userAgent);

function loadScriptList(list, callback) {
  if (list.length == 0) {
    callback();
    return;
  }
  var item = list.shift();
  loadScript(item,  function() {
    if (isWebkit) {
      // force async, else Safari fails with a "maximum recursion depth exceeded"
      window.setTimeout(function() {
        loadScriptList(list, callback);
      }, 0);
    } else {
      loadScriptList(list, callback);
    }
  });
}

var fireContentLoadedEvent = function() {
  qx.$$domReady = true;
  document.removeEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
};
if (document.addEventListener) {
  document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
}

qx.$$loader.importPackageData = function (dataMap, callback) {
  if (dataMap["resources"]){
    var resMap = dataMap["resources"];
    for (var k in resMap) qx.$$resources[k] = resMap[k];
  }
  if (dataMap["locales"]){
    var locMap = dataMap["locales"];
    var qxlocs = qx.$$locales;
    for (var lang in locMap){
      if (!qxlocs[lang]) qxlocs[lang] = locMap[lang];
      else
        for (var k in locMap[lang]) qxlocs[lang][k] = locMap[lang][k];
    }
  }
  if (dataMap["translations"]){
    var trMap   = dataMap["translations"];
    var qxtrans = qx.$$translations;
    for (var lang in trMap){
      if (!qxtrans[lang]) qxtrans[lang] = trMap[lang];
      else
        for (var k in trMap[lang]) qxtrans[lang][k] = trMap[lang][k];
    }
  }
  if (callback){
    callback(dataMap);
  }
}

qx.$$loader.signalStartup = function ()
{
  qx.$$loader.scriptLoaded = true;
  if (window.qx && qx.event && qx.event.handler && qx.event.handler.Application) {
    qx.event.handler.Application.onScriptLoaded();
    qx.$$loader.applicationHandlerReady = true;
  } else {
    qx.$$loader.applicationHandlerReady = false;
  }
}

// Load all stuff
qx.$$loader.init = function(){
  var l=qx.$$loader;
  if (l.cssBefore.length>0) {
    for (var i=0, m=l.cssBefore.length; i<m; i++) {
      loadCss(l.cssBefore[i]);
    }
  }
  if (l.urisBefore.length>0){
    loadScriptList(l.urisBefore, function(){
      l.initUris();
    });
  } else {
    l.initUris();
  }
}

// Load qooxdoo boot stuff
qx.$$loader.initUris = function(){
  var l=qx.$$loader;
  var bootPackageHash=l.parts[l.boot][0];
  if (l.bootIsInline){
    l.importPackageData(qx.$$packageData[bootPackageHash]);
    l.signalStartup();
  } else {
    loadScriptList(l.decodeUris(l.packages[l.parts[l.boot][0]].uris), function(){
      // Opera needs this extra time to parse the scripts
      window.setTimeout(function(){
        l.importPackageData(qx.$$packageData[bootPackageHash] || {});
        l.signalStartup();
      }, 0);
    });
  }
}
})();

qx.$$packageData['0']={"locales":{"C":{"alternateQuotationEnd":"’","alternateQuotationStart":"‘","cldr_am":"AM","cldr_date_format_full":"EEEE, MMMM d, y","cldr_date_format_long":"MMMM d, y","cldr_date_format_medium":"MMM d, y","cldr_date_format_short":"M/d/yy","cldr_date_time_format_Ed":"d E","cldr_date_time_format_Hm":"HH:mm","cldr_date_time_format_Hms":"HH:mm:ss","cldr_date_time_format_M":"L","cldr_date_time_format_MEd":"E, M/d","cldr_date_time_format_MMM":"LLL","cldr_date_time_format_MMMEd":"E, MMM d","cldr_date_time_format_MMMd":"MMM d","cldr_date_time_format_Md":"M/d","cldr_date_time_format_d":"d","cldr_date_time_format_hm":"h:mm a","cldr_date_time_format_hms":"h:mm:ss a","cldr_date_time_format_ms":"mm:ss","cldr_date_time_format_y":"y","cldr_date_time_format_yM":"M/y","cldr_date_time_format_yMEd":"E, M/d/y","cldr_date_time_format_yMMM":"MMM y","cldr_date_time_format_yMMMEd":"E, MMM d, y","cldr_date_time_format_yMMMd":"MMM d, y","cldr_date_time_format_yMd":"M/d/y","cldr_date_time_format_yQ":"Q y","cldr_date_time_format_yQQQ":"QQQ y","cldr_day_format_abbreviated_fri":"Fri","cldr_day_format_abbreviated_mon":"Mon","cldr_day_format_abbreviated_sat":"Sat","cldr_day_format_abbreviated_sun":"Sun","cldr_day_format_abbreviated_thu":"Thu","cldr_day_format_abbreviated_tue":"Tue","cldr_day_format_abbreviated_wed":"Wed","cldr_day_format_wide_fri":"Friday","cldr_day_format_wide_mon":"Monday","cldr_day_format_wide_sat":"Saturday","cldr_day_format_wide_sun":"Sunday","cldr_day_format_wide_thu":"Thursday","cldr_day_format_wide_tue":"Tuesday","cldr_day_format_wide_wed":"Wednesday","cldr_day_stand-alone_narrow_fri":"F","cldr_day_stand-alone_narrow_mon":"M","cldr_day_stand-alone_narrow_sat":"S","cldr_day_stand-alone_narrow_sun":"S","cldr_day_stand-alone_narrow_thu":"T","cldr_day_stand-alone_narrow_tue":"T","cldr_day_stand-alone_narrow_wed":"W","cldr_month_format_abbreviated_1":"Jan","cldr_month_format_abbreviated_10":"Oct","cldr_month_format_abbreviated_11":"Nov","cldr_month_format_abbreviated_12":"Dec","cldr_month_format_abbreviated_2":"Feb","cldr_month_format_abbreviated_3":"Mar","cldr_month_format_abbreviated_4":"Apr","cldr_month_format_abbreviated_5":"May","cldr_month_format_abbreviated_6":"Jun","cldr_month_format_abbreviated_7":"Jul","cldr_month_format_abbreviated_8":"Aug","cldr_month_format_abbreviated_9":"Sep","cldr_month_format_wide_1":"January","cldr_month_format_wide_10":"October","cldr_month_format_wide_11":"November","cldr_month_format_wide_12":"December","cldr_month_format_wide_2":"February","cldr_month_format_wide_3":"March","cldr_month_format_wide_4":"April","cldr_month_format_wide_5":"May","cldr_month_format_wide_6":"June","cldr_month_format_wide_7":"July","cldr_month_format_wide_8":"August","cldr_month_format_wide_9":"September","cldr_month_stand-alone_narrow_1":"J","cldr_month_stand-alone_narrow_10":"O","cldr_month_stand-alone_narrow_11":"N","cldr_month_stand-alone_narrow_12":"D","cldr_month_stand-alone_narrow_2":"F","cldr_month_stand-alone_narrow_3":"M","cldr_month_stand-alone_narrow_4":"A","cldr_month_stand-alone_narrow_5":"M","cldr_month_stand-alone_narrow_6":"J","cldr_month_stand-alone_narrow_7":"J","cldr_month_stand-alone_narrow_8":"A","cldr_month_stand-alone_narrow_9":"S","cldr_number_decimal_separator":".","cldr_number_group_separator":",","cldr_number_percent_format":"#,##0%","cldr_pm":"PM","cldr_time_format_full":"h:mm:ss a zzzz","cldr_time_format_long":"h:mm:ss a z","cldr_time_format_medium":"h:mm:ss a","cldr_time_format_short":"h:mm a","day":"Day","dayperiod":"AM/PM","era":"Era","hour":"Hour","minute":"Minute","month":"Month","quotationEnd":"”","quotationStart":"“","second":"Second","week":"Week","weekday":"Day of the Week","year":"Year","zone":"Time Zone"},"en":{"alternateQuotationEnd":"’","alternateQuotationStart":"‘","cldr_am":"AM","cldr_date_format_full":"EEEE, MMMM d, y","cldr_date_format_long":"MMMM d, y","cldr_date_format_medium":"MMM d, y","cldr_date_format_short":"M/d/yy","cldr_date_time_format_Ed":"d E","cldr_date_time_format_Hm":"HH:mm","cldr_date_time_format_Hms":"HH:mm:ss","cldr_date_time_format_M":"L","cldr_date_time_format_MEd":"E, M/d","cldr_date_time_format_MMM":"LLL","cldr_date_time_format_MMMEd":"E, MMM d","cldr_date_time_format_MMMd":"MMM d","cldr_date_time_format_Md":"M/d","cldr_date_time_format_d":"d","cldr_date_time_format_hm":"h:mm a","cldr_date_time_format_hms":"h:mm:ss a","cldr_date_time_format_ms":"mm:ss","cldr_date_time_format_y":"y","cldr_date_time_format_yM":"M/y","cldr_date_time_format_yMEd":"E, M/d/y","cldr_date_time_format_yMMM":"MMM y","cldr_date_time_format_yMMMEd":"E, MMM d, y","cldr_date_time_format_yMMMd":"MMM d, y","cldr_date_time_format_yMd":"M/d/y","cldr_date_time_format_yQ":"Q y","cldr_date_time_format_yQQQ":"QQQ y","cldr_day_format_abbreviated_fri":"Fri","cldr_day_format_abbreviated_mon":"Mon","cldr_day_format_abbreviated_sat":"Sat","cldr_day_format_abbreviated_sun":"Sun","cldr_day_format_abbreviated_thu":"Thu","cldr_day_format_abbreviated_tue":"Tue","cldr_day_format_abbreviated_wed":"Wed","cldr_day_format_wide_fri":"Friday","cldr_day_format_wide_mon":"Monday","cldr_day_format_wide_sat":"Saturday","cldr_day_format_wide_sun":"Sunday","cldr_day_format_wide_thu":"Thursday","cldr_day_format_wide_tue":"Tuesday","cldr_day_format_wide_wed":"Wednesday","cldr_day_stand-alone_narrow_fri":"F","cldr_day_stand-alone_narrow_mon":"M","cldr_day_stand-alone_narrow_sat":"S","cldr_day_stand-alone_narrow_sun":"S","cldr_day_stand-alone_narrow_thu":"T","cldr_day_stand-alone_narrow_tue":"T","cldr_day_stand-alone_narrow_wed":"W","cldr_month_format_abbreviated_1":"Jan","cldr_month_format_abbreviated_10":"Oct","cldr_month_format_abbreviated_11":"Nov","cldr_month_format_abbreviated_12":"Dec","cldr_month_format_abbreviated_2":"Feb","cldr_month_format_abbreviated_3":"Mar","cldr_month_format_abbreviated_4":"Apr","cldr_month_format_abbreviated_5":"May","cldr_month_format_abbreviated_6":"Jun","cldr_month_format_abbreviated_7":"Jul","cldr_month_format_abbreviated_8":"Aug","cldr_month_format_abbreviated_9":"Sep","cldr_month_format_wide_1":"January","cldr_month_format_wide_10":"October","cldr_month_format_wide_11":"November","cldr_month_format_wide_12":"December","cldr_month_format_wide_2":"February","cldr_month_format_wide_3":"March","cldr_month_format_wide_4":"April","cldr_month_format_wide_5":"May","cldr_month_format_wide_6":"June","cldr_month_format_wide_7":"July","cldr_month_format_wide_8":"August","cldr_month_format_wide_9":"September","cldr_month_stand-alone_narrow_1":"J","cldr_month_stand-alone_narrow_10":"O","cldr_month_stand-alone_narrow_11":"N","cldr_month_stand-alone_narrow_12":"D","cldr_month_stand-alone_narrow_2":"F","cldr_month_stand-alone_narrow_3":"M","cldr_month_stand-alone_narrow_4":"A","cldr_month_stand-alone_narrow_5":"M","cldr_month_stand-alone_narrow_6":"J","cldr_month_stand-alone_narrow_7":"J","cldr_month_stand-alone_narrow_8":"A","cldr_month_stand-alone_narrow_9":"S","cldr_number_decimal_separator":".","cldr_number_group_separator":",","cldr_number_percent_format":"#,##0%","cldr_pm":"PM","cldr_time_format_full":"h:mm:ss a zzzz","cldr_time_format_long":"h:mm:ss a z","cldr_time_format_medium":"h:mm:ss a","cldr_time_format_short":"h:mm a","day":"Day","dayperiod":"AM/PM","era":"Era","hour":"Hour","minute":"Minute","month":"Month","quotationEnd":"”","quotationStart":"“","second":"Second","week":"Week","weekday":"Day of the Week","year":"Year","zone":"Time Zone"}},"resources":{"dicomheaderview/test.png":[32,32,"png","dicomheaderview"],"qx/decoration/Modern/app-header.png":[110,20,"png","qx"],"qx/decoration/Modern/arrows-combined.png":[87,8,"png","qx"],"qx/decoration/Modern/arrows/down-invert.png":[8,5,"png","qx","qx/decoration/Modern/arrows-combined.png",-74,0],"qx/decoration/Modern/arrows/down-small-invert.png":[5,3,"png","qx","qx/decoration/Modern/arrows-combined.png",-69,0],"qx/decoration/Modern/arrows/down-small.png":[5,3,"png","qx","qx/decoration/Modern/arrows-combined.png",-49,0],"qx/decoration/Modern/arrows/down.png":[8,5,"png","qx","qx/decoration/Modern/arrows-combined.png",-20,0],"qx/decoration/Modern/arrows/forward.png":[10,8,"png","qx","qx/decoration/Modern/arrows-combined.png",-59,0],"qx/decoration/Modern/arrows/left-invert.png":[5,8,"png","qx","qx/decoration/Modern/arrows-combined.png",0,0],"qx/decoration/Modern/arrows/left.png":[5,8,"png","qx","qx/decoration/Modern/arrows-combined.png",-44,0],"qx/decoration/Modern/arrows/rewind.png":[10,8,"png","qx","qx/decoration/Modern/arrows-combined.png",-10,0],"qx/decoration/Modern/arrows/right-invert.png":[5,8,"png","qx","qx/decoration/Modern/arrows-combined.png",-5,0],"qx/decoration/Modern/arrows/right.png":[5,8,"png","qx","qx/decoration/Modern/arrows-combined.png",-54,0],"qx/decoration/Modern/arrows/up-invert.png":[8,5,"png","qx","qx/decoration/Modern/arrows-combined.png",-28,0],"qx/decoration/Modern/arrows/up-small.png":[5,3,"png","qx","qx/decoration/Modern/arrows-combined.png",-82,0],"qx/decoration/Modern/arrows/up.png":[8,5,"png","qx","qx/decoration/Modern/arrows-combined.png",-36,0],"qx/decoration/Modern/button-lr-combined.png":[72,52,"png","qx"],"qx/decoration/Modern/button-tb-combined.png":[4,216,"png","qx"],"qx/decoration/Modern/checkradio-combined.png":[504,14,"png","qx"],"qx/decoration/Modern/colorselector-combined.gif":[46,11,"gif","qx"],"qx/decoration/Modern/colorselector/brightness-field.png":[19,256,"png","qx"],"qx/decoration/Modern/colorselector/brightness-handle.gif":[35,11,"gif","qx","qx/decoration/Modern/colorselector-combined.gif",0,0],"qx/decoration/Modern/colorselector/huesaturation-field.jpg":[256,256,"jpeg","qx"],"qx/decoration/Modern/colorselector/huesaturation-handle.gif":[11,11,"gif","qx","qx/decoration/Modern/colorselector-combined.gif",-35,0],"qx/decoration/Modern/cursors-combined.gif":[71,20,"gif","qx"],"qx/decoration/Modern/cursors/alias.gif":[19,15,"gif","qx","qx/decoration/Modern/cursors-combined.gif",-52,0],"qx/decoration/Modern/cursors/copy.gif":[19,15,"gif","qx","qx/decoration/Modern/cursors-combined.gif",-33,0],"qx/decoration/Modern/cursors/move.gif":[13,9,"gif","qx","qx/decoration/Modern/cursors-combined.gif",-20,0],"qx/decoration/Modern/cursors/nodrop.gif":[20,20,"gif","qx","qx/decoration/Modern/cursors-combined.gif",0,0],"qx/decoration/Modern/form/button-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-72],"qx/decoration/Modern/form/button-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-204],"qx/decoration/Modern/form/button-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-188],"qx/decoration/Modern/form/button-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-checked-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-36],"qx/decoration/Modern/form/button-checked-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-84],"qx/decoration/Modern/form/button-checked-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-184],"qx/decoration/Modern/form/button-checked-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-checked-focused-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-156],"qx/decoration/Modern/form/button-checked-focused-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-208],"qx/decoration/Modern/form/button-checked-focused-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-160],"qx/decoration/Modern/form/button-checked-focused-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-checked-focused-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-40,0],"qx/decoration/Modern/form/button-checked-focused-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-32,0],"qx/decoration/Modern/form/button-checked-focused-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-28],"qx/decoration/Modern/form/button-checked-focused-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-24],"qx/decoration/Modern/form/button-checked-focused-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-48],"qx/decoration/Modern/form/button-checked-focused.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-checked-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-16,0],"qx/decoration/Modern/form/button-checked-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-60,0],"qx/decoration/Modern/form/button-checked-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-140],"qx/decoration/Modern/form/button-checked-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-56],"qx/decoration/Modern/form/button-checked-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-112],"qx/decoration/Modern/form/button-checked.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-disabled-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-40],"qx/decoration/Modern/form/button-disabled-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-136],"qx/decoration/Modern/form/button-disabled-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-16],"qx/decoration/Modern/form/button-disabled-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-disabled-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-68,0],"qx/decoration/Modern/form/button-disabled-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-4,0],"qx/decoration/Modern/form/button-disabled-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-116],"qx/decoration/Modern/form/button-disabled-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-168],"qx/decoration/Modern/form/button-disabled-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-60],"qx/decoration/Modern/form/button-disabled.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-focused-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-68],"qx/decoration/Modern/form/button-focused-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-144],"qx/decoration/Modern/form/button-focused-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-8],"qx/decoration/Modern/form/button-focused-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-focused-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-24,0],"qx/decoration/Modern/form/button-focused-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-44,0],"qx/decoration/Modern/form/button-focused-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-192],"qx/decoration/Modern/form/button-focused-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-148],"qx/decoration/Modern/form/button-focused-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-104],"qx/decoration/Modern/form/button-focused.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-hovered-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-108],"qx/decoration/Modern/form/button-hovered-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-32],"qx/decoration/Modern/form/button-hovered-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-128],"qx/decoration/Modern/form/button-hovered-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-hovered-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-20,0],"qx/decoration/Modern/form/button-hovered-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-48,0],"qx/decoration/Modern/form/button-hovered-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-44],"qx/decoration/Modern/form/button-hovered-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-76],"qx/decoration/Modern/form/button-hovered-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-88],"qx/decoration/Modern/form/button-hovered.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-56,0],"qx/decoration/Modern/form/button-preselected-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-124],"qx/decoration/Modern/form/button-preselected-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-176],"qx/decoration/Modern/form/button-preselected-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-200],"qx/decoration/Modern/form/button-preselected-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-preselected-focused-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,0],"qx/decoration/Modern/form/button-preselected-focused-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-4],"qx/decoration/Modern/form/button-preselected-focused-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-152],"qx/decoration/Modern/form/button-preselected-focused-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-preselected-focused-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-28,0],"qx/decoration/Modern/form/button-preselected-focused-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-36,0],"qx/decoration/Modern/form/button-preselected-focused-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-196],"qx/decoration/Modern/form/button-preselected-focused-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-164],"qx/decoration/Modern/form/button-preselected-focused-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-212],"qx/decoration/Modern/form/button-preselected-focused.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-preselected-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-8,0],"qx/decoration/Modern/form/button-preselected-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-64,0],"qx/decoration/Modern/form/button-preselected-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-96],"qx/decoration/Modern/form/button-preselected-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-80],"qx/decoration/Modern/form/button-preselected-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-132],"qx/decoration/Modern/form/button-preselected.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-pressed-b.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-12],"qx/decoration/Modern/form/button-pressed-bl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-52],"qx/decoration/Modern/form/button-pressed-br.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-20],"qx/decoration/Modern/form/button-pressed-c.png":[40,52,"png","qx"],"qx/decoration/Modern/form/button-pressed-l.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-52,0],"qx/decoration/Modern/form/button-pressed-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",-12,0],"qx/decoration/Modern/form/button-pressed-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-100],"qx/decoration/Modern/form/button-pressed-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-172],"qx/decoration/Modern/form/button-pressed-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-64],"qx/decoration/Modern/form/button-pressed.png":[80,60,"png","qx"],"qx/decoration/Modern/form/button-r.png":[4,52,"png","qx","qx/decoration/Modern/button-lr-combined.png",0,0],"qx/decoration/Modern/form/button-t.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-92],"qx/decoration/Modern/form/button-tl.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-120],"qx/decoration/Modern/form/button-tr.png":[4,4,"png","qx","qx/decoration/Modern/button-tb-combined.png",0,-180],"qx/decoration/Modern/form/button.png":[80,60,"png","qx"],"qx/decoration/Modern/form/checkbox-checked-disabled.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-126,0],"qx/decoration/Modern/form/checkbox-checked-focused-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-322,0],"qx/decoration/Modern/form/checkbox-checked-focused.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-294,0],"qx/decoration/Modern/form/checkbox-checked-hovered-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-364,0],"qx/decoration/Modern/form/checkbox-checked-hovered.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-490,0],"qx/decoration/Modern/form/checkbox-checked-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-224,0],"qx/decoration/Modern/form/checkbox-checked-pressed-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-378,0],"qx/decoration/Modern/form/checkbox-checked-pressed.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-84,0],"qx/decoration/Modern/form/checkbox-checked.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-182,0],"qx/decoration/Modern/form/checkbox-disabled.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-42,0],"qx/decoration/Modern/form/checkbox-focused-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-392,0],"qx/decoration/Modern/form/checkbox-focused.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-210,0],"qx/decoration/Modern/form/checkbox-hovered-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-14,0],"qx/decoration/Modern/form/checkbox-hovered.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-238,0],"qx/decoration/Modern/form/checkbox-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-462,0],"qx/decoration/Modern/form/checkbox-pressed-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-112,0],"qx/decoration/Modern/form/checkbox-pressed.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-448,0],"qx/decoration/Modern/form/checkbox-undetermined-disabled.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined-focused-invalid.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined-focused.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined-hovered-invalid.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined-hovered.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined-invalid.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox-undetermined.png":[14,14,"png","qx"],"qx/decoration/Modern/form/checkbox.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-140,0],"qx/decoration/Modern/form/checked-disabled.png":[6,6,"png","qx"],"qx/decoration/Modern/form/checked.png":[6,6,"png","qx"],"qx/decoration/Modern/form/input-focused.png":[40,12,"png","qx"],"qx/decoration/Modern/form/input.png":[84,12,"png","qx"],"qx/decoration/Modern/form/radiobutton-checked-disabled.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-196,0],"qx/decoration/Modern/form/radiobutton-checked-focused-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-168,0],"qx/decoration/Modern/form/radiobutton-checked-focused.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-98,0],"qx/decoration/Modern/form/radiobutton-checked-hovered-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-308,0],"qx/decoration/Modern/form/radiobutton-checked-hovered.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-406,0],"qx/decoration/Modern/form/radiobutton-checked-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-28,0],"qx/decoration/Modern/form/radiobutton-checked-pressed-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-350,0],"qx/decoration/Modern/form/radiobutton-checked-pressed.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-266,0],"qx/decoration/Modern/form/radiobutton-checked.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-252,0],"qx/decoration/Modern/form/radiobutton-disabled.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-336,0],"qx/decoration/Modern/form/radiobutton-focused-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-476,0],"qx/decoration/Modern/form/radiobutton-focused.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-420,0],"qx/decoration/Modern/form/radiobutton-hovered-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-56,0],"qx/decoration/Modern/form/radiobutton-hovered.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",0,0],"qx/decoration/Modern/form/radiobutton-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-154,0],"qx/decoration/Modern/form/radiobutton-pressed-invalid.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-434,0],"qx/decoration/Modern/form/radiobutton-pressed.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-280,0],"qx/decoration/Modern/form/radiobutton.png":[14,14,"png","qx","qx/decoration/Modern/checkradio-combined.png",-70,0],"qx/decoration/Modern/form/tooltip-error-arrow-right.png":[11,14,"png","qx"],"qx/decoration/Modern/form/tooltip-error-arrow.png":[11,14,"png","qx"],"qx/decoration/Modern/form/tooltip-error-b.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,-30],"qx/decoration/Modern/form/tooltip-error-bl.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,-24],"qx/decoration/Modern/form/tooltip-error-br.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,0],"qx/decoration/Modern/form/tooltip-error-c.png":[40,18,"png","qx"],"qx/decoration/Modern/form/tooltip-error-l.png":[6,18,"png","qx","qx/decoration/Modern/tooltip-error-lr-combined.png",-6,0],"qx/decoration/Modern/form/tooltip-error-r.png":[6,18,"png","qx","qx/decoration/Modern/tooltip-error-lr-combined.png",0,0],"qx/decoration/Modern/form/tooltip-error-t.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,-6],"qx/decoration/Modern/form/tooltip-error-tl.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,-18],"qx/decoration/Modern/form/tooltip-error-tr.png":[6,6,"png","qx","qx/decoration/Modern/tooltip-error-tb-combined.png",0,-12],"qx/decoration/Modern/form/tooltip-error.png":[127,30,"png","qx"],"qx/decoration/Modern/form/undetermined-disabled.png":[6,2,"png","qx"],"qx/decoration/Modern/form/undetermined.png":[6,2,"png","qx"],"qx/decoration/Modern/group-item.png":[110,20,"png","qx"],"qx/decoration/Modern/groupbox-lr-combined.png":[8,51,"png","qx"],"qx/decoration/Modern/groupbox-tb-combined.png":[4,24,"png","qx"],"qx/decoration/Modern/groupbox/groupbox-b.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,-12],"qx/decoration/Modern/groupbox/groupbox-bl.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,-16],"qx/decoration/Modern/groupbox/groupbox-br.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,-8],"qx/decoration/Modern/groupbox/groupbox-c.png":[40,51,"png","qx"],"qx/decoration/Modern/groupbox/groupbox-l.png":[4,51,"png","qx","qx/decoration/Modern/groupbox-lr-combined.png",-4,0],"qx/decoration/Modern/groupbox/groupbox-r.png":[4,51,"png","qx","qx/decoration/Modern/groupbox-lr-combined.png",0,0],"qx/decoration/Modern/groupbox/groupbox-t.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,-4],"qx/decoration/Modern/groupbox/groupbox-tl.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,0],"qx/decoration/Modern/groupbox/groupbox-tr.png":[4,4,"png","qx","qx/decoration/Modern/groupbox-tb-combined.png",0,-20],"qx/decoration/Modern/groupbox/groupbox.png":[255,59,"png","qx"],"qx/decoration/Modern/menu-background-combined.png":[80,49,"png","qx"],"qx/decoration/Modern/menu-checkradio-combined.gif":[64,7,"gif","qx"],"qx/decoration/Modern/menu/background.png":[40,49,"png","qx","qx/decoration/Modern/menu-background-combined.png",-40,0],"qx/decoration/Modern/menu/bar-background.png":[40,20,"png","qx","qx/decoration/Modern/menu-background-combined.png",0,0],"qx/decoration/Modern/menu/checkbox-invert.gif":[16,7,"gif","qx","qx/decoration/Modern/menu-checkradio-combined.gif",-16,0],"qx/decoration/Modern/menu/checkbox.gif":[16,7,"gif","qx","qx/decoration/Modern/menu-checkradio-combined.gif",-48,0],"qx/decoration/Modern/menu/radiobutton-invert.gif":[16,5,"gif","qx","qx/decoration/Modern/menu-checkradio-combined.gif",-32,0],"qx/decoration/Modern/menu/radiobutton.gif":[16,5,"gif","qx","qx/decoration/Modern/menu-checkradio-combined.gif",0,0],"qx/decoration/Modern/pane-lr-combined.png":[12,238,"png","qx"],"qx/decoration/Modern/pane-tb-combined.png":[6,36,"png","qx"],"qx/decoration/Modern/pane/pane-b.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,-30],"qx/decoration/Modern/pane/pane-bl.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,-18],"qx/decoration/Modern/pane/pane-br.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,-12],"qx/decoration/Modern/pane/pane-c.png":[40,238,"png","qx"],"qx/decoration/Modern/pane/pane-l.png":[6,238,"png","qx","qx/decoration/Modern/pane-lr-combined.png",0,0],"qx/decoration/Modern/pane/pane-r.png":[6,238,"png","qx","qx/decoration/Modern/pane-lr-combined.png",-6,0],"qx/decoration/Modern/pane/pane-t.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,0],"qx/decoration/Modern/pane/pane-tl.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,-24],"qx/decoration/Modern/pane/pane-tr.png":[6,6,"png","qx","qx/decoration/Modern/pane-tb-combined.png",0,-6],"qx/decoration/Modern/pane/pane.png":[185,250,"png","qx"],"qx/decoration/Modern/scrollbar-combined.png":[54,12,"png","qx"],"qx/decoration/Modern/scrollbar/scrollbar-bg-horizontal.png":[76,15,"png","qx"],"qx/decoration/Modern/scrollbar/scrollbar-bg-pressed-horizontal.png":[19,10,"png","qx"],"qx/decoration/Modern/scrollbar/scrollbar-bg-pressed-vertical.png":[10,19,"png","qx"],"qx/decoration/Modern/scrollbar/scrollbar-bg-vertical.png":[15,76,"png","qx"],"qx/decoration/Modern/scrollbar/scrollbar-button-bg-horizontal.png":[12,10,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-34,0],"qx/decoration/Modern/scrollbar/scrollbar-button-bg-vertical.png":[10,12,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-6,0],"qx/decoration/Modern/scrollbar/scrollbar-down.png":[6,4,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-28,0],"qx/decoration/Modern/scrollbar/scrollbar-left.png":[4,6,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-50,0],"qx/decoration/Modern/scrollbar/scrollbar-right.png":[4,6,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-46,0],"qx/decoration/Modern/scrollbar/scrollbar-up.png":[6,4,"png","qx","qx/decoration/Modern/scrollbar-combined.png",0,0],"qx/decoration/Modern/scrollbar/slider-knob-background.png":[12,10,"png","qx","qx/decoration/Modern/scrollbar-combined.png",-16,0],"qx/decoration/Modern/selection.png":[110,20,"png","qx"],"qx/decoration/Modern/shadow-lr-combined.png":[30,382,"png","qx"],"qx/decoration/Modern/shadow-small-lr-combined.png":[10,136,"png","qx"],"qx/decoration/Modern/shadow-small-tb-combined.png":[5,30,"png","qx"],"qx/decoration/Modern/shadow-tb-combined.png":[15,90,"png","qx"],"qx/decoration/Modern/shadow/shadow-b.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,-30],"qx/decoration/Modern/shadow/shadow-bl.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,-15],"qx/decoration/Modern/shadow/shadow-br.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,-45],"qx/decoration/Modern/shadow/shadow-c.png":[40,382,"png","qx"],"qx/decoration/Modern/shadow/shadow-l.png":[15,382,"png","qx","qx/decoration/Modern/shadow-lr-combined.png",0,0],"qx/decoration/Modern/shadow/shadow-r.png":[15,382,"png","qx","qx/decoration/Modern/shadow-lr-combined.png",-15,0],"qx/decoration/Modern/shadow/shadow-small-b.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,-20],"qx/decoration/Modern/shadow/shadow-small-bl.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,-15],"qx/decoration/Modern/shadow/shadow-small-br.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,-10],"qx/decoration/Modern/shadow/shadow-small-c.png":[40,136,"png","qx"],"qx/decoration/Modern/shadow/shadow-small-l.png":[5,136,"png","qx","qx/decoration/Modern/shadow-small-lr-combined.png",0,0],"qx/decoration/Modern/shadow/shadow-small-r.png":[5,136,"png","qx","qx/decoration/Modern/shadow-small-lr-combined.png",-5,0],"qx/decoration/Modern/shadow/shadow-small-t.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,-5],"qx/decoration/Modern/shadow/shadow-small-tl.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,0],"qx/decoration/Modern/shadow/shadow-small-tr.png":[5,5,"png","qx","qx/decoration/Modern/shadow-small-tb-combined.png",0,-25],"qx/decoration/Modern/shadow/shadow-small.png":[114,146,"png","qx"],"qx/decoration/Modern/shadow/shadow-t.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,-60],"qx/decoration/Modern/shadow/shadow-tl.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,-75],"qx/decoration/Modern/shadow/shadow-tr.png":[15,15,"png","qx","qx/decoration/Modern/shadow-tb-combined.png",0,0],"qx/decoration/Modern/shadow/shadow.png":[381,412,"png","qx"],"qx/decoration/Modern/splitpane-knobs-combined.png":[8,9,"png","qx"],"qx/decoration/Modern/splitpane/knob-horizontal.png":[1,8,"png","qx","qx/decoration/Modern/splitpane-knobs-combined.png",0,-1],"qx/decoration/Modern/splitpane/knob-vertical.png":[8,1,"png","qx","qx/decoration/Modern/splitpane-knobs-combined.png",0,0],"qx/decoration/Modern/table-combined.png":[94,18,"png","qx"],"qx/decoration/Modern/table/ascending.png":[8,5,"png","qx","qx/decoration/Modern/table-combined.png",0,0],"qx/decoration/Modern/table/boolean-false.png":[14,14,"png","qx","qx/decoration/Modern/table-combined.png",-80,0],"qx/decoration/Modern/table/boolean-true.png":[14,14,"png","qx","qx/decoration/Modern/table-combined.png",-26,0],"qx/decoration/Modern/table/descending.png":[8,5,"png","qx","qx/decoration/Modern/table-combined.png",-18,0],"qx/decoration/Modern/table/header-cell.png":[40,18,"png","qx","qx/decoration/Modern/table-combined.png",-40,0],"qx/decoration/Modern/table/select-column-order.png":[10,9,"png","qx","qx/decoration/Modern/table-combined.png",-8,0],"qx/decoration/Modern/tabview-button-bottom-active-lr-combined.png":[10,14,"png","qx"],"qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png":[5,30,"png","qx"],"qx/decoration/Modern/tabview-button-bottom-inactive-b-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-bottom-inactive-lr-combined.png":[6,15,"png","qx"],"qx/decoration/Modern/tabview-button-bottom-inactive-t-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-left-active-lr-combined.png":[10,37,"png","qx"],"qx/decoration/Modern/tabview-button-left-active-tb-combined.png":[5,30,"png","qx"],"qx/decoration/Modern/tabview-button-left-inactive-b-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-left-inactive-lr-combined.png":[6,39,"png","qx"],"qx/decoration/Modern/tabview-button-left-inactive-t-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-right-active-lr-combined.png":[10,37,"png","qx"],"qx/decoration/Modern/tabview-button-right-active-tb-combined.png":[5,30,"png","qx"],"qx/decoration/Modern/tabview-button-right-inactive-b-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-right-inactive-lr-combined.png":[6,39,"png","qx"],"qx/decoration/Modern/tabview-button-right-inactive-t-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-top-active-lr-combined.png":[10,12,"png","qx"],"qx/decoration/Modern/tabview-button-top-active-tb-combined.png":[5,30,"png","qx"],"qx/decoration/Modern/tabview-button-top-inactive-b-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-button-top-inactive-lr-combined.png":[6,15,"png","qx"],"qx/decoration/Modern/tabview-button-top-inactive-t-combined.png":[3,9,"png","qx"],"qx/decoration/Modern/tabview-pane-lr-combined.png":[60,2,"png","qx"],"qx/decoration/Modern/tabview-pane-tb-combined.png":[30,180,"png","qx"],"qx/decoration/Modern/tabview/tab-button-bottom-active-b.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,-10],"qx/decoration/Modern/tabview/tab-button-bottom-active-bl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,-15],"qx/decoration/Modern/tabview/tab-button-bottom-active-br.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,-5],"qx/decoration/Modern/tabview/tab-button-bottom-active-c.png":[40,14,"png","qx"],"qx/decoration/Modern/tabview/tab-button-bottom-active-l.png":[5,14,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-bottom-active-r.png":[5,14,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-lr-combined.png",-5,0],"qx/decoration/Modern/tabview/tab-button-bottom-active-t.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,-20],"qx/decoration/Modern/tabview/tab-button-bottom-active-tl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,-25],"qx/decoration/Modern/tabview/tab-button-bottom-active-tr.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-bottom-active-tb-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-bottom-active.png":[49,24,"png","qx"],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-b.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-b-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-bl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-b-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-br.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-b-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-c.png":[40,15,"png","qx"],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-l.png":[3,15,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-lr-combined.png",-3,0],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-r.png":[3,15,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-t.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-t-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-tl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-t-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-bottom-inactive-tr.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-bottom-inactive-t-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-bottom-inactive.png":[45,21,"png","qx"],"qx/decoration/Modern/tabview/tab-button-left-active-b.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,-5],"qx/decoration/Modern/tabview/tab-button-left-active-bl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-left-active-br.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,-25],"qx/decoration/Modern/tabview/tab-button-left-active-c.png":[40,37,"png","qx"],"qx/decoration/Modern/tabview/tab-button-left-active-l.png":[5,37,"png","qx","qx/decoration/Modern/tabview-button-left-active-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-left-active-r.png":[5,37,"png","qx","qx/decoration/Modern/tabview-button-left-active-lr-combined.png",-5,0],"qx/decoration/Modern/tabview/tab-button-left-active-t.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,-15],"qx/decoration/Modern/tabview/tab-button-left-active-tl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,-10],"qx/decoration/Modern/tabview/tab-button-left-active-tr.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-left-active-tb-combined.png",0,-20],"qx/decoration/Modern/tabview/tab-button-left-active.png":[22,47,"png","qx"],"qx/decoration/Modern/tabview/tab-button-left-inactive-b.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-b-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-left-inactive-bl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-b-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-left-inactive-br.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-b-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-left-inactive-c.png":[40,39,"png","qx"],"qx/decoration/Modern/tabview/tab-button-left-inactive-l.png":[3,39,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-lr-combined.png",-3,0],"qx/decoration/Modern/tabview/tab-button-left-inactive-r.png":[3,39,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-left-inactive-t.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-t-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-left-inactive-tl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-t-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-left-inactive-tr.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-left-inactive-t-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-left-inactive.png":[20,45,"png","qx"],"qx/decoration/Modern/tabview/tab-button-right-active-b.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,-25],"qx/decoration/Modern/tabview/tab-button-right-active-bl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-right-active-br.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,-20],"qx/decoration/Modern/tabview/tab-button-right-active-c.png":[40,37,"png","qx"],"qx/decoration/Modern/tabview/tab-button-right-active-l.png":[5,37,"png","qx","qx/decoration/Modern/tabview-button-right-active-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-right-active-r.png":[5,37,"png","qx","qx/decoration/Modern/tabview-button-right-active-lr-combined.png",-5,0],"qx/decoration/Modern/tabview/tab-button-right-active-t.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,-5],"qx/decoration/Modern/tabview/tab-button-right-active-tl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,-15],"qx/decoration/Modern/tabview/tab-button-right-active-tr.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-right-active-tb-combined.png",0,-10],"qx/decoration/Modern/tabview/tab-button-right-active.png":[22,47,"png","qx"],"qx/decoration/Modern/tabview/tab-button-right-inactive-b.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-b-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-right-inactive-bl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-b-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-right-inactive-br.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-b-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-right-inactive-c.png":[40,39,"png","qx"],"qx/decoration/Modern/tabview/tab-button-right-inactive-l.png":[3,39,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-right-inactive-r.png":[3,39,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-lr-combined.png",-3,0],"qx/decoration/Modern/tabview/tab-button-right-inactive-t.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-t-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-right-inactive-tl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-t-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-right-inactive-tr.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-right-inactive-t-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-right-inactive.png":[20,45,"png","qx"],"qx/decoration/Modern/tabview/tab-button-top-active-b.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,-20],"qx/decoration/Modern/tabview/tab-button-top-active-bl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,-15],"qx/decoration/Modern/tabview/tab-button-top-active-br.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,-10],"qx/decoration/Modern/tabview/tab-button-top-active-c.png":[40,14,"png","qx"],"qx/decoration/Modern/tabview/tab-button-top-active-l.png":[5,12,"png","qx","qx/decoration/Modern/tabview-button-top-active-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-top-active-r.png":[5,12,"png","qx","qx/decoration/Modern/tabview-button-top-active-lr-combined.png",-5,0],"qx/decoration/Modern/tabview/tab-button-top-active-t.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-top-active-tl.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,-25],"qx/decoration/Modern/tabview/tab-button-top-active-tr.png":[5,5,"png","qx","qx/decoration/Modern/tabview-button-top-active-tb-combined.png",0,-5],"qx/decoration/Modern/tabview/tab-button-top-active.png":[48,22,"png","qx"],"qx/decoration/Modern/tabview/tab-button-top-inactive-b.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-b-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-top-inactive-bl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-b-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-top-inactive-br.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-b-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-top-inactive-c.png":[40,15,"png","qx"],"qx/decoration/Modern/tabview/tab-button-top-inactive-l.png":[3,15,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-top-inactive-r.png":[3,15,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-lr-combined.png",-3,0],"qx/decoration/Modern/tabview/tab-button-top-inactive-t.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-t-combined.png",0,-3],"qx/decoration/Modern/tabview/tab-button-top-inactive-tl.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-t-combined.png",0,0],"qx/decoration/Modern/tabview/tab-button-top-inactive-tr.png":[3,3,"png","qx","qx/decoration/Modern/tabview-button-top-inactive-t-combined.png",0,-6],"qx/decoration/Modern/tabview/tab-button-top-inactive.png":[45,21,"png","qx"],"qx/decoration/Modern/tabview/tabview-pane-b.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,-60],"qx/decoration/Modern/tabview/tabview-pane-bl.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,0],"qx/decoration/Modern/tabview/tabview-pane-br.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,-120],"qx/decoration/Modern/tabview/tabview-pane-c.png":[40,120,"png","qx"],"qx/decoration/Modern/tabview/tabview-pane-l.png":[30,2,"png","qx","qx/decoration/Modern/tabview-pane-lr-combined.png",0,0],"qx/decoration/Modern/tabview/tabview-pane-r.png":[30,2,"png","qx","qx/decoration/Modern/tabview-pane-lr-combined.png",-30,0],"qx/decoration/Modern/tabview/tabview-pane-t.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,-150],"qx/decoration/Modern/tabview/tabview-pane-tl.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,-30],"qx/decoration/Modern/tabview/tabview-pane-tr.png":[30,30,"png","qx","qx/decoration/Modern/tabview-pane-tb-combined.png",0,-90],"qx/decoration/Modern/tabview/tabview-pane.png":[185,250,"png","qx"],"qx/decoration/Modern/toolbar-combined.png":[80,130,"png","qx"],"qx/decoration/Modern/toolbar/toolbar-gradient-blue.png":[40,130,"png","qx","qx/decoration/Modern/toolbar-combined.png",-40,0],"qx/decoration/Modern/toolbar/toolbar-gradient.png":[40,130,"png","qx","qx/decoration/Modern/toolbar-combined.png",0,0],"qx/decoration/Modern/toolbar/toolbar-handle-knob.gif":[1,8,"gif","qx"],"qx/decoration/Modern/toolbar/toolbar-part.gif":[7,1,"gif","qx"],"qx/decoration/Modern/tooltip-error-lr-combined.png":[12,18,"png","qx"],"qx/decoration/Modern/tooltip-error-tb-combined.png":[6,36,"png","qx"],"qx/decoration/Modern/tree-combined.png":[32,8,"png","qx"],"qx/decoration/Modern/tree/closed-selected.png":[8,8,"png","qx","qx/decoration/Modern/tree-combined.png",-24,0],"qx/decoration/Modern/tree/closed.png":[8,8,"png","qx","qx/decoration/Modern/tree-combined.png",-16,0],"qx/decoration/Modern/tree/open-selected.png":[8,8,"png","qx","qx/decoration/Modern/tree-combined.png",-8,0],"qx/decoration/Modern/tree/open.png":[8,8,"png","qx","qx/decoration/Modern/tree-combined.png",0,0],"qx/decoration/Modern/window-captionbar-buttons-combined.png":[108,9,"png","qx"],"qx/decoration/Modern/window-captionbar-lr-active-combined.png":[12,9,"png","qx"],"qx/decoration/Modern/window-captionbar-lr-inactive-combined.png":[12,9,"png","qx"],"qx/decoration/Modern/window-captionbar-tb-active-combined.png":[6,36,"png","qx"],"qx/decoration/Modern/window-captionbar-tb-inactive-combined.png":[6,36,"png","qx"],"qx/decoration/Modern/window-statusbar-lr-combined.png":[8,7,"png","qx"],"qx/decoration/Modern/window-statusbar-tb-combined.png":[4,24,"png","qx"],"qx/decoration/Modern/window/captionbar-active-b.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,-18],"qx/decoration/Modern/window/captionbar-active-bl.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,-24],"qx/decoration/Modern/window/captionbar-active-br.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,-12],"qx/decoration/Modern/window/captionbar-active-c.png":[40,9,"png","qx"],"qx/decoration/Modern/window/captionbar-active-l.png":[6,9,"png","qx","qx/decoration/Modern/window-captionbar-lr-active-combined.png",-6,0],"qx/decoration/Modern/window/captionbar-active-r.png":[6,9,"png","qx","qx/decoration/Modern/window-captionbar-lr-active-combined.png",0,0],"qx/decoration/Modern/window/captionbar-active-t.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,-6],"qx/decoration/Modern/window/captionbar-active-tl.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,0],"qx/decoration/Modern/window/captionbar-active-tr.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-active-combined.png",0,-30],"qx/decoration/Modern/window/captionbar-active.png":[69,21,"png","qx"],"qx/decoration/Modern/window/captionbar-inactive-b.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,-24],"qx/decoration/Modern/window/captionbar-inactive-bl.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,-6],"qx/decoration/Modern/window/captionbar-inactive-br.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,-30],"qx/decoration/Modern/window/captionbar-inactive-c.png":[40,9,"png","qx"],"qx/decoration/Modern/window/captionbar-inactive-l.png":[6,9,"png","qx","qx/decoration/Modern/window-captionbar-lr-inactive-combined.png",0,0],"qx/decoration/Modern/window/captionbar-inactive-r.png":[6,9,"png","qx","qx/decoration/Modern/window-captionbar-lr-inactive-combined.png",-6,0],"qx/decoration/Modern/window/captionbar-inactive-t.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,0],"qx/decoration/Modern/window/captionbar-inactive-tl.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,-12],"qx/decoration/Modern/window/captionbar-inactive-tr.png":[6,6,"png","qx","qx/decoration/Modern/window-captionbar-tb-inactive-combined.png",0,-18],"qx/decoration/Modern/window/captionbar-inactive.png":[69,21,"png","qx"],"qx/decoration/Modern/window/close-active-hovered.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-27,0],"qx/decoration/Modern/window/close-active.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-9,0],"qx/decoration/Modern/window/close-inactive.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-90,0],"qx/decoration/Modern/window/maximize-active-hovered.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-18,0],"qx/decoration/Modern/window/maximize-active.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-81,0],"qx/decoration/Modern/window/maximize-inactive.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-54,0],"qx/decoration/Modern/window/minimize-active-hovered.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-63,0],"qx/decoration/Modern/window/minimize-active.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-72,0],"qx/decoration/Modern/window/minimize-inactive.png":[9,9,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-36,0],"qx/decoration/Modern/window/restore-active-hovered.png":[9,8,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",0,0],"qx/decoration/Modern/window/restore-active.png":[9,8,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-99,0],"qx/decoration/Modern/window/restore-inactive.png":[9,8,"png","qx","qx/decoration/Modern/window-captionbar-buttons-combined.png",-45,0],"qx/decoration/Modern/window/statusbar-b.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,-16],"qx/decoration/Modern/window/statusbar-bl.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,-20],"qx/decoration/Modern/window/statusbar-br.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,-4],"qx/decoration/Modern/window/statusbar-c.png":[40,7,"png","qx"],"qx/decoration/Modern/window/statusbar-l.png":[4,7,"png","qx","qx/decoration/Modern/window-statusbar-lr-combined.png",-4,0],"qx/decoration/Modern/window/statusbar-r.png":[4,7,"png","qx","qx/decoration/Modern/window-statusbar-lr-combined.png",0,0],"qx/decoration/Modern/window/statusbar-t.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,0],"qx/decoration/Modern/window/statusbar-tl.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,-8],"qx/decoration/Modern/window/statusbar-tr.png":[4,4,"png","qx","qx/decoration/Modern/window-statusbar-tb-combined.png",0,-12],"qx/decoration/Modern/window/statusbar.png":[369,15,"png","qx"],"qx/icon/Tango/16/actions/dialog-cancel.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/dialog-ok.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/view-refresh.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/window-close.png":[16,16,"png","qx"],"qx/icon/Tango/16/apps/office-calendar.png":[16,16,"png","qx"],"qx/icon/Tango/16/apps/utilities-color-chooser.png":[16,16,"png","qx"],"qx/icon/Tango/16/mimetypes/office-document.png":[16,16,"png","qx"],"qx/icon/Tango/16/places/folder-open.png":[16,16,"png","qx"],"qx/icon/Tango/16/places/folder.png":[16,16,"png","qx"],"qx/icon/Tango/22/mimetypes/office-document.png":[22,22,"png","qx"],"qx/icon/Tango/22/places/folder-open.png":[22,22,"png","qx"],"qx/icon/Tango/22/places/folder.png":[22,22,"png","qx"],"qx/icon/Tango/32/mimetypes/office-document.png":[32,32,"png","qx"],"qx/icon/Tango/32/places/folder-open.png":[32,32,"png","qx"],"qx/icon/Tango/32/places/folder.png":[32,32,"png","qx"],"qx/static/blank.gif":[1,1,"gif","qx"]},"translations":{"C":{},"en":{}}};

(function(){

  var m = ".prototype",k = "function",j = "Boolean",h = "Error",g = "constructor",f = "warn",e = "default",d = "hasOwnProperty",c = "string",b = "toLocaleString",K = "RegExp",J = '\", "',I = "info",H = "BROKEN_IE",G = "isPrototypeOf",F = "Date",E = "qx.Bootstrap",D = "]",C = "Class",B = "error",t = "[Class ",u = "valueOf",r = "Number",s = "debug",p = "ES5",q = "Object",n = '"',o = "",v = "Array",w = "()",y = "String",x = "Function",A = "toString",z = ".";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.data)
  #ignore(qx.data.IListData)
  #ignore(qx.util.OOUtil)
  
  ************************************************************************ */
  /**
   * Create namespace
   */
  if(!window.qx){

    window.qx = {
    };
  };
  /**
   * Bootstrap qx.Bootstrap to create myself later
   * This is needed for the API browser etc. to let them detect me
   */
  qx.Bootstrap = {
    genericToString : function(){

      return t + this.classname + D;
    },
    createNamespace : function(name, L){

      var N = name.split(z);
      var parent = window;
      var M = N[0];
      for(var i = 0,O = N.length - 1;i < O;i++,M = N[i]){

        if(!parent[M]){

          parent = parent[M] = {
          };
        } else {

          parent = parent[M];
        };
      };
      // store object
      parent[M] = L;
      // return last part name (e.g. classname)
      return M;
    },
    setDisplayName : function(P, Q, name){

      P.displayName = Q + z + name + w;
    },
    setDisplayNames : function(R, S){

      for(var name in R){

        var T = R[name];
        if(T instanceof Function){

          T.displayName = S + z + name + w;
        };
      };
    },
    define : function(name, U){

      if(!U){

        var U = {
          statics : {
          }
        };
      };
      var ba;
      var X = null;
      qx.Bootstrap.setDisplayNames(U.statics, name);
      if(U.members || U.extend){

        qx.Bootstrap.setDisplayNames(U.members, name + m);
        ba = U.construct || new Function;
        if(U.extend){

          this.extendClass(ba, ba, U.extend, name, Y);
        };
        var V = U.statics || {
        };
        // use getKeys to include the shadowed in IE
        for(var i = 0,bb = qx.Bootstrap.getKeys(V),l = bb.length;i < l;i++){

          var bc = bb[i];
          ba[bc] = V[bc];
        };
        X = ba.prototype;
        var W = U.members || {
        };
        // use getKeys to include the shadowed in IE
        for(var i = 0,bb = qx.Bootstrap.getKeys(W),l = bb.length;i < l;i++){

          var bc = bb[i];
          X[bc] = W[bc];
        };
      } else {

        ba = U.statics || {
        };
      };
      // Create namespace
      var Y = name ? this.createNamespace(name, ba) : o;
      // Store names in constructor/object
      ba.name = ba.classname = name;
      ba.basename = Y;
      // Store type info
      ba.$$type = C;
      // Attach toString
      if(!ba.hasOwnProperty(A)){

        ba.toString = this.genericToString;
      };
      // Execute defer section
      if(U.defer){

        U.defer(ba, X);
      };
      // Store class reference in global class registry
      qx.Bootstrap.$$registry[name] = ba;
      return ba;
    }
  };
  /**
   * Internal class that is responsible for bootstrapping the qooxdoo
   * framework at load time.
   *
   * Automatically loads JavaScript language fixes and enhancements to
   * bring all engines to at least JavaScript 1.6.
   *
   * Does support:
   *
   * * Construct
   * * Statics
   * * Members
   * * Extend
   * * Defer
   *
   * Does not support:
   *
   * * Super class calls
   * * Mixins, Interfaces, Properties, ...
   */
  qx.Bootstrap.define(E, {
    statics : {
      /** Timestamp of qooxdoo based application startup */
      LOADSTART : qx.$$start || new Date(),
      /**
       * Mapping for early use of the qx.debug environment setting.
       */
      DEBUG : (function(){

        // make sure to reflect all changes here to the environment class!
        var bd = true;
        if(qx.$$environment && qx.$$environment["qx.debug"] === false){

          bd = false;
        };
        return bd;
      })(),
      /**
       * Minimal accessor API for the environment settings given from the
       * generator.
       *
       * WARNING: This method only should be used if the
       * {@link qx.core.Environment} class is not loaded!
       *
       * @param key {String} The key to get the value from.
       * @return {var} The value of the setting or <code>undefined</code>.
       */
      getEnvironmentSetting : function(be){

        if(qx.$$environment){

          return qx.$$environment[be];
        };
      },
      /**
       * Minimal mutator for the environment settings given from the generator.
       * It checks for the existance of the environment settings and sets the
       * key if its not given from the generator. If a setting is available from
       * the generator, the setting will be ignored.
       *
       * WARNING: This method only should be used if the
       * {@link qx.core.Environment} class is not loaded!
       *
       * @param key {String} The key of the setting.
       * @param value {var} The value for the setting.
       */
      setEnvironmentSetting : function(bf, bg){

        if(!qx.$$environment){

          qx.$$environment = {
          };
        };
        if(qx.$$environment[bf] === undefined){

          qx.$$environment[bf] = bg;
        };
      },
      /**
       * Creates a namespace and assigns the given object to it.
       *
       * @internal
       * @param name {String} The complete namespace to create. Typically, the last part is the class name itself
       * @param object {Object} The object to attach to the namespace
       * @return {Object} last part of the namespace (typically the class name)
       * @throws an exception when the given object already exists.
       */
      createNamespace : qx.Bootstrap.createNamespace,
      /**
       * Define a new class using the qooxdoo class system.
       * Lightweight version of {@link qx.Class#define} only used during bootstrap phase.
       *
       * @internal
       * @signature function(name, config)
       * @param name {String?} Name of the class. If null, the class will not be
       *   attached to a namespace.
       * @param config {Map ? null} Class definition structure.
       * @return {Class} The defined class
       */
      define : qx.Bootstrap.define,
      /**
       * Sets the display name of the given function
       *
       * @signature function(fcn, classname, name)
       * @param fcn {Function} the function to set the display name for
       * @param classname {String} the name of the class the function is defined in
       * @param name {String} the function name
       */
      setDisplayName : qx.Bootstrap.setDisplayName,
      /**
       * Set the names of all functions defined in the given map
       *
       * @signature function(functionMap, classname)
       * @param functionMap {Object} a map with functions as values
       * @param classname {String} the name of the class, the functions are
       *   defined in
       */
      setDisplayNames : qx.Bootstrap.setDisplayNames,
      /**
       * This method will be attached to all classes to return
       * a nice identifier for them.
       *
       * @internal
       * @signature function()
       * @return {String} The class identifier
       */
      genericToString : qx.Bootstrap.genericToString,
      /**
       * Inherit a clazz from a super class.
       *
       * This function differentiates between class and constructor because the
       * constructor written by the user might be wrapped and the <code>base</code>
       * property has to be attached to the constructor, while the <code>superclass</code>
       * property has to be attached to the wrapped constructor.
       *
       * @param clazz {Function} The class's wrapped constructor
       * @param construct {Function} The unwrapped constructor
       * @param superClass {Function} The super class
       * @param name {Function} fully qualified class name
       * @param basename {Function} the base name
       */
      extendClass : function(bh, bi, bj, name, bk){

        var bn = bj.prototype;
        // Use helper function/class to save the unnecessary constructor call while
        // setting up inheritance.
        var bm = new Function;
        bm.prototype = bn;
        var bl = new bm;
        // Apply prototype to new helper instance
        bh.prototype = bl;
        // Store names in prototype
        bl.name = bl.classname = name;
        bl.basename = bk;
        /*
          - Store base constructor to constructor-
          - Store reference to extend class
        */
        bi.base = bh.superclass = bj;
        /*
          - Store statics/constructor onto constructor/prototype
          - Store correct constructor
          - Store statics onto prototype
        */
        bi.self = bh.constructor = bl.constructor = bh;
      },
      /**
       * Find a class by its name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName : function(name){

        return qx.Bootstrap.$$registry[name];
      },
      /** {Map} Stores all defined classes */
      $$registry : {
      },
      /*
      ---------------------------------------------------------------------------
        OBJECT UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      /**
       * Get the number of objects in the map
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Integer} number of objects in the map
       */
      objectGetLength : function(bo){

        var length = 0;
        for(var bp in bo){

          length++;
        };
        return length;
      },
      /**
       * Inserts all keys of the source object into the
       * target objects. Attention: The target map gets modified.
       *
       * @param target {Object} target object
       * @param source {Object} object to be merged
       * @param overwrite {Boolean ? true} If enabled existing keys will be overwritten
       * @return {Object} Target with merged values from the source object
       */
      objectMergeWith : function(bq, br, bs){

        if(bs === undefined){

          bs = true;
        };
        for(var bt in br){

          if(bs || bq[bt] === undefined){

            bq[bt] = br[bt];
          };
        };
        return bq;
      },
      /**
       * IE does not return "shadowed" keys even if they are defined directly
       * in the object.
       *
       * @internal
       */
      __shadowedKeys : [G, d, b, A, u, g],
      /**
       * Get the keys of a map as array as returned by a "for ... in" statement.
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Array} array of the keys of the map
       */
      getKeys : ({
        "ES5" : Object.keys,
        "BROKEN_IE" : function(bu){

          var bv = [];
          var bx = Object.prototype.hasOwnProperty;
          for(var by in bu){

            if(bx.call(bu, by)){

              bv.push(by);
            };
          };
          // IE does not return "shadowed" keys even if they are defined directly
          // in the object. This is incompatible with the ECMA standard!!
          // This is why this checks are needed.
          var bw = qx.Bootstrap.__shadowedKeys;
          for(var i = 0,a = bw,l = a.length;i < l;i++){

            if(bx.call(bu, a[i])){

              bv.push(a[i]);
            };
          };
          return bv;
        },
        "default" : function(bz){

          var bA = [];
          var bB = Object.prototype.hasOwnProperty;
          for(var bC in bz){

            if(bB.call(bz, bC)){

              bA.push(bC);
            };
          };
          return bA;
        }
      })[typeof (Object.keys) == k ? p : (function(){

        for(var bD in {
          toString : 1
        }){

          return bD;
        };
      })() !== A ? H : e],
      /**
       * Get the keys of a map as string
       *
       * @param map {Object} the map
       * @return {String} String of the keys of the map
       *         The keys are separated by ", "
       */
      getKeysAsString : function(bE){

        var bF = qx.Bootstrap.getKeys(bE);
        if(bF.length == 0){

          return o;
        };
        return n + bF.join(J) + n;
      },
      /**
       * Mapping from JavaScript string representation of objects to names
       * @internal
       */
      __classToTypeMap : {
        "[object String]" : y,
        "[object Array]" : v,
        "[object Object]" : q,
        "[object RegExp]" : K,
        "[object Number]" : r,
        "[object Boolean]" : j,
        "[object Date]" : F,
        "[object Function]" : x,
        "[object Error]" : h
      },
      /*
      ---------------------------------------------------------------------------
        FUNCTION UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns a function whose "this" is altered.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.Bootstrap.bind(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction()
       * {
       *   this.setStyle('color', 'red');
       *   // note that 'this' here refers to myFunction, not an element
       *   // we'll need to bind this function to the element we want to alter
       * };
       *
       * var myBoundFunction = qx.Bootstrap.bind(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Function} The bound function.
       */
      bind : function(bG, self, bH){

        var bI = Array.prototype.slice.call(arguments, 2, arguments.length);
        return function(){

          var bJ = Array.prototype.slice.call(arguments, 0, arguments.length);
          return bG.apply(self, bI.concat(bJ));
        };
      },
      /*
      ---------------------------------------------------------------------------
        STRING UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      /**
       * Convert the first character of the string to upper case.
       *
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp : function(bK){

        return bK.charAt(0).toUpperCase() + bK.substr(1);
      },
      /**
       * Convert the first character of the string to lower case.
       *
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow : function(bL){

        return bL.charAt(0).toLowerCase() + bL.substr(1);
      },
      /*
      ---------------------------------------------------------------------------
        TYPE UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      /**
       * Get the internal class of the value. See
       * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
       * for details.
       *
       * @param value {var} value to get the class for
       * @return {String} the internal class of the value
       */
      getClass : function(bM){

        var bN = Object.prototype.toString.call(bM);
        return (qx.Bootstrap.__classToTypeMap[bN] || bN.slice(8, -1));
      },
      /**
       * Whether the value is a string.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a string.
       */
      isString : function(bO){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof String" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (bO !== null && (typeof bO === c || qx.Bootstrap.getClass(bO) == y || bO instanceof String || (!!bO && !!bO.$$isString)));
      },
      /**
       * Whether the value is an array.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an array.
       */
      isArray : function(bP){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Array" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (bP !== null && (bP instanceof Array || (bP && qx.data && qx.data.IListData && qx.util.OOUtil.hasInterface(bP.constructor, qx.data.IListData)) || qx.Bootstrap.getClass(bP) == v || (!!bP && !!bP.$$isArray)));
      },
      /**
       * Whether the value is an object. Note that built-in types like Window are
       * not reported to be objects.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an object.
       */
      isObject : function(bQ){

        return (bQ !== undefined && bQ !== null && qx.Bootstrap.getClass(bQ) == q);
      },
      /**
       * Whether the value is a function.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function.
       */
      isFunction : function(bR){

        return qx.Bootstrap.getClass(bR) == x;
      },
      /*
      ---------------------------------------------------------------------------
        LOGGING UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      $$logs : [],
      /**
       * Sending a message at level "debug" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      debug : function(bS, bT){

        qx.Bootstrap.$$logs.push([s, arguments]);
      },
      /**
       * Sending a message at level "info" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      info : function(bU, bV){

        qx.Bootstrap.$$logs.push([I, arguments]);
      },
      /**
       * Sending a message at level "warn" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      warn : function(bW, bX){

        qx.Bootstrap.$$logs.push([f, arguments]);
      },
      /**
       * Sending a message at level "error" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      error : function(bY, ca){

        qx.Bootstrap.$$logs.push([B, arguments]);
      },
      /**
       * Prints the current stack trace at level "info"
       *
       * @param object {Object} Contextual object (either instance or static class)
       */
      trace : function(cb){
      }
    }
  });
})();
(function(){

  var cs = "qx.blankpage",cr = "qx.bom.client.Stylesheet.getInsertRule",cq = "qx.bom.client.Html.getDataset",cp = "qx.bom.client.PhoneGap.getPhoneGap",co = '] found, and no default ("default") given',cn = "qx.bom.client.Html.getAudioAif",cm = "qx.bom.client.CssTransform.get3D",cl = ' type)',ck = "qx.bom.client.Xml.getAttributeNS",cj = "qx.bom.client.Stylesheet.getRemoveImport",bt = "qx.bom.client.Css.getUserModify",bs = "qx.bom.client.Css.getFilterGradient",br = "qx.bom.client.Event.getHashChange",bq = "qx.bom.client.Plugin.getWindowsMedia",bp = "qx.bom.client.Html.getVideo",bo = "qx.bom.client.Device.getName",bn = "qx.bom.client.Event.getTouch",bm = "qx.optimization.strings",bl = "qx.debug.property.level",bk = "qx.optimization.variables",cz = "qx.bom.client.EcmaScript.getStackTrace",cA = "qx.bom.client.Xml.getSelectSingleNode",cx = "qx.bom.client.Xml.getImplementation",cy = "qx.bom.client.Html.getConsole",cv = "qx.bom.client.Engine.getVersion",cw = "qx.bom.client.Plugin.getQuicktime",ct = "qx.bom.client.Html.getNaturalDimensions",cu = "qx.bom.client.Xml.getSelectNodes",cB = "qx.bom.client.Xml.getElementsByTagNameNS",cC = "qx.bom.client.Html.getDataUrl",bR = "qx.bom.client.Flash.isAvailable",bQ = "qx.bom.client.Html.getCanvas",bT = "qx.bom.client.Css.getBoxModel",bS = "qx.bom.client.Plugin.getSilverlight",bV = "qx/static/blank.html",bU = "qx.bom.client.Css.getUserSelect",bX = "qx.bom.client.Css.getRadialGradient",bW = "module.property",bP = "qx.bom.client.Plugin.getWindowsMediaVersion",bO = "qx.bom.client.Stylesheet.getCreateStyleSheet",a = 'No match for variant "',b = "qx.bom.client.Locale.getLocale",c = "module.events",d = "module.databinding",e = "qx.bom.client.Html.getFileReader",f = "qx.bom.client.Css.getBorderImage",g = "qx.bom.client.Stylesheet.getDeleteRule",h = "qx.bom.client.Plugin.getDivXVersion",j = "qx.bom.client.Scroll.scrollBarOverlayed",k = "qx.bom.client.Plugin.getPdfVersion",cQ = ":",cP = "qx.bom.client.Css.getLinearGradient",cO = "qx.bom.client.Transport.getXmlHttpRequest",cN = "qx.bom.client.Css.getBorderImageSyntax",cU = "qx.bom.client.Html.getClassList",cT = "qx.bom.client.Event.getHelp",cS = "qx.optimization.comments",cR = "qx.bom.client.Locale.getVariant",cW = "qx.bom.client.Css.getBoxSizing",cV = "qx.bom.client.OperatingSystem.getName",J = "module.logger",K = "qx.bom.client.Css.getOverflowXY",H = "qx.mobile.emulatetouch",I = "qx.bom.client.Html.getAudioWav",N = "qx.bom.client.Browser.getName",O = "qx.bom.client.Css.getInlineBlock",L = "qx.bom.client.Plugin.getPdf",M = "qx.dynlocale",F = '" (',G = "qx.bom.client.Html.getAudio",s = "qx.core.Environment",r = "qx.bom.client.CssTransform.getSupport",u = "qx.bom.client.Html.getTextContent",t = "qx.bom.client.Css.getPlaceholder",o = "qx.bom.client.Css.getFloat",n = ' in variants [',q = "false",p = "qx.bom.client.Css.getBoxShadow",m = "qx.bom.client.Html.getXul",l = "qx.bom.client.Xml.getCreateNode",T = "qxenv",U = "qx.bom.client.Html.getSessionStorage",V = "qx.bom.client.Html.getAudioAu",W = "qx.bom.client.Css.getOpacity",P = "qx.bom.client.Css.getFilterTextShadow",Q = "qx.bom.client.Html.getVml",R = "qx.bom.client.Css.getRgba",S = "qx.bom.client.Transport.getMaxConcurrentRequestCount",X = "qx.bom.client.Css.getBorderRadius",Y = "qx.bom.client.Event.getPointer",C = "qx.bom.client.Transport.getSsl",B = "qx.bom.client.Html.getWebWorker",A = "qx.bom.client.Json.getJson",z = "qx.bom.client.Browser.getQuirksMode",y = "qx.debug.dispose",x = "qx.bom.client.Css.getTextOverflow",w = "qx.bom.client.Xml.getQualifiedItem",v = "qx.bom.client.Html.getVideoOgg",E = "&",D = "qx.bom.client.Device.getType",ba = "qx.bom.client.Browser.getDocumentMode",bb = "qx.allowUrlVariants",bc = "qx.bom.client.Html.getContains",bd = "qx.bom.client.Plugin.getActiveX",be = ".",bf = "qx.bom.client.Xml.getDomProperties",bg = "qx.bom.client.CssAnimation.getSupport",bh = "qx.debug.databinding",bi = "qx.optimization.basecalls",bj = "qx.bom.client.Browser.getVersion",bx = "qx.bom.client.Css.getUserSelectNone",bw = "qx.bom.client.Html.getSvg",bv = "qx.optimization.privates",bu = "qx.bom.client.Plugin.getDivX",bB = "qx.bom.client.Runtime.getName",bA = "qx.bom.client.Html.getLocalStorage",bz = "qx.bom.client.Flash.getStrictSecurityModel",by = "qx.aspects",bD = "qx.debug",bC = "qx.dynamicmousewheel",bK = "qx.bom.client.Html.getAudioMp3",bL = "qx.bom.client.Engine.getName",bI = "qx.bom.client.Html.getUserDataStorage",bJ = "qx.bom.client.Plugin.getGears",bG = "qx.bom.client.Plugin.getQuicktimeVersion",bH = "qx.bom.client.Html.getAudioOgg",bE = "qx.bom.client.Css.getTextShadow",bF = "qx.bom.client.Plugin.getSilverlightVersion",bM = "qx.bom.client.Html.getCompareDocumentPosition",bN = "qx.bom.client.Flash.getExpressInstall",cc = "qx.bom.client.OperatingSystem.getVersion",cb = "qx.bom.client.Html.getXPath",ce = "qx.bom.client.Html.getGeoLocation",cd = "qx.bom.client.Css.getAppearance",cg = "qx.mobile.nativescroll",cf = "qx.bom.client.Xml.getDomParser",ci = "qx.bom.client.Stylesheet.getAddImport",ch = "qx.optimization.variants",ca = "qx.bom.client.Html.getVideoWebm",bY = "qx.bom.client.Flash.getVersion",cJ = "qx.bom.client.Css.getLegacyWebkitGradient",cK = "qx.bom.client.PhoneGap.getNotification",cL = "qx.bom.client.Html.getVideoH264",cM = "qx.bom.client.Xml.getCreateElementNS",cF = "qx.core.Environment for a list of predefined keys.",cG = " is not a valid key. Please see the API-doc of ",cH = "default",cI = "|",cD = "true",cE = "qx.allowUrlSettings";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2005-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class is the single point to access all settings that may be different
   * in different environments. This contains e.g. the browser name, engine
   * version but also qooxdoo or application specific settings.
   *
   * Its public API can be found in its four main methods. One pair of methods
   * is used to check the synchronous values of the environment. The other pair
   * of methods is used for asynchronous checks.
   *
   * The most often used method should be {@link #get}, which returns the
   * current value for a given environment check.
   *
   * All qooxdoo settings can be changed via the generator's config. See the manual
   * for more details about the environment key in the config. As you can see
   * from the methods API, there is no way to override an existing key. So if you
   * need to change a qooxdoo setting, you have to use the generator to do so.
   *
   * The following table shows the available checks. If you are
   * interested in more details, check the reference to the implementation of
   * each check. Please do not use those check implementations directly, as the
   * Environment class comes with a smart caching feature.
   *
   * <table border="0" cellspacing="10">
   *   <tbody>
   *     <tr>
   *       <td colspan="4"><h2>Synchronous checks</h2>
   *       </td>
   *     </tr>
   *     <tr>
   *       <th><h3>Key</h3></th>
   *       <th><h3>Type</h3></th>
   *       <th><h3>Example</h3></th>
   *       <th><h3>Details</h3></th>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>browser</b></td>
   *     </tr>
   *     <tr>
   *       <td>browser.documentmode</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td>{@link qx.bom.client.Browser#getDocumentMode}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.name</td><td><i>String</i></td><td><code> chrome </code></td>
   *       <td>{@link qx.bom.client.Browser#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.quirksmode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Browser#getQuirksMode}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.version</td><td><i>String</i></td><td><code>11.0</code></td>
   *       <td>{@link qx.bom.client.Browser#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>runtime</b></td>
   *     </tr>
   *     <tr>
   *       <td>runtime.name</td><td><i> String </i></td><td><code> node.js </code></td>
   *       <td>{@link qx.bom.client.Runtime#getName}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>css</b></td>
   *     </tr>
   *     <tr>
   *       <td>css.borderradius</td><td><i>String</i> or <i>null</i></td><td><code>borderRadius</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderRadius}</td>
   *     </tr>
   *     <tr>
   *       <td>css.borderimage</td><td><i>String</i> or <i>null</i></td><td><code>WebkitBorderImage</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderImage}</td>
   *     </tr>
   *     <tr>
   *       <td>css.borderimage.standardsyntax</td><td><i>Boolean</i> or <i>null</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderImageSyntax}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxmodel</td><td><i>String</i></td><td><code>content</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxModel}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxshadow</td><td><i>String</i> or <i>null</i></td><td><code>boxShadow</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxShadow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.linear</td><td><i>String</i> or <i>null</i></td><td><code>-moz-linear-gradient</code></td>
   *       <td>{@link qx.bom.client.Css#getLinearGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.filter</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getFilterGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.radial</td><td><i>String</i> or <i>null</i></td><td><code>-moz-radial-gradient</code></td>
   *       <td>{@link qx.bom.client.Css#getRadialGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.legacywebkit</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Css#getLegacyWebkitGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.placeholder</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getPlaceholder}</td>
   *     </tr>
   *     <tr>
   *       <td>css.textoverflow</td><td><i>String</i> or <i>null</i></td><td><code>textOverflow</code></td>
   *       <td>{@link qx.bom.client.Css#getTextOverflow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.rgba</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getRgba}</td>
   *     </tr>
   *     <tr>
   *       <td>css.usermodify</td><td><i>String</i> or <i>null</i></td><td><code>WebkitUserModify</code></td>
   *       <td>{@link qx.bom.client.Css#getUserModify}</td>
   *     </tr>
   *     <tr>
   *       <td>css.appearance</td><td><i>String</i> or <i>null</i></td><td><code>WebkitAppearance</code></td>
   *       <td>{@link qx.bom.client.Css#getAppearance}</td>
   *     </tr>
   *     <tr>
   *       <td>css.float</td><td><i>String</i> or <i>null</i></td><td><code>cssFloat</code></td>
   *       <td>{@link qx.bom.client.Css#getFloat}</td>
   *     </tr>
   *     <tr>
   *       <td>css.userselect</td><td><i>String</i> or <i>null</i></td><td><code>WebkitUserSelect</code></td>
   *       <td>{@link qx.bom.client.Css#getUserSelect}</td>
   *     </tr>
   *     <tr>
   *       <td>css.userselect.none</td><td><i>String</i> or <i>null</i></td><td><code>-moz-none</code></td>
   *       <td>{@link qx.bom.client.Css#getUserSelectNone}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxsizing</td><td><i>String</i> or <i>null</i></td><td><code>boxSizing</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxSizing}</td>
   *     </tr>
   *     <tr>
   *       <td>css.animation</td><td><i>Object</i> or <i>null</i></td><td><code>{end-event: "webkitAnimationEnd", keyframes: "@-webkit-keyframes", play-state: null, name: "WebkitAnimation"}</code></td>
   *       <td>{@link qx.bom.client.CssAnimation#getSupport}</td>
   *     </tr>
   *     <tr>
   *       <td>css.transform</td><td><i>Object</i> or <i>null</i></td><td><code>{3d: true, origin: "WebkitTransformOrigin", name: "WebkitTransform", style: "WebkitTransformStyle", perspective: "WebkitPerspective", perspective-origin: "WebkitPerspectiveOrigin", backface-visibility: "WebkitBackfaceVisibility"}</code></td>
   *       <td>{@link qx.bom.client.CssTransform#getSupport}</td>
   *     </tr>
   *     <tr>
   *       <td>css.transform.3d</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.CssTransform#get3D}</td>
   *     </tr>
   *     <tr>
   *       <td>css.inlineblock</td><td><i>String</i> or <i>null</i></td><td><code>inline-block</code></td>
   *       <td>{@link qx.bom.client.Css#getInlineBlock}</td>
   *     </tr>
   *     <tr>
   *       <td>css.opacity</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getOpacity}</td>
   *     </tr>
   *     <tr>
   *       <td>css.overflowxy</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getOverflowXY}</td>
   *     </tr>
   *     <tr>
   *       <td>css.textShadow</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getTextShadow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.textShadow.filter</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getFilterTextShadow}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>device</b></td>
   *     </tr>
   *     <tr>
   *       <td>device.name</td><td><i>String</i></td><td><code>pc</code></td>
   *       <td>{@link qx.bom.client.Device#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>device.type</td><td><i>String</i></td><td><code>mobile</code></td>
   *       <td>{@link qx.bom.client.Device#getType}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>ecmascript</b></td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.stacktrace</td><td><i>String</i> or <i>null</i></td><td><code>stack</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getStackTrace}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>engine</b></td>
   *     </tr>
   *     <tr>
   *       <td>engine.name</td><td><i>String</i></td><td><code>webkit</code></td>
   *       <td>{@link qx.bom.client.Engine#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>engine.version</td><td><i>String</i></td><td><code>534.24</code></td>
   *       <td>{@link qx.bom.client.Engine#getVersion}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>event</b></td>
   *     </tr>
   *     <tr>
   *       <td>event.pointer</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getPointer}</td>
   *     </tr>
   *     <tr>
   *       <td>event.touch</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Event#getTouch}</td>
   *     </tr>
   *     <tr>
   *       <td>event.help</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Event#getHelp}</td>
   *     </tr>
   *     <tr>
   *       <td>event.hashchange</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getHashChange}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>html</b></td>
   *     </tr>
   *     <tr>
   *       <td>html.audio</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getAudio}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.mp3</td><td><i>String</i></td><td><code>""</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioMp3}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.ogg</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioOgg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.wav</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioWav}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.au</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioAu}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.aif</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioAif}</td>
   *     </tr>
   *     <tr>
   *       <td>html.canvas</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getCanvas}</td>
   *     </tr>
   *     <tr>
   *       <td>html.classlist</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getClassList}</td>
   *     </tr>
   *     <tr>
   *       <td>html.geolocation</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getGeoLocation}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.local</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getLocalStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.session</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getSessionStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.userdata</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getUserDataStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.svg</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getSvg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getVideo}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.h264</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoH264}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.ogg</td><td><i>String</i></td><td><code>""</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoOgg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.webm</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoWebm}</td>
   *     </tr>
   *     <tr>
   *       <td>html.vml</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Html#getVml}</td>
   *     </tr>
   *     <tr>
   *       <td>html.webworker</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getWebWorker}</td>
   *     <tr>
   *       <td>html.filereader</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getFileReader}</td>
   *     </tr>
   *     <tr>
   *       <td>html.xpath</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getXPath}</td>
   *     </tr>
   *     <tr>
   *       <td>html.xul</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getXul}</td>
   *     </tr>
   *     <tr>
   *       <td>html.console</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getConsole}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.contains</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getContains}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.compareDocumentPosition</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getCompareDocumentPosition}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.textContent</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getTextContent}</td>
   *     </tr>
   *     <tr>
   *       <td>html.image.naturaldimensions</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getNaturalDimensions}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>XML</b></td>
   *     </tr>
   *     <tr>
   *       <td>xml.implementation</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getImplementation}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.domparser</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getDomParser}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.selectsinglenode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getSelectSingleNode}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.selectnodes</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getSelectNodes}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.getelementsbytagnamens</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getElementsByTagNameNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.domproperties</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getDomProperties}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.attributens</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getAttributeNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.createelementns</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getCreateElementNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.createnode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getCreateNode}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.getqualifieditem</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getQualifiedItem}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>Stylesheets</b></td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.createstylesheet</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getCreateStyleSheet}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.insertrule</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getInsertRule}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.deleterule</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getDeleteRule}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.addimport</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getAddImport}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.removeimport</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getRemoveImport}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>io</b></td>
   *     </tr>
   *     <tr>
   *       <td>io.maxrequests</td><td><i>Integer</i></td><td><code>4</code></td>
   *       <td>{@link qx.bom.client.Transport#getMaxConcurrentRequestCount}</td>
   *     </tr>
   *     <tr>
   *       <td>io.ssl</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Transport#getSsl}</td>
   *     </tr>
   *     <tr>
   *       <td>io.xhr</td><td><i>String</i></td><td><code>xhr</code></td>
   *       <td>{@link qx.bom.client.Transport#getXmlHttpRequest}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>locale</b></td>
   *     </tr>
   *     <tr>
   *       <td>locale</td><td><i>String</i></td><td><code>de</code></td>
   *       <td>{@link qx.bom.client.Locale#getLocale}</td>
   *     </tr>
   *     <tr>
   *       <td>locale.variant</td><td><i>String</i></td><td><code>de</code></td>
   *       <td>{@link qx.bom.client.Locale#getVariant}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>os</b></td>
   *     </tr>
   *     <tr>
   *       <td>os.name</td><td><i>String</i></td><td><code>osx</code></td>
   *       <td>{@link qx.bom.client.OperatingSystem#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>os.version</td><td><i>String</i></td><td><code>10.6</code></td>
   *       <td>{@link qx.bom.client.OperatingSystem#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>os.scrollBarOverlayed</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Scroll#scrollBarOverlayed}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>phonegap</b></td>
   *     </tr>
   *     <tr>
   *       <td>phonegap</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.PhoneGap#getPhoneGap}</td>
   *     </tr>
   *     <tr>
   *       <td>phonegap.notification</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.PhoneGap#getNotification}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>plugin</b></td>
   *     </tr>
   *     <tr>
   *       <td>plugin.divx</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getDivX}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.divx.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getDivXVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#isAvailable}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.express</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#getExpressInstall}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.strictsecurity</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#getStrictSecurityModel}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.version</td><td><i>String</i></td><td><code>10.2.154</code></td>
   *       <td>{@link qx.bom.client.Flash#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.gears</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getGears}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.activex</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getActiveX}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.pdf</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getPdf}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.pdf.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getPdfVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.quicktime</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Plugin#getQuicktime}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.quicktime.version</td><td><i>String</i></td><td><code>7.6</code></td>
   *       <td>{@link qx.bom.client.Plugin#getQuicktimeVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.silverlight</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getSilverlight}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.silverlight.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getSilverlightVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.windowsmedia</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getWindowsMedia}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.windowsmedia.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getWindowsMediaVersion}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>qx</b></td>
   *     </tr>
   *     <tr>
   *       <td>qx.allowUrlSettings</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.allowUrlVariants</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.application</td><td><i>String</i></td><td><code>name.space</code></td>
   *       <td><i>default:</i> <code>&lt;&lt;application name&gt;&gt;</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.aspects</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.databinding</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.dispose</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.dispose.level</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td><i>default:</i> <code>0</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.io</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *     <tr>
   *       <td>qx.debug.io.remote</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *     <tr>
   *       <td>qx.debug.io.remote.data</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.property.level</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td><i>default:</i> <code>0</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.dynamicmousewheel</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.dynlocale</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.globalErrorHandling</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.mobile.emulatetouch</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.mobile.nativescroll</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.basecalls</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.comments</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.privates</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.strings</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.variables</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.variants</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresp. <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.revision</td><td><i>String</i></td><td><code>27348</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.theme</td><td><i>String</i></td><td><code>qx.theme.Modern</code></td>
   *       <td><i>default:</i> <code>&lt;&lt;theme name&gt;&gt;</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.version</td><td><i>String</i></td><td><code>${qxversion}</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.blankpage</td><td><i>String</i></td><td><code>URI to blank.html page</code></td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>module</b></td>
   *     </tr>
   *     <tr>
   *       <td>module.databinding</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.logger</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.property</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.events</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><h3>Asynchronous checks</h3>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td>html.dataurl</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getDataUrl}</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   */
  qx.Bootstrap.define(s, {
    statics : {
      /** Map containing the synchronous check functions. */
      _checks : {
      },
      /** Map containing the asynchronous check functions. */
      _asyncChecks : {
      },
      /** Internal cache for all checks. */
      __cache : {
      },
      /** Internal map for environment keys to check methods. */
      _checksMap : {
        "engine.version" : cv,
        "engine.name" : bL,
        "browser.name" : N,
        "browser.version" : bj,
        "browser.documentmode" : ba,
        "browser.quirksmode" : z,
        "runtime.name" : bB,
        "device.name" : bo,
        "device.type" : D,
        "locale" : b,
        "locale.variant" : cR,
        "os.name" : cV,
        "os.version" : cc,
        "os.scrollBarOverlayed" : j,
        "plugin.gears" : bJ,
        "plugin.activex" : bd,
        "plugin.quicktime" : cw,
        "plugin.quicktime.version" : bG,
        "plugin.windowsmedia" : bq,
        "plugin.windowsmedia.version" : bP,
        "plugin.divx" : bu,
        "plugin.divx.version" : h,
        "plugin.silverlight" : bS,
        "plugin.silverlight.version" : bF,
        "plugin.flash" : bR,
        "plugin.flash.version" : bY,
        "plugin.flash.express" : bN,
        "plugin.flash.strictsecurity" : bz,
        "plugin.pdf" : L,
        "plugin.pdf.version" : k,
        "io.maxrequests" : S,
        "io.ssl" : C,
        "io.xhr" : cO,
        "event.touch" : bn,
        "event.pointer" : Y,
        "event.help" : cT,
        "event.hashchange" : br,
        "ecmascript.stacktrace" : cz,
        "html.webworker" : B,
        "html.filereader" : e,
        "html.geolocation" : ce,
        "html.audio" : G,
        "html.audio.ogg" : bH,
        "html.audio.mp3" : bK,
        "html.audio.wav" : I,
        "html.audio.au" : V,
        "html.audio.aif" : cn,
        "html.video" : bp,
        "html.video.ogg" : v,
        "html.video.h264" : cL,
        "html.video.webm" : ca,
        "html.storage.local" : bA,
        "html.storage.session" : U,
        "html.storage.userdata" : bI,
        "html.classlist" : cU,
        "html.xpath" : cb,
        "html.xul" : m,
        "html.canvas" : bQ,
        "html.svg" : bw,
        "html.vml" : Q,
        "html.dataset" : cq,
        "html.dataurl" : cC,
        "html.console" : cy,
        "html.stylesheet.createstylesheet" : bO,
        "html.stylesheet.insertrule" : cr,
        "html.stylesheet.deleterule" : g,
        "html.stylesheet.addimport" : ci,
        "html.stylesheet.removeimport" : cj,
        "html.element.contains" : bc,
        "html.element.compareDocumentPosition" : bM,
        "html.element.textcontent" : u,
        "html.image.naturaldimensions" : ct,
        "json" : A,
        "css.textoverflow" : x,
        "css.placeholder" : t,
        "css.borderradius" : X,
        "css.borderimage" : f,
        "css.borderimage.standardsyntax" : cN,
        "css.boxshadow" : p,
        "css.gradient.linear" : cP,
        "css.gradient.filter" : bs,
        "css.gradient.radial" : bX,
        "css.gradient.legacywebkit" : cJ,
        "css.boxmodel" : bT,
        "css.rgba" : R,
        "css.userselect" : bU,
        "css.userselect.none" : bx,
        "css.usermodify" : bt,
        "css.appearance" : cd,
        "css.float" : o,
        "css.boxsizing" : cW,
        "css.animation" : bg,
        "css.transform" : r,
        "css.transform.3d" : cm,
        "css.inlineblock" : O,
        "css.opacity" : W,
        "css.overflowxy" : K,
        "css.textShadow" : bE,
        "css.textShadow.filter" : P,
        "phonegap" : cp,
        "phonegap.notification" : cK,
        "xml.implementation" : cx,
        "xml.domparser" : cf,
        "xml.selectsinglenode" : cA,
        "xml.selectnodes" : cu,
        "xml.getelementsbytagnamens" : cB,
        "xml.domproperties" : bf,
        "xml.attributens" : ck,
        "xml.createnode" : l,
        "xml.getqualifieditem" : w,
        "xml.createelementns" : cM
      },
      /**
       * The default accessor for the checks. It returns the value the current
       * environment has for the given key. The key could be something like
       * "qx.debug", "css.textoverflow" or "io.ssl". A complete list of
       * checks can be found in the class comment of this class.
       *
       * Please keep in mind that the result is cached. If you want to run the
       * check function again in case something could have been changed, take a
       * look at the {@link #invalidateCacheKey} function.
       *
       * @param key {String} The name of the check you want to query.
       * @return {var} The stored value depending on the given key.
       *   (Details in the class doc)
       */
      get : function(cX){

        // check the cache
        if(this.__cache[cX] != undefined){

          return this.__cache[cX];
        };
        // search for a matching check
        var db = this._checks[cX];
        if(db){

          // execute the check and write the result in the cache
          var dc = db();
          this.__cache[cX] = dc;
          return dc;
        };
        // try class lookup
        var da = this._getClassNameFromEnvKey(cX);
        if(da[0] != undefined){

          var dd = da[0];
          var cY = da[1];
          var dc = dd[cY]();
          // call the check method
          this.__cache[cX] = dc;
          return dc;
        };
        // debug flag
        if(qx.Bootstrap.DEBUG){

          qx.Bootstrap.warn(cX + cG + cF);
          qx.Bootstrap.trace(this);
        };
      },
      /**
       * Maps an environment key to a check class and method name.
       *
       * @param key {String} The name of the check you want to query.
       * @return {Array} [className, methodName] of
       *  the corresponding implementation.
       */
      _getClassNameFromEnvKey : function(de){

        var dk = this._checksMap;
        if(dk[de] != undefined){

          var dg = dk[de];
          // separate class from method
          var dj = dg.lastIndexOf(be);
          if(dj > -1){

            var di = dg.slice(0, dj);
            var df = dg.slice(dj + 1);
            var dh = qx.Bootstrap.getByName(di);
            if(dh != undefined){

              return [dh, df];
            };
          };
        };
        return [undefined, undefined];
      },
      /**
       * Invokes the callback as soon as the check has been done. If no check
       * could be found, a warning will be printed.
       *
       * @param key {String} The key of the asynchronous check.
       * @param callback {Function} The function to call as soon as the check is
       *   done. The function should have one argument which is the result of the
       *   check.
       * @param self {var} The context to use when invoking the callback.
       */
      getAsync : function(dl, dm, self){

        // check the cache
        var dr = this;
        if(this.__cache[dl] != undefined){

          // force async behavior
          window.setTimeout(function(){

            dm.call(self, dr.__cache[dl]);
          }, 0);
          return;
        };
        var dq = this._asyncChecks[dl];
        if(dq){

          dq(function(dt){

            dr.__cache[dl] = dt;
            dm.call(self, dt);
          });
          return;
        };
        // try class lookup
        var dp = this._getClassNameFromEnvKey(dl);
        if(dp[0] != undefined){

          var ds = dp[0];
          var dn = dp[1];
          ds[dn](function(du){

            // call the check method
            dr.__cache[dl] = du;
            dm.call(self, du);
          });
          return;
        };
        // debug flag
        if(qx.Bootstrap.DEBUG){

          qx.Bootstrap.warn(dl + cG + cF);
          qx.Bootstrap.trace(this);
        };
      },
      /**
       * Returns the proper value dependent on the check for the given key.
       *
       * @param key {String} The name of the check the select depends on.
       * @param values {Map} A map containing the values which should be returned
       *   in any case. The "default" key could be used as a catch all statement.
       * @return {var} The value which is stored in the map for the given
       *   check of the key.
       */
      select : function(dv, dw){

        return this.__pickFromValues(this.get(dv), dw);
      },
      /**
       * Selects the proper function dependent on the asynchronous check.
       *
       * @param key {String} The key for the async check.
       * @param values {Map} A map containing functions. The map keys should
       *   contain all possibilities which could be returned by the given check
       *   key. The "default" key could be used as a catch all statement.
       *   The called function will get one parameter, the result of the query.
       * @param self {var} The context which should be used when calling the
       *   method in the values map.
       */
      selectAsync : function(dx, dy, self){

        this.getAsync(dx, function(dz){

          var dA = this.__pickFromValues(dx, dy);
          dA.call(self, dz);
        }, this);
      },
      /**
       * Internal helper which tries to pick the given key from the given values
       * map. If that key is not found, it tries to use a key named "default".
       * If there is also no default key, it prints out a warning and returns
       * undefined.
       *
       * @param key {String} The key to search for in the values.
       * @param values {Map} A map containing some keys.
       * @return {var} The value stored as values[key] usually.
       */
      __pickFromValues : function(dB, dC){

        var dE = dC[dB];
        if(dC.hasOwnProperty(dB)){

          return dE;
        };
        // check for piped values
        for(var dD in dC){

          if(dD.indexOf(cI) != -1){

            var dF = dD.split(cI);
            for(var i = 0;i < dF.length;i++){

              if(dF[i] == dB){

                return dC[dD];
              };
            };
          };
        };
        if(dC[cH] !== undefined){

          return dC[cH];
        };
        if(qx.Bootstrap.DEBUG){

          throw new Error(a + dB + F + (typeof dB) + cl + n + qx.Bootstrap.getKeysAsString(dC) + co);
        };
      },
      /**
       * Takes a given map containing the check names as keys and converts
       * the map to an array only containing the values for check evaluating
       * to <code>true</code>. This is especially handy for conditional
       * includes of mixins.
       * @param map {Map} A map containing check names as keys and values.
       * @return {Array} An array containing the values.
       */
      filter : function(dG){

        var dI = [];
        for(var dH in dG){

          if(this.get(dH)){

            dI.push(dG[dH]);
          };
        };
        return dI;
      },
      /**
       * Invalidates the cache for the given key.
       *
       * @param key {String} The key of the check.
       */
      invalidateCacheKey : function(dJ){

        delete this.__cache[dJ];
      },
      /**
       * Add a check to the environment class. If there is already a check
       * added for the given key, the add will be ignored.
       *
       * @param key {String} The key for the check e.g. html.featurexyz.
       * @param check {var} It could be either a function or a simple value.
       *   The function should be responsible for the check and should return the
       *   result of the check.
       */
      add : function(dK, dL){

        // ignore already added checks.
        if(this._checks[dK] == undefined){

          // add functions directly
          if(dL instanceof Function){

            this._checks[dK] = dL;
          } else {

            this._checks[dK] = this.__createCheck(dL);
          };
        };
      },
      /**
       * Adds an asynchronous check to the environment. If there is already a check
       * added for the given key, the add will be ignored.
       *
       * @param key {String} The key of the check e.g. html.featureabc
       * @param check {Function} A function which should check for a specific
       *   environment setting in an asynchronous way. The method should take two
       *   arguments. First one is the callback and the second one is the context.
       */
      addAsync : function(dM, dN){

        if(this._checks[dM] == undefined){

          this._asyncChecks[dM] = dN;
        };
      },
      /**
       * Returns all currently defined synchronous checks.
       *
       * @internal
       * @return {Map} The map of synchronous checks
       */
      getChecks : function(){

        return this._checks;
      },
      /**
       * Returns all currently defined asynchronous checks.
       *
       * @internal
       * @return {Map} The map of asynchronous checks
       */
      getAsyncChecks : function(){

        return this._asyncChecks;
      },
      /**
       * Initializer for the default values of the framework settings.
       */
      _initDefaultQxValues : function(){

        // an always-true key (e.g. for use in qx.core.Environment.filter() calls)
        this.add(cD, function(){

          return true;
        });
        // old settings
        this.add(cE, function(){

          return false;
        });
        this.add(bb, function(){

          return false;
        });
        this.add(bl, function(){

          return 0;
        });
        // old variants
        // make sure to reflect all changes to qx.debug here in the bootstrap class!
        this.add(bD, function(){

          return true;
        });
        this.add(by, function(){

          return false;
        });
        this.add(M, function(){

          return true;
        });
        this.add(H, function(){

          return false;
        });
        this.add(cg, function(){

          return false;
        });
        this.add(cs, function(){

          return bV;
        });
        this.add(bC, function(){

          return true;
        });
        this.add(bh, function(){

          return false;
        });
        this.add(y, function(){

          return false;
        });
        // generator optimization vectors
        this.add(bi, function(){

          return false;
        });
        this.add(cS, function(){

          return false;
        });
        this.add(bv, function(){

          return false;
        });
        this.add(bm, function(){

          return false;
        });
        this.add(bk, function(){

          return false;
        });
        this.add(ch, function(){

          return false;
        });
        // qooxdoo modules
        this.add(d, function(){

          return true;
        });
        this.add(J, function(){

          return true;
        });
        this.add(bW, function(){

          return true;
        });
        this.add(c, function(){

          return true;
        });
      },
      /**
       * Import checks from global qx.$$environment into the Environment class.
       */
      __importFromGenerator : function(){

        // import the environment map
        if(qx && qx.$$environment){

          for(var dP in qx.$$environment){

            var dO = qx.$$environment[dP];
            this._checks[dP] = this.__createCheck(dO);
          };
        };
      },
      /**
       * Checks the URL for environment settings and imports these into the
       * Environment class.
       */
      __importFromUrl : function(){

        if(window.document && window.document.location){

          var dQ = window.document.location.search.slice(1).split(E);
          for(var i = 0;i < dQ.length;i++){

            var dS = dQ[i].split(cQ);
            if(dS.length != 3 || dS[0] != T){

              continue;
            };
            var dT = dS[1];
            var dR = decodeURIComponent(dS[2]);
            // implicit type conversion
            if(dR == cD){

              dR = true;
            } else if(dR == q){

              dR = false;
            } else if(/^(\d|\.)+$/.test(dR)){

              dR = parseFloat(dR);
            };;
            this._checks[dT] = this.__createCheck(dR);
          };
        };
      },
      /**
       * Internal helper which creates a function returning the given value.
       *
       * @param value {var} The value which should be returned.
       * @return {Function} A function which could be used by a test.
       */
      __createCheck : function(dU){

        return qx.Bootstrap.bind(function(dV){

          return dV;
        }, null, dU);
      }
    },
    defer : function(dW){

      // create default values for the environment class
      dW._initDefaultQxValues();
      // load the checks from the generator
      dW.__importFromGenerator();
      // load the checks from the url
      if(dW.get(cE) === true){

        dW.__importFromUrl();
      };
    }
  });
})();
(function(){

  var a = "qx.util.OOUtil";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */
  /**
   * This class is a base class for the OO system defined by Class, Mixin
   * and Interface. It contains helper which are basically needed to create the
   * Classes which define the OO system.
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * Whether the given class exists
       *
       * @param name {String} class name to check
       * @return {Boolean} true if class exists
       */
      classIsDefined : function(name){

        return qx.Bootstrap.getByName(name) !== undefined;
      },
      /**
       * Returns the definition of the given property. Returns null
       * if the property does not exist.
       *
       * TODO: Correctly support refined properties?
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the class to check for
       * @return {Map|null} whether the object support the given event.
       */
      getPropertyDefinition : function(b, name){

        while(b){

          if(b.$$properties && b.$$properties[name]){

            return b.$$properties[name];
          };
          b = b.superclass;
        };
        return null;
      },
      /**
       * Whether a class has the given property
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the property to check for
       * @return {Boolean} whether the class includes the given property.
       */
      hasProperty : function(c, name){

        return !!qx.util.OOUtil.getPropertyDefinition(c, name);
      },
      /**
       * Returns the event type of the given event. Returns null if
       * the event does not exist.
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the event
       * @return {Map|null} Event type of the given event.
       */
      getEventType : function(d, name){

        var d = d.constructor;
        while(d.superclass){

          if(d.$$events && d.$$events[name] !== undefined){

            return d.$$events[name];
          };
          d = d.superclass;
        };
        return null;
      },
      /**
       * Whether a class supports the given event type
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the event to check for
       * @return {Boolean} whether the class supports the given event.
       */
      supportsEvent : function(e, name){

        return !!qx.util.OOUtil.getEventType(e, name);
      },
      /**
       * Returns the class or one of its super classes which contains the
       * declaration of the given interface. Returns null if the interface is not
       * specified anywhere.
       *
       * @param clazz {Class} class to look for the interface
       * @param iface {Interface} interface to look for
       * @return {Class | null} the class which directly implements the given interface
       */
      getByInterface : function(f, g){

        var h,i,l;
        while(f){

          if(f.$$implements){

            h = f.$$flatImplements;
            for(i = 0,l = h.length;i < l;i++){

              if(h[i] === g){

                return f;
              };
            };
          };
          f = f.superclass;
        };
        return null;
      },
      /**
       * Whether a given class or any of its super classes includes a given interface.
       *
       * This function will return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) of the class
       * or any of its super classes using the "implement"
       * key.
       *
       * @param clazz {Class} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the interface.
       */
      hasInterface : function(j, k){

        return !!qx.util.OOUtil.getByInterface(j, k);
      },
      /**
       * Returns a list of all mixins available in a given class.
       *
       * @param clazz {Class} class which should be inspected
       * @return {Mixin[]} array of mixins this class uses
       */
      getMixins : function(m){

        var n = [];
        while(m){

          if(m.$$includes){

            n.push.apply(n, m.$$flatIncludes);
          };
          m = m.superclass;
        };
        return n;
      }
    }
  });
})();
(function(){

  var m = ".prototype",k = "'is undefined/null!",j = "constructor",h = 'The configuration key "',g = '" is not allowed!',f = '"! The type of the key must be "',e = "RegExp",d = "members",c = '" in property "',b = "properties",K = "statics",J = "qx.Mixin",I = "events",H = "'is not a mixin!",G = 'Invalid type of key "',F = "]",E = '"! The value needs to be a map!',D = "[Mixin ",C = "destruct",B = "Date",t = '"! The value is undefined/null!',u = "function",r = "' in mixin '",s = '" in member "',p = "Array",q = "Mixin",n = "Includes of mixins must be mixins. The include number '",o = 'Invalid key "',v = 'Conflict between mixin "',w = '" and "',y = "qx.debug",x = '"!',A = '" in mixin "',z = "object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This class is used to define mixins (similar to mixins in Ruby).
   *
   * Mixins are collections of code and variables, which can be merged into
   * other classes. They are similar to classes but don't support inheritance.
   *
   * See the description of the {@link #define} method how a mixin is defined.
   */
  qx.Bootstrap.define(J, {
    statics : {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Define a new mixin.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Mixin.define("name",
       * {
       *   includes: [SuperMixins],
       *
       *   properties: {
       *     tabIndex: {type: "number", init: -1}
       *   },
       *
       *   members:
       *   {
       *     prop1: "foo",
       *     meth1: function() {},
       *     meth2: function() {}
       *   }
       * });
       * </pre>
       *
       * @param name {String} name of the mixin
       * @param config {Map ? null} Mixin definition structure. The configuration map has the following keys:
       *   <table>
       *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *     <tr><th>construct</th><td>Function</td><td>An optional mixin constructor. It is called on instantiation each
       *         class including this mixin. The constructor takes no parameters.</td></tr>
       *     <tr><th>destruct</th><td>Function</td><td>An optional mixin destructor.</td></tr>
       *     <tr><th>include</th><td>Mixin[]</td><td>Array of mixins, which will be merged into the mixin.</td></tr>
       *     <tr><th>statics</th><td>Map</td><td>
       *         Map of statics of the mixin. The statics will not get copied into the target class. They remain
       *         accessible from the mixin. This is the same behaviour as statics in interfaces ({@link qx.Interface#define}).
       *     </td></tr>
       *     <tr><th>members</th><td>Map</td><td>Map of members of the mixin.</td></tr>
       *     <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see
       *           {@link qx.core.Property}.</td></tr>
       *     <tr><th>events</th><td>Map</td><td>
       *         Map of events the mixin fires. The keys are the names of the events and the values are
       *         corresponding event type classes.
       *     </td></tr>
       *   </table>
       */
      define : function(name, L){

        if(L){

          // Normalize include
          if(L.include && !(qx.Bootstrap.getClass(L.include) === p)){

            L.include = [L.include];
          };
          // Validate incoming data
          if(qx.core.Environment.get(y)){

            this.__validateConfig(name, L);
          };
          // Create Interface from statics
          var N = L.statics ? L.statics : {
          };
          qx.Bootstrap.setDisplayNames(N, name);
          for(var M in N){

            if(N[M] instanceof Function){

              N[M].$$mixin = N;
            };
          };
          // Attach configuration
          if(L.construct){

            N.$$constructor = L.construct;
            qx.Bootstrap.setDisplayName(L.construct, name, j);
          };
          if(L.include){

            N.$$includes = L.include;
          };
          if(L.properties){

            N.$$properties = L.properties;
          };
          if(L.members){

            N.$$members = L.members;
            qx.Bootstrap.setDisplayNames(L.members, name + m);
          };
          for(var M in N.$$members){

            if(N.$$members[M] instanceof Function){

              N.$$members[M].$$mixin = N;
            };
          };
          if(L.events){

            N.$$events = L.events;
          };
          if(L.destruct){

            N.$$destructor = L.destruct;
            qx.Bootstrap.setDisplayName(L.destruct, name, C);
          };
        } else {

          var N = {
          };
        };
        // Add basics
        N.$$type = q;
        N.name = name;
        // Attach toString
        N.toString = this.genericToString;
        // Assign to namespace
        N.basename = qx.Bootstrap.createNamespace(name, N);
        // Store class reference in global mixin registry
        this.$$registry[name] = N;
        // Return final mixin
        return N;
      },
      /**
       * Check compatibility between mixins (including their includes)
       *
       * @param mixins {Mixin[]} an array of mixins
       * @throws an exception when there is a conflict between the mixins
       */
      checkCompatibility : function(O){

        var R = this.flatten(O);
        var S = R.length;
        if(S < 2){

          return true;
        };
        var V = {
        };
        var U = {
        };
        var T = {
        };
        var Q;
        for(var i = 0;i < S;i++){

          Q = R[i];
          for(var P in Q.events){

            if(T[P]){

              throw new Error(v + Q.name + w + T[P] + s + P + x);
            };
            T[P] = Q.name;
          };
          for(var P in Q.properties){

            if(V[P]){

              throw new Error(v + Q.name + w + V[P] + c + P + x);
            };
            V[P] = Q.name;
          };
          for(var P in Q.members){

            if(U[P]){

              throw new Error(v + Q.name + w + U[P] + s + P + x);
            };
            U[P] = Q.name;
          };
        };
        return true;
      },
      /**
       * Checks if a class is compatible to the given mixin (no conflicts)
       *
       * @param mixin {Mixin} mixin to check
       * @param clazz {Class} class to check
       * @throws an exception when the given mixin is incompatible to the class
       * @return {Boolean} true if the mixin is compatible to the given class
       */
      isCompatible : function(W, X){

        var Y = qx.util.OOUtil.getMixins(X);
        Y.push(W);
        return qx.Mixin.checkCompatibility(Y);
      },
      /**
       * Returns a mixin by name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName : function(name){

        return this.$$registry[name];
      },
      /**
       * Determine if mixin exists
       *
       * @name isDefined
       * @param name {String} mixin name to check
       * @return {Boolean} true if mixin exists
       */
      isDefined : function(name){

        return this.getByName(name) !== undefined;
      },
      /**
       * Determine the number of mixins which are defined
       *
       * @return {Number} the number of mixins
       */
      getTotalNumber : function(){

        return qx.Bootstrap.objectGetLength(this.$$registry);
      },
      /**
       * Generates a list of all mixins given plus all the
       * mixins these includes plus... (deep)
       *
       * @param mixins {Mixin[] ? []} List of mixins
       * @return {Array} List of all mixins
       */
      flatten : function(ba){

        if(!ba){

          return [];
        };
        // we need to create a copy and not to modify the existing array
        var bb = ba.concat();
        for(var i = 0,l = ba.length;i < l;i++){

          if(ba[i].$$includes){

            bb.push.apply(bb, this.flatten(ba[i].$$includes));
          };
        };
        return bb;
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */
      /**
       * This method will be attached to all mixins to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The mixin identifier
       */
      genericToString : function(){

        return D + this.name + F;
      },
      /** Registers all defined mixins */
      $$registry : {
      },
      /** {Map} allowed keys in mixin definition */
      __allowedKeys : qx.core.Environment.select(y, {
        "true" : {
          "include" : z,
          // Mixin | Mixin[]
          "statics" : z,
          // Map
          "members" : z,
          // Map
          "properties" : z,
          // Map
          "events" : z,
          // Map
          "destruct" : u,
          // Function
          "construct" : u
        },
        "default" : null
      }),
      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __validateConfig : qx.core.Environment.select(y, {
        "true" : function(name, bc){

          // Validate keys
          var bf = this.__allowedKeys;
          for(var be in bc){

            if(!bf[be]){

              throw new Error(h + be + A + name + g);
            };
            if(bc[be] == null){

              throw new Error(o + be + A + name + t);
            };
            if(bf[be] !== null && typeof bc[be] !== bf[be]){

              throw new Error(G + be + A + name + f + bf[be] + x);
            };
          };
          // Validate maps
          var bd = [K, d, b, I];
          for(var i = 0,l = bd.length;i < l;i++){

            var be = bd[i];
            if(bc[be] !== undefined && ([p, e, B].indexOf(qx.Bootstrap.getClass(bc[be])) != -1 || bc[be].classname !== undefined)){

              throw new Error(o + be + A + name + E);
            };
          };
          // Validate includes
          if(bc.include){

            for(var i = 0,a = bc.include,l = a.length;i < l;i++){

              if(a[i] == null){

                throw new Error(n + (i + 1) + r + name + k);
              };
              if(a[i].$$type !== q){

                throw new Error(n + (i + 1) + r + name + H);
              };
            };
            this.checkCompatibility(bc.include);
          };
        },
        "default" : function(){
        }
      })
    }
  });
})();
(function(){

  var d = "qx.core.Aspect",c = "before",b = "*",a = "static";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Basis for Aspect Oriented features in qooxdoo.
   *
   * This class makes it possible to attach functions (aspects) before or
   * after each function call of any function defined in {@link qx.Class#define}.
   *
   * Classes, which define own aspects must add an explicit require to this class
   * in the header comment using the following code:
   *
   * <pre>
   * &#35;require(qx.core.Aspect)
   * &#35;ignore(auto-require)
   * </pre>
   *
   * One example for a qooxdoo aspect is profiling ({@link qx.dev.Profile}).
   */
  qx.Bootstrap.define(d, {
    statics : {
      /** {Array} Registry for all known aspect wishes */
      __registry : [],
      /**
       * This function is used by {@link qx.Class#define} to wrap all statics, members and
       * constructors.
       *
       * @param fullName {String} Full name of the function including the class name.
       * @param fcn {Function} function to wrap.
       * @param type {String} Type of the wrapped function. One of "member", "static",
       *          "constructor", "destructor" or "property".
       *
       * @return {Function} wrapped function
       */
      wrap : function(e, f, g){

        var m = [];
        var h = [];
        var l = this.__registry;
        var k;
        for(var i = 0;i < l.length;i++){

          k = l[i];
          if((k.type == null || g == k.type || k.type == b) && (k.name == null || e.match(k.name))){

            k.pos == -1 ? m.push(k.fcn) : h.push(k.fcn);
          };
        };
        if(m.length === 0 && h.length === 0){

          return f;
        };
        var j = function(){

          for(var i = 0;i < m.length;i++){

            m[i].call(this, e, f, g, arguments);
          };
          var n = f.apply(this, arguments);
          for(var i = 0;i < h.length;i++){

            h[i].call(this, e, f, g, arguments, n);
          };
          return n;
        };
        if(g !== a){

          j.self = f.self;
          j.base = f.base;
        };
        f.wrapper = j;
        j.original = f;
        return j;
      },
      /**
       * Register a function to be called just before or after each time
       * one of the selected functions is called.
       *
       * @param fcn {Function} Function to be called just before or after any of the
       *     selected functions is called. If position is "before" the functions
       *     supports the same signature as {@link qx.dev.Profile#profileBefore}. If
       *     position is "after" it supports the same signature as
       *     {@link qx.dev.Profile#profileAfter}.
       * @param position {String?"after"} One of "before" or "after". Whether the function
       *     should be called before or after the wrapped function.
       * @param type {String?null} Type of the wrapped function. One of "member",
       *     "static", "constructor", "destructor", "property" or "*". <code>null</code>
       *     is handled identical to "*".
       * @param name {String|RegExp?null} Each function, with a full name matching
       *     this pattern (using <code>fullName.match(name)</code>) will be
       *     wrapped.
       */
      addAdvice : function(o, p, q, name){

        this.__registry.push({
          fcn : o,
          pos : p === c ? -1 : 1,
          type : q,
          name : name
        });
      }
    }
  });
})();
(function(){

  var m = "function",k = "Boolean",j = "'! The value is undefined/null!",h = "RegExp",g = 'The configuration key "',f = 'The property "',e = '" is not allowed!',d = "string",c = 'Implementation of method "',b = "members",V = "number",U = "properties",T = "statics",S = "Invalid key '",R = 'The event "',Q = "events",P = 'Invalid type of key "',O = "]",N = '" in class "',M = '"! The value needs to be a map!',t = "' is undefined/null!",u = '"! The type of the key must be "',r = 'Implementation of member "',s = "' is not an interface!",p = "qx.Interface",q = "Date",n = '"! Static constants must be all uppercase.',o = "toggle",v = "boolean",w = "is",D = "[Interface ",B = '"! Static constants must be all of a primitive type.',G = '"',F = "Array",I = '" is missing in class "',H = "Interface",y = "Extends of interfaces must be interfaces. The extend number '",L = '" is not supported by Class "',K = '" required by interface "',J = "' in interface '",x = '"!',z = 'Invalid key "',A = '" in interface "',C = "qx.debug",E = "object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This class is used to define interfaces (similar to Java interfaces).
   *
   * See the description of the {@link #define} method how an interface is
   * defined.
   */
  qx.Bootstrap.define(p, {
    statics : {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Define a new interface. Interface definitions look much like class definitions.
       *
       * The main difference is that the bodies of functions defined in <code>members</code>
       * and <code>statics</code> are called before the original function with the
       * same arguments. This can be used to check the passed arguments. If the
       * checks fail, an exception should be thrown. It is convenient to use the
       * method defined in {@link qx.core.MAssert} to check the arguments.
       *
       * In the <code>build</code> version the checks are omitted.
       *
       * For properties only the names are required so the value of the properties
       * can be empty maps.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Interface.define("name",
       * {
       *   extend: [SuperInterfaces],
       *
       *   statics:
       *   {
       *     PI : 3.14
       *   },
       *
       *   properties: {"color": {}, "name": {} },
       *
       *   members:
       *   {
       *     meth1: function() {},
       *     meth2: function(a, b) { this.assertArgumentsCount(arguments, 2, 2); },
       *     meth3: function(c) { this.assertInterface(c.constructor, qx.some.Interface); }
       *   },
       *
       *   events :
       *   {
       *     keydown : "qx.event.type.KeySequence"
       *   }
       * });
       * </pre>
       *
       * @param name {String} name of the interface
       * @param config {Map ? null} Interface definition structure. The configuration map has the following keys:
       *   <table>
       *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *     <tr><th>extend</th><td>Interface |<br>Interface[]</td><td>Single interface or array of interfaces this interface inherits from.</td></tr>
       *     <tr><th>members</th><td>Map</td><td>Map of members of the interface.</td></tr>
       *     <tr><th>statics</th><td>Map</td><td>
       *         Map of statics of the interface. The statics will not get copied into the target class.
       *         This is the same behaviour as statics in mixins ({@link qx.Mixin#define}).
       *     </td></tr>
       *     <tr><th>properties</th><td>Map</td><td>Map of properties and their definitions.</td></tr>
       *     <tr><th>events</th><td>Map</td><td>Map of event names and the corresponding event class name.</td></tr>
       *   </table>
       */
      define : function(name, W){

        if(W){

          // Normalize include
          if(W.extend && !(qx.Bootstrap.getClass(W.extend) === F)){

            W.extend = [W.extend];
          };
          // Validate incoming data
          if(qx.core.Environment.get(C)){

            this.__validateConfig(name, W);
          };
          // Create interface from statics
          var X = W.statics ? W.statics : {
          };
          // Attach configuration
          if(W.extend){

            X.$$extends = W.extend;
          };
          if(W.properties){

            X.$$properties = W.properties;
          };
          if(W.members){

            X.$$members = W.members;
          };
          if(W.events){

            X.$$events = W.events;
          };
        } else {

          // Create empty interface
          var X = {
          };
        };
        // Add Basics
        X.$$type = H;
        X.name = name;
        // Attach toString
        X.toString = this.genericToString;
        // Assign to namespace
        X.basename = qx.Bootstrap.createNamespace(name, X);
        // Add to registry
        qx.Interface.$$registry[name] = X;
        // Return final interface
        return X;
      },
      /**
       * Returns an interface by name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName : function(name){

        return this.$$registry[name];
      },
      /**
       * Determine if interface exists
       *
       * @param name {String} Interface name to check
       * @return {Boolean} true if interface exists
       */
      isDefined : function(name){

        return this.getByName(name) !== undefined;
      },
      /**
       * Determine the number of interfaces which are defined
       *
       * @return {Number} the number of interfaces
       */
      getTotalNumber : function(){

        return qx.Bootstrap.objectGetLength(this.$$registry);
      },
      /**
       * Generates a list of all interfaces including their super interfaces
       * (resolved recursively)
       *
       * @param ifaces {Interface[] ? []} List of interfaces to be resolved
       * @return {Array} List of all interfaces
       */
      flatten : function(Y){

        if(!Y){

          return [];
        };
        // we need to create a copy and not to modify the existing array
        var ba = Y.concat();
        for(var i = 0,l = Y.length;i < l;i++){

          if(Y[i].$$extends){

            ba.push.apply(ba, this.flatten(Y[i].$$extends));
          };
        };
        return ba;
      },
      /**
       * Assert members
       *
       * @param object {qx.core.Object} The object, which contains the methods
       * @param clazz {Class} class of the object
       * @param iface {Interface} the interface to verify
       * @param wrap {Boolean ? false} wrap functions required by interface to
       *     check parameters etc.
       */
      __assertMembers : function(bb, bc, bd, be){

        // Validate members
        var bi = bd.$$members;
        if(bi){

          for(var bh in bi){

            if(qx.Bootstrap.isFunction(bi[bh])){

              var bg = this.__isPropertyMethod(bc, bh);
              var bf = bg || qx.Bootstrap.isFunction(bb[bh]);
              if(!bf){

                throw new Error(c + bh + I + bc.classname + K + bd.name + G);
              };
              // Only wrap members if the interface was not been applied yet. This
              // can easily be checked by the recursive hasInterface method.
              var bj = be === true && !bg && !qx.util.OOUtil.hasInterface(bc, bd);
              if(bj){

                bb[bh] = this.__wrapInterfaceMember(bd, bb[bh], bh, bi[bh]);
              };
            } else {

              // Other members are not checked more detailed because of
              // JavaScript's loose type handling
              if(typeof bb[bh] === undefined){

                if(typeof bb[bh] !== m){

                  throw new Error(r + bh + I + bc.classname + K + bd.name + G);
                };
              };
            };
          };
        };
      },
      /**
       * Internal helper to detect if the method will be generated by the
       * property system.
       *
       * @param clazz {Class} The current class.
       * @param methodName {String} The name of the method.
       *
       * @return {Boolean} true, if the method will be generated by the property
       *   system.
       */
      __isPropertyMethod : function(bk, bl){

        var bp = bl.match(/^(is|toggle|get|set|reset)(.*)$/);
        if(!bp){

          return false;
        };
        var bm = qx.Bootstrap.firstLow(bp[2]);
        var bn = qx.util.OOUtil.getPropertyDefinition(bk, bm);
        if(!bn){

          return false;
        };
        var bo = bp[0] == w || bp[0] == o;
        if(bo){

          return qx.util.OOUtil.getPropertyDefinition(bk, bm).check == k;
        };
        return true;
      },
      /**
       * Assert properties
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       */
      __assertProperties : function(bq, br){

        if(br.$$properties){

          for(var bs in br.$$properties){

            if(!qx.util.OOUtil.getPropertyDefinition(bq, bs)){

              throw new Error(f + bs + L + bq.classname + x);
            };
          };
        };
      },
      /**
       * Assert events
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       */
      __assertEvents : function(bt, bu){

        if(bu.$$events){

          for(var bv in bu.$$events){

            if(!qx.util.OOUtil.supportsEvent(bt, bv)){

              throw new Error(R + bv + L + bt.classname + x);
            };
          };
        };
      },
      /**
       * Asserts that the given object implements all the methods defined in the
       * interface. This method throws an exception if the object does not
       * implement the interface.
       *
       *  @param object {qx.core.Object} Object to check interface for
       *  @param iface {Interface} The interface to verify
       */
      assertObject : function(bw, bx){

        var bz = bw.constructor;
        this.__assertMembers(bw, bz, bx, false);
        this.__assertProperties(bz, bx);
        this.__assertEvents(bz, bx);
        // Validate extends, recursive
        var by = bx.$$extends;
        if(by){

          for(var i = 0,l = by.length;i < l;i++){

            this.assertObject(bw, by[i]);
          };
        };
      },
      /**
       * Checks if an interface is implemented by a class
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       * @param wrap {Boolean ? false} wrap functions required by interface to
       *     check parameters etc.
       */
      assert : function(bA, bB, bC){

        this.__assertMembers(bA.prototype, bA, bB, bC);
        this.__assertProperties(bA, bB);
        this.__assertEvents(bA, bB);
        // Validate extends, recursive
        var bD = bB.$$extends;
        if(bD){

          for(var i = 0,l = bD.length;i < l;i++){

            this.assert(bA, bD[i], bC);
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */
      /**
       * This method will be attached to all interface to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The interface identifier
       */
      genericToString : function(){

        return D + this.name + O;
      },
      /** Registry of all defined interfaces */
      $$registry : {
      },
      /**
       * Wrap a method with a precondition check.
       *
       * @signature function(iface, origFunction, functionName, preCondition)
       * @param iface {String} Name of the interface, where the pre condition
       *   was defined. (Used in error messages).
       * @param origFunction {Function} function to wrap.
       * @param functionName {String} name of the function. (Used in error messages).
       * @param preCondition {Function}. This function gets called with the arguments of the
       *   original function. If this function return true the original function is called.
       *   Otherwise an exception is thrown.
       * @return {Function} wrapped function
       */
      __wrapInterfaceMember : qx.core.Environment.select(C, {
        "true" : function(bE, bF, bG, bH){

          function bI(){

            // call precondition
            bH.apply(this, arguments);
            // call original function
            return bF.apply(this, arguments);
          };
          bF.wrapper = bI;
          return bI;
        },
        "default" : function(){
        }
      }),
      /** {Map} allowed keys in interface definition */
      __allowedKeys : qx.core.Environment.select(C, {
        "true" : {
          "extend" : E,
          // Interface | Interface[]
          "statics" : E,
          // Map
          "members" : E,
          // Map
          "properties" : E,
          // Map
          "events" : E
        },
        "default" : null
      }),
      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __validateConfig : qx.core.Environment.select(C, {
        "true" : function(name, bJ){

          if(qx.core.Environment.get(C)){

            // Validate keys
            var bM = this.__allowedKeys;
            for(var bL in bJ){

              if(bM[bL] === undefined){

                throw new Error(g + bL + N + name + e);
              };
              if(bJ[bL] == null){

                throw new Error(S + bL + J + name + j);
              };
              if(bM[bL] !== null && typeof bJ[bL] !== bM[bL]){

                throw new Error(P + bL + A + name + u + bM[bL] + x);
              };
            };
            // Validate maps
            var bK = [T, b, U, Q];
            for(var i = 0,l = bK.length;i < l;i++){

              var bL = bK[i];
              if(bJ[bL] !== undefined && ([F, h, q].indexOf(qx.Bootstrap.getClass(bJ[bL])) != -1 || bJ[bL].classname !== undefined)){

                throw new Error(z + bL + A + name + M);
              };
            };
            // Validate extends
            if(bJ.extend){

              for(var i = 0,a = bJ.extend,l = a.length;i < l;i++){

                if(a[i] == null){

                  throw new Error(y + i + 1 + J + name + t);
                };
                if(a[i].$$type !== H){

                  throw new Error(y + i + 1 + J + name + s);
                };
              };
            };
            // Validate statics
            if(bJ.statics){

              for(var bL in bJ.statics){

                if(bL.toUpperCase() !== bL){

                  throw new Error(z + bL + A + name + n);
                };
                switch(typeof bJ.statics[bL]){case v:case d:case V:
                break;default:
                throw new Error(z + bL + A + name + B);};
              };
            };
          };
        },
        "default" : function(){
        }
      })
    }
  });
})();
(function(){

  var g = "qx.lang.Core",f = "\\\\",e = "\\\"",d = '"',c = "[object Error]",b = "emulated",a = "native";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The intention of this class is to add features to native JavaScript
   * objects so that all browsers operate on a common JavaScript language level
   * (particularly JavaScript 1.6).
   *
   * The methods defined in this class contain implementations of methods, which
   * are not supported by all browsers. If a method is supported it points to
   * the native implementation, otherwise it contains an emulation function.
   *
   * For reference:
   *
   * * http://www.ecma-international.org/publications/standards/Ecma-262.htm
   * * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference
   * * http://developer.mozilla.org/en/docs/New_in_JavaScript_1.6
   *
   * The following methods are added if they are not supported natively:
   *
   * * Error.toString()
   * * Array.indexOf()
   * * Array.lastIndexOf()
   * * Array.forEach()
   * * Array.filter()
   * * Array.map()
   * * Array.some()
   * * Array.every()
   * * String.quote()
   */
  qx.Bootstrap.define(g, {
    statics : {
      /**
       * Some browsers (e.g. Internet Explorer) do not support to stringify
       * error objects like other browsers usually do. This feature is added to
       * those browsers.
       *
       * @signature function()
       * @return {String} Error message
       */
      errorToString : {
        "native" : Error.prototype.toString,
        "emulated" : function(){

          return this.message;
        }
      }[(!Error.prototype.toString || Error.prototype.toString() == c) ? b : a],
      /**
       * Returns the first index at which a given element can be found in the array,
       * or <code>-1</code> if it is not present. It compares <code>searchElement</code> to elements of the Array
       * using strict equality (the same method used by the <code>===</code>, or
       * triple-equals, operator).
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
       *
       * @signature function(searchElement, fromIndex)
       * @param searchElement {var} Element to locate in the array.
       * @param fromIndex {Integer} The index at which to begin the search. Defaults to 0, i.e. the whole
       *         array will be searched. If the index is greater than or equal to the length of the array,
       *         <code>-1</code> is returned, i.e. the array will not be searched. If negative, it is taken as the
       *         offset from the end of the array. Note that even when the index is negative, the array is still
       *         searched from front to back. If the calculated index is less than 0, the whole array will be searched.
       * @return {Integer} Returns the first index at which a given element can
       *    be found in the array, or <code>-1</code> if it is not present.
       */
      arrayIndexOf : {
        "native" : Array.prototype.indexOf,
        "emulated" : function(h, j){

          if(j == null){

            j = 0;
          } else if(j < 0){

            j = Math.max(0, this.length + j);
          };
          for(var i = j;i < this.length;i++){

            if(this[i] === h){

              return i;
            };
          };
          return -1;
        }
      }[Array.prototype.indexOf ? a : b],
      /**
       * Returns the last index at which a given element can be found in the array, or <code>-1</code>
       * if it is not present. The array is searched backwards, starting at <code>fromIndex</code>.
       * It compares <code>searchElement</code> to elements of the Array using strict equality
       * (the same method used by the <code>===</code>, or triple-equals, operator).
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:lastIndexOf
       *
       * @signature function(searchElement, fromIndex)
       * @param searchElement {var} Element to locate in the array.
       * @param fromIndex {Integer} The index at which to start searching backwards.
       *         Defaults to the array's length, i.e. the whole array will be searched. If
       *         the index is greater than or equal to the length of the array, the whole array
       *         will be searched. If negative, it is taken as the offset from the end of the
       *         array. Note that even when the index is negative, the array is still searched
       *         from back to front. If the calculated index is less than 0, -1 is returned,
       *         i.e. the array will not be searched.
       * @return {Integer} Returns the last index at which a given element can be
       *    found in the array, or <code>-1</code> if it is not present.
       */
      arrayLastIndexOf : {
        "native" : Array.prototype.lastIndexOf,
        "emulated" : function(k, m){

          if(m == null){

            m = this.length - 1;
          } else if(m < 0){

            m = Math.max(0, this.length + m);
          };
          for(var i = m;i >= 0;i--){

            if(this[i] === k){

              return i;
            };
          };
          return -1;
        }
      }[Array.prototype.lastIndexOf ? a : b],
      /**
       * Executes a provided function once per array element.
       *
       * <code>forEach</code> executes the provided function (<code>callback</code>) once for each
       * element present in the array.  <code>callback</code> is invoked only for indexes of the array
       * which have assigned values; it is not invoked for indexes which have been deleted or which
       * have never been assigned values.
       *
       * <code>callback</code> is invoked with three arguments: the value of the element, the index
       * of the element, and the Array object being traversed.
       *
       * If a <code>obj</code> parameter is provided to <code>forEach</code>, it will be used
       * as the <code>this</code> for each invocation of the <code>callback</code>.  If it is not
       * provided, or is <code>null</code>, the global object associated with <code>callback</code>
       * is used instead.
       *
       * <code>forEach</code> does not mutate the array on which it is called.
       *
       * The range of elements processed by <code>forEach</code> is set before the first invocation of
       * <code>callback</code>.  Elements which are appended to the array after the call to
       * <code>forEach</code> begins will not be visited by <code>callback</code>. If existing elements
       * of the array are changed, or deleted, their value as passed to <code>callback</code> will be
       * the value at the time <code>forEach</code> visits them; elements that are deleted are not visited.
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:forEach
       *
       * @signature function(callback, obj)
       * @param callback {Function} Function to execute for each element.
       * @param obj {Object} Object to use as this when executing callback.
       * @return {void}
       */
      arrayForEach : {
        "native" : Array.prototype.forEach,
        "emulated" : function(n, o){

          var l = this.length;
          for(var i = 0;i < l;i++){

            var p = this[i];
            if(p !== undefined){

              n.call(o || window, p, i, this);
            };
          };
        }
      }[Array.prototype.forEach ? a : b],
      /**
       * Creates a new array with all elements that pass the test implemented by the provided
       * function.
       *
       * <code>filter</code> calls a provided <code>callback</code> function once for each
       * element in an array, and constructs a new array of all the values for which
       * <code>callback</code> returns a true value.  <code>callback</code> is invoked only
       * for indexes of the array which have assigned values; it is not invoked for indexes
       * which have been deleted or which have never been assigned values.  Array elements which
       * do not pass the <code>callback</code> test are simply skipped, and are not included
       * in the new array.
       *
       * <code>callback</code> is invoked with three arguments: the value of the element, the
       * index of the element, and the Array object being traversed.
       *
       * If a <code>obj</code> parameter is provided to <code>filter</code>, it will
       * be used as the <code>this</code> for each invocation of the <code>callback</code>.
       * If it is not provided, or is <code>null</code>, the global object associated with
       * <code>callback</code> is used instead.
       *
       * <code>filter</code> does not mutate the array on which it is called. The range of
       * elements processed by <code>filter</code> is set before the first invocation of
       * <code>callback</code>. Elements which are appended to the array after the call to
       * <code>filter</code> begins will not be visited by <code>callback</code>. If existing
       * elements of the array are changed, or deleted, their value as passed to <code>callback</code>
       * will be the value at the time <code>filter</code> visits them; elements that are deleted
       * are not visited.
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:filter
       *
       * @signature function(callback, obj)
       * @param callback {Function} Function to test each element of the array.
       * @param obj {Object} Object to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} Returns a new array with all elements that pass the test
       *    implemented by the provided function.
       */
      arrayFilter : {
        "native" : Array.prototype.filter,
        "emulated" : function(q, r){

          var s = [];
          var l = this.length;
          for(var i = 0;i < l;i++){

            var t = this[i];
            if(t !== undefined){

              if(q.call(r || window, t, i, this)){

                s.push(this[i]);
              };
            };
          };
          return s;
        }
      }[Array.prototype.filter ? a : b],
      /**
       * Creates a new array with the results of calling a provided function on every element in this array.
       *
       * <code>map</code> calls a provided <code>callback</code> function once for each element in an array,
       * in order, and constructs a new array from the results.  <code>callback</code> is invoked only for
       * indexes of the array which have assigned values; it is not invoked for indexes which have been
       * deleted or which have never been assigned values.
       *
       * <code>callback</code> is invoked with three arguments: the value of the element, the index of the
       * element, and the Array object being traversed.
       *
       * If a <code>obj</code> parameter is provided to <code>map</code>, it will be used as the
       * <code>this</code> for each invocation of the <code>callback</code>. If it is not provided, or is
       * <code>null</code>, the global object associated with <code>callback</code> is used instead.
       *
       * <code>map</code> does not mutate the array on which it is called.
       *
       * The range of elements processed by <code>map</code> is set before the first invocation of
       * <code>callback</code>. Elements which are appended to the array after the call to <code>map</code>
       * begins will not be visited by <code>callback</code>.  If existing elements of the array are changed,
       * or deleted, their value as passed to <code>callback</code> will be the value at the time
       * <code>map</code> visits them; elements that are deleted are not visited.
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:map
       *
       * @signature function(callback, obj)
       * @param callback {Function} Function produce an element of the new Array from an element of the current one.
       * @param obj {Object} Object to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} Returns a new array with the results of calling a provided
       *    function on every element in this array.
       */
      arrayMap : {
        "native" : Array.prototype.map,
        "emulated" : function(u, v){

          var w = [];
          var l = this.length;
          for(var i = 0;i < l;i++){

            var x = this[i];
            if(x !== undefined){

              w[i] = u.call(v || window, x, i, this);
            };
          };
          return w;
        }
      }[Array.prototype.map ? a : b],
      /**
       * Tests whether some element in the array passes the test implemented by the provided function.
       *
       * <code>some</code> executes the <code>callback</code> function once for each element present in
       * the array until it finds one where <code>callback</code> returns a true value. If such an element
       * is found, <code>some</code> immediately returns <code>true</code>. Otherwise, <code>some</code>
       * returns <code>false</code>. <code>callback</code> is invoked only for indexes of the array which
       * have assigned values; it is not invoked for indexes which have been deleted or which have never
       * been assigned values.
       *
       * <code>callback</code> is invoked with three arguments: the value of the element, the index of the
       * element, and the Array object being traversed.
       *
       * If a <code>obj</code> parameter is provided to <code>some</code>, it will be used as the
       * <code>this</code> for each invocation of the <code>callback</code>. If it is not provided, or is
       * <code>null</code>, the global object associated with <code>callback</code> is used instead.
       *
       * <code>some</code> does not mutate the array on which it is called.
       *
       * The range of elements processed by <code>some</code> is set before the first invocation of
       * <code>callback</code>.  Elements that are appended to the array after the call to <code>some</code>
       * begins will not be visited by <code>callback</code>. If an existing, unvisited element of the array
       * is changed by <code>callback</code>, its value passed to the visiting <code>callback</code> will
       * be the value at the time that <code>some</code> visits that element's index; elements that are
       * deleted are not visited.
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:some
       *
       * @param callback {Function} Function to test for each element.
       * @param obj {Object} Object to use as <code>this</code> when executing <code>callback</code>.
       * @return {Boolean} Returns <code>true</code> whether some element in the
       *    array passes the test implemented by the provided function,
       *    <code>false</code> otherwise.
       */
      arraySome : {
        "native" : Array.prototype.some,
        "emulated" : function(y, z){

          var l = this.length;
          for(var i = 0;i < l;i++){

            var A = this[i];
            if(A !== undefined){

              if(y.call(z || window, A, i, this)){

                return true;
              };
            };
          };
          return false;
        }
      }[Array.prototype.some ? a : b],
      /**
       * Tests whether all elements in the array pass the test implemented by the provided function.
       *
       * <code>every</code> executes the provided <code>callback</code> function once for each element
       * present in the array until it finds one where <code>callback</code> returns a false value. If
       * such an element is found, the <code>every</code> method immediately returns <code>false</code>.
       * Otherwise, if <code>callback</code> returned a true value for all elements, <code>every</code>
       * will return <code>true</code>.  <code>callback</code> is invoked only for indexes of the array
       * which have assigned values; it is not invoked for indexes which have been deleted or which have
       * never been assigned values.
       *
       * <code>callback</code> is invoked with three arguments: the value of the element, the index of
       * the element, and the Array object being traversed.
       *
       * If a <code>obj</code> parameter is provided to <code>every</code>, it will be used as
       * the <code>this</code> for each invocation of the <code>callback</code>. If it is not provided,
       * or is <code>null</code>, the global object associated with <code>callback</code> is used instead.
       *
       * <code>every</code> does not mutate the array on which it is called. The range of elements processed
       * by <code>every</code> is set before the first invocation of <code>callback</code>. Elements which
       * are appended to the array after the call to <code>every</code> begins will not be visited by
       * <code>callback</code>.  If existing elements of the array are changed, their value as passed
       * to <code>callback</code> will be the value at the time <code>every</code> visits them; elements
       * that are deleted are not visited.
       *
       * Natively supported in Gecko since version 1.8.
       * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:every
       *
       * @signature function(callback, obj)
       * @param callback {Function} Function to test for each element.
       * @param obj {Object} Object to use as <code>this</code> when executing <code>callback</code>.
       * @return {Boolean} Returns <code>false</code> whether all elements in the
       *    array pass the test implemented by the provided function,
       *    <code>false</code> otherwise.
       */
      arrayEvery : {
        "native" : Array.prototype.every,
        "emulated" : function(B, C){

          var l = this.length;
          for(var i = 0;i < l;i++){

            var D = this[i];
            if(D !== undefined){

              if(!B.call(C || window, D, i, this)){

                return false;
              };
            };
          };
          return true;
        }
      }[Array.prototype.every ? a : b],
      /**
       * Surrounds the string with double quotes and escapes all double quotes
       * and backslashes within the string.
       *
       * Note: Not part of ECMAScript Language Specification ECMA-262
       *       3rd edition (December 1999), but implemented by Gecko:
       *       http://lxr.mozilla.org/seamonkey/source/js/src/jsstr.c
       *
       * @signature function()
       * @return {String} Returns a string with double quotes and escapes all
       *    double quotes and backslashes within the string.
       */
      stringQuote : {
        "native" : String.prototype.quote,
        "emulated" : function(){

          return d + this.replace(/\\/g, f).replace(/\"/g, e) + d;
        }
      }[String.prototype.quote ? a : b]
    }
  });
  /*
  ---------------------------------------------------------------------------
    FEATURE EXTENSION OF NATIVE ERROR OBJECT
  ---------------------------------------------------------------------------
  */
  if(!Error.prototype.toString || Error.prototype.toString() == c){

    Error.prototype.toString = qx.lang.Core.errorToString;
  };
  /*
  ---------------------------------------------------------------------------
    FEATURE EXTENSION OF NATIVE ARRAY OBJECT
  ---------------------------------------------------------------------------
  */
  if(!Array.prototype.indexOf){

    Array.prototype.indexOf = qx.lang.Core.arrayIndexOf;
  };
  if(!Array.prototype.lastIndexOf){

    Array.prototype.lastIndexOf = qx.lang.Core.arrayLastIndexOf;
  };
  if(!Array.prototype.forEach){

    Array.prototype.forEach = qx.lang.Core.arrayForEach;
  };
  if(!Array.prototype.filter){

    Array.prototype.filter = qx.lang.Core.arrayFilter;
  };
  if(!Array.prototype.map){

    Array.prototype.map = qx.lang.Core.arrayMap;
  };
  if(!Array.prototype.some){

    Array.prototype.some = qx.lang.Core.arraySome;
  };
  if(!Array.prototype.every){

    Array.prototype.every = qx.lang.Core.arrayEvery;
  };
  /*
  ---------------------------------------------------------------------------
    FEATURE EXTENSION OF NATIVE STRING OBJECT
  ---------------------------------------------------------------------------
  */
  if(!String.prototype.quote){

    String.prototype.quote = qx.lang.Core.stringQuote;
  };
})();
(function(){

  var dl = '!==inherit){',dk = 'var msg = "Invalid incoming value for property \'',dj = 'qx.lang.Type.isString(value) && qx.util.ColorUtil.isValidPropertyValue(value)',di = 'value !== null && qx.theme.manager.Font.getInstance().isDynamic(value)',dh = "function",dg = 'value !== null && value.nodeType === 9 && value.documentElement',df = '===value)return value;',de = 'value !== null && value.$$type === "Mixin"',dd = 'return init;',dc = 'var init=this.',cd = ')prop.error(this,5,"',cc = 'value !== null && value.nodeType === 1 && value.attributes',cb = "var parent = this.getLayoutParent();",ca = "Error in property ",bY = 'var a=this._getChildren();if(a)for(var i=0,l=a.length;i<l;i++){',bX = "property",bW = '.check.call(this, value)',bV = 'if((computed===undefined||computed===inherit)&&',bU = '.validate.call(this, value);',bT = 'qx.core.Assert.assertInstance(value, Date, msg) || true',dt = 'else{',du = "Cannot add the non themable property '",dr = "if (!parent) return;",ds = " in method ",dp = 'qx.core.Assert.assertInstance(value, Error, msg) || true',dq = '=computed;',dm = 'Undefined value is not allowed!',dn = '(backup);',dv = 'if(',dw = "MSIE 6.0",cK = "' to the themable property group '",cJ = 'if(computed===inherit){',cM = "]: ",cL = "inherit",cO = 'Is invalid!',cN = 'var computed, old=this.',cQ = 'else if(computed===undefined)',cP = "Malformed generated code to unwrap method: ",cI = "': ",cH = 'value !== null && value.nodeType !== undefined',n = '===undefined)return;',o = 'value !== null && qx.theme.manager.Decoration.getInstance().isValidPropertyValue(value)',p = "Could not add check to property ",q = "')){",r = "module.events",s = 'qx.core.Assert.assertPositiveInteger(value, msg) || true',t = "Code[",u = 'value=this.',v = "Cannot create property group '",w = 'if(init==qx.core.Property.$$inherit)init=null;',dK = 'qx.core.Assert.assertInArray(value, ',dJ = 'value !== null && value.$$type === "Interface"',dI = 'var inherit=prop.$$inherit;',dH = "', qx.event.type.Data, [computed, old]",dO = "var value = parent.",dN = "$$useinit_",dM = 'computed=undefined;delete this.',dL = "(value);",dQ = 'computed=value;',dP = '}else{',bj = "$$runtime_",bk = 'Requires exactly one argument!',bh = 'if(this.$$initialized)prop.error(this,0,"',bi = 'qx.core.Assert.assertInstance(value, qx.Class.getByName("',bn = "$$user_",bo = 'if(value===null)prop.error(this,4,"',bl = '){',bm = '!',bf = 'qx.core.Assert.assertArray(value, msg) || true',bg = 'if(computed===undefined||computed===inherit){',O = 'qx.core.Assert.assertPositiveNumber(value, msg) || true',N = ".prototype",Q = "' including non-existing property '",P = "Boolean",K = ")}",J = '(computed, old, "',M = 'return value;',L = '.check, msg)',I = 'if(init==qx.core.Property.$$inherit)throw new Error("Inheritable property ',H = "if(reg.hasListener(this, '",bt = 'Does not allow any arguments!',bu = '\'";',bv = ')a[i].',bw = "()",bp = ';}',bq = "var a=arguments[0] instanceof Array?arguments[0]:arguments;",br = 'value !== null && value.$$type === "Theme"',bs = 'if(value!==null)',bx = "'!",by = "var reg=qx.event.Registration;",ba = "())",Y = 'return null;',X = 'qx.core.Assert.assertObject(value, msg) || true',W = '");',V = 'qx.core.Assert.assertString(value, msg) || true',U = '!==undefined&&',T = "\n",S = 'var pa=this.getLayoutParent();if(pa)computed=pa.',be = "if (value===undefined) value = parent.",bd = 'value !== null && value.$$type === "Class"',bz = 'qx.core.Assert.assertFunction(value, msg) || true',bA = 'var computed, old;',bB = 'var backup=computed;',bC = ".",bD = "object",bE = "$$init_",bF = 'qx.core.Assert.assertInterface(value, qx.Interface.getByName("',bG = "$$theme_",bH = 'if(computed===undefined)computed=null;',bI = '\' of class \'',cl = "Unknown reason: ",ck = 'if(arguments.length!==1)prop.error(this,1,"',cj = 'qx.core.Assert.assertMap(value, msg) || true',ci = "Generating property wrappers: ",cp = "'",co = 'qx.core.Assert.assertNumber(value, msg) || true',cn = "reg.fireEvent(this, '",cm = 'Null value is not allowed!',cs = 'if(value!==inherit)',cr = 'qx.core.Assert.assertInteger(value, msg) || true',cD = "rv:1.8.1",cE = "shorthand",cB = "Generating property group: ",cC = 'qx.core.Assert.assertInstance(value, RegExp, msg) || true',cz = 'value !== null && value.type !== undefined',cA = 'value !== null && value.document',cx = 'throw new Error("Property ',cy = "(!this.",cF = 'qx.core.Assert.assertBoolean(value, msg) || true',cG = 'if(a[i].',cU = "qx.aspects",cT = "toggle",cW = "$$inherit_",cV = 'else this.',cY = " with incoming value '",cX = 'if(arguments.length!==0)prop.error(this,3,"',db = "a=qx.lang.Array.fromShortHand(qx.lang.Array.fromArguments(a));",da = 'if(computed===undefined||computed==inherit)computed=null;',cS = "qx.core.Property",cR = "is",dD = 'Could not change or apply init value after constructing phase!',dE = "();",dF = 'else ',dG = 'if(old===undefined)old=this.',dz = 'old=computed=this.',dA = 'if(value===undefined)prop.error(this,2,"',dB = " of class ",dC = "return this.",dx = "get",dy = '(value);',m = "(a[",k = 'if(old===computed)return value;',j = '"), msg)',h = '!(',g = "value",f = ' of an instance of ',e = 'var prop=qx.core.Property;',d = 'if(old===undefined)old=null;',c = ')',b = ' is not (yet) ready!");',z = "]);",A = '.$$properties.',x = "qx.debug.property.level",y = ";",D = 'old=this.',E = '=true;',B = "this.",C = "resetRuntime",F = '!==undefined){',G = 'return this.',ct = "reset",cq = '","',cw = '",value);',cu = "refresh",cg = "boolean",ce = "resetThemed",R = 'else if(this.',ch = "string",bc = "qx.debug",bb = "",bL = '}',bM = 'if(this.',bN = 'delete this.',bO = '!==undefined)',bP = "setRuntime",bQ = "set",bR = "setThemed",bS = "init",bJ = 'this.',bK = '=value;',cf = 'computed=this.',cv = ';';
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.Interface)
  
  ************************************************************************ */
  /**
   * Internal class for handling of dynamic properties. Should only be used
   * through the methods provided by {@link qx.Class}.
   *
   * For a complete documentation of properties take a look at
   * http://manual.qooxdoo.org/${qxversion}/pages/core.html#properties.
   *
   *
   * *Normal properties*
   *
   * The <code>properties</code> key in the class definition map of {@link qx.Class#define}
   * is used to generate the properties.
   *
   * Valid keys of a property definition are:
   *
   * <table>
   *   <tr><th>Name</th><th>Type</th><th>Description</th></tr>
   *   <tr><th>check</th><td>Array, String, Function</td><td>
   *     The check is used to check the type the incoming value of a property. This will only
   *     be executed in the source version. The build version will not contain the checks.
   *     The check can be:
   *     <ul>
   *       <li>a custom check function. The function takes the incoming value as a parameter and must
   *           return a boolean value to indicate whether the values is valid.
   *       </li>
   *       <li>inline check code as a string e.g. <code>"value &gt; 0 && value &lt; 100"</code></li>
   *       <li>a class name e.g. <code>qx.ui.form.Button</code></li>
   *       <li>a name of an interface the value must implement</li>
   *       <li>an array of all valid values</li>
   *       <li>one of the predefined checks: Boolean, String, Number, Integer, Float, Double,
   *           Object, Array, Map, Class, Mixin, Interface, Theme, Error, RegExp, Function,
   *           Date, Node, Element, Document, Window, Event
   *       </li>
   *     <ul>
   *   </td></tr>
   *   <tr><th>init</th><td>var</td><td>
   *     Sets the default/initial value of the property. If no property value is set or the property
   *     gets reset, the getter will return the <code>init</code> value.
   *   </td></tr>
   *   <tr><th>apply</th><td>String</td><td>
   *     On change of the property value the method of the specified name will be called. The signature of
   *     the method is <code>function(newValue, oldValue, propertyName)</code>. It is conventional to name
   *     the callback <code>_apply</code> + <i>PropertyName</i>, with the property name camel-cased (e.g.
   *     "<i>_applyFooBar</i>" for a property <i>fooBar</i>).
   *   </td></tr>
   *   <tr><th>event</th><td>String</td><td>
   *     On change of the property value an event with the given name will be dispatched. The event type is
   *     {@link qx.event.type.Data}.
   *   </td></tr>
   *   <tr><th>themeable</th><td>Boolean</td><td>
   *     Whether this property can be set using themes.
   *   </td></tr>
   *   <tr><th>inheritable</th><td>Boolean</td><td>
   *     Whether the property value should be inheritable. If the property does not have an user defined or an
   *     init value, the property will try to get the value from the parent of the current object.
   *   </td></tr>
   *   <tr><th>nullable</th><td>Boolean</td><td>
   *     Whether <code>null</code> is an allowed value of the property. This is complementary to the check
   *     defined using the <code>check</code> key.
   *   </td></tr>
   *   <tr><th>refine</th><td>Boolean</td><td>
   *     Whether the property definition is a refinement of a property in one of the super classes of the class.
   *     Only the <code>init</code> value can be changed using refine.
   *   </td></tr>
   *   <tr><th>transform</th><td>String</td><td>
   *     On setting of the property value the method of the specified name will
   *     be called. The signature of the method is <code>function(value)</code>.
   *     The parameter <code>value</code> is the value passed to the setter.
   *     The function must return the modified or unmodified value.
   *     Transformation occurs before the check function, so both may be
   *     specified if desired.  Alternatively, the transform function may throw
   *     an error if the value passed to it is invalid.
   *   </td></tr>
   *   <tr><th>validate</th><td>Function, String</td><td>
   *     On setting of the property value the method of the specified name will
   *     be called. The signature of the method is <code>function(value)</code>.
   *     The parameter <code>value</code> is the value passed to the setter.
   *     If the validation fails, an <code>qx.core.ValidationError</code> should
   *     be thrown by the validation function. Otherwise, just do nothing in the
   *     function.<br>
   *     If a string is given, the string should hold a reference to a member
   *     method.<br>
   *     <code>"<i>methodname</i>"</code> for example
   *     <code>"__validateProperty"</code><br>
   *     There are some default validators in the {@link qx.util.Validate} class.
   *     See this documentation for usage examples.
   *   </td></tr>
   *   <tr><th>dereference</th><td>Boolean</td><td>
   *     By default, the references to the values (current, init, ...) of the
   *     property will be stored as references on the object. When disposing
   *     this object, the references will not be deleted. Setting the
   *     dereference key to true tells the property system to delete all
   *     connections made by this property on dispose. This can be necessary for
   *     disconnecting DOM objects to allow the garbage collector to work
   *     properly.
   *   </td></tr>
   *   <tr><th>deferredInit</th><td>Boolean</td><td>
   *     Allow for a deferred initialization for reference types. Defaults to false.
   *   </td></tr>
   * </table>
   *
   * *Property groups*
   *
   * Property groups are defined in a similar way but support a different set of keys:
   *
   * <table>
   *   <tr><th>Name</th><th>Type</th><th>Description</th></tr>
   *   <tr><th>group</th><td>String[]</td><td>
   *     A list of property names which should be set using the property group.
   *   </td></tr>
   *   <tr><th>mode</th><td>String</td><td>
   *     If mode is set to <code>"shorthand"</code>, the properties can be set using a CSS like shorthand mode.
   *   </td></tr>
   *   <tr><th>themeable</th><td>Boolean</td><td>
   *     Whether this property can be set using themes.
   *   </td></tr>
   * </table>
   *
   * @internal
   */
  qx.Bootstrap.define(cS, {
    statics : {
      /**
       * This is a method which does nothing than gethering dependencies for the
       * module system. Calling this method is useless because it does nothing.
       */
      __gatherDependency : function(){

        if(qx.core.Environment.get(r)){

          qx.event.type.Data;
          qx.event.dispatch.Direct;
        };
      },
      /**
       * Built-in checks
       * The keys could be used in the check of the properties
       */
      __checks : {
        "Boolean" : cF,
        "String" : V,
        "Number" : co,
        "Integer" : cr,
        "PositiveNumber" : O,
        "PositiveInteger" : s,
        "Error" : dp,
        "RegExp" : cC,
        "Object" : X,
        "Array" : bf,
        "Map" : cj,
        "Function" : bz,
        "Date" : bT,
        "Node" : cH,
        "Element" : cc,
        "Document" : dg,
        "Window" : cA,
        "Event" : cz,
        "Class" : bd,
        "Mixin" : de,
        "Interface" : dJ,
        "Theme" : br,
        "Color" : dj,
        "Decorator" : o,
        "Font" : di
      },
      /**
       * Contains types from {@link #__checks} list which need to be dereferenced
       */
      __dereference : {
        "Node" : true,
        "Element" : true,
        "Document" : true,
        "Window" : true,
        "Event" : true
      },
      /**
       * Inherit value, used to override defaults etc. to force inheritance
       * even if property value is not undefined (through multi-values)
       *
       * @internal
       */
      $$inherit : cL,
      /**
       * Caching field names for each property created
       *
       * @internal
       */
      $$store : {
        runtime : {
        },
        user : {
        },
        theme : {
        },
        inherit : {
        },
        init : {
        },
        useinit : {
        }
      },
      /**
       * Caching function names for each property created
       *
       * @internal
       */
      $$method : {
        get : {
        },
        set : {
        },
        reset : {
        },
        init : {
        },
        refresh : {
        },
        setRuntime : {
        },
        resetRuntime : {
        },
        setThemed : {
        },
        resetThemed : {
        }
      },
      /**
       * Supported keys for property defintions
       *
       * @internal
       */
      $$allowedKeys : {
        name : ch,
        // String
        dereference : cg,
        // Boolean
        inheritable : cg,
        // Boolean
        nullable : cg,
        // Boolean
        themeable : cg,
        // Boolean
        refine : cg,
        // Boolean
        init : null,
        // var
        apply : ch,
        // String
        event : ch,
        // String
        check : null,
        // Array, String, Function
        transform : ch,
        // String
        deferredInit : cg,
        // Boolean
        validate : null
      },
      /**
       * Supported keys for property group definitions
       *
       * @internal
       */
      $$allowedGroupKeys : {
        name : ch,
        // String
        group : bD,
        // Array
        mode : ch,
        // String
        themeable : cg
      },
      /** Contains names of inheritable properties, filled by {@link qx.Class.define} */
      $$inheritable : {
      },
      /**
       * Generate optimized refresh method and  attach it to the class' prototype
       *
       * @param clazz {Clazz} clazz to which the refresher should be added
       */
      __executeOptimizedRefresh : function(dR){

        var dS = this.__getInheritablesOfClass(dR);
        if(!dS.length){

          var dT = function(){
          };
        } else {

          dT = this.__createRefresher(dS);
        };
        dR.prototype.$$refreshInheritables = dT;
      },
      /**
       * Get the names of all inheritable properties of the given class
       *
       * @param clazz {Clazz} class to get the inheritable properties of
       * @return {String[]} List of property names
       */
      __getInheritablesOfClass : function(dU){

        var dW = [];
        while(dU){

          var dV = dU.$$properties;
          if(dV){

            for(var name in this.$$inheritable){

              // Whether the property is available in this class
              // and whether it is inheritable in this class as well
              if(dV[name] && dV[name].inheritable){

                dW.push(name);
              };
            };
          };
          dU = dU.superclass;
        };
        return dW;
      },
      /**
       * Assemble the refresher code and return the generated function
       *
       * @param inheritables {String[]} list of inheritable properties
       */
      __createRefresher : function(dX){

        var ec = this.$$store.inherit;
        var eb = this.$$store.init;
        var ea = this.$$method.refresh;
        var dY = [cb, dr];
        for(var i = 0,l = dX.length;i < l;i++){

          var name = dX[i];
          dY.push(dO, ec[name], y, be, eb[name], y, B, ea[name], dL);
        };
        return new Function(dY.join(bb));
      },
      /**
       * Attach $$refreshInheritables method stub to the given class
       *
       * @param clazz {Clazz} clazz to which the refresher should be added
       */
      attachRefreshInheritables : function(ed){

        ed.prototype.$$refreshInheritables = function(){

          qx.core.Property.__executeOptimizedRefresh(ed);
          return this.$$refreshInheritables();
        };
      },
      /**
       * Attach one property to class
       *
       * @param clazz {Class} Class to attach properties to
       * @param name {String} Name of property
       * @param config {Map} Configuration map of property
       * @return {void}
       */
      attachMethods : function(ee, name, ef){

        // Divide groups from "normal" properties
        ef.group ? this.__attachGroupMethods(ee, ef, name) : this.__attachPropertyMethods(ee, ef, name);
      },
      /**
       * Attach group methods
       *
       * @param clazz {Class} Class to attach properties to
       * @param config {Map} Property configuration
       * @param name {String} Name of the property
       * @return {void}
       */
      __attachGroupMethods : function(eg, eh, name){

        var eo = qx.Bootstrap.firstUp(name);
        var en = eg.prototype;
        var ep = eh.themeable === true;
        if(qx.core.Environment.get(bc)){

          if(qx.core.Environment.get(x) > 1){

            qx.Bootstrap.debug(cB + name);
          };
        };
        var eq = [];
        var ek = [];
        if(ep){

          var ei = [];
          var em = [];
        };
        var el = bq;
        eq.push(el);
        if(ep){

          ei.push(el);
        };
        if(eh.mode == cE){

          var ej = db;
          eq.push(ej);
          if(ep){

            ei.push(ej);
          };
        };
        for(var i = 0,a = eh.group,l = a.length;i < l;i++){

          if(qx.core.Environment.get(bc)){

            if(!this.$$method.set[a[i]] || !this.$$method.reset[a[i]]){

              throw new Error(v + name + Q + a[i] + bx);
            };
          };
          eq.push(B, this.$$method.set[a[i]], m, i, z);
          ek.push(B, this.$$method.reset[a[i]], dE);
          if(ep){

            if(qx.core.Environment.get(bc)){

              if(!this.$$method.setThemed[a[i]]){

                throw new Error(du + a[i] + cK + name + cp);
              };
            };
            ei.push(B, this.$$method.setThemed[a[i]], m, i, z);
            em.push(B, this.$$method.resetThemed[a[i]], dE);
          };
        };
        // Attach setter
        this.$$method.set[name] = bQ + eo;
        en[this.$$method.set[name]] = new Function(eq.join(bb));
        // Attach resetter
        this.$$method.reset[name] = ct + eo;
        en[this.$$method.reset[name]] = new Function(ek.join(bb));
        if(ep){

          // Attach styler
          this.$$method.setThemed[name] = bR + eo;
          en[this.$$method.setThemed[name]] = new Function(ei.join(bb));
          // Attach unstyler
          this.$$method.resetThemed[name] = ce + eo;
          en[this.$$method.resetThemed[name]] = new Function(em.join(bb));
        };
      },
      /**
       * Attach property methods
       *
       * @param clazz {Class} Class to attach properties to
       * @param config {Map} Property configuration
       * @param name {String} Name of the property
       * @return {void}
       */
      __attachPropertyMethods : function(er, es, name){

        var eu = qx.Bootstrap.firstUp(name);
        var ew = er.prototype;
        if(qx.core.Environment.get(bc)){

          if(qx.core.Environment.get(x) > 1){

            qx.Bootstrap.debug(ci + name);
          };
        };
        // Fill dispose value
        if(es.dereference === undefined && typeof es.check === ch){

          es.dereference = this.__shouldBeDereferenced(es.check);
        };
        var ev = this.$$method;
        var et = this.$$store;
        et.runtime[name] = bj + name;
        et.user[name] = bn + name;
        et.theme[name] = bG + name;
        et.init[name] = bE + name;
        et.inherit[name] = cW + name;
        et.useinit[name] = dN + name;
        ev.get[name] = dx + eu;
        ew[ev.get[name]] = function(){

          return qx.core.Property.executeOptimizedGetter(this, er, name, dx);
        };
        ev.set[name] = bQ + eu;
        ew[ev.set[name]] = function(ey){

          return qx.core.Property.executeOptimizedSetter(this, er, name, bQ, arguments);
        };
        ev.reset[name] = ct + eu;
        ew[ev.reset[name]] = function(){

          return qx.core.Property.executeOptimizedSetter(this, er, name, ct);
        };
        if(es.inheritable || es.apply || es.event || es.deferredInit){

          ev.init[name] = bS + eu;
          ew[ev.init[name]] = function(ez){

            return qx.core.Property.executeOptimizedSetter(this, er, name, bS, arguments);
          };
        };
        if(es.inheritable){

          ev.refresh[name] = cu + eu;
          ew[ev.refresh[name]] = function(eA){

            return qx.core.Property.executeOptimizedSetter(this, er, name, cu, arguments);
          };
        };
        ev.setRuntime[name] = bP + eu;
        ew[ev.setRuntime[name]] = function(eB){

          return qx.core.Property.executeOptimizedSetter(this, er, name, bP, arguments);
        };
        ev.resetRuntime[name] = C + eu;
        ew[ev.resetRuntime[name]] = function(){

          return qx.core.Property.executeOptimizedSetter(this, er, name, C);
        };
        if(es.themeable){

          ev.setThemed[name] = bR + eu;
          ew[ev.setThemed[name]] = function(eC){

            return qx.core.Property.executeOptimizedSetter(this, er, name, bR, arguments);
          };
          ev.resetThemed[name] = ce + eu;
          ew[ev.resetThemed[name]] = function(){

            return qx.core.Property.executeOptimizedSetter(this, er, name, ce);
          };
        };
        if(es.check === P){

          ew[cT + eu] = new Function(dC + ev.set[name] + cy + ev.get[name] + ba);
          ew[cR + eu] = new Function(dC + ev.get[name] + bw);
        };
      },
      /**
       * Returns if the reference for the given property check should be removed
       * on dispose.
       *
       * @param check {var} The check of the property definition.
       * @return {Boolean} If the dereference key should be set.
       */
      __shouldBeDereferenced : function(eD){

        return !!this.__dereference[eD];
      },
      /**
       * Special function for IE6 and FF2 which returns if the reference for
       * the given property check should be removed on dispose.
       * As IE6 and FF2 seem to have bad garbage collection behaviors, we should
       * additionally remove all references between qooxdoo objects and
       * interfaces.
       *
       * @param check {var} The check of the property definition.
       * @return {Boolean} If the dereference key should be set.
       */
      __shouldBeDereferencedOld : function(eE){

        return this.__dereference[eE] || qx.util.OOUtil.classIsDefined(eE) || (qx.Interface && qx.Interface.isDefined(eE));
      },
      /** {Map} Internal data field for error messages used by {@link #error} */
      __errors : {
        '0' : dD,
        '1' : bk,
        '2' : dm,
        '3' : bt,
        '4' : cm,
        '5' : cO
      },
      /**
       * Error method used by the property system to report errors.
       *
       * @param obj {qx.core.Object} Any qooxdoo object
       * @param id {Integer} Numeric error identifier
       * @param property {String} Name of the property
       * @param variant {String} Name of the method variant e.g. "set", "reset", ...
       * @param value {var} Incoming value
       */
      error : function(eF, eG, eH, eI, eJ){

        var eK = eF.constructor.classname;
        var eL = ca + eH + dB + eK + ds + this.$$method[eI][eH] + cY + eJ + cI;
        throw new Error(eL + (this.__errors[eG] || cl + eG));
      },
      /**
       * Compiles a string builder object to a function, executes the function and
       * returns the return value.
       *
       * @param instance {Object} Instance which have called the original method
       * @param members {Object} Prototype members map where the new function should be stored
       * @param name {String} Name of the property
       * @param variant {String} Function variant e.g. get, set, reset, ...
       * @param code {Array} Array which contains the code
       * @param args {arguments} Incoming arguments of wrapper method
       * @return {var} Return value of the generated function
       */
      __unwrapFunctionFromCode : function(eM, eN, name, eO, eP, eQ){

        var eR = this.$$method[eO][name];
        // Output generate code
        if(qx.core.Environment.get(bc)){

          if(qx.core.Environment.get(x) > 1){

            qx.Bootstrap.debug(t + this.$$method[eO][name] + cM + eP.join(bb));
          };
          // Overriding temporary wrapper
          try{

            eN[eR] = new Function(g, eP.join(bb));
          } catch(eS) {

            throw new Error(cP + this.$$method[eO][name] + T + eP.join(bb));
          };
        } else {

          eN[eR] = new Function(g, eP.join(bb));
        };
        // Enable profiling code
        if(qx.core.Environment.get(cU)){

          eN[eR] = qx.core.Aspect.wrap(eM.classname + bC + eR, eN[eR], bX);
        };
        qx.Bootstrap.setDisplayName(eN[eR], eM.classname + N, eR);
        // Executing new function
        if(eQ === undefined){

          return eM[eR]();
        } else if(qx.core.Environment.get(bc)){

          return eM[eR].apply(eM, eQ);
        } else {

          return eM[eR](eQ[0]);
        };
      },
      /**
       * Generates the optimized getter
       * Supported variants: get
       *
       * @param instance {Object} the instance which calls the method
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @return {var} Execute return value of apply generated function, generally the incoming value
       */
      executeOptimizedGetter : function(eT, eU, name, eV){

        var eX = eU.$$properties[name];
        var fa = eU.prototype;
        var eW = [];
        var eY = this.$$store;
        eW.push(bM, eY.runtime[name], bO);
        eW.push(G, eY.runtime[name], cv);
        if(eX.inheritable){

          eW.push(R, eY.inherit[name], bO);
          eW.push(G, eY.inherit[name], cv);
          eW.push(dF);
        };
        eW.push(bM, eY.user[name], bO);
        eW.push(G, eY.user[name], cv);
        if(eX.themeable){

          eW.push(R, eY.theme[name], bO);
          eW.push(G, eY.theme[name], cv);
        };
        if(eX.deferredInit && eX.init === undefined){

          eW.push(R, eY.init[name], bO);
          eW.push(G, eY.init[name], cv);
        };
        eW.push(dF);
        if(eX.init !== undefined){

          if(eX.inheritable){

            eW.push(dc, eY.init[name], cv);
            if(eX.nullable){

              eW.push(w);
            } else if(eX.init !== undefined){

              eW.push(G, eY.init[name], cv);
            } else {

              eW.push(I, name, f, eU.classname, b);
            };
            eW.push(dd);
          } else {

            eW.push(G, eY.init[name], cv);
          };
        } else if(eX.inheritable || eX.nullable){

          eW.push(Y);
        } else {

          eW.push(cx, name, f, eU.classname, b);
        };
        return this.__unwrapFunctionFromCode(eT, fa, name, eV, eW);
      },
      /**
       * Generates the optimized setter
       * Supported variants: set, reset, init, refresh, style, unstyle
       *
       * @param instance {Object} the instance which calls the method
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param args {arguments} Incoming arguments of wrapper method
       * @return {var} Execute return value of apply generated function, generally the incoming value
       */
      executeOptimizedSetter : function(fb, fc, name, fd, fe){

        var fj = fc.$$properties[name];
        var fi = fc.prototype;
        var fg = [];
        var ff = fd === bQ || fd === bR || fd === bP || (fd === bS && fj.init === undefined);
        var fh = fj.apply || fj.event || fj.inheritable;
        var fk = this.__getStore(fd, name);
        this.__emitSetterPreConditions(fg, fj, name, fd, ff);
        if(ff){

          this.__emitIncomingValueTransformation(fg, fc, fj, name);
        };
        if(fh){

          this.__emitOldNewComparison(fg, ff, fk, fd);
        };
        if(fj.inheritable){

          fg.push(dI);
        };
        if(qx.core.Environment.get(bc)){

          if(ff){

            this.__emitIncomingValueValidation(fg, fj, fc, name, fd);
          };
        };
        if(!fh){

          this.__emitStoreValue(fg, name, fd, ff);
        } else {

          this.__emitStoreComputedAndOldValue(fg, fj, name, fd, ff);
        };
        if(fj.inheritable){

          this.__emitStoreInheritedPropertyValue(fg, fj, name, fd);
        } else if(fh){

          this.__emitNormalizeUndefinedValues(fg, fj, name, fd);
        };
        if(fh){

          this.__emitCallCallback(fg, fj, name);
          // Refresh children
          // Requires the parent/children interface
          if(fj.inheritable && fi._getChildren){

            this.__emitRefreshChildrenValue(fg, name);
          };
        };
        // Return value
        if(ff){

          fg.push(M);
        };
        return this.__unwrapFunctionFromCode(fb, fi, name, fd, fg, fe);
      },
      /**
       * Get the object to store the value for the given variant
       *
       * @param variant {String} Method variant.
       * @param name {String} name of the property
       *
       * @return {Object} the value store
       */
      __getStore : function(fl, name){

        if(fl === bP || fl === C){

          var fm = this.$$store.runtime[name];
        } else if(fl === bR || fl === ce){

          fm = this.$$store.theme[name];
        } else if(fl === bS){

          fm = this.$$store.init[name];
        } else {

          fm = this.$$store.user[name];
        };;
        return fm;
      },
      /**
       * Emit code to check the arguments pre-conditions
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __emitSetterPreConditions : function(fn, fo, name, fp, fq){

        if(qx.core.Environment.get(bc)){

          fn.push(e);
          if(fp === bS){

            fn.push(bh, name, cq, fp, cw);
          };
          if(fp === cu){
          } else if(fq){

            // Check argument length
            fn.push(ck, name, cq, fp, cw);
            // Undefined check
            fn.push(dA, name, cq, fp, cw);
          } else {

            // Check argument length
            fn.push(cX, name, cq, fp, cw);
          };
        } else {

          if(!fo.nullable || fo.check || fo.inheritable){

            fn.push(e);
          };
          // Undefined check
          if(fp === bQ){

            fn.push(dA, name, cq, fp, cw);
          };
        };
      },
      /**
       * Emit code to apply the "validate" and "transform" config keys.
       *
       * @param code {String[]} String array to append the code to
       * @param clazz {Class} the class which originally defined the property
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       */
      __emitIncomingValueTransformation : function(fr, fs, ft, name){

        // Call user-provided transform method, if one is provided.  Transform
        // method should either throw an error or return the new value.
        if(ft.transform){

          fr.push(u, ft.transform, dy);
        };
        // Call user-provided validate method, if one is provided.  Validate
        // method should either throw an error or do nothing.
        if(ft.validate){

          // if it is a string
          if(typeof ft.validate === ch){

            fr.push(bJ, ft.validate, dy);
          } else if(ft.validate instanceof Function){

            fr.push(fs.classname, A, name);
            fr.push(bU);
          };
        };
      },
      /**
       * Emit code, which returns if the incoming value equals the current value.
       *
       * @param code {String[]} String array to append the code to
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       * @param store {Object} The data store to use for the incoming value
       * @param variant {String} Method variant.
       */
      __emitOldNewComparison : function(fu, fv, fw, fx){

        var fy = (fx === ct || fx === ce || fx === C);
        if(fv){

          fu.push(bM, fw, df);
        } else if(fy){

          fu.push(bM, fw, n);
        };
      },
      /**
       * Emit code, which performs validation of the incoming value according to
       * the "nullable", "check" and "inheritable" config keys.
       *
       * @signature function(code, config, clazz, name, variant)
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __emitIncomingValueValidation : qx.core.Environment.select(bc, {
        "true" : function(fz, fA, fB, name, fC){

          // Null check
          if(!fA.nullable){

            fz.push(bo, name, cq, fC, cw);
          };
          // Processing check definition
          if(fA.check !== undefined){

            fz.push(dk + name + bI + fB.classname + bu);
            // Accept "null"
            if(fA.nullable){

              fz.push(bs);
            };
            // Inheritable properties always accept "inherit" as value
            if(fA.inheritable){

              fz.push(cs);
            };
            fz.push(dv);
            if(this.__checks[fA.check] !== undefined){

              fz.push(h, this.__checks[fA.check], c);
            } else if(qx.Class.isDefined(fA.check)){

              fz.push(bi, fA.check, j);
            } else if(qx.Interface && qx.Interface.isDefined(fA.check)){

              fz.push(bF, fA.check, j);
            } else if(typeof fA.check === dh){

              fz.push(bm, fB.classname, A, name);
              fz.push(bW);
            } else if(typeof fA.check === ch){

              fz.push(h, fA.check, c);
            } else if(fA.check instanceof Array){

              fz.push(dK, fB.classname, A, name, L);
            } else {

              throw new Error(p + name + dB + fB.classname);
            };;;;;
            fz.push(cd, name, cq, fC, cw);
          };
        },
        "false" : undefined
      }),
      /**
       * Emit code to store the incoming value
       *
       * @param code {String[]} String array to append the code to
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __emitStoreValue : function(fD, name, fE, fF){

        if(fE === bP){

          fD.push(bJ, this.$$store.runtime[name], bK);
        } else if(fE === C){

          fD.push(bM, this.$$store.runtime[name], bO);
          fD.push(bN, this.$$store.runtime[name], cv);
        } else if(fE === bQ){

          fD.push(bJ, this.$$store.user[name], bK);
        } else if(fE === ct){

          fD.push(bM, this.$$store.user[name], bO);
          fD.push(bN, this.$$store.user[name], cv);
        } else if(fE === bR){

          fD.push(bJ, this.$$store.theme[name], bK);
        } else if(fE === ce){

          fD.push(bM, this.$$store.theme[name], bO);
          fD.push(bN, this.$$store.theme[name], cv);
        } else if(fE === bS && fF){

          fD.push(bJ, this.$$store.init[name], bK);
        };;;;;;
      },
      /**
       * Emit code to store the incoming value and compute the "old" and "computed"
       * values.
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __emitStoreComputedAndOldValue : function(fG, fH, name, fI, fJ){

        if(fH.inheritable){

          fG.push(cN, this.$$store.inherit[name], cv);
        } else {

          fG.push(bA);
        };
        // OLD = RUNTIME VALUE
        fG.push(bM, this.$$store.runtime[name], F);
        if(fI === bP){

          // Replace it with new value
          fG.push(cf, this.$$store.runtime[name], bK);
        } else if(fI === C){

          // Delete field
          fG.push(bN, this.$$store.runtime[name], cv);
          // Complex compution of new value
          fG.push(bM, this.$$store.user[name], bO);
          fG.push(cf, this.$$store.user[name], cv);
          fG.push(R, this.$$store.theme[name], bO);
          fG.push(cf, this.$$store.theme[name], cv);
          fG.push(R, this.$$store.init[name], F);
          fG.push(cf, this.$$store.init[name], cv);
          fG.push(bJ, this.$$store.useinit[name], E);
          fG.push(bL);
        } else {

          // Use runtime value as it has higher priority
          fG.push(dz, this.$$store.runtime[name], cv);
          // Store incoming value
          if(fI === bQ){

            fG.push(bJ, this.$$store.user[name], bK);
          } else if(fI === ct){

            fG.push(bN, this.$$store.user[name], cv);
          } else if(fI === bR){

            fG.push(bJ, this.$$store.theme[name], bK);
          } else if(fI === ce){

            fG.push(bN, this.$$store.theme[name], cv);
          } else if(fI === bS && fJ){

            fG.push(bJ, this.$$store.init[name], bK);
          };;;;
        };
        fG.push(bL);
        // OLD = USER VALUE
        fG.push(R, this.$$store.user[name], F);
        if(fI === bQ){

          if(!fH.inheritable){

            // Remember old value
            fG.push(D, this.$$store.user[name], cv);
          };
          // Replace it with new value
          fG.push(cf, this.$$store.user[name], bK);
        } else if(fI === ct){

          if(!fH.inheritable){

            // Remember old value
            fG.push(D, this.$$store.user[name], cv);
          };
          // Delete field
          fG.push(bN, this.$$store.user[name], cv);
          // Complex compution of new value
          fG.push(bM, this.$$store.runtime[name], bO);
          fG.push(cf, this.$$store.runtime[name], cv);
          fG.push(bM, this.$$store.theme[name], bO);
          fG.push(cf, this.$$store.theme[name], cv);
          fG.push(R, this.$$store.init[name], F);
          fG.push(cf, this.$$store.init[name], cv);
          fG.push(bJ, this.$$store.useinit[name], E);
          fG.push(bL);
        } else {

          if(fI === bP){

            // Use runtime value where it has higher priority
            fG.push(cf, this.$$store.runtime[name], bK);
          } else if(fH.inheritable){

            // Use user value where it has higher priority
            fG.push(cf, this.$$store.user[name], cv);
          } else {

            // Use user value where it has higher priority
            fG.push(dz, this.$$store.user[name], cv);
          };
          // Store incoming value
          if(fI === bR){

            fG.push(bJ, this.$$store.theme[name], bK);
          } else if(fI === ce){

            fG.push(bN, this.$$store.theme[name], cv);
          } else if(fI === bS && fJ){

            fG.push(bJ, this.$$store.init[name], bK);
          };;
        };
        fG.push(bL);
        // OLD = THEMED VALUE
        if(fH.themeable){

          fG.push(R, this.$$store.theme[name], F);
          if(!fH.inheritable){

            fG.push(D, this.$$store.theme[name], cv);
          };
          if(fI === bP){

            fG.push(cf, this.$$store.runtime[name], bK);
          } else if(fI === bQ){

            fG.push(cf, this.$$store.user[name], bK);
          } else if(fI === bR){

            fG.push(cf, this.$$store.theme[name], bK);
          } else if(fI === ce){

            // Delete entry
            fG.push(bN, this.$$store.theme[name], cv);
            // Fallback to init value
            fG.push(bM, this.$$store.init[name], F);
            fG.push(cf, this.$$store.init[name], cv);
            fG.push(bJ, this.$$store.useinit[name], E);
            fG.push(bL);
          } else if(fI === bS){

            if(fJ){

              fG.push(bJ, this.$$store.init[name], bK);
            };
            fG.push(cf, this.$$store.theme[name], cv);
          } else if(fI === cu){

            fG.push(cf, this.$$store.theme[name], cv);
          };;;;;
          fG.push(bL);
        };
        // OLD = INIT VALUE
        fG.push(R, this.$$store.useinit[name], bl);
        if(!fH.inheritable){

          fG.push(D, this.$$store.init[name], cv);
        };
        if(fI === bS){

          if(fJ){

            fG.push(cf, this.$$store.init[name], bK);
          } else {

            fG.push(cf, this.$$store.init[name], cv);
          };
        } else if(fI === bQ || fI === bP || fI === bR || fI === cu){

          fG.push(bN, this.$$store.useinit[name], cv);
          if(fI === bP){

            fG.push(cf, this.$$store.runtime[name], bK);
          } else if(fI === bQ){

            fG.push(cf, this.$$store.user[name], bK);
          } else if(fI === bR){

            fG.push(cf, this.$$store.theme[name], bK);
          } else if(fI === cu){

            fG.push(cf, this.$$store.init[name], cv);
          };;;
        };
        fG.push(bL);
        // OLD = NONE
        // reset(), resetRuntime() and resetStyle() are impossible because otherwise there
        // is already an old value
        if(fI === bQ || fI === bP || fI === bR || fI === bS){

          fG.push(dt);
          if(fI === bP){

            fG.push(cf, this.$$store.runtime[name], bK);
          } else if(fI === bQ){

            fG.push(cf, this.$$store.user[name], bK);
          } else if(fI === bR){

            fG.push(cf, this.$$store.theme[name], bK);
          } else if(fI === bS){

            if(fJ){

              fG.push(cf, this.$$store.init[name], bK);
            } else {

              fG.push(cf, this.$$store.init[name], cv);
            };
            fG.push(bJ, this.$$store.useinit[name], E);
          };;;
          // refresh() will work with the undefined value, later
          fG.push(bL);
        };
      },
      /**
       * Emit code to store the value of an inheritable property
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __emitStoreInheritedPropertyValue : function(fK, fL, name, fM){

        fK.push(bg);
        if(fM === cu){

          fK.push(dQ);
        } else {

          fK.push(S, this.$$store.inherit[name], cv);
        };
        // Fallback to init value if inheritance was unsuccessful
        fK.push(bV);
        fK.push(bJ, this.$$store.init[name], U);
        fK.push(bJ, this.$$store.init[name], dl);
        fK.push(cf, this.$$store.init[name], cv);
        fK.push(bJ, this.$$store.useinit[name], E);
        fK.push(dP);
        fK.push(bN, this.$$store.useinit[name], bp);
        fK.push(bL);
        // Compare old/new computed value
        fK.push(k);
        // Note: At this point computed can be "inherit" or "undefined".
        // Normalize "inherit" to undefined and delete inherited value
        fK.push(cJ);
        fK.push(dM, this.$$store.inherit[name], cv);
        fK.push(bL);
        // Only delete inherited value
        fK.push(cQ);
        fK.push(bN, this.$$store.inherit[name], cv);
        // Store inherited value
        fK.push(cV, this.$$store.inherit[name], dq);
        // Protect against normalization
        fK.push(bB);
        // After storage finally normalize computed and old value
        if(fL.init !== undefined && fM !== bS){

          fK.push(dG, this.$$store.init[name], y);
        } else {

          fK.push(d);
        };
        fK.push(da);
      },
      /**
       * Emit code to normalize the old and incoming values from undefined to
       * <code>null</code>.
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __emitNormalizeUndefinedValues : function(fN, fO, name, fP){

        // Properties which are not inheritable have no possibility to get
        // undefined at this position. (Hint: set(), setRuntime() and setThemed() only allow non undefined values)
        if(fP !== bQ && fP !== bP && fP !== bR){

          fN.push(bH);
        };
        // Compare old/new computed value
        fN.push(k);
        // Normalize old value
        if(fO.init !== undefined && fP !== bS){

          fN.push(dG, this.$$store.init[name], y);
        } else {

          fN.push(d);
        };
      },
      /**
       * Emit code to call the apply method and fire the change event
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       */
      __emitCallCallback : function(fQ, fR, name){

        // Execute user configured setter
        if(fR.apply){

          fQ.push(bJ, fR.apply, J, name, W);
        };
        // Fire event
        if(fR.event){

          fQ.push(by, H, fR.event, q, cn, fR.event, dH, K);
        };
      },
      /**
       * Emit code to update the inherited values of child objects
       *
       * @param code {String[]} String array to append the code to
       * @param name {String} name of the property
       */
      __emitRefreshChildrenValue : function(fS, name){

        fS.push(bY);
        fS.push(cG, this.$$method.refresh[name], bv, this.$$method.refresh[name], dn);
        fS.push(bL);
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(fT){

      var fV = navigator.userAgent.indexOf(dw) != -1;
      var fU = navigator.userAgent.indexOf(cD) != -1;
      // keep the old dereference behavior for IE6 and FF2
      if(fV || fU){

        fT.__shouldBeDereferenced = fT.__shouldBeDereferencedOld;
      };
    }
  });
})();
(function(){

  var bV = "The mixin to include into class '",bU = "' is abstract! It is not possible to instantiate it.",bT = "environment",bS = '"! The value is undefined: ',bR = 'Invalid check definition of property "',bQ = "qx.event.type.Data",bP = 'Forbidden environment setting "',bO = '". It is forbidden to define a default setting for an external namespace!',bN = ": the event value needs to be a string with the class name of the event object which will be fired.",bM = 'Invalid include definition in class "',bv = " could not refine property: ",bu = 'Invalid config in class "',bt = "toString",bs = "! Key: ",br = "events",bq = 'Invalid transform definition of property "',bp = "Interface",bo = "Please initialize '",bn = 'Assumed static class because no "extend" key was found. ',bm = "'.",cd = "' objects using the new keyword!",ce = ": the event value/type cannot be changed from ",cb = "destructor",cc = "destruct",bY = '"! The value is undefined/null!',ca = '" contains an invalid mixin at position ',bW = "Could not refine an init value if there was previously no init value defined. Property '",bX = 'Interface "',cf = "extend",cg = 'Error in include definition of class "',bF = 'Overwriting member "',bE = "module.events",bH = '" definition for class "',bG = "members",bJ = '". It is forbidden to define a ',bI = "' is a singleton! It is not possible to instantiate it directly. Use the static getInstance() method instead.",bL = " already has a property: ",bK = "Events module not enabled.",bD = "The mixin to patch class '",bC = "' of class: '",b = '.',c = " could not be refined!",d = "Could not refine non-existent property: '",e = ".prototype",f = ": the events must be defined as map!",g = "refine",h = "!",j = "properties",k = "'!",m = '"! ',ck = "The class '",cj = "Class",ci = '"! The value needs to be a map!',ch = 'Forbidden variant "',co = '"! Needs to be a String.',cn = '"! Only interfaces and arrays of interfaces are allowed!',cm = 'The include definition in class "',cl = '". It is forbidden to define a variant for an external namespace!',cq = "$$init_",cp = '"! Only mixins and arrays of mixins are allowed!',L = '!',M = '"! Needs to be a String, Array or Function.',J = '"! Every non-static class has to extend at least the "qx.core.Object" class.',K = "init",P = '" without a "refine" flag in the property definition! This class: ',Q = '" contains an invalid interface at position ',N = "variants",O = 'The implement definition in class "',H = '" is already used by Class "',I = 'Overwriting private member "',u = 'Invalid type "',t = "statics",w = " to ",v = "' of class '",q = "",p = "]",s = "member",r = ', original class: ',o = "qx.Class",n = 'Could not refine property "',V = "Mixin",W = "settings",X = "[Class ",Y = 'environment setting for an external namespace!',R = "The class ',",S = 'Invalid implement definition in class "',T = 'Forbidden setting "',U = ': ',ba = "constructor",bb = "Property module disabled.",E = 'Invalid type of key "',D = '" of Class "',C = "' is undefined/null!",B = 'The configuration key "',A = '"! The type of the key must be "',z = "_",y = "Incomplete parameters!",x = "Class ",G = "/",F = "singleton",bc = '" of property "',bd = "module.property",be = '"!',bf = '" found in "',bg = 'Invalid key "',bh = "string",bi = '" is not allowed!',bj = "abstract",bk = "function",bl = "Array",bz = "static",by = "qx.aspects",bx = '" in class "',bw = ".",bB = "object",bA = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.Interface)
  #require(qx.Mixin)
  #require(qx.lang.Core)
  
  #use(qx.lang.Generics)
  
  ************************************************************************ */
  /**
   * This class is one of the most important parts of qooxdoo's
   * object-oriented features.
   *
   * Its {@link #define} method is used to create qooxdoo classes.
   *
   * Each instance of a class defined by {@link #define} has
   * the following keys attached to the constructor and the prototype:
   *
   * <table>
   * <tr><th><code>classname</code></th><td>The fully-qualified name of the class (e.g. <code>"qx.ui.core.Widget"</code>).</td></tr>
   * <tr><th><code>basename</code></th><td>The namespace part of the class name (e.g. <code>"qx.ui.core"</code>).</td></tr>
   * <tr><th><code>constructor</code></th><td>A reference to the constructor of the class.</td></tr>
   * <tr><th><code>superclass</code></th><td>A reference to the constructor of the super class.</td></tr>
   * </table>
   *
   * Each method may access static members of the same class by using
   * <code>this.self(arguments)</code> ({@link qx.core.Object#self}):
   * <pre class='javascript'>
   * statics : { FOO : "bar" },
   * members: {
   *   baz: function(x) {
   *     this.self(arguments).FOO;
   *     ...
   *   }
   * }
   * </pre>
   *
   * Each overriding method may call the overridden method by using
   * <code>this.base(arguments [, ...])</code> ({@link qx.core.Object#base}). This is also true for calling
   * the constructor of the superclass.
   * <pre class='javascript'>
   * members: {
   *   foo: function(x) {
   *     this.base(arguments, x);
   *     ...
   *   }
   * }
   * </pre>
   */
  qx.Bootstrap.define(o, {
    statics : {
      /**
       * A static reference to the property implementation in the case it
       * should be included.
       */
      __Property : qx.core.Environment.get(bd) ? qx.core.Property : null,
      /*
      ---------------------------------------------------------------------------
         PUBLIC METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Define a new class using the qooxdoo class system. This sets up the
       * namespace for the class and generates the class from the definition map.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Class.define("name",
       * {
       *   extend : Object, // superclass
       *   implement : [Interfaces],
       *   include : [Mixins],
       *
       *   statics:
       *   {
       *     CONSTANT : 3.141,
       *
       *     publicMethod: function() {},
       *     _protectedMethod: function() {},
       *     __privateMethod: function() {}
       *   },
       *
       *   properties:
       *   {
       *     "tabIndex": { check: "Number", init : -1 }
       *   },
       *
       *   members:
       *   {
       *     publicField: "foo",
       *     publicMethod: function() {},
       *
       *     _protectedField: "bar",
       *     _protectedMethod: function() {},
       *
       *     __privateField: "baz",
       *     __privateMethod: function() {}
       *   }
       * });
       * </pre>
       *
       * @param name {String?null} Name of the class. If <code>null</code>, the class
       *   will not be added to any namespace which could be handy for testing.
       * @param config {Map ? null} Class definition structure. The configuration map has the following keys:
       *     <table>
       *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *       <tr><th>type</th><td>String</td><td>
       *           Type of the class. Valid types are "abstract", "static" and "singleton".
       *           If unset it defaults to a regular non-static class.
       *       </td></tr>
       *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>
       *       <tr><th>implement</th><td>Interface | Interface[]</td><td>Single interface or array of interfaces the class implements.</td></tr>
       *       <tr><th>include</th><td>Mixin | Mixin[]</td><td>Single mixin or array of mixins, which will be merged into the class.</td></tr>
       *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>
       *       <tr><th>statics</th><td>Map</td><td>Map of static members of the class.</td></tr>
       *       <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see
       *           {@link qx.core.Property}.</td></tr>
       *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>
       *       <tr><th>environment</th><td>Map</td><td>Map of environment settings for this class. For a description of the format of a setting see
       *           {@link qx.core.Environment}.</td></tr>
       *       <tr><th>events</th><td>Map</td><td>
       *           Map of events the class fires. The keys are the names of the events and the values are the
       *           corresponding event type class names.
       *       </td></tr>
       *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of processing the class declaration. It allows access to the declared statics, members and properties.</td></tr>
       *       <tr><th>destruct</th><td>Function</td><td>The destructor of the class.</td></tr>
       *     </table>
       * @return {Class} The defined class
       */
      define : function(name, cr){

        if(!cr){

          var cr = {
          };
        };
        // Normalize include to array
        if(cr.include && !(qx.Bootstrap.getClass(cr.include) === bl)){

          cr.include = [cr.include];
        };
        // Normalize implement to array
        if(cr.implement && !(qx.Bootstrap.getClass(cr.implement) === bl)){

          cr.implement = [cr.implement];
        };
        // Normalize type
        var cs = false;
        if(!cr.hasOwnProperty(cf) && !cr.type){

          cr.type = bz;
          cs = true;
        };
        // Validate incoming data
        if(qx.core.Environment.get(bA)){

          try{

            this.__validateConfig(name, cr);
          } catch(cv) {

            if(cs){

              cv.message = bn + cv.message;
            };
            throw cv;
          };
        };
        // Create the class
        var ct = this.__createClass(name, cr.type, cr.extend, cr.statics, cr.construct, cr.destruct, cr.include);
        // Members, properties, events and mixins are only allowed for non-static classes
        if(cr.extend){

          // Attach properties
          if(cr.properties){

            this.__addProperties(ct, cr.properties, true);
          };
          // Attach members
          if(cr.members){

            this.__addMembers(ct, cr.members, true, true, false);
          };
          // Process events
          if(cr.events){

            this.__addEvents(ct, cr.events, true);
          };
          // Include mixins
          // Must be the last here to detect conflicts
          if(cr.include){

            for(var i = 0,l = cr.include.length;i < l;i++){

              this.__addMixin(ct, cr.include[i], false);
            };
          };
        };
        // Process environment
        if(cr.environment){

          for(var cu in cr.environment){

            qx.core.Environment.add(cu, cr.environment[cu]);
          };
        };
        // Interface support for non-static classes
        if(cr.implement){

          for(var i = 0,l = cr.implement.length;i < l;i++){

            this.__addInterface(ct, cr.implement[i]);
          };
        };
        if(qx.core.Environment.get(bA)){

          this.__validateAbstractInterfaces(ct);
        };
        // Process defer
        if(cr.defer){

          cr.defer.self = ct;
          cr.defer(ct, ct.prototype, {
            add : function(name, cw){

              // build pseudo properties map
              var cx = {
              };
              cx[name] = cw;
              // execute generic property handler
              qx.Class.__addProperties(ct, cx, true);
            }
          });
        };
        return ct;
      },
      /**
       * Removes a class from qooxdoo defined by {@link #define}
       *
       * @param name {String} Name of the class
       */
      undefine : function(name){

        // first, delete the class from the registry
        delete this.$$registry[name];
        // delete the class reference from the namespaces and all empty namespaces
        var cy = name.split(bw);
        // build up an array containing all namespace objects including window
        var cA = [window];
        for(var i = 0;i < cy.length;i++){

          cA.push(cA[i][cy[i]]);
        };
        // go through all objects and check for the constructor or empty namespaces
        for(var i = cA.length - 1;i >= 1;i--){

          var cz = cA[i];
          var parent = cA[i - 1];
          if(qx.Bootstrap.isFunction(cz) || qx.Bootstrap.objectGetLength(cz) === 0){

            delete parent[cy[i - 1]];
          } else {

            break;
          };
        };
      },
      /**
       * Whether the given class exists
       *
       * @signature function(name)
       * @param name {String} class name to check
       * @return {Boolean} true if class exists
       */
      isDefined : qx.util.OOUtil.classIsDefined,
      /**
       * Determine the total number of classes
       *
       * @return {Number} the total number of classes
       */
      getTotalNumber : function(){

        return qx.Bootstrap.objectGetLength(this.$$registry);
      },
      /**
       * Find a class by its name
       *
       * @signature function(name)
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName : qx.Bootstrap.getByName,
      /**
       * Include all features of the given mixin into the class. The mixin must
       * not include any methods or properties that are already available in the
       * class. This would only be possible using the {@link #patch} method.
       *
       * @param clazz {Class} An existing class which should be augmented by including a mixin.
       * @param mixin {Mixin} The mixin to be included.
       */
      include : function(cB, cC){

        if(qx.core.Environment.get(bA)){

          if(!cC){

            throw new Error(bV + cB.classname + C);
          };
          qx.Mixin.isCompatible(cC, cB);
        };
        qx.Class.__addMixin(cB, cC, false);
      },
      /**
       * Include all features of the given mixin into the class. The mixin may
       * include features, which are already defined in the target class. Existing
       * features of equal name will be overwritten.
       * Please keep in mind that this functionality is not intended for regular
       * use, but as a formalized way (and a last resort) in order to patch
       * existing classes.
       *
       * <b>WARNING</b>: You may break working classes and features.
       *
       * @param clazz {Class} An existing class which should be modified by including a mixin.
       * @param mixin {Mixin} The mixin to be included.
       */
      patch : function(cD, cE){

        if(qx.core.Environment.get(bA)){

          if(!cE){

            throw new Error(bD + cD.classname + C);
          };
          qx.Mixin.isCompatible(cE, cD);
        };
        qx.Class.__addMixin(cD, cE, true);
      },
      /**
       * Whether a class is a direct or indirect sub class of another class,
       * or both classes coincide.
       *
       * @param clazz {Class} the class to check.
       * @param superClass {Class} the potential super class
       * @return {Boolean} whether clazz is a sub class of superClass.
       */
      isSubClassOf : function(cF, cG){

        if(!cF){

          return false;
        };
        if(cF == cG){

          return true;
        };
        if(cF.prototype instanceof cG){

          return true;
        };
        return false;
      },
      /**
       * Returns the definition of the given property. Returns null
       * if the property does not exist.
       *
       * TODO: Correctly support refined properties?
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the class to check for
       * @return {Map|null} whether the object support the given event.
       */
      getPropertyDefinition : qx.util.OOUtil.getPropertyDefinition,
      /**
       * Returns a list of all properties supported by the given class
       *
       * @param clazz {Class} Class to query
       * @return {String[]} List of all property names
       */
      getProperties : function(cH){

        var cI = [];
        while(cH){

          if(cH.$$properties){

            cI.push.apply(cI, qx.Bootstrap.getKeys(cH.$$properties));
          };
          cH = cH.superclass;
        };
        return cI;
      },
      /**
       * Returns the class or one of its superclasses which contains the
       * declaration for the given property in its class definition. Returns null
       * if the property is not specified anywhere.
       *
       * @param clazz {Class} class to look for the property
       * @param name {String} name of the property
       * @return {Class | null} The class which includes the property
       */
      getByProperty : function(cJ, name){

        while(cJ){

          if(cJ.$$properties && cJ.$$properties[name]){

            return cJ;
          };
          cJ = cJ.superclass;
        };
        return null;
      },
      /**
       * Whether a class has the given property
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the property to check for
       * @return {Boolean} whether the class includes the given property.
       */
      hasProperty : qx.util.OOUtil.hasProperty,
      /**
       * Returns the event type of the given event. Returns null if
       * the event does not exist.
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the event
       * @return {String|null} Event type of the given event.
       */
      getEventType : qx.util.OOUtil.getEventType,
      /**
       * Whether a class supports the given event type
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the event to check for
       * @return {Boolean} whether the class supports the given event.
       */
      supportsEvent : qx.util.OOUtil.supportsEvent,
      /**
       * Whether a class directly includes a mixin.
       *
       * @param clazz {Class} class to check
       * @param mixin {Mixin} the mixin to check for
       * @return {Boolean} whether the class includes the mixin directly.
       */
      hasOwnMixin : function(cK, cL){

        return cK.$$includes && cK.$$includes.indexOf(cL) !== -1;
      },
      /**
       * Returns the class or one of its superclasses which contains the
       * declaration for the given mixin. Returns null if the mixin is not
       * specified anywhere.
       *
       * @param clazz {Class} class to look for the mixin
       * @param mixin {Mixin} mixin to look for
       * @return {Class | null} The class which directly includes the given mixin
       */
      getByMixin : function(cM, cN){

        var cO,i,l;
        while(cM){

          if(cM.$$includes){

            cO = cM.$$flatIncludes;
            for(i = 0,l = cO.length;i < l;i++){

              if(cO[i] === cN){

                return cM;
              };
            };
          };
          cM = cM.superclass;
        };
        return null;
      },
      /**
       * Returns a list of all mixins available in a given class.
       *
       * @signature function(clazz)
       * @param clazz {Class} class which should be inspected
       * @return {Mixin[]} array of mixins this class uses
       */
      getMixins : qx.util.OOUtil.getMixins,
      /**
       * Whether a given class or any of its superclasses includes a given mixin.
       *
       * @param clazz {Class} class to check
       * @param mixin {Mixin} the mixin to check for
       * @return {Boolean} whether the class includes the mixin.
       */
      hasMixin : function(cP, cQ){

        return !!this.getByMixin(cP, cQ);
      },
      /**
       * Whether a given class directly includes an interface.
       *
       * This function will only return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) using the "implement"
       * key.
       *
       * @param clazz {Class} class or instance to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the mixin directly.
       */
      hasOwnInterface : function(cR, cS){

        return cR.$$implements && cR.$$implements.indexOf(cS) !== -1;
      },
      /**
       * Returns the class or one of its super classes which contains the
       * declaration of the given interface. Returns null if the interface is not
       * specified anywhere.
       *
       * @signature function(clazz, iface)
       * @param clazz {Class} class to look for the interface
       * @param iface {Interface} interface to look for
       * @return {Class | null} the class which directly implements the given interface
       */
      getByInterface : qx.util.OOUtil.getByInterface,
      /**
       * Returns a list of all mixins available in a class.
       *
       * @param clazz {Class} class which should be inspected
       * @return {Mixin[]} array of mixins this class uses
       */
      getInterfaces : function(cT){

        var cU = [];
        while(cT){

          if(cT.$$implements){

            cU.push.apply(cU, cT.$$flatImplements);
          };
          cT = cT.superclass;
        };
        return cU;
      },
      /**
       * Whether a given class or any of its super classes includes a given interface.
       *
       * This function will return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) of the class
       * or any of its super classes using the "implement"
       * key.
       *
       * @signature function(clazz, iface)
       * @param clazz {Class} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the interface.
       */
      hasInterface : qx.util.OOUtil.hasInterface,
      /**
       * Whether a given class to an interface.
       *
       * Checks whether all methods defined in the interface are
       * implemented. The class does not need to implement
       * the interface explicitly in the <code>extend</code> key.
       *
       * @param obj {Object} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class conforms to the interface.
       */
      implementsInterface : function(cV, cW){

        var cX = cV.constructor;
        if(this.hasInterface(cX, cW)){

          return true;
        };
        try{

          qx.Interface.assertObject(cV, cW);
          return true;
        } catch(cY) {
        };
        try{

          qx.Interface.assert(cX, cW, false);
          return true;
        } catch(da) {
        };
        return false;
      },
      /**
       * Helper method to handle singletons
       *
       * @internal
       */
      getInstance : function(){

        if(!this.$$instance){

          this.$$allowconstruct = true;
          this.$$instance = new this;
          delete this.$$allowconstruct;
        };
        return this.$$instance;
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL BASICS
      ---------------------------------------------------------------------------
      */
      /**
       * This method will be attached to all classes to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The class identifier
       */
      genericToString : function(){

        return X + this.classname + p;
      },
      /** Stores all defined classes */
      $$registry : qx.Bootstrap.$$registry,
      /** {Map} allowed keys in non-static class definition */
      __allowedKeys : qx.core.Environment.select(bA, {
        "true" : {
          "type" : bh,
          // String
          "extend" : bk,
          // Function
          "implement" : bB,
          // Interface[]
          "include" : bB,
          // Mixin[]
          "construct" : bk,
          // Function
          "statics" : bB,
          // Map
          "properties" : bB,
          // Map
          "members" : bB,
          // Map
          "environment" : bB,
          // Map
          "events" : bB,
          // Map
          "defer" : bk,
          // Function
          "destruct" : bk
        },
        "default" : null
      }),
      /** {Map} allowed keys in static class definition */
      __staticAllowedKeys : qx.core.Environment.select(bA, {
        "true" : {
          "type" : bh,
          // String
          "statics" : bB,
          // Map
          "environment" : bB,
          // Map
          "defer" : bk
        },
        "default" : null
      }),
      /**
       * Validates an incoming configuration and checks for proper keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __validateConfig : qx.core.Environment.select(bA, {
        "true" : function(name, db){

          // Validate type
          if(db.type && !(db.type === bz || db.type === bj || db.type === F)){

            throw new Error(u + db.type + bH + name + be);
          };
          // Validate non-static class on the "extend" key
          if(db.type && db.type !== bz && !db.extend){

            throw new Error(bu + name + J);
          };
          // Validate keys
          var de = db.type === bz ? this.__staticAllowedKeys : this.__allowedKeys;
          for(var dd in db){

            if(!de[dd]){

              throw new Error(B + dd + bx + name + bi);
            };
            if(db[dd] == null){

              throw new Error(bg + dd + bx + name + bY);
            };
            if(typeof db[dd] !== de[dd]){

              throw new Error(E + dd + bx + name + A + de[dd] + be);
            };
          };
          // Validate maps
          var dc = [t, j, bG, bT, W, N, br];
          for(var i = 0,l = dc.length;i < l;i++){

            var dd = dc[i];
            if(db[dd] !== undefined && (db[dd].$$hash !== undefined || !qx.Bootstrap.isObject(db[dd]))){

              throw new Error(bg + dd + bx + name + ci);
            };
          };
          // Validate include definition
          if(db.include){

            if(qx.Bootstrap.getClass(db.include) === bl){

              for(var i = 0,a = db.include,l = a.length;i < l;i++){

                if(a[i] == null || a[i].$$type !== V){

                  throw new Error(cm + name + ca + i + U + a[i]);
                };
              };
            } else {

              throw new Error(bM + name + cp);
            };
          };
          // Validate implement definition
          if(db.implement){

            if(qx.Bootstrap.getClass(db.implement) === bl){

              for(var i = 0,a = db.implement,l = a.length;i < l;i++){

                if(a[i] == null || a[i].$$type !== bp){

                  throw new Error(O + name + Q + i + U + a[i]);
                };
              };
            } else {

              throw new Error(S + name + cn);
            };
          };
          // Check mixin compatibility
          if(db.include){

            try{

              qx.Mixin.checkCompatibility(db.include);
            } catch(df) {

              throw new Error(cg + name + m + df.message);
            };
          };
          // Validate environment
          if(db.environment){

            for(var dd in db.environment){

              if(dd.substr(0, dd.indexOf(bw)) != name.substr(0, name.indexOf(bw))){

                throw new Error(bP + dd + bf + name + bJ + Y);
              };
            };
          };
          // Validate settings
          if(db.settings){

            for(var dd in db.settings){

              if(dd.substr(0, dd.indexOf(bw)) != name.substr(0, name.indexOf(bw))){

                throw new Error(T + dd + bf + name + bO);
              };
            };
          };
          // Validate variants
          if(db.variants){

            for(var dd in db.variants){

              if(dd.substr(0, dd.indexOf(bw)) != name.substr(0, name.indexOf(bw))){

                throw new Error(ch + dd + bf + name + cl);
              };
            };
          };
        },
        "default" : function(){
        }
      }),
      /**
       * Validates the interfaces required by abstract base classes
       *
       * @signature function(clazz)
       * @param clazz {Class} The configured class.
       */
      __validateAbstractInterfaces : qx.core.Environment.select(bA, {
        "true" : function(dg){

          var di = dg.superclass;
          while(di){

            if(di.$$classtype !== bj){

              break;
            };
            var dh = di.$$implements;
            if(dh){

              for(var i = 0;i < dh.length;i++){

                qx.Interface.assert(dg, dh[i], true);
              };
            };
            di = di.superclass;
          };
        },
        "default" : function(){
        }
      }),
      /**
       * Creates a class by type. Supports modern inheritance etc.
       *
       * @param name {String} Full name of the class
       * @param type {String} type of the class, i.e. "static", "abstract" or "singleton"
       * @param extend {Class} Superclass to inherit from
       * @param statics {Map} Static methods or fields
       * @param construct {Function} Constructor of the class
       * @param destruct {Function} Destructor of the class
       * @param mixins {Mixin[]} array of mixins of the class
       * @return {Class} The generated class
       */
      __createClass : function(name, dj, dk, dl, dm, dn, dp){

        var ds;
        if(!dk && qx.core.Environment.get(by) == false){

          // Create empty/non-empty class
          ds = dl || {
          };
          qx.Bootstrap.setDisplayNames(ds, name);
        } else {

          var ds = {
          };
          if(dk){

            // Create default constructor
            if(!dm){

              dm = this.__createDefaultConstructor();
            };
            if(this.__needsConstructorWrapper(dk, dp)){

              ds = this.__wrapConstructor(dm, name, dj);
            } else {

              ds = dm;
            };
            // Add singleton getInstance()
            if(dj === F){

              ds.getInstance = this.getInstance;
            };
            qx.Bootstrap.setDisplayName(dm, name, ba);
          };
          // Copy statics
          if(dl){

            qx.Bootstrap.setDisplayNames(dl, name);
            var dt;
            for(var i = 0,a = qx.Bootstrap.getKeys(dl),l = a.length;i < l;i++){

              dt = a[i];
              var dq = dl[dt];
              if(qx.core.Environment.get(by)){

                if(dq instanceof Function){

                  dq = qx.core.Aspect.wrap(name + bw + dt, dq, bz);
                };
                ds[dt] = dq;
              } else {

                ds[dt] = dq;
              };
            };
          };
        };
        // Create namespace
        var dr = name ? qx.Bootstrap.createNamespace(name, ds) : q;
        // Store names in constructor/object
        ds.name = ds.classname = name;
        ds.basename = dr;
        // Store type info
        ds.$$type = cj;
        if(dj){

          ds.$$classtype = dj;
        };
        // Attach toString
        if(!ds.hasOwnProperty(bt)){

          ds.toString = this.genericToString;
        };
        if(dk){

          qx.Bootstrap.extendClass(ds, dm, dk, name, dr);
          // Store destruct onto class
          if(dn){

            if(qx.core.Environment.get(by)){

              dn = qx.core.Aspect.wrap(name, dn, cb);
            };
            ds.$$destructor = dn;
            qx.Bootstrap.setDisplayName(dn, name, cc);
          };
        };
        // Store class reference in global class registry
        this.$$registry[name] = ds;
        // Return final class object
        return ds;
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE ADD HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Attach events to the class
       *
       * @param clazz {Class} class to add the events to
       * @param events {Map} map of event names the class fires.
       * @param patch {Boolean ? false} Enable redefinition of event type?
       */
      __addEvents : function(du, dv, dw){

        if(qx.core.Environment.get(bA)){

          if(typeof dv !== bB || qx.Bootstrap.getClass(dv) === bl){

            throw new Error(du.classname + f);
          };
          for(var dx in dv){

            if(typeof dv[dx] !== bh){

              throw new Error(du.classname + G + dx + bN);
            };
          };
          // Compare old and new event type/value if patching is disabled
          if(du.$$events && dw !== true){

            for(var dx in dv){

              if(du.$$events[dx] !== undefined && du.$$events[dx] !== dv[dx]){

                throw new Error(du.classname + G + dx + ce + du.$$events[dx] + w + dv[dx]);
              };
            };
          };
        };
        if(du.$$events){

          for(var dx in dv){

            du.$$events[dx] = dv[dx];
          };
        } else {

          du.$$events = dv;
        };
      },
      /**
       * Attach properties to classes
       *
       * @param clazz {Class} class to add the properties to
       * @param properties {Map} map of properties
       * @param patch {Boolean ? false} Overwrite property with the limitations of a property
                 which means you are able to refine but not to replace (esp. for new properties)
       */
      __addProperties : function(dy, dz, dA){

        // check for the property module
        if(!qx.core.Environment.get(bd)){

          throw new Error(bb);
        };
        var dB;
        if(dA === undefined){

          dA = false;
        };
        var dC = dy.prototype;
        for(var name in dz){

          dB = dz[name];
          // Check incoming configuration
          if(qx.core.Environment.get(bA)){

            this.__validateProperty(dy, name, dB, dA);
          };
          // Store name into configuration
          dB.name = name;
          // Add config to local registry
          if(!dB.refine){

            if(dy.$$properties === undefined){

              dy.$$properties = {
              };
            };
            dy.$$properties[name] = dB;
          };
          // Store init value to prototype. This makes it possible to
          // overwrite this value in derived classes.
          if(dB.init !== undefined){

            dy.prototype[cq + name] = dB.init;
          };
          // register event name
          if(dB.event !== undefined){

            // break if no events layer loaded
            if(!qx.core.Environment.get(bE)){

              throw new Error(bK);
            };
            var event = {
            };
            event[dB.event] = bQ;
            this.__addEvents(dy, event, dA);
          };
          // Remember inheritable properties
          if(dB.inheritable){

            this.__Property.$$inheritable[name] = true;
            if(!dC.$$refreshInheritables){

              this.__Property.attachRefreshInheritables(dy);
            };
          };
          if(!dB.refine){

            this.__Property.attachMethods(dy, name, dB);
          };
        };
      },
      /**
       * Validates the given property
       *
       * @signature function(clazz, name, config, patch)
       * @param clazz {Class} class to add property to
       * @param name {String} name of the property
       * @param config {Map} configuration map
       * @param patch {Boolean ? false} enable refine/patch?
       */
      __validateProperty : qx.core.Environment.select(bA, {
        "true" : function(dD, name, dE, dF){

          // check for properties
          if(!qx.core.Environment.get(bd)){

            throw new Error(bb);
          };
          var dH = this.hasProperty(dD, name);
          if(dH){

            var dG = this.getPropertyDefinition(dD, name);
            if(dE.refine && dG.init === undefined){

              throw new Error(bW + name + v + dD.classname + bm);
            };
          };
          if(!dH && dE.refine){

            throw new Error(d + name + bC + dD.classname + k);
          };
          if(dH && !dF){

            throw new Error(x + dD.classname + bL + name + h);
          };
          if(dH && dF){

            if(!dE.refine){

              throw new Error(n + name + P + dD.classname + r + this.getByProperty(dD, name).classname + b);
            };
            for(var dI in dE){

              if(dI !== K && dI !== g){

                throw new Error(x + dD.classname + bv + name + bs + dI + c);
              };
            };
          };
          // Check 0.7 keys
          var dJ = dE.group ? this.__Property.$$allowedGroupKeys : this.__Property.$$allowedKeys;
          for(var dI in dE){

            if(dJ[dI] === undefined){

              throw new Error(B + dI + bc + name + bx + dD.classname + bi);
            };
            if(dE[dI] === undefined){

              throw new Error(bg + dI + bc + name + bx + dD.classname + bS + dE[dI]);
            };
            if(dJ[dI] !== null && typeof dE[dI] !== dJ[dI]){

              throw new Error(E + dI + bc + name + bx + dD.classname + A + dJ[dI] + be);
            };
          };
          if(dE.transform != null){

            if(!(typeof dE.transform == bh)){

              throw new Error(bq + name + bx + dD.classname + co);
            };
          };
          if(dE.check != null){

            if(!qx.Bootstrap.isString(dE.check) && !qx.Bootstrap.isArray(dE.check) && !qx.Bootstrap.isFunction(dE.check)){

              throw new Error(bR + name + bx + dD.classname + M);
            };
          };
        },
        "default" : null
      }),
      /**
       * Attach members to a class
       *
       * @param clazz {Class} clazz to add members to
       * @param members {Map} The map of members to attach
       * @param patch {Boolean ? false} Enable patching of
       * @param base (Boolean ? true) Attach base flag to mark function as members
       *     of this class
       * @param wrap {Boolean ? false} Whether the member method should be wrapped.
       *     this is needed to allow base calls in patched mixin members.
       */
      __addMembers : function(dK, dL, dM, dN, dO){

        var dP = dK.prototype;
        var dR,dQ;
        qx.Bootstrap.setDisplayNames(dL, dK.classname + e);
        for(var i = 0,a = qx.Bootstrap.getKeys(dL),l = a.length;i < l;i++){

          dR = a[i];
          dQ = dL[dR];
          if(qx.core.Environment.get(bA)){

            if(dP[dR] !== undefined && dR.charAt(0) == z && dR.charAt(1) == z){

              throw new Error(I + dR + D + dK.classname + bi);
            };
            if(dM !== true && dP.hasOwnProperty(dR)){

              throw new Error(bF + dR + D + dK.classname + bi);
            };
          };
          // Added helper stuff to functions
          // Hint: Could not use typeof function because RegExp objects are functions, too
          // Protect to apply base property and aspect support on special attributes e.g.
          // classes which are function like as well.
          if(dN !== false && dQ instanceof Function && dQ.$$type == null){

            if(dO == true){

              // wrap "patched" mixin member
              dQ = this.__mixinMemberWrapper(dQ, dP[dR]);
            } else {

              // Configure extend (named base here)
              // Hint: proto[key] is not yet overwritten here
              if(dP[dR]){

                dQ.base = dP[dR];
              };
              dQ.self = dK;
            };
            if(qx.core.Environment.get(by)){

              dQ = qx.core.Aspect.wrap(dK.classname + bw + dR, dQ, s);
            };
          };
          // Attach member
          dP[dR] = dQ;
        };
      },
      /**
       * Wraps a member function of a mixin, which is included using "patch". This
       * allows "base" calls in the mixin member function.
       *
       * @param member {Function} The mixin method to wrap
       * @param base {Function} The overwritten method
       * @return {Function} the wrapped mixin member
       */
      __mixinMemberWrapper : function(dS, dT){

        if(dT){

          return function(){

            var dV = dS.base;
            dS.base = dT;
            var dU = dS.apply(this, arguments);
            dS.base = dV;
            return dU;
          };
        } else {

          return dS;
        };
      },
      /**
       * Add a single interface to a class
       *
       * @param clazz {Class} class to add interface to
       * @param iface {Interface} the Interface to add
       */
      __addInterface : function(dW, dX){

        if(qx.core.Environment.get(bA)){

          if(!dW || !dX){

            throw new Error(y);
          };
          // This differs from mixins, we only check if the interface is already
          // directly used by this class. It is allowed however, to have an interface
          // included multiple times by extends in the interfaces etc.
          if(this.hasOwnInterface(dW, dX)){

            throw new Error(bX + dX.name + H + dW.classname + L);
          };
          // Check interface and wrap members
          if(dW.$$classtype !== bj){

            qx.Interface.assert(dW, dX, true);
          };
        };
        // Store interface reference
        var dY = qx.Interface.flatten([dX]);
        if(dW.$$implements){

          dW.$$implements.push(dX);
          dW.$$flatImplements.push.apply(dW.$$flatImplements, dY);
        } else {

          dW.$$implements = [dX];
          dW.$$flatImplements = dY;
        };
      },
      /**
       * Wrap the constructor of an already existing clazz. This function will
       * replace all references to the existing constructor with the new wrapped
       * constructor.
       *
       * @param clazz {Class} The class to wrap
       */
      __retrospectWrapConstruct : function(ea){

        var name = ea.classname;
        var eb = this.__wrapConstructor(ea, name, ea.$$classtype);
        // copy all keys from the wrapped constructor to the wrapper
        for(var i = 0,a = qx.Bootstrap.getKeys(ea),l = a.length;i < l;i++){

          ec = a[i];
          eb[ec] = ea[ec];
        };
        // fix prototype
        eb.prototype = ea.prototype;
        // fix self references in members
        var ee = ea.prototype;
        for(var i = 0,a = qx.Bootstrap.getKeys(ee),l = a.length;i < l;i++){

          ec = a[i];
          var ef = ee[ec];
          // check if method is available because null values can be stored as
          // init values on classes e.g. [BUG #3709]
          if(ef && ef.self == ea){

            ef.self = eb;
          };
        };
        // fix base and superclass references in all defined classes
        for(var ec in this.$$registry){

          var ed = this.$$registry[ec];
          if(!ed){

            continue;
          };
          if(ed.base == ea){

            ed.base = eb;
          };
          if(ed.superclass == ea){

            ed.superclass = eb;
          };
          if(ed.$$original){

            if(ed.$$original.base == ea){

              ed.$$original.base = eb;
            };
            if(ed.$$original.superclass == ea){

              ed.$$original.superclass = eb;
            };
          };
        };
        qx.Bootstrap.createNamespace(name, eb);
        this.$$registry[name] = eb;
        return eb;
      },
      /**
       * Include all features of the mixin into the given class, recursively.
       *
       * @param clazz {Class} The class onto which the mixin should be attached.
       * @param mixin {Mixin} Include all features of this mixin
       * @param patch {Boolean} Overwrite existing fields, functions and properties
       */
      __addMixin : function(eg, eh, ei){

        if(qx.core.Environment.get(bA)){

          if(!eg || !eh){

            throw new Error(y);
          };
        };
        if(this.hasMixin(eg, eh)){

          return;
        };
        var el = eg.$$original;
        if(eh.$$constructor && !el){

          eg = this.__retrospectWrapConstruct(eg);
        };
        // Attach content
        var ek = qx.Mixin.flatten([eh]);
        var ej;
        for(var i = 0,l = ek.length;i < l;i++){

          ej = ek[i];
          // Attach events
          if(ej.$$events){

            this.__addEvents(eg, ej.$$events, ei);
          };
          // Attach properties (Properties are already readonly themselves, no patch handling needed)
          if(ej.$$properties){

            this.__addProperties(eg, ej.$$properties, ei);
          };
          // Attach members (Respect patch setting, but dont apply base variables)
          if(ej.$$members){

            this.__addMembers(eg, ej.$$members, ei, ei, ei);
          };
        };
        // Store mixin reference
        if(eg.$$includes){

          eg.$$includes.push(eh);
          eg.$$flatIncludes.push.apply(eg.$$flatIncludes, ek);
        } else {

          eg.$$includes = [eh];
          eg.$$flatIncludes = ek;
        };
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE FUNCTION HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the default constructor.
       * This constructor just calls the constructor of the base class.
       *
       * @return {Function} The default constructor.
       */
      __createDefaultConstructor : function(){

        function em(){

          em.base.apply(this, arguments);
        };
        return em;
      },
      /**
       * Returns an empty function. This is needed to get an empty function with an empty closure.
       *
       * @return {Function} empty function
       */
      __createEmptyFunction : function(){

        return function(){
        };
      },
      /**
       * Checks if the constructor needs to be wrapped.
       *
       * @param base {Class} The base class.
       * @param mixins {Mixin[]} All mixins which should be included.
       * @return {Boolean} true, if the constructor needs to be wrapped.
       */
      __needsConstructorWrapper : function(en, eo){

        if(qx.core.Environment.get(bA)){

          return true;
        };
        // Check for base class mixin constructors
        if(en && en.$$includes){

          var ep = en.$$flatIncludes;
          for(var i = 0,l = ep.length;i < l;i++){

            if(ep[i].$$constructor){

              return true;
            };
          };
        };
        // check for direct mixin constructors
        if(eo){

          var eq = qx.Mixin.flatten(eo);
          for(var i = 0,l = eq.length;i < l;i++){

            if(eq[i].$$constructor){

              return true;
            };
          };
        };
        return false;
      },
      /**
       * Generate a wrapper of the original class constructor in order to enable
       * some of the advanced OO features (e.g. abstract class, singleton, mixins)
       *
       * @param construct {Function} the original constructor
       * @param name {String} name of the class
       * @param type {String} the user specified class type
       */
      __wrapConstructor : function(er, name, es){

        var eu = function(){

          var ey = eu;
          if(qx.core.Environment.get(bA)){

            // new keyword check
            if(!(this instanceof ey)){

              throw new Error(bo + name + cd);
            };
            // add abstract and singleton checks
            if(es === bj){

              if(this.classname === name){

                throw new Error(R + name + bU);
              };
            } else if(es === F){

              if(!ey.$$allowconstruct){

                throw new Error(ck + name + bI);
              };
            };
          };
          // Execute default constructor
          var ew = ey.$$original.apply(this, arguments);
          // Initialize local mixins
          if(ey.$$includes){

            var ev = ey.$$flatIncludes;
            for(var i = 0,l = ev.length;i < l;i++){

              if(ev[i].$$constructor){

                ev[i].$$constructor.apply(this, arguments);
              };
            };
          };
          if(qx.core.Environment.get(bA)){

            // Mark instance as initialized
            if(this.classname === name){

              this.$$initialized = true;
            };
          };
          // Return optional return value
          return ew;
        };
        if(qx.core.Environment.get(by)){

          var et = qx.core.Aspect.wrap(name, eu, ba);
          eu.$$original = er;
          eu.constructor = et;
          eu = et;
        };
        // Store original constructor
        eu.$$original = er;
        // Store wrapper into constructor (needed for base calls etc.)
        er.wrapper = eu;
        // Return generated wrapper
        return eu;
      }
    },
    defer : function(){

      // Binding of already loaded bootstrap classes
      if(qx.core.Environment.get(by)){

        for(var ez in qx.Bootstrap.$$registry){

          var eA = qx.Bootstrap.$$registry[ez];
          for(var eB in eA){

            // only functions, no regexps
            if(eA[eB] instanceof Function){

              eA[eB] = qx.core.Aspect.wrap(ez + bw + eB, eA[eB], bz);
            };
          };
        };
      };
    }
  });
})();
(function(){

  var k = "join",j = "toLocaleUpperCase",h = "shift",g = "substr",f = "filter",e = "unshift",d = "match",c = "quote",b = "qx.lang.Generics",a = "localeCompare",I = "sort",H = "some",G = "charAt",F = "split",E = "substring",D = "pop",C = "toUpperCase",B = "replace",A = "push",z = "charCodeAt",t = "every",u = "reverse",q = "search",r = "forEach",o = "map",p = "toLowerCase",m = "splice",n = "toLocaleLowerCase",v = "indexOf",w = "lastIndexOf",y = "slice",x = "concat";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.lang.Core)
  
  ************************************************************************ */
  /**
   * Support string/array generics as introduced with JavaScript 1.6 for
   * all browsers.
   *
   * http://developer.mozilla.org/en/docs/New_in_JavaScript_1.6#Array_and_String_generics
   *
   * *Array*
   *
   * * join
   * * reverse
   * * sort
   * * push
   * * pop
   * * shift
   * * unshift
   * * splice
   * * concat
   * * slice
   * * indexOf
   * * lastIndexOf
   * * forEach
   * * map
   * * filter
   * * some
   * * every
   *
   * *String*
   *
   * * quote
   * * substring
   * * toLowerCase
   * * toUpperCase
   * * charAt
   * * charCodeAt
   * * indexOf
   * * lastIndexOf
   * * toLocaleLowerCase
   * * toLocaleUpperCase
   * * localeCompare
   * * match
   * * search
   * * replace
   * * split
   * * substr
   * * concat
   * * slice
   */
  qx.Class.define(b, {
    statics : {
      /** Which methods to map */
      __map : {
        "Array" : [k, u, I, A, D, h, e, m, x, y, v, w, r, o, f, H, t],
        "String" : [c, E, p, C, G, z, v, w, n, j, a, d, q, B, F, g, x, y]
      },
      /**
       * Make a method of an object generic and return the generic functions.
       * The generic function takes as first parameter the object the method operates on.
       *
       * TODO: maybe mode this function to qx.lang.Function
       *
       * @param obj {Object} the object in which prototype the function is defined.
       * @param func {String} name of the method to wrap.
       * @return {Function} wrapped method. This function takes as first argument an
       *         instance of obj and as following arguments the arguments of the original method.
       */
      __wrap : function(J, K){

        return function(s){

          return J.prototype[K].apply(s, Array.prototype.slice.call(arguments, 1));
        };
      },
      /**
       * Initialize all generic functions as defined in JavaScript 1.6.
       *
       * @return {void}
       */
      __init : function(){

        var L = qx.lang.Generics.__map;
        for(var P in L){

          var N = window[P];
          var M = L[P];
          for(var i = 0,l = M.length;i < l;i++){

            var O = M[i];
            if(!N[O]){

              N[O] = qx.lang.Generics.__wrap(N, O);
            };
          };
        };
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(Q){

      Q.__init();
    }
  });
})();
(function(){

  var a = "qx.data.MBinding";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This mixin is forwarding the static methods of
   * {@link qx.data.SingleValueBinding} to the instance including the mixin.
   * The source object will be <code>this</code>.
   */
  qx.Mixin.define(a, {
    members : {
      /**
       * The bind method delegates the call to the
       * {@link qx.data.SingleValueBinding#bind} function. As source, the current
       * object (this) will be used.
       *
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetProperty {String} The property name of the target object.
       * @param options {Map} A map containing the options. See
       *   {@link qx.data.SingleValueBinding#bind} for more
       *   information.
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index.
       *
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for object and property (source and
       *   target).
       */
      bind : function(b, c, d, e){

        return qx.data.SingleValueBinding.bind(this, b, c, d, e);
      },
      /**
       * Removes the binding with the given id from the current object. The
       * id hast to be the id returned by any of the bind functions.
       *
       * @param id {var} The id of the binding.
       * @throws {Error} If the binding could not be found.
       */
      removeBinding : function(f){

        qx.data.SingleValueBinding.removeBindingFromObject(this, f);
      },
      /**
       * Removes all bindings from the object.
       *
       * @throws {qx.core.AssertionError} If the object is not in the internal
       *   registry of the bindings.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeAllBindings : function(){

        qx.data.SingleValueBinding.removeAllBindingsForObject(this);
      },
      /**
       * Returns an array which lists all bindings for the object.
       *
       * @return {Array} An array of binding informations. Every binding
       *   information is an array itself containing id, sourceObject, sourceEvent,
       *   targetObject and targetProperty in that order.
       */
      getBindings : function(){

        return qx.data.SingleValueBinding.getAllBindingsForObject(this);
      }
    }
  });
})();
(function(){

  var m = "Boolean",l = "Data after conversion: ",k = ")",h = ") to the object '",g = "Can not remove the bindings for null object!",f = "Please use only one array at a time: ",d = "Binding executed from ",c = "Integer",b = " of object ",a = "qx.event.type.Data",Y = "qx.data.SingleValueBinding",X = "No number or 'last' value hast been given",W = "Binding property ",V = "Binding could not be found!",U = " to ",T = "Binding from '",S = " (",R = "PositiveNumber",Q = "Data before conversion: ",P = "PositiveInteger",u = "Binding does not exist!",v = " in an array binding: ",s = " is not an data (qx.event.type.Data) event on ",t = ").",q = " by ",r = "Date",n = " not possible: No event available. ",p = "qx.debug.databinding",w = ". Error message: ",x = "set",E = "deepBinding",C = "item",I = "reset",G = "Failed so set value ",L = "qx.debug",K = " does not work.",z = "' (",O = " on ",N = "String",M = "Number",y = "change",A = "]",B = ".",D = "last",F = "[",H = "",J = "get";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * The data binding package is still under development so there will be changes
   * to the API. This Features is for testing purpose only.
   */
  qx.Class.define(Y, {
    statics : {
      /** internal reference for all bindings */
      __bindings : {
      },
      /**
       * The function is responsible for binding a source objects property to
       * a target objects property. Both properties have to have the usual qooxdoo
       * getter and setter. The source property also needs to fire change-events
       * on every change of its value.
       * Please keep in mind, that this binding is unidirectional. If you need
       * a binding in both directions, you have to use two of this bindings.
       *
       * It's also possible to bind some kind of a hierarchy as a source. This
       * means that you can separate the source properties with a dot and bind
       * by that the object referenced to this property chain.
       * Example with an object 'a' which has object 'b' stored in its 'child'
       * property. Object b has a string property named abc:
       * <pre><code>
       * qx.data.SingleValueBinding.bind(a, "child.abc", textfield, "value");
       * </code></pre>
       * In that case, if the property abc of b changes, the textfield will
       * automatically contain the new value. Also if the child of a changes, the
       * new value (abc of the new child) will be in the textfield.
       *
       * There is also a possibility of binding an array. Therefor the array
       * {@link qx.data.IListData} is needed because this array has change events
       * which the native does not. Imagine a qooxdoo object a which has a
       * children property containing an array holding more of its own kind.
       * Every object has a name property as a string.
       * <pre><code>
       * var svb = qx.data.SingleValueBinding;
       * // bind the first childs name of 'a' to a textfield
       * svb.bind(a, "children[0].name", textfield, "value");
       * // bind the last childs name of 'a' to a textfield
       * svb.bind(a, "children[last].name", textfield2, "value");
       * // also deeper bindinds are possible
       * svb.bind(a, "children[0].children[0].name", textfield3, "value");
       * </code></pre>
       *
       * As you can see in this example, the abc property of a's b will be bound
       * to the textfield. If now the value of b changed or even the a will get a
       * new b, the binding still shows the right value.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property chain to the target
       *   object.
       * @param options {Map?null} A map containing the options.
       *   <li>converter: A converter function which takes four parameters
       *       and should return the converted value. The first parameter is the
       *       data to convert and the second one is the corresponding model
       *       object, which is only set in case of the use of an controller.
       *       The third parameter is the source object for the binding and the
       *       fourth parameter the target object. If no conversion has been
       *       done, the given value should be returned.</li>
       *   <li>onUpdate: A callback function can be given here. This method will be
       *       called if the binding was updated successful. There will be
       *       three parameter you do get in that method call: the source object,
       *       the target object and the data as third parameter.</li>
       *   <li>onSetFail: A callback function can be given here. This method will
       *       be called if the set of the value fails.</li>
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding or e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index.
       *
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for object and property (source and
       *   target).
       */
      bind : function(ba, bb, bc, bd, be){

        // set up the target binding
        var bp = this.__setUpTargetBinding(ba, bb, bc, bd, be);
        // get the property names
        var bk = bb.split(B);
        // stuff that's needed to store for the listener function
        var bg = this.__checkForArrayInPropertyChain(bk);
        var bo = [];
        var bl = [];
        var bm = [];
        var bi = [];
        var bj = ba;
        // add a try catch to make it possible to remove the listeners of the
        // chain in case the loop breaks after some listeners already added.
        try{

          // go through all property names
          for(var i = 0;i < bk.length;i++){

            // check for the array
            if(bg[i] !== H){

              // push the array change event
              bi.push(y);
            } else {

              bi.push(this.__getEventNameForProperty(bj, bk[i]));
            };
            // save the current source
            bo[i] = bj;
            // check for the last property
            if(i == bk.length - 1){

              // if it is an array, set the initial value and bind the event
              if(bg[i] !== H){

                // getthe current value
                var bt = bg[i] === D ? bj.length - 1 : bg[i];
                var bf = bj.getItem(bt);
                // set the initial value
                this.__setInitialValue(bf, bc, bd, be, ba);
                // bind the event
                bm[i] = this.__bindEventToProperty(bj, bi[i], bc, bd, be, bg[i]);
              } else {

                // try to set the initial value
                if(bk[i] != null && bj[J + qx.lang.String.firstUp(bk[i])] != null){

                  var bf = bj[J + qx.lang.String.firstUp(bk[i])]();
                  this.__setInitialValue(bf, bc, bd, be, ba);
                };
                // bind the property
                bm[i] = this.__bindEventToProperty(bj, bi[i], bc, bd, be);
              };
            } else {

              // create the contenxt for the listener
              var bq = {
                index : i,
                propertyNames : bk,
                sources : bo,
                listenerIds : bm,
                arrayIndexValues : bg,
                targetObject : bc,
                targetPropertyChain : bd,
                options : be,
                listeners : bl
              };
              // create a listener
              var bn = qx.lang.Function.bind(this.__chainListener, this, bq);
              // store the listener for further processing
              bl.push(bn);
              // add the chaining listener
              bm[i] = bj.addListener(bi[i], bn);
            };
            // get and store the next source
            if(bj[J + qx.lang.String.firstUp(bk[i])] == null){

              bj = null;
            } else if(bg[i] !== H){

              bj = bj[J + qx.lang.String.firstUp(bk[i])](bg[i]);
            } else {

              bj = bj[J + qx.lang.String.firstUp(bk[i])]();
            };
            if(!bj){

              break;
            };
          };
        } catch(bu) {

          // remove the already added listener
          // go threw all added listeners (source)
          for(var i = 0;i < bo.length;i++){

            // check if a source is available
            if(bo[i] && bm[i]){

              bo[i].removeListenerById(bm[i]);
            };
          };
          var bs = bp.targets;
          var bh = bp.listenerIds[i];
          // go threw all added listeners (target)
          for(var i = 0;i < bs.length;i++){

            // check if a target is available
            if(bs[i] && bh[i]){

              bs[i].removeListenerById(bh[i]);
            };
          };
          throw bu;
        };
        // create the id map
        var br = {
          type : E,
          listenerIds : bm,
          sources : bo,
          targetListenerIds : bp.listenerIds,
          targets : bp.targets
        };
        // store the bindings
        this.__storeBinding(br, ba, bb, bc, bd);
        return br;
      },
      /**
       * Event listener for the chaining of the properties.
       *
       * @param context {Map} The current context for the listener.
       */
      __chainListener : function(bv){

        // invoke the onUpdate method
        if(bv.options && bv.options.onUpdate){

          bv.options.onUpdate(bv.sources[bv.index], bv.targetObject);
        };
        // delete all listener after the current one
        for(var j = bv.index + 1;j < bv.propertyNames.length;j++){

          // remove the old sources
          var bz = bv.sources[j];
          bv.sources[j] = null;
          if(!bz){

            continue;
          };
          // remove the listeners
          bz.removeListenerById(bv.listenerIds[j]);
        };
        // get the current source
        var bz = bv.sources[bv.index];
        // add new once after the current one
        for(var j = bv.index + 1;j < bv.propertyNames.length;j++){

          // get and store the new source
          if(bv.arrayIndexValues[j - 1] !== H){

            bz = bz[J + qx.lang.String.firstUp(bv.propertyNames[j - 1])](bv.arrayIndexValues[j - 1]);
          } else {

            bz = bz[J + qx.lang.String.firstUp(bv.propertyNames[j - 1])]();
          };
          bv.sources[j] = bz;
          // reset the target object if no new source could be found
          if(!bz){

            this.__resetTargetValue(bv.targetObject, bv.targetPropertyChain);
            break;
          };
          // if its the last property
          if(j == bv.propertyNames.length - 1){

            // if its an array
            if(qx.Class.implementsInterface(bz, qx.data.IListData)){

              // set the inital value
              var bA = bv.arrayIndexValues[j] === D ? bz.length - 1 : bv.arrayIndexValues[j];
              var bx = bz.getItem(bA);
              this.__setInitialValue(bx, bv.targetObject, bv.targetPropertyChain, bv.options, bv.sources[bv.index]);
              // bind the item event to the new target
              bv.listenerIds[j] = this.__bindEventToProperty(bz, y, bv.targetObject, bv.targetPropertyChain, bv.options, bv.arrayIndexValues[j]);
            } else {

              if(bv.propertyNames[j] != null && bz[J + qx.lang.String.firstUp(bv.propertyNames[j])] != null){

                var bx = bz[J + qx.lang.String.firstUp(bv.propertyNames[j])]();
                this.__setInitialValue(bx, bv.targetObject, bv.targetPropertyChain, bv.options, bv.sources[bv.index]);
              };
              var by = this.__getEventNameForProperty(bz, bv.propertyNames[j]);
              // bind the last property to the new target
              bv.listenerIds[j] = this.__bindEventToProperty(bz, by, bv.targetObject, bv.targetPropertyChain, bv.options);
            };
          } else {

            // check if a listener already created
            if(bv.listeners[j] == null){

              var bw = qx.lang.Function.bind(this.__chainListener, this, bv);
              // store the listener for further processing
              bv.listeners.push(bw);
            };
            // add a new listener
            if(qx.Class.implementsInterface(bz, qx.data.IListData)){

              var by = y;
            } else {

              var by = this.__getEventNameForProperty(bz, bv.propertyNames[j]);
            };
            bv.listenerIds[j] = bz.addListener(by, bv.listeners[j]);
          };
        };
      },
      /**
       * Internal helper for setting up the listening to the changes on the
       * target side of the binding. Only works if the target property is a
       * property chain
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property name of the target
       *   object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       * @return {var} A map containing the listener ids and the targets.
       */
      __setUpTargetBinding : function(bB, bC, bD, bE, bF){

        // get the property names
        var bJ = bE.split(B);
        var bH = this.__checkForArrayInPropertyChain(bJ);
        var bO = [];
        var bN = [];
        var bL = [];
        var bK = [];
        var bI = bD;
        // go through all property names
        for(var i = 0;i < bJ.length - 1;i++){

          // check for the array
          if(bH[i] !== H){

            // push the array change event
            bK.push(y);
          } else {

            try{

              bK.push(this.__getEventNameForProperty(bI, bJ[i]));
            } catch(e) {

              // if the event names could not be terminated,
              // just ignore the target chain listening
              break;
            };
          };
          // save the current source
          bO[i] = bI;
          // create a listener
          var bM = function(){

            // delete all listener after the current one
            for(var j = i + 1;j < bJ.length - 1;j++){

              // remove the old sources
              var bR = bO[j];
              bO[j] = null;
              if(!bR){

                continue;
              };
              // remove the listeners
              bR.removeListenerById(bL[j]);
            };
            // get the current target
            var bR = bO[i];
            // add new once after the current one
            for(var j = i + 1;j < bJ.length - 1;j++){

              var bP = qx.lang.String.firstUp(bJ[j - 1]);
              // get and store the new target
              if(bH[j - 1] !== H){

                var bS = bH[j - 1] === D ? bR.getLength() - 1 : bH[j - 1];
                bR = bR[J + bP](bS);
              } else {

                bR = bR[J + bP]();
              };
              bO[j] = bR;
              // check if a listener already created
              if(bN[j] == null){

                // store the listener for further processing
                bN.push(bM);
              };
              // add a new listener
              if(qx.Class.implementsInterface(bR, qx.data.IListData)){

                var bQ = y;
              } else {

                try{

                  var bQ = qx.data.SingleValueBinding.__getEventNameForProperty(bR, bJ[j]);
                } catch(e) {

                  // if the event name could not be terminated,
                  // ignore the rest
                  break;
                };
              };
              bL[j] = bR.addListener(bQ, bN[j]);
            };
            qx.data.SingleValueBinding.updateTarget(bB, bC, bD, bE, bF);
          };
          // store the listener for further processing
          bN.push(bM);
          // add the chaining listener
          bL[i] = bI.addListener(bK[i], bM);
          var bG = qx.lang.String.firstUp(bJ[i]);
          // get and store the next target
          if(bI[J + bG] == null){

            bI = null;
          } else if(bH[i] !== H){

            bI = bI[J + bG](bH[i]);
          } else {

            bI = bI[J + bG]();
          };
          if(!bI){

            break;
          };
        };
        return {
          listenerIds : bL,
          targets : bO
        };
      },
      /**
       * Helper for updating the target. Gets the current set data from the source
       * and set that on the target.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property name of the target
       *   object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       *
       * @internal
       */
      updateTarget : function(bT, bU, bV, bW, bX){

        var bY = this.getValueFromObject(bT, bU);
        // convert the data before setting
        bY = qx.data.SingleValueBinding.__convertValue(bY, bV, bW, bX, bT);
        this.__setTargetValue(bV, bW, bY);
      },
      /**
       * Internal helper for getting the current set value at the property chain.
       *
       * @param o {qx.core.Object} The source of the binding.
       * @param propertyChain {String} The property chain which represents
       *   the source property.
       * @return {var?undefined} Returns the set value if defined.
       *
       * @internal
       */
      getValueFromObject : function(o, ca){

        var ce = this.__getTargetFromChain(o, ca);
        var cc;
        if(ce != null){

          // geht the name of the last property
          var cg = ca.substring(ca.lastIndexOf(B) + 1, ca.length);
          // check for arrays
          if(cg.charAt(cg.length - 1) == A){

            // split up the chain into property and index
            var cb = cg.substring(cg.lastIndexOf(F) + 1, cg.length - 1);
            var cd = cg.substring(0, cg.lastIndexOf(F));
            // get the array
            var cf = ce[J + qx.lang.String.firstUp(cd)]();
            if(cb == D){

              cb = cf.length - 1;
            };
            if(cf != null){

              cc = cf.getItem(cb);
            };
          } else {

            // set the given value
            cc = ce[J + qx.lang.String.firstUp(cg)]();
          };
        };
        return cc;
      },
      /**
       * Tries to return a fitting event name to the given source object and
       * property name. First, it assumes that the propertyname is a real property
       * and therefore it checks the property definition for the event. The second
       * possibility is to check if there is an event with the given name. The
       * third and last possibility checked is if there is an event which is named
       * change + propertyname. If this three possibilities fail, an error will be
       * thrown.
       *
       * @param source {qx.core.Object} The source where the property is stored.
       * @param propertyname {String} The name of the property.
       * @return {String} The name of the corresponding property.
       */
      __getEventNameForProperty : function(ch, ci){

        // get the current event Name from the property definition
        var cj = this.__getEventForProperty(ch, ci);
        // if no event name could be found
        if(cj == null){

          // check if the propertyname is the event name
          if(qx.Class.supportsEvent(ch.constructor, ci)){

            cj = ci;
          } else if(qx.Class.supportsEvent(ch.constructor, y + qx.lang.String.firstUp(ci))){

            cj = y + qx.lang.String.firstUp(ci);
          } else {

            throw new qx.core.AssertionError(W + ci + b + ch + n);
          };
        };
        return cj;
      },
      /**
       * Resets the value of the given target after resolving the target property
       * chain.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetPropertyChain {String} The names of the properties,
       *   separated with a dot.
       */
      __resetTargetValue : function(ck, cl){

        // get the last target object of the chain
        var cm = this.__getTargetFromChain(ck, cl);
        if(cm != null){

          // get the name of the last property
          var cn = cl.substring(cl.lastIndexOf(B) + 1, cl.length);
          // check for an array and set the value to null
          if(cn.charAt(cn.length - 1) == A){

            this.__setTargetValue(ck, cl, null);
            return;
          };
          // try to reset the property
          if(cm[I + qx.lang.String.firstUp(cn)] != undefined){

            cm[I + qx.lang.String.firstUp(cn)]();
          } else {

            // fallback if no resetter is given (see bug #2456)
            cm[x + qx.lang.String.firstUp(cn)](null);
          };
        };
      },
      /**
       * Sets the given value to the given target after resolving the
       * target property chain.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetPropertyChain {String} The names of the properties,
       *   separated with a dot.
       * @param value {var} The value to set.
       */
      __setTargetValue : function(co, cp, cq){

        // get the last target object of the chain
        var cu = this.__getTargetFromChain(co, cp);
        if(cu != null){

          // geht the name of the last property
          var cv = cp.substring(cp.lastIndexOf(B) + 1, cp.length);
          // check for arrays
          if(cv.charAt(cv.length - 1) == A){

            // split up the chain into property and index
            var cr = cv.substring(cv.lastIndexOf(F) + 1, cv.length - 1);
            var ct = cv.substring(0, cv.lastIndexOf(F));
            // get the array
            var cs = co;
            if(!qx.Class.implementsInterface(cs, qx.data.IListData)){

              cs = cu[J + qx.lang.String.firstUp(ct)]();
            };
            if(cr == D){

              cr = cs.length - 1;
            };
            if(cs != null){

              cs.setItem(cr, cq);
            };
          } else {

            // set the given value
            cu[x + qx.lang.String.firstUp(cv)](cq);
          };
        };
      },
      /**
       * Helper-Function resolving the object on which the last property of the
       * chain should be set.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetPropertyChain {String} The names of the properties,
       *   separated with a dot.
       * @return {qx.core.Object | null} The object on which the last property
       *   should be set.
       */
      __getTargetFromChain : function(cw, cx){

        var cA = cx.split(B);
        var cB = cw;
        // ignore the last property
        for(var i = 0;i < cA.length - 1;i++){

          try{

            var cz = cA[i];
            // if there is an array notation
            if(cz.indexOf(A) == cz.length - 1){

              var cy = cz.substring(cz.indexOf(F) + 1, cz.length - 1);
              cz = cz.substring(0, cz.indexOf(F));
            };
            // in case there is a property infront of the brackets
            if(cz != H){

              cB = cB[J + qx.lang.String.firstUp(cz)]();
            };
            // if there is an index, we can be sure its an array
            if(cy != null){

              // check for the 'last' notation
              if(cy == D){

                cy = cB.length - 1;
              };
              // get the array item
              cB = cB.getItem(cy);
              cy = null;
            };
          } catch(cC) {

            return null;
          };
        };
        return cB;
      },
      /**
       * Set the given value to the target property. This method is used for
       * initially set the value.
       *
       * @param value {var} The value to set.
       * @param targetObject {qx.core.Object} The object which contains the target
       *   property.
       * @param targetPropertyChain {String} The name of the target property in the
       *   target object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       * @param sourceObject {qx.core.Object} The source object of the binding (
       *   used for the onUpdate callback).
       */
      __setInitialValue : function(cD, cE, cF, cG, cH){

        // first convert the initial value
        cD = this.__convertValue(cD, cE, cF, cG, cH);
        // check if the converted value is undefined
        if(cD === undefined){

          this.__resetTargetValue(cE, cF);
        };
        // only set the initial value if one is given (may be null)
        if(cD !== undefined){

          try{

            this.__setTargetValue(cE, cF, cD);
            // tell the user that the setter was invoked probably
            if(cG && cG.onUpdate){

              cG.onUpdate(cH, cE, cD);
            };
          } catch(e) {

            if(!(e instanceof qx.core.ValidationError)){

              throw e;
            };
            if(cG && cG.onSetFail){

              cG.onSetFail(e);
            } else {

              qx.log.Logger.warn(G + cD + O + cE + w + e);
            };
          };
        };
      },
      /**
       * Checks for an array element in the given property names and adapts the
       * arrays to fit the algorithm.
       *
       * @param propertyNames {Array} The array containing the property names.
       *   Attention, this method can chang this parameter!!!
       * @return {Array} An array containing the values of the array properties
       *   corresponding to the property names.
       */
      __checkForArrayInPropertyChain : function(cI){

        // array for the values of the array properties
        var cJ = [];
        // go through all properties and check for array notations
        for(var i = 0;i < cI.length;i++){

          var name = cI[i];
          // if its an array property in the chain
          if(qx.lang.String.endsWith(name, A)){

            // get the inner value of the array notation
            var cK = name.substring(name.indexOf(F) + 1, name.indexOf(A));
            // check the arrayIndex
            if(name.indexOf(A) != name.length - 1){

              throw new Error(f + name + K);
            };
            if(cK !== D){

              if(cK == H || isNaN(parseInt(cK, 10))){

                throw new Error(X + v + name + K);
              };
            };
            // if a property is infront of the array notation
            if(name.indexOf(F) != 0){

              // store the property name without the array notation
              cI[i] = name.substring(0, name.indexOf(F));
              // store the values in the array for the current iteration
              cJ[i] = H;
              // store the properties for the next iteration (the item of the array)
              cJ[i + 1] = cK;
              cI.splice(i + 1, 0, C);
              // skip the next iteration. its the array item and its already set
              i++;
            } else {

              // store the array index and override the entry in the property names
              cJ[i] = cK;
              cI.splice(i, 1, C);
            };
          } else {

            cJ[i] = H;
          };
        };
        return cJ;
      },
      /**
       * Internal helper method which is actually doing all bindings. That means
       * that an event listener will be added to the source object which listens
       * to the given event and invokes an set on the target property on the
       * targetObject.
       * This method does not store the binding in the internal reference store
       * so it should NOT be used from outside this class. For an outside usage,
       * use {@link #bind}.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourceEvent {String} The event of the source object which could
       *   be the change event in common but has to be an
       *   {@link qx.event.type.Data} event.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetProperty {String} The property name of the target object.
       * @param options {Map} A map containing the options. See
       *   {@link #bind} for more information.
       * @param arrayIndex {String} The index of the given array if its an array
       *   to bind.
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding or e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index. It's the id which will
       *   be returned by the {@link qx.core.Object#addListener} method.
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for the target object and target
       *   property.
       */
      __bindEventToProperty : function(cL, cM, cN, cO, cP, cQ){

        // checks
        if(qx.core.Environment.get(L)){

          // check for the data event
          var cR = qx.Class.getEventType(cL.constructor, cM);
          qx.core.Assert.assertEquals(a, cR, cM + s + cL + B);
        };
        var cT = function(cU, e){

          // if an array value is given
          if(cU !== H){

            //check if its the "last" value
            if(cU === D){

              cU = cL.length - 1;
            };
            // get the data of the array
            var cX = cL.getItem(cU);
            // reset the target if the data is not set
            if(cX === undefined){

              qx.data.SingleValueBinding.__resetTargetValue(cN, cO);
            };
            // only do something if the curren array has been changed
            var cV = e.getData().start;
            var cW = e.getData().end;
            if(cU < cV || cU > cW){

              return;
            };
          } else {

            // get the data out of the event
            var cX = e.getData();
          };
          // debug message
          if(qx.core.Environment.get(p)){

            qx.log.Logger.debug(d + cL + q + cM + U + cN + S + cO + k);
            qx.log.Logger.debug(Q + cX);
          };
          // convert the data
          cX = qx.data.SingleValueBinding.__convertValue(cX, cN, cO, cP, cL);
          // debug message
          if(qx.core.Environment.get(p)){

            qx.log.Logger.debug(l + cX);
          };
          // try to set the value
          try{

            if(cX !== undefined){

              qx.data.SingleValueBinding.__setTargetValue(cN, cO, cX);
            } else {

              qx.data.SingleValueBinding.__resetTargetValue(cN, cO);
            };
            // tell the user that the setter was invoked probably
            if(cP && cP.onUpdate){

              cP.onUpdate(cL, cN, cX);
            };
          } catch(e) {

            if(!(e instanceof qx.core.ValidationError)){

              throw e;
            };
            if(cP && cP.onSetFail){

              cP.onSetFail(e);
            } else {

              qx.log.Logger.warn(G + cX + O + cN + w + e);
            };
          };
        };
        // check if an array index is given
        if(!cQ){

          // if not, signal it a s an empty string
          cQ = H;
        };
        // bind the listener function (make the array index in the listener available)
        cT = qx.lang.Function.bind(cT, cL, cQ);
        // add the listener
        var cS = cL.addListener(cM, cT);
        return cS;
      },
      /**
       * This method stores the given value as a binding in the internal structure
       * of all bindings.
       *
       * @param id {var} The listener id of the id for a deeper binding.
       * @param sourceObject {qx.core.Object} The source Object of the binding.
       * @param sourceEvent {String} The name of the source event.
       * @param targetObject {qx.core.Object} The target object.
       * @param targetProperty {String} The name of the property on the target
       *   object.
       */
      __storeBinding : function(cY, da, db, dc, dd){

        // add the listener id to the internal registry
        if(this.__bindings[da.toHashCode()] === undefined){

          this.__bindings[da.toHashCode()] = [];
        };
        this.__bindings[da.toHashCode()].push([cY, da, db, dc, dd]);
      },
      /**
       * This method takes the given value, checks if the user has given a
       * converter and converts the value to its target type. If no converter is
       * given by the user, the {@link #__defaultConversion} will try to convert
       * the value.
       *
       * @param value {var} The value which possibly should be converted.
       * @param targetObject {qx.core.Object} The target object.
       * @param targetPropertyChain {String} The property name of the target object.
       * @param options {Map} The options map which can includes the converter.
       *   For a detailed information on the map, take a look at
       *   {@link #bind}.
       * @param sourceObject {qx.core.Object} The source obejct for the binding.
       *
       * @return {var} The converted value. If no conversion has been done, the
       *   value property will be returned.
       * @throws {qx.core.AssertionError} If there is no property definition
       *   of the given target object and target property.
       */
      __convertValue : function(de, df, dg, dh, di){

        // do the conversion given by the user
        if(dh && dh.converter){

          var dk;
          if(df.getModel){

            dk = df.getModel();
          };
          return dh.converter(de, dk, di, df);
        } else {

          var dm = this.__getTargetFromChain(df, dg);
          var dn = dg.substring(dg.lastIndexOf(B) + 1, dg.length);
          // if no target is currently available, return the original value
          if(dm == null){

            return de;
          };
          var dl = qx.Class.getPropertyDefinition(dm.constructor, dn);
          var dj = dl == null ? H : dl.check;
          return this.__defaultConversion(de, dj);
        };
      },
      /**
       * Helper method which tries to figure out if the given property on the
       * given object does have a change event and if returns the name of it.
       *
       * @param sourceObject {qx.core.Object} The object to check.
       * @param sourceProperty {String} The name of the property.
       *
       * @return {String} The name of the change event.
       * @throws {qx.core.AssertionError} If there is no property definition of
       *   the given object property pair.
       */
      __getEventForProperty : function(dp, dq){

        // get the event name
        var dr = qx.Class.getPropertyDefinition(dp.constructor, dq);
        if(dr == null){

          return null;
        };
        return dr.event;
      },
      /**
       * Tries to convert the data to the type given in the targetCheck argument.
       *
       * @param data {var} The data to convert.
       * @param targetCheck {String} The value of the check property. That usually
       *   contains the target type.
       */
      __defaultConversion : function(ds, dt){

        var du = qx.lang.Type.getClass(ds);
        // to integer
        if((du == M || du == N) && (dt == c || dt == P)){

          ds = parseInt(ds, 10);
        };
        // to string
        if((du == m || du == M || du == r) && dt == N){

          ds = ds + H;
        };
        // to float
        if((du == M || du == N) && (dt == M || dt == R)){

          ds = parseFloat(ds);
        };
        return ds;
      },
      /**
       * Removes the binding with the given id from the given sourceObject. The
       * id hast to be the id returned by any of the bind functions.
       *
       * @param sourceObject {qx.core.Object} The source object of the binding.
       * @param id {var} The id of the binding.
       * @throws {Error} If the binding could not be found.
       */
      removeBindingFromObject : function(dv, dw){

        // check for a deep binding
        if(dw.type == E){

          // go threw all added listeners (source)
          for(var i = 0;i < dw.sources.length;i++){

            // check if a source is available
            if(dw.sources[i]){

              dw.sources[i].removeListenerById(dw.listenerIds[i]);
            };
          };
          // go threw all added listeners (target)
          for(var i = 0;i < dw.targets.length;i++){

            // check if a target is available
            if(dw.targets[i]){

              dw.targets[i].removeListenerById(dw.targetListenerIds[i]);
            };
          };
        } else {

          // remove the listener
          dv.removeListenerById(dw);
        };
        // remove the id from the internal reference system
        var dx = this.__bindings[dv.toHashCode()];
        // check if the binding exists
        if(dx != undefined){

          for(var i = 0;i < dx.length;i++){

            if(dx[i][0] == dw){

              qx.lang.Array.remove(dx, dx[i]);
              return;
            };
          };
        };
        throw new Error(V);
      },
      /**
       * Removes all bindings for the given object.
       *
       * @param object {qx.core.Object} The object of which the bindings should be
       *   removed.
       * @throws {qx.core.AssertionError} If the object is not in the internal
       *   registry of the bindings.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeAllBindingsForObject : function(dy){

        // check for the null value
        if(qx.core.Environment.get(L)){

          qx.core.Assert.assertNotNull(dy, g);
        };
        // get the bindings
        var dz = this.__bindings[dy.toHashCode()];
        if(dz != undefined){

          // remove every binding with the removeBindingFromObject function
          for(var i = dz.length - 1;i >= 0;i--){

            this.removeBindingFromObject(dy, dz[i][0]);
          };
        };
      },
      /**
       * Returns an array which lists all bindings.
       *
       * @param object {qx.core.Object} The object of which the bindings should
       *   be returned.
       *
       * @return {Array} An array of binding informations. Every binding
       *   information is an array itself containing id, sourceObject,
       *   sourceEvent, targetObject and targetProperty in that order.
       */
      getAllBindingsForObject : function(dA){

        // create an empty array if no binding exists
        if(this.__bindings[dA.toHashCode()] === undefined){

          this.__bindings[dA.toHashCode()] = [];
        };
        return this.__bindings[dA.toHashCode()];
      },
      /**
       * Removes all binding in the whole application. After that not a single
       * binding is left.
       */
      removeAllBindings : function(){

        // go threw all registerd objects
        for(var dC in this.__bindings){

          var dB = qx.core.ObjectRegistry.fromHashCode(dC);
          // check for the object, perhaps its already deleted
          if(dB == null){

            delete this.__bindings[dC];
            continue;
          };
          this.removeAllBindingsForObject(dB);
        };
        // reset the bindings map
        this.__bindings = {
        };
      },
      /**
       * Returns a map containing for every bound object an array of data binding
       * information. The key of the map is the hashcode of the bound objects.
       * Every binding is represented by an array containing id, sourceObject,
       * sourceEvent, targetObject and targetProperty.
       *
       * @return {Map} Map containing all bindings.
       */
      getAllBindings : function(){

        return this.__bindings;
      },
      /**
       * Debug function which shows some valuable information about the given
       * binding in console. For that it uses {@link qx.log.Logger}.
       *
       * @param object {qx.core.Object} the source of the binding.
       * @param id {var} The id of the binding.
       */
      showBindingInLog : function(dD, dE){

        var dG;
        // go threw all bindings of the given object
        for(var i = 0;i < this.__bindings[dD.toHashCode()].length;i++){

          // the first array item is the id
          if(this.__bindings[dD.toHashCode()][i][0] == dE){

            dG = this.__bindings[dD.toHashCode()][i];
            break;
          };
        };
        if(dG === undefined){

          var dF = u;
        } else {

          var dF = T + dG[1] + z + dG[2] + h + dG[3] + z + dG[4] + t;
        };
        qx.log.Logger.debug(dF);
      },
      /**
       * Debug function which shows all bindings in the log console. To get only
       * one binding in the console use {@link #showBindingInLog}
       */
      showAllBindingsInLog : function(){

        // go threw all objects in the registry
        for(var dI in this.__bindings){

          var dH = qx.core.ObjectRegistry.fromHashCode(dI);
          for(var i = 0;i < this.__bindings[dI].length;i++){

            this.showBindingInLog(dH, this.__bindings[dI][i][0]);
          };
        };
      }
    }
  });
})();
(function(){

  var p = "]",o = '\\u',n = "undefined",m = '\\$1',l = "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",k = '-',j = "qx.lang.String",h = "(^|[^",g = "0",f = "%",c = ' ',e = '\n',d = "])[",b = "g",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Mootools
       http://mootools.net/
       Version 1.1.1
  
       Copyright:
         (c) 2007 Valerio Proietti
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
     and
  
     * XRegExp
     http://xregexp.com/
     Version 1.5
  
     Copyright:
         (c) 2006-2007, Steven Levithan <http://stevenlevithan.com>
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Steven Levithan
  
  ************************************************************************ */
  /**
   * String helper functions
   *
   * The native JavaScript String is not modified by this class. However,
   * there are modifications to the native String in {@link qx.lang.Core} for
   * browsers that do not support certain features.
   *
   * The string/array generics introduced in JavaScript 1.6 are supported by
   * {@link qx.lang.Generics}.
   */
  qx.Bootstrap.define(j, {
    statics : {
      /**
       * Unicode letters.  they are taken from Steve Levithan's excellent XRegExp library [http://xregexp.com/plugins/xregexp-unicode-base.js]
       */
      __unicodeLetters : l,
      /**
       * A RegExp that matches the first letter in a word - unicode aware
       */
      __unicodeFirstLetterInWordRegexp : null,
      /**
       * {Map} Cache for often used string operations [camelCasing and hyphenation]
       * e.g. marginTop => margin-top
       */
      __stringsMap : {
      },
      /**
       * Converts a hyphenated string (separated by '-') to camel case.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.camelCase("I-like-cookies"); //returns "ILikeCookies"</pre>
       * The implementation does not force a lowerCamelCase or upperCamelCase version.
       * (think java variables that start with lower case versus classnames that start with capital letter)
       * The first letter of the parameter keeps its case.
       *
       * @param str {String} hyphenated string
       * @return {String} camelcase string
       */
      camelCase : function(q){

        var r = this.__stringsMap[q];
        if(!r){

          r = q.replace(/\-([a-z])/g, function(s, t){

            return t.toUpperCase();
          });
          this.__stringsMap[q] = r;
        };
        return r;
      },
      /**
       * Converts a camelcased string to a hyphenated (separated by '-') string.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.hyphenate("ILikeCookies"); //returns "I-like-cookies"</pre>
       * The implementation does not force a lowerCamelCase or upperCamelCase version.
       * (think java variables that start with lower case versus classnames that start with capital letter)
       * The first letter of the parameter keeps its case.
       *
       * @param str {String} camelcased string
       * @return {String} hyphenated string
       */
      hyphenate : function(u){

        var v = this.__stringsMap[u];
        if(!v){

          v = u.replace(/[A-Z]/g, function(w){

            return (k + w.charAt(0).toLowerCase());
          });
          this.__stringsMap[u] = v;
        };
        return v;
      },
      /**
       * Converts a string to camel case.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.camelCase("i like cookies"); //returns "I Like Cookies"</pre>
       *
       * @param str {String} any string
       * @return {String} capitalized string
       */
      capitalize : function(x){

        if(this.__unicodeFirstLetterInWordRegexp === null){

          var y = o;
          this.__unicodeFirstLetterInWordRegexp = new RegExp(h + this.__unicodeLetters.replace(/[0-9A-F]{4}/g, function(z){

            return y + z;
          }) + d + this.__unicodeLetters.replace(/[0-9A-F]{4}/g, function(A){

            return y + A;
          }) + p, b);
        };
        return x.replace(this.__unicodeFirstLetterInWordRegexp, function(B){

          return B.toUpperCase();
        });
      },
      /**
       * Removes all extraneous whitespace from a string and trims it
       *
       * Example:
       *
       * <code>
       * qx.lang.String.clean(" i      like     cookies      \n\n");
       * </code>
       *
       * Returns "i like cookies"
       *
       * @param str {String} the string to clean up
       * @return {String} Cleaned up string
       */
      clean : function(C){

        return this.trim(C.replace(/\s+/g, c));
      },
      /**
       * removes white space from the left side of a string
       *
       * @param str {String} the string to trim
       * @return {String} the trimmed string
       */
      trimLeft : function(D){

        return D.replace(/^\s+/, a);
      },
      /**
       * removes white space from the right side of a string
       *
       * @param str {String} the string to trim
       * @return {String} the trimmed string
       */
      trimRight : function(E){

        return E.replace(/\s+$/, a);
      },
      /**
       * removes white space from the left and the right side of a string
       *
       * @param str {String} the string to trim
       * @return {String} the trimmed string
       */
      trim : function(F){

        return F.replace(/^\s+|\s+$/g, a);
      },
      /**
       * Check whether the string starts with the given substring
       *
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string starts with the given substring
       */
      startsWith : function(G, H){

        return G.indexOf(H) === 0;
      },
      /**
       * Check whether the string ends with the given substring
       *
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string ends with the given substring
       */
      endsWith : function(I, J){

        return I.substring(I.length - J.length, I.length) === J;
      },
      /**
       * Returns a string, which repeats a string 'length' times
       *
       * @param str {String} string used to repeat
       * @param times {Integer} the number of repetitions
       * @return {String} repeated string
       */
      repeat : function(K, L){

        return K.length > 0 ? new Array(L + 1).join(K) : a;
      },
      /**
       * Pad a string up to a given length. Padding characters are added to the left of the string.
       *
       * @param str {String} the string to pad
       * @param length {Integer} the final length of the string
       * @param ch {String} character used to fill up the string
       * @return {String} padded string
       */
      pad : function(M, length, N){

        var O = length - M.length;
        if(O > 0){

          if(typeof N === n){

            N = g;
          };
          return this.repeat(N, O) + M;
        } else {

          return M;
        };
      },
      /**
       * Convert the first character of the string to upper case.
       *
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp : qx.Bootstrap.firstUp,
      /**
       * Convert the first character of the string to lower case.
       *
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow : qx.Bootstrap.firstLow,
      /**
       * Check whether the string contains a given substring
       *
       * @param str {String} the string
       * @param substring {String} substring to search for
       * @return {Boolean} whether the string contains the substring
       */
      contains : function(P, Q){

        return P.indexOf(Q) != -1;
      },
      /**
       * Print a list of arguments using a format string
       * In the format string occurrences of %n are replaced by the n'th element of the args list.
       * Example:
       * <pre class='javascript'>qx.lang.String.format("Hello %1, my name is %2", ["Egon", "Franz"]) == "Hello Egon, my name is Franz"</pre>
       *
       * @param pattern {String} format string
       * @param args {Array} array of arguments to insert into the format string
       * @return {String} the formatted string
       */
      format : function(R, S){

        var T = R;
        var i = S.length;
        while(i--){

          // be sure to always use a string for replacement.
          T = T.replace(new RegExp(f + (i + 1), b), S[i] + a);
        };
        return T;
      },
      /**
       * Escapes all chars that have a special meaning in regular expressions
       *
       * @param str {String} the string where to escape the chars.
       * @return {String} the string with the escaped chars.
       */
      escapeRegexpChars : function(U){

        return U.replace(/([.*+?^${}()|[\]\/\\])/g, m);
      },
      /**
       * Converts a string to an array of characters.
       * <pre>"hello" => [ "h", "e", "l", "l", "o" ];</pre>
       *
       * @param str {String} the string which should be split
       * @return {Array} the result array of characters
       */
      toArray : function(V){

        return V.split(/\B|\b/g);
      },
      /**
       * Remove HTML/XML tags from a string
       * Example:
       * <pre class='javascript'>qx.lang.String.stripTags("&lt;h1>Hello&lt;/h1>") == "Hello"</pre>
       *
       * @param str {String} string containing tags
       * @return {String} the string with stripped tags
       */
      stripTags : function(W){

        return W.replace(/<\/?[^>]+>/gi, a);
      },
      /**
       * Strips <script> tags including its content from the given string.
       *
       * @param str {String} string containing tags
       * @param exec {Boolean?false} Whether the filtered code should be executed
       * @return {String} The filtered string
       */
      stripScripts : function(X, Y){

        var bb = a;
        var ba = X.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function(){

          bb += arguments[1] + e;
          return a;
        });
        if(Y === true){

          qx.lang.Function.globalEval(bb);
        };
        return ba;
      }
    }
  });
})();
(function(){

  var p = "[object Array]",o = "qx.lang.Array",n = "]",m = "qx",k = "number",j = "][",h = "string",g = "Cannot clean-up map entry doneObjects[",f = "The second parameter must be an array.",e = "mshtml",b = "engine.name",d = "The first parameter must be an array.",c = "Parameter must be an array.",a = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * jQuery
       http://jquery.com
       Version 1.3.1
  
       Copyright:
         2009 John Resig
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.data.IListData)
  #ignore(qx.Class)
  
  ************************************************************************ */
  /**
   * Static helper functions for arrays with a lot of often used convenience
   * methods like <code>remove</code> or <code>contains</code>.
   *
   * The native JavaScript Array is not modified by this class. However,
   * there are modifications to the native Array in {@link qx.lang.Core} for
   * browsers that do not support certain JavaScript 1.6 features natively .
   *
   * The string/array generics introduced in JavaScript 1.6 are supported by
   * {@link qx.lang.Generics}.
   */
  qx.Bootstrap.define(o, {
    statics : {
      /**
       * Converts array like constructions like the <code>argument</code> object,
       * node collections like the ones returned by <code>getElementsByTagName</code>
       * or extended array objects like <code>qx.type.BaseArray</code> to an
       * native Array instance.
       *
       * @param object {var} any array like object
       * @param offset {Integer?0} position to start from
       * @return {Array} New array with the content of the incoming object
       */
      toArray : function(q, r){

        return this.cast(q, Array, r);
      },
      /**
       * Converts an array like object to any other array like
       * object.
       *
       * Attention: The returned array may be same
       * instance as the incoming one if the constructor is identical!
       *
       * @param object {var} any array-like object
       * @param constructor {Function} constructor of the new instance
       * @param offset {Integer?0} position to start from
       * @return {Array} the converted array
       */
      cast : function(s, t, u){

        if(s.constructor === t){

          return s;
        };
        if(qx.data && qx.data.IListData){

          if(qx.Class && qx.Class.hasInterface(s, qx.data.IListData)){

            var s = s.toArray();
          };
        };
        // Create from given constructor
        var v = new t;
        // Some collections in mshtml are not able to be sliced.
        // These lines are a special workaround for this client.
        if((qx.core.Environment.get(b) == e)){

          if(s.item){

            for(var i = u || 0,l = s.length;i < l;i++){

              v.push(s[i]);
            };
            return v;
          };
        };
        // Copy over items
        if(Object.prototype.toString.call(s) === p && u == null){

          v.push.apply(v, s);
        } else {

          v.push.apply(v, Array.prototype.slice.call(s, u || 0));
        };
        return v;
      },
      /**
       * Convert an arguments object into an array.
       *
       * @param args {arguments} arguments object
       * @param offset {Integer?0} position to start from
       * @return {Array} a newly created array (copy) with the content of the arguments object.
       */
      fromArguments : function(w, x){

        return Array.prototype.slice.call(w, x || 0);
      },
      /**
       * Convert a (node) collection into an array
       *
       * @param coll {var} node collection
       * @return {Array} a newly created array (copy) with the content of the node collection.
       */
      fromCollection : function(y){

        // Some collection is mshtml are not able to be sliced.
        // This lines are a special workaround for this client.
        if((qx.core.Environment.get(b) == e)){

          if(y.item){

            var z = [];
            for(var i = 0,l = y.length;i < l;i++){

              z[i] = y[i];
            };
            return z;
          };
        };
        return Array.prototype.slice.call(y, 0);
      },
      /**
       * Expand shorthand definition to a four element list.
       * This is an utility function for padding/margin and all other shorthand handling.
       *
       * @param input {Array} arr with one to four elements
       * @return {Array} an arr with four elements
       */
      fromShortHand : function(A){

        var C = A.length;
        var B = qx.lang.Array.clone(A);
        // Copy Values (according to the length)
        switch(C){case 1:
        B[1] = B[2] = B[3] = B[0];
        break;case 2:
        B[2] = B[0];// no break here
        case 3:
        B[3] = B[1];};
        // Return list with 4 items
        return B;
      },
      /**
       * Return a copy of the given array
       *
       * @param arr {Array} the array to copy
       * @return {Array} copy of the array
       */
      clone : function(D){

        return D.concat();
      },
      /**
       * Insert an element at a given position into the array
       *
       * @param arr {Array} the array
       * @param obj {var} the element to insert
       * @param i {Integer} position where to insert the element into the array
       * @return {Array} the array
       */
      insertAt : function(E, F, i){

        E.splice(i, 0, F);
        return E;
      },
      /**
       * Insert an element into the array before a given second element.
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} the array
       */
      insertBefore : function(G, H, I){

        var i = G.indexOf(I);
        if(i == -1){

          G.push(H);
        } else {

          G.splice(i, 0, H);
        };
        return G;
      },
      /**
       * Insert an element into the array after a given second element.
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} the array
       */
      insertAfter : function(J, K, L){

        var i = J.indexOf(L);
        if(i == -1 || i == (J.length - 1)){

          J.push(K);
        } else {

          J.splice(i + 1, 0, K);
        };
        return J;
      },
      /**
       * Remove an element from the array at the given index
       *
       * @param arr {Array} the array
       * @param i {Integer} index of the element to be removed
       * @return {var} The removed element.
       */
      removeAt : function(M, i){

        return M.splice(i, 1)[0];
      },
      /**
       * Remove all elements from the array
       *
       * @param arr {Array} the array
       * @return {Array} empty array
       */
      removeAll : function(N){

        N.length = 0;
        return this;
      },
      /**
       * Append the elements of an array to the array
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be appended to other one
       * @return {Array} The modified array.
       * @throws an exception if one of the arguments is not an array
       */
      append : function(O, P){

        // this check is important because opera throws an uncatchable error if apply is called without
        // an arr as second argument.
        if(qx.core.Environment.get(a)){

          qx.core.Assert && qx.core.Assert.assertArray(O, d);
          qx.core.Assert && qx.core.Assert.assertArray(P, f);
        };
        Array.prototype.push.apply(O, P);
        return O;
      },
      /**
       * Modifies the first array as it removes all elements
       * which are listed in the second array as well.
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be excluded from the other one
       * @return {Array} The modified array.
       * @throws an exception if one of the arguments is not an array
       */
      exclude : function(Q, R){

        // this check is important because opera throws an uncatchable error if apply is called without
        // an arr as second argument.
        if(qx.core.Environment.get(a)){

          qx.core.Assert && qx.core.Assert.assertArray(Q, d);
          qx.core.Assert && qx.core.Assert.assertArray(R, f);
        };
        for(var i = 0,T = R.length,S;i < T;i++){

          S = Q.indexOf(R[i]);
          if(S != -1){

            Q.splice(S, 1);
          };
        };
        return Q;
      },
      /**
       * Remove an element from the array.
       *
       * @param arr {Array} the array
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove : function(U, V){

        var i = U.indexOf(V);
        if(i != -1){

          U.splice(i, 1);
          return V;
        };
      },
      /**
       * Whether the array contains the given element
       *
       * @param arr {Array} the array
       * @param obj {var} object to look for
       * @return {Boolean} whether the arr contains the element
       */
      contains : function(W, X){

        return W.indexOf(X) !== -1;
      },
      /**
       * Check whether the two arrays have the same content. Checks only the
       * equality of the arrays' content.
       *
       * @param arr1 {Array} first array
       * @param arr2 {Array} second array
       * @return {Boolean} Whether the two arrays are equal
       */
      equals : function(Y, ba){

        var length = Y.length;
        if(length !== ba.length){

          return false;
        };
        for(var i = 0;i < length;i++){

          if(Y[i] !== ba[i]){

            return false;
          };
        };
        return true;
      },
      /**
       * Returns the sum of all values in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number} The sum of all values.
       */
      sum : function(bb){

        var bc = 0;
        for(var i = 0,l = bb.length;i < l;i++){

          bc += bb[i];
        };
        return bc;
      },
      /**
       * Returns the highest value in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number | null} The highest of all values or undefined if array is empty.
       */
      max : function(bd){

        if(qx.core.Environment.get(a)){

          qx.core.Assert && qx.core.Assert.assertArray(bd, c);
        };
        var i,bf = bd.length,be = bd[0];
        for(i = 1;i < bf;i++){

          if(bd[i] > be){

            be = bd[i];
          };
        };
        return be === undefined ? null : be;
      },
      /**
       * Returns the lowest value in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number | null} The lowest of all values or undefined if array is empty.
       */
      min : function(bg){

        if(qx.core.Environment.get(a)){

          qx.core.Assert && qx.core.Assert.assertArray(bg, c);
        };
        var i,bi = bg.length,bh = bg[0];
        for(i = 1;i < bi;i++){

          if(bg[i] < bh){

            bh = bg[i];
          };
        };
        return bh === undefined ? null : bh;
      },
      /**
       * Recreates an array which is free of all duplicate elements from the original.
       *
       * This method do not modifies the original array!
       *
       * Keep in mind that this methods deletes undefined indexes.
       *
       * @param arr {Array} Incoming array
       * @return {Array} Returns a copy with no duplicates or the original array if no duplicates were found
       */
      unique : function(bj){

        var bt = [],bl = {
        },bo = {
        },bq = {
        };
        var bp,bk = 0;
        var bu = m + qx.lang.Date.now();
        var bm = false,bs = false,bv = false;
        // Rebuild array and omit duplicates
        for(var i = 0,br = bj.length;i < br;i++){

          bp = bj[i];
          // Differ between null, primitives and reference types
          if(bp === null){

            if(!bm){

              bm = true;
              bt.push(bp);
            };
          } else if(bp === undefined){
          } else if(bp === false){

            if(!bs){

              bs = true;
              bt.push(bp);
            };
          } else if(bp === true){

            if(!bv){

              bv = true;
              bt.push(bp);
            };
          } else if(typeof bp === h){

            if(!bl[bp]){

              bl[bp] = 1;
              bt.push(bp);
            };
          } else if(typeof bp === k){

            if(!bo[bp]){

              bo[bp] = 1;
              bt.push(bp);
            };
          } else {

            var bn = bp[bu];
            if(bn == null){

              bn = bp[bu] = bk++;
            };
            if(!bq[bn]){

              bq[bn] = bp;
              bt.push(bp);
            };
          };;;;;
        };
        // Clear object hashs
        for(var bn in bq){

          try{

            // TODO: The following delete seems to fail in IE7
            delete bq[bn][bu];
          } catch(bw) {

            try{

              bq[bn][bu] = null;
            } catch(bx) {

              throw new Error(g + bn + j + bu + n);
            };
          };
        };
        return bt;
      }
    }
  });
})();
(function(){

  var j = "[object Opera]",i = "[^\\.0-9]",h = "4.0",g = "1.9.0.0",f = "Version/",e = "9.0",d = "8.0",c = "Gecko",b = "AppleWebKit/",a = "opera",w = "engine.version",v = "mshtml",u = "engine.name",t = "webkit",s = "5.0",r = "qx.bom.client.Engine",q = "function",p = "gecko",o = "Maple",n = "Unsupported client: ",l = "",m = "! Assumed gecko version 1.9.0.0 (Firefox 3.0).",k = ".";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Martin Wittemann (martinwittemann)
  
     ======================================================================
  
     This class contains code from:
  
       Copyright:
         2011 Pocket Widget S.L., Spain, http://www.pocketwidget.com
  
       License:
         LGPL: http://www.gnu.org/licenses/lgpl.html
         EPL: http://www.eclipse.org/org/documents/epl-v10.php
  
       Authors:
         * Javier Martinez Villacampa
  
  ************************************************************************ */
  /**
   * This class comes with all relevant information regarding
   * the client's engine.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(r, {
    // General: http://en.wikipedia.org/wiki/Browser_timeline
    // Webkit: http://developer.apple.com/internet/safari/uamatrix.html
    // Firefox: http://en.wikipedia.org/wiki/History_of_Mozilla_Firefox
    // Maple: http://www.scribd.com/doc/46675822/2011-SDK2-0-Maple-Browser-Specification-V1-00
    statics : {
      /**
       * Returns the version of the engine.
       *
       * @return {String} The version number of the current engine.
       * @internal
       */
      getVersion : function(){

        var A = window.navigator.userAgent;
        var y = l;
        if(qx.bom.client.Engine.__isOpera()){

          // Opera has a special versioning scheme, where the second part is combined
          // e.g. 8.54 which should be handled like 8.5.4 to be compatible to the
          // common versioning system used by other browsers
          if(/Opera[\s\/]([0-9]+)\.([0-9])([0-9]*)/.test(A)){

            // opera >= 10 has as a first verison 9.80 and adds the proper version
            // in a separate "Version/" postfix
            // http://my.opera.com/chooseopera/blog/2009/05/29/changes-in-operas-user-agent-string-format
            if(A.indexOf(f) != -1){

              var z = A.match(/Version\/(\d+)\.(\d+)/);
              // ignore the first match, its the whole version string
              y = z[1] + k + z[2].charAt(0) + k + z[2].substring(1, z[2].length);
            } else {

              y = RegExp.$1 + k + RegExp.$2;
              if(RegExp.$3 != l){

                y += k + RegExp.$3;
              };
            };
          };
        } else if(qx.bom.client.Engine.__isWebkit()){

          if(/AppleWebKit\/([^ ]+)/.test(A)){

            y = RegExp.$1;
            // We need to filter these invalid characters
            var B = RegExp(i).exec(y);
            if(B){

              y = y.slice(0, B.index);
            };
          };
        } else if(qx.bom.client.Engine.__isGecko() || qx.bom.client.Engine.__isMaple()){

          // Parse "rv" section in user agent string
          if(/rv\:([^\);]+)(\)|;)/.test(A)){

            y = RegExp.$1;
          };
        } else if(qx.bom.client.Engine.__isMshtml()){

          if(/MSIE\s+([^\);]+)(\)|;)/.test(A)){

            y = RegExp.$1;
            // If the IE8 or IE9 is running in the compatibility mode, the MSIE value
            // is set to an older version, but we need the correct version. The only
            // way is to compare the trident version.
            if(y < 8 && /Trident\/([^\);]+)(\)|;)/.test(A)){

              if(RegExp.$1 == h){

                y = d;
              } else if(RegExp.$1 == s){

                y = e;
              };
            };
          };
        } else {

          var x = window.qxFail;
          if(x && typeof x === q){

            y = x().FULLVERSION;
          } else {

            y = g;
            qx.Bootstrap.warn(n + A + m);
          };
        };;;
        return y;
      },
      /**
       * Returns the name of the engine.
       *
       * @return {String} The name of the current engine.
       * @internal
       */
      getName : function(){

        var name;
        if(qx.bom.client.Engine.__isOpera()){

          name = a;
        } else if(qx.bom.client.Engine.__isWebkit()){

          name = t;
        } else if(qx.bom.client.Engine.__isGecko() || qx.bom.client.Engine.__isMaple()){

          name = p;
        } else if(qx.bom.client.Engine.__isMshtml()){

          name = v;
        } else {

          // check for the fallback
          var C = window.qxFail;
          if(C && typeof C === q){

            name = C().NAME;
          } else {

            name = p;
            qx.Bootstrap.warn(n + window.navigator.userAgent + m);
          };
        };;;
        return name;
      },
      /**
       * Internal helper for checking for opera.
       * @return {boolean} true, if its opera.
       */
      __isOpera : function(){

        return window.opera && Object.prototype.toString.call(window.opera) == j;
      },
      /**
       * Internal helper for checking for webkit.
       * @return {boolean} true, if its webkit.
       */
      __isWebkit : function(){

        return window.navigator.userAgent.indexOf(b) != -1;
      },
      /**
       * Internal helper for checking for Maple .
       * Maple is used in Samsung SMART TV 2010-2011 models. It's based on Gecko
       * engine 1.8.1.11.
       * @return {boolean} true, if its maple.
       */
      __isMaple : function(){

        return window.navigator.userAgent.indexOf(o) != -1;
      },
      /**
       * Internal helper for checking for gecko.
       * @return {boolean} true, if its gecko.
       */
      __isGecko : function(){

        return window.controllers && window.navigator.product === c && window.navigator.userAgent.indexOf(o) == -1;
      },
      /**
       * Internal helper to check for MSHTML.
       * @return {boolean} true, if its MSHTML.
       */
      __isMshtml : function(){

        return window.navigator.cpuClass && /MSIE\s+([^\);]+)(\)|;)/.test(window.navigator.userAgent);
      }
    },
    defer : function(D){

      qx.core.Environment.add(w, D.getVersion);
      qx.core.Environment.add(u, D.getName);
    }
  });
})();
(function(){

  var f = "qx.lang.Type",e = "Error",d = "RegExp",c = "Date",b = "Number",a = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Utility class with type check for all native JavaScript data types.
   */
  qx.Bootstrap.define(f, {
    statics : {
      /**
       * Get the internal class of the value. See
       * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
       * for details.
       *
       * @signature function(value)
       * @param value {var} value to get the class for
       * @return {String} the internal class of the value
       */
      getClass : qx.Bootstrap.getClass,
      /**
       * Whether the value is a string.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a string.
       */
      isString : qx.Bootstrap.isString,
      /**
       * Whether the value is an array.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an array.
       */
      isArray : qx.Bootstrap.isArray,
      /**
       * Whether the value is an object. Note that built-in types like Window are
       * not reported to be objects.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an object.
       */
      isObject : qx.Bootstrap.isObject,
      /**
       * Whether the value is a function.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function.
       */
      isFunction : qx.Bootstrap.isFunction,
      /**
      * Whether the value is a regular expression.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a regular expression.
      */
      isRegExp : function(g){

        return this.getClass(g) == d;
      },
      /**
      * Whether the value is a number.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a number.
      */
      isNumber : function(h){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Number" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (h !== null && (this.getClass(h) == b || h instanceof Number));
      },
      /**
      * Whether the value is a boolean.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a boolean.
      */
      isBoolean : function(i){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Boolean" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (i !== null && (this.getClass(i) == a || i instanceof Boolean));
      },
      /**
       * Whether the value is a date.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a date.
       */
      isDate : function(j){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Date" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (j !== null && (this.getClass(j) == c || j instanceof Date));
      },
      /**
       * Whether the value is a Error.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a Error.
       */
      isError : function(k){

        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Error" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return (k !== null && (this.getClass(k) == e || k instanceof Error));
      }
    }
  });
})();
(function(){

  var p = " != ",o = "qx.core.Object",n = "Expected value to be an array but found ",m = ") was fired.",k = "Expected value to be an integer >= 0 but found ",j = "' to be not equal with '",h = "' to '",g = "Expected object '",f = "Called assertTrue with '",d = "Expected value to be a map but found ",bC = "The function did not raise an exception!",bB = "Expected value to be undefined but found ",bA = "Expected value to be a DOM element but found  '",bz = "Expected value to be a regular expression but found ",by = "' to implement the interface '",bx = "Expected value to be null but found ",bw = "Invalid argument 'type'",bv = "Called assert with 'false'",bu = "Assertion error! ",bt = "null",w = "' but found '",x = "'undefined'",u = "' must must be a key of the map '",v = "The String '",s = "Expected value to be a string but found ",t = "Expected value not to be undefined but found undefined!",q = "qx.util.ColorUtil",r = ": ",E = "The raised exception does not have the expected type! ",F = ") not fired.",U = "qx.core.Assert",Q = "Expected value to be typeof object but found ",bd = "' (identical) but found '",X = "' must have any of the values defined in the array '",bp = "Expected value to be a number but found ",bj = "Called assertFalse with '",L = "qx.ui.core.Widget",bs = "Expected value to be a qooxdoo object but found ",br = "' arguments.",bq = "Expected value '%1' to be in the range '%2'..'%3'!",J = "Array[",N = "' does not match the regular expression '",P = "' to be not identical with '",S = "Expected [",V = "' arguments but found '",Y = "', which cannot be converted to a CSS color!",bf = "qx.core.AssertionError",bl = "Expected value to be a boolean but found ",y = "Expected value not to be null but found null!",z = "))!",M = "Expected value to be a qooxdoo widget but found ",bc = "Expected value to be typeof '",bb = "\n Stack trace: \n",ba = "Expected value to be typeof function but found ",bh = "Expected value to be an integer but found ",bg = "Called fail().",W = "The parameter 're' must be a string or a regular expression.",be = "qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'",a = "Expected value to be a number >= 0 but found ",bk = "Expected value to be instanceof '",A = "], but found [",B = "Wrong number of arguments given. Expected '",R = "object",b = "Event (",c = "Expected value to be the CSS color '",I = "' but found ",C = "]",D = ", ",H = "The value '",T = ")), but found value '",bn = "' (rgb(",bm = ",",O = "'",bo = "Expected '",K = "'!",bi = "!",G = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.lang.Type)
  
  ************************************************************************ */
  /**
   * A collection of assertions.
   *
   * These methods can be used to assert incoming parameters, return values, ...
   * If an assertion fails an {@link AssertionError} is thrown.
   *
   * Assertions are used in unit tests as well.
   */
  qx.Class.define(U, {
    statics : {
      __logError : true,
      /**
       * Assert that the condition evaluates to <code>true</code>. An
       * {@link AssertionError} is thrown if otherwise.
       *
       * @param comment {String} Message to be shown if the assertion fails. This
       *    message is provided by the user.
       * @param msgvarargs {var} any number of parts of a message to show if assertion
       *                         triggers. Each will be converted to a string and all
       *                         parts will be concatenated. E. g. instead of
       *                         "Got invalid value " + this.__toString(val) + "!!!!!"
       *                         use
       *                         "Got invalid value ", val, "!!!!!"
       *                         (much better performance)
       *
       */
      __fail : function(bD, bE){

        // Build up message from message varargs. It's not really important
        // how long this takes as it is done only when assertion is triggered
        var bI = G;
        for(var i = 1,l = arguments.length;i < l;i++){

          bI = bI + this.__toString(arguments[i] === undefined ? x : arguments[i]);
        };
        var bH = G;
        if(bI){

          bH = bD + r + bI;
        } else {

          bH = bD;
        };
        var bG = bu + bH;
        if(qx.Class.isDefined(bf)){

          var bF = new qx.core.AssertionError(bD, bI);
          if(this.__logError){

            qx.Bootstrap.error(bG + bb + bF.getStackTrace());
          };
          throw bF;
        } else {

          if(this.__logError){

            qx.Bootstrap.error(bG);
          };
          throw new Error(bG);
        };
      },
      /**
       * Convert an unknown value to a string to display in error messages
       *
       * @param value {var} any value
       * @return {String} a string representation of the value
       */
      __toString : function(bJ){

        var bK;
        if(bJ === null){

          bK = bt;
        } else if(qx.lang.Type.isArray(bJ) && bJ.length > 10){

          bK = J + bJ.length + C;
        } else if((bJ instanceof Object) && (bJ.toString == null)){

          bK = qx.lang.Json.stringify(bJ, null, 2);
        } else {

          try{

            bK = bJ.toString();
          } catch(e) {

            bK = G;
          };
        };;
        return bK;
      },
      /**
       * Assert that the condition evaluates to <code>true</code>.
       *
       * @param condition {var} Condition to check for. Must evaluate to
       *    <code>true</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assert : function(bL, bM){

        bL == true || this.__fail(bM || G, bv);
      },
      /**
       * Raise an {@link AssertionError}.
       *
       * @param msg {String} Message to be shown if the assertion fails.
       * @param compact {Boolean} Show less verbose message. Default: false.
       */
      fail : function(bN, bO){

        var bP = bO ? G : bg;
        this.__fail(bN || G, bP);
      },
      /**
       * Assert that the value is <code>true</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>true</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertTrue : function(bQ, bR){

        (bQ === true) || this.__fail(bR || G, f, bQ, O);
      },
      /**
       * Assert that the value is <code>false</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>false</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertFalse : function(bS, bT){

        (bS === false) || this.__fail(bT || G, bj, bS, O);
      },
      /**
       * Assert that both values are equal. (Uses the equality operator
       * <code>==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertEquals : function(bU, bV, bW){

        bU == bV || this.__fail(bW || G, bo, bU, w, bV, K);
      },
      /**
       * Assert that both values are not equal. (Uses the not equality operator
       * <code>!=</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotEquals : function(bX, bY, ca){

        bX != bY || this.__fail(ca || G, bo, bX, j, bY, K);
      },
      /**
       * Assert that both values are identical. (Uses the identity operator
       * <code>===</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertIdentical : function(cb, cc, cd){

        cb === cc || this.__fail(cd || G, bo, cb, bd, cc, K);
      },
      /**
       * Assert that both values are not identical. (Uses the not identity operator
       * <code>!==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotIdentical : function(ce, cf, cg){

        ce !== cf || this.__fail(cg || G, bo, ce, P, cf, K);
      },
      /**
       * Assert that the value is not <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotUndefined : function(ch, ci){

        ch !== undefined || this.__fail(ci || G, t);
      },
      /**
       * Assert that the value is <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertUndefined : function(cj, ck){

        cj === undefined || this.__fail(ck || G, bB, cj, bi);
      },
      /**
       * Assert that the value is not <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotNull : function(cl, cm){

        cl !== null || this.__fail(cm || G, y);
      },
      /**
       * Assert that the value is <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNull : function(cn, co){

        cn === null || this.__fail(co || G, bx, cn, bi);
      },
      /**
       * Assert that the first two arguments are equal, when serialized into
       * JSON.
       *
       * @param expected {var} The the expected value
       * @param found {var} The found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertJsonEquals : function(cp, cq, cr){

        this.assertEquals(qx.lang.Json.stringify(cp), qx.lang.Json.stringify(cq), cr);
      },
      /**
       * Assert that the given string matches the regular expression
       *
       * @param str {String} String, which should match the regular expression
       * @param re {String|RegExp} Regular expression to match
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertMatch : function(cs, ct, cu){

        this.assertString(cs);
        this.assert(qx.lang.Type.isRegExp(ct) || qx.lang.Type.isString(ct), W);
        cs.search(ct) >= 0 || this.__fail(cu || G, v, cs, N, ct.toString(), K);
      },
      /**
       * Assert that the number of arguments is within the given range
       *
       * @param args {arguments} The <code>arguments<code> variable of a function
       * @param minCount {Integer} Minimal number of arguments
       * @param maxCount {Integer} Maximum number of arguments
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArgumentsCount : function(cv, cw, cx, cy){

        var cz = cv.length;
        (cz >= cw && cz <= cx) || this.__fail(cy || G, B, cw, h, cx, V, cz, br);
      },
      /**
       * Assert that an event is fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   fires the event.
       * @param listenerFunc {Function?null} The function which will be invoked in the
       *   listener. The function receives one parameter which is the event.
       * @param msg {String?""} Message to be shows if the assertion fails.
       */
      assertEventFired : function(cA, event, cB, cC, cD){

        var cF = false;
        var cE = function(e){

          if(cC){

            cC.call(cA, e);
          };
          cF = true;
        };
        var cG;
        try{

          cG = cA.addListener(event, cE, cA);
          cB.call(cA);
        } catch(cH) {

          throw cH;
        }finally{

          try{

            cA.removeListenerById(cG);
          } catch(cI) {
          };
        };
        cF === true || this.__fail(cD || G, b, event, F);
      },
      /**
       * Assert that an event is not fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   should not fire the event.
       * @param msg {String} Message to be shows if the assertion fails.
       */
      assertEventNotFired : function(cJ, event, cK, cL){

        var cN = false;
        var cM = function(e){

          cN = true;
        };
        var cO = cJ.addListener(event, cM, cJ);
        cK.call();
        cN === false || this.__fail(cL || G, b, event, m);
        cJ.removeListenerById(cO);
      },
      /**
       * Asserts that the callback raises a matching exception.
       *
       * @param callback {Function} function to check
       * @param exception {Error?Error} Expected constructor of the exception.
       *   The assertion fails if the raised exception is not an instance of the
       *   parameter.
       * @param re {String|RegExp} The assertion fails if the error message does
       *   not match this parameter
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertException : function(cP, cQ, cR, cS){

        var cQ = cQ || Error;
        var cT;
        try{

          this.__logError = false;
          cP();
        } catch(cU) {

          cT = cU;
        }finally{

          this.__logError = true;
        };
        if(cT == null){

          this.__fail(cS || G, bC);
        };
        cT instanceof cQ || this.__fail(cS || G, E, cQ, p, cT);
        if(cR){

          this.assertMatch(cT.toString(), cR, cS);
        };
      },
      /**
       * Assert that the value is an item in the given array.
       *
       * @param value {var} Value to check
       * @param array {Array} List of valid values
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInArray : function(cV, cW, cX){

        cW.indexOf(cV) !== -1 || this.__fail(cX || G, H, cV, X, cW, O);
      },
      /**
       * Assert that both array have identical array items.
       *
       * @param expected {Array} The expected array
       * @param found {Array} The found array
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArrayEquals : function(cY, da, db){

        this.assertArray(cY, db);
        this.assertArray(da, db);
        db = db || S + cY.join(D) + A + da.join(D) + C;
        if(cY.length !== da.length){

          this.fail(db, true);
        };
        for(var i = 0;i < cY.length;i++){

          if(cY[i] !== da[i]){

            this.fail(db, true);
          };
        };
      },
      /**
       * Assert that the value is a key in the given map.
       *
       * @param value {var} Value to check
       * @param map {map} Map, where the keys represent the valid values
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertKeyInMap : function(dc, dd, de){

        dd[dc] !== undefined || this.__fail(de || G, H, dc, u, dd, O);
      },
      /**
       * Assert that the value is a function.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertFunction : function(df, dg){

        qx.lang.Type.isFunction(df) || this.__fail(dg || G, ba, df, bi);
      },
      /**
       * Assert that the value is a string.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertString : function(dh, di){

        qx.lang.Type.isString(dh) || this.__fail(di || G, s, dh, bi);
      },
      /**
       * Assert that the value is a boolean.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertBoolean : function(dj, dk){

        qx.lang.Type.isBoolean(dj) || this.__fail(dk || G, bl, dj, bi);
      },
      /**
       * Assert that the value is a number.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNumber : function(dl, dm){

        (qx.lang.Type.isNumber(dl) && isFinite(dl)) || this.__fail(dm || G, bp, dl, bi);
      },
      /**
       * Assert that the value is a number >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertPositiveNumber : function(dn, dp){

        (qx.lang.Type.isNumber(dn) && isFinite(dn) && dn >= 0) || this.__fail(dp || G, a, dn, bi);
      },
      /**
       * Assert that the value is an integer.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInteger : function(dq, dr){

        (qx.lang.Type.isNumber(dq) && isFinite(dq) && dq % 1 === 0) || this.__fail(dr || G, bh, dq, bi);
      },
      /**
       * Assert that the value is an integer >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertPositiveInteger : function(ds, dt){

        var du = (qx.lang.Type.isNumber(ds) && isFinite(ds) && ds % 1 === 0 && ds >= 0);
        du || this.__fail(dt || G, k, ds, bi);
      },
      /**
       * Assert that the value is inside the given range.
       *
       * @param value {var} Value to check
       * @param min {Number} lower bound
       * @param max {Number} upper bound
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInRange : function(dv, dw, dx, dy){

        (dv >= dw && dv <= dx) || this.__fail(dy || G, qx.lang.String.format(bq, [dv, dw, dx]));
      },
      /**
       * Assert that the value is an object.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertObject : function(dz, dA){

        var dB = dz !== null && (qx.lang.Type.isObject(dz) || typeof dz === R);
        dB || this.__fail(dA || G, Q, (dz), bi);
      },
      /**
       * Assert that the value is an array.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArray : function(dC, dD){

        qx.lang.Type.isArray(dC) || this.__fail(dD || G, n, dC, bi);
      },
      /**
       * Assert that the value is a map either created using <code>new Object</code>
       * or by using the object literal notation <code>{ ... }</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertMap : function(dE, dF){

        qx.lang.Type.isObject(dE) || this.__fail(dF || G, d, dE, bi);
      },
      /**
      * Assert that the value is a regular expression.
      *
      * @param value {var} Value to check
      * @param msg {String} Message to be shown if the assertion fails.
      */
      assertRegExp : function(dG, dH){

        qx.lang.Type.isRegExp(dG) || this.__fail(dH || G, bz, dG, bi);
      },
      /**
       * Assert that the value has the given type using the <code>typeof</code>
       * operator. Because the type is not always what it is supposed to be it is
       * better to use more explicit checks like {@link #assertString} or
       * {@link #assertArray}.
       *
       * @param value {var} Value to check
       * @param type {String} expected type of the value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertType : function(dI, dJ, dK){

        this.assertString(dJ, bw);
        typeof (dI) === dJ || this.__fail(dK || G, bc, dJ, I, dI, bi);
      },
      /**
       * Assert that the value is an instance of the given class.
       *
       * @param value {var} Value to check
       * @param clazz {Class} The value must be an instance of this class
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInstance : function(dL, dM, dN){

        var dO = dM.classname || dM + G;
        dL instanceof dM || this.__fail(dN || G, bk, dO, I, dL, bi);
      },
      /**
       * Assert that the value implements the given interface.
       *
       * @param value {var} Value to check
       * @param iface {Class} The value must implement this interface
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInterface : function(dP, dQ, dR){

        qx.Class.implementsInterface(dP, dQ) || this.__fail(dR || G, g, dP, by, dQ, K);
      },
      /**
       * Assert that the value represents the given CSS color value. This method
       * parses the color strings and compares the RGB values. It is able to
       * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.
       *
       *  @param expected {String} The expected color
       *  @param value {String} The value to check
       *  @param msg {String} Message to be shown if the assertion fails.
       */
      assertCssColor : function(dS, dT, dU){

        var dV = qx.Class.getByName(q);
        if(!dV){

          throw new Error(be);
        };
        var dX = dV.stringToRgb(dS);
        try{

          var dW = dV.stringToRgb(dT);
        } catch(ea) {

          this.__fail(dU || G, c, dS, bn, dX.join(bm), T, dT, Y);
        };
        var dY = dX[0] == dW[0] && dX[1] == dW[1] && dX[2] == dW[2];
        dY || this.__fail(dU || G, c, dX, bn, dX.join(bm), T, dT, bn, dW.join(bm), z);
      },
      /**
       * Assert that the value is a DOM element.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertElement : function(eb, ec){

        // see qx.dom.Node.isElement
        !!(eb && eb.nodeType === 1) || this.__fail(ec || G, bA, eb, K);
      },
      /**
       * Assert that the value is an instance of {@link qx.core.Object}.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertQxObject : function(ed, ee){

        this.__isQxInstance(ed, o) || this.__fail(ee || G, bs, ed, bi);
      },
      /**
       * Assert that the value is an instance of {@link qx.ui.core.Widget}.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertQxWidget : function(ef, eg){

        this.__isQxInstance(ef, L) || this.__fail(eg || G, M, ef, bi);
      },
      /**
       * Internal helper for checking the instance of a qooxdoo object using the
       * classname.
       *
       * @param object {var} The object to check.
       * @param classname {String} The classname of the class as string.
       */
      __isQxInstance : function(eh, ei){

        if(!eh){

          return false;
        };
        var ej = eh.constructor;
        while(ej){

          if(ej.classname === ei){

            return true;
          };
          ej = ej.superclass;
        };
        return false;
      }
    }
  });
})();
(function(){

  var c = ": ",b = "qx.type.BaseError",a = "";
  /* ************************************************************************
  
    qooxdoo - the new era of web development
  
    http://qooxdoo.org
  
    Copyright:
      2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
    License:
      LGPL: http://www.gnu.org/licenses/lgpl.html
      EPL: http://www.eclipse.org/org/documents/epl-v10.php
      See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Fabian Jakobs (fjakobs)
      * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class is the common super class for all error classes in qooxdoo.
   *
   * It has a comment and a fail message as members. The toString method returns
   * the comment and the fail message separated by a colon.
   */
  qx.Class.define(b, {
    extend : Error,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param comment {String} Comment passed to the assertion call
     * @param failMessage {String} Fail message provided by the assertion
     */
    construct : function(d, e){

      var f = Error.call(this, e);
      // map stack trace properties since they're not added by Error's constructor
      if(f.stack){

        this.stack = f.stack;
      };
      if(f.stacktrace){

        this.stacktrace = f.stacktrace;
      };
      this.__comment = d || a;
      // opera 10 crashes if the message is an empty string!!!?!?!
      this.message = e || qx.type.BaseError.DEFAULTMESSAGE;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      DEFAULTMESSAGE : "error"
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __sTrace : null,
      __comment : null,
      /** {String} Fail message provided by the assertion */
      message : null,
      /**
       * Comment passed to the assertion call
       *
       * @return {String} The comment passed to the assertion call
       */
      getComment : function(){

        return this.__comment;
      },
      /**
       * Get the error message
       *
       * @return {String} The error message
       */
      toString : function(){

        return this.__comment + (this.message ? c + this.message : a);
      }
    }
  });
})();
(function(){

  var a = "qx.core.AssertionError";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Assertion errors are thrown if an assertion in {@link qx.core.Assert}
   * fails.
   */
  qx.Class.define(a, {
    extend : qx.type.BaseError,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param comment {String} Comment passed to the assertion call
     * @param failMessage {String} Fail message provided by the assertion
     */
    construct : function(b, c){

      qx.type.BaseError.call(this, b, c);
      this.__trace = qx.dev.StackTrace.getStackTrace();
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __trace : null,
      /**
       * Stack trace of the error
       *
       * @return {String[]} The stack trace of the location the exception was thrown
       */
      getStackTrace : function(){

        return this.__trace;
      }
    }
  });
})();
(function(){

  var t = "?",s = "anonymous",r = "...",q = "qx.dev.StackTrace",p = "",o = "\n",n = "/source/class/",m = "FILENAME_TO_CLASSNAME must return a string!",l = "stack",k = "FORMAT_STACKTRACE must return an array of strings!",d = "prototype",j = "stacktrace",g = "qx.debug",c = "Error created at",b = "Backtrace:",f = "function",e = "ecmascript.stacktrace",h = ".",a = ":";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Methods to get information about the JavaScript call stack.
   */
  qx.Bootstrap.define(q, {
    statics : {
      /**
       * Optional user-defined function to convert source file names into readable
       * class names. Will be called with the source file name extracted from the
       * browser's stack trace information as the only argument. The returned
       * string is used in the output of {@link #getStackTraceFromError}
       */
      FILENAME_TO_CLASSNAME : null,
      /**
       * Optional user-defined formatting function for stack trace information.
       * Will be called by with an array of strings representing the calls in the
       * stack trace. {@link #getStackTraceFromError} will return the output of
       * this function. Must return an array of strings.
       */
      FORMAT_STACKTRACE : null,
      /**
       * Get a stack trace of the current position in the code.
       *
       * Browser compatibility:
       * <ul>
       *   <li>In new versions of Gecko, WebKit and Opera, the output of
       *   {@link #getStackTraceFromError} and {@link #getStackTraceFromCaller} is
       *   combined to generate the richest trace, including line numbers.</li>
       *   <li>For Internet Explorer (and other engines that do not provide stack
       *    traces), {@link #getStackTraceFromCaller} is used</li>
       * </ul>
       *
       * @return {String[]} Stack trace of the current position in the code. Each line in the array
       *     represents one call in the stack trace.
       */
      getStackTrace : function(){

        var y = [];
        try{

          throw new Error();
        } catch(J) {

          if(qx.core.Environment.get(e)){

            var D = qx.dev.StackTrace.getStackTraceFromError(J);
            var B = qx.dev.StackTrace.getStackTraceFromCaller(arguments);
            qx.lang.Array.removeAt(D, 0);
            y = B.length > D.length ? B : D;
            for(var i = 0;i < Math.min(B.length, D.length);i++){

              var z = B[i];
              if(z.indexOf(s) >= 0){

                continue;
              };
              var x = null;
              var H = z.split(h);
              var A = /(.*?)\(/.exec(H[H.length - 1]);
              if(A && A.length == 2){

                x = A[1];
                H.pop();
              };
              if(H[H.length - 1] == d){

                H.pop();
              };
              var F = H.join(h);
              var w = D[i];
              var I = w.split(a);
              var E = I[0];
              var u = I[1];
              var v;
              if(I[2]){

                v = I[2];
              };
              var C = null;
              if(qx.Class.getByName(E)){

                C = E;
              } else {

                C = F;
              };
              var G = C;
              if(x){

                G += h + x;
              };
              G += a + u;
              if(v){

                G += a + v;
              };
              y[i] = G;
            };
          } else {

            y = this.getStackTraceFromCaller(arguments);
          };
        };
        return y;
      },
      /**
       * Get a stack trace from the arguments special variable using the
       * <code>caller</code> property.
       *
       * This methods returns class/mixin and function names of each step
       * in the call stack.
       *
       * Recursion is not supported.
       *
       * @param args {arguments} arguments variable.
       * @return {String[]} Stack trace of caller of the function the arguments variable belongs to.
       *     Each line in the array represents one call in the stack trace.
       * @signature function(args)
       */
      getStackTraceFromCaller : function(K){

        var P = [];
        var O = qx.lang.Function.getCaller(K);
        var L = {
        };
        while(O){

          var M = qx.lang.Function.getName(O);
          P.push(M);
          try{

            O = O.caller;
          } catch(Q) {

            break;
          };
          if(!O){

            break;
          };
          // avoid infinite recursion
          var N = qx.core.ObjectRegistry.toHashCode(O);
          if(L[N]){

            P.push(r);
            break;
          };
          L[N] = O;
        };
        return P;
      },
      /**
       * Try to get a stack trace from an Error object. Mozilla sets the field
       * <code>stack</code> for Error objects thrown using <code>throw new Error()</code>.
       * From this field it is possible to get a stack trace from the position
       * the exception was thrown at.
       *
       * This will get the JavaScript file names and the line numbers of each call.
       * The file names are converted into qooxdoo class names if possible (customizable
       * via {@link #FILENAME_TO_CLASSNAME}).
       *
       * The stack trace can be custom formatted using {@link #FORMAT_STACKTRACE}.
       *
       * This works reliably in Gecko-based browsers. Later Opera versions and
       * Chrome also provide a useful stack trace. For Safari, only the class or
       * file name and line number where the error occurred are returned.
       * IE 6/7/8/9 does not attach any stack information to error objects so an
       * empty array is returned.
       *
       * @param error {Error} Error exception instance.
       * @return {String[]} Stack trace of the exception. Each line in the array
       *     represents one call in the stack trace.
       */
      getStackTraceFromError : function(R){

        var V = [];
        if(qx.core.Environment.get(e) === l){

          if(!R.stack){

            return V;
          };
          // Gecko style, e.g. "()@http://localhost:8080/webcomponent-test-SNAPSHOT/webcomponent/js/com/ptvag/webcomponent/common/log/Logger:253"
          var bh = /@(.+):(\d+)$/gm;
          var U;
          while((U = bh.exec(R.stack)) != null){

            var X = U[1];
            var bf = U[2];
            var bd = this.__fileNameToClassName(X);
            V.push(bd + a + bf);
          };
          if(V.length > 0){

            return this.__formatStackTrace(V);
          };
          /*
           * Chrome trace info comes in two flavors:
           * at [jsObject].function (fileUrl:line:char)
           * at fileUrl:line:char
           */
          var bh = /at (.*)/gm;
          var bg = /\((.*?)(:[^\/].*)\)/;
          var bc = /(.*?)(:[^\/].*)/;
          var U;
          while((U = bh.exec(R.stack)) != null){

            var bb = bg.exec(U[1]);
            if(!bb){

              bb = bc.exec(U[1]);
            };
            if(bb){

              var bd = this.__fileNameToClassName(bb[1]);
              V.push(bd + bb[2]);
            } else {

              V.push(U[1]);
            };
          };
        } else if(qx.core.Environment.get(e) === j){

          // Opera
          var T = R.stacktrace;
          if(!T){

            return V;
          };
          if(T.indexOf(c) >= 0){

            T = T.split(c)[0];
          };
          // new Opera style (10.6+)
          var bh = /line\ (\d+?),\ column\ (\d+?)\ in\ (?:.*?)\ in\ (.*?):[^\/]/gm;
          var U;
          while((U = bh.exec(T)) != null){

            var bf = U[1];
            var W = U[2];
            var X = U[3];
            var bd = this.__fileNameToClassName(X);
            V.push(bd + a + bf + a + W);
          };
          if(V.length > 0){

            return this.__formatStackTrace(V);
          };
          // older Opera style
          var bh = /Line\ (\d+?)\ of\ linked\ script\ (.*?)$/gm;
          var U;
          while((U = bh.exec(T)) != null){

            var bf = U[1];
            var X = U[2];
            var bd = this.__fileNameToClassName(X);
            V.push(bd + a + bf);
          };
        } else if(R.message && R.message.indexOf(b) >= 0){

          // Some old Opera versions append the trace to the message property
          var ba = qx.lang.String.trim(R.message.split(b)[1]);
          var Y = ba.split(o);
          for(var i = 0;i < Y.length;i++){

            var S = Y[i].match(/\s*Line ([0-9]+) of.* (\S.*)/);
            if(S && S.length >= 2){

              var bf = S[1];
              var be = this.__fileNameToClassName(S[2]);
              V.push(be + a + bf);
            };
          };
        } else if(R.sourceURL && R.line){

          // Safari
          V.push(this.__fileNameToClassName(R.sourceURL) + a + R.line);
        };;;
        return this.__formatStackTrace(V);
      },
      /**
       * Converts the URL of a JavaScript file to a class name using either a
       * user-defined ({@link #FILENAME_TO_CLASSNAME}) or default
       * ({@link #__fileNameToClassNameDefault}) converter
       *
       * @param fileName {String} URL of the JavaScript file
       * @return {String} Result of the conversion
       */
      __fileNameToClassName : function(bi){

        if(typeof qx.dev.StackTrace.FILENAME_TO_CLASSNAME == f){

          var bj = qx.dev.StackTrace.FILENAME_TO_CLASSNAME(bi);
          if(qx.core.Environment.get(g) && !qx.lang.Type.isString(bj)){

            throw new Error(m);
          };
          return bj;
        };
        return qx.dev.StackTrace.__fileNameToClassNameDefault(bi);
      },
      /**
       * Converts the URL of a JavaScript file to a class name if the file is
       * named using the qooxdoo naming conventions.
       *
       * @param fileName {String} URL of the JavaScript file
       * @return {String} class name of the file if conversion was possible.
       * Otherwise the fileName is returned unmodified.
       */
      __fileNameToClassNameDefault : function(bk){

        var bo = n;
        var bl = bk.indexOf(bo);
        var bn = bk.indexOf(t);
        if(bn >= 0){

          bk = bk.substring(0, bn);
        };
        var bm = (bl == -1) ? bk : bk.substring(bl + bo.length).replace(/\//g, h).replace(/\.js$/, p);
        return bm;
      },
      /**
       * Runs the given stack trace array through the formatter function
       * ({@link #FORMAT_STACKTRACE}) if available and returns it. Otherwise, the
       * original array is returned
       *
       * @param trace {String[]} Stack trace information
       * @return {String[]} Formatted stack trace info
       */
      __formatStackTrace : function(bp){

        if(typeof qx.dev.StackTrace.FORMAT_STACKTRACE == f){

          bp = qx.dev.StackTrace.FORMAT_STACKTRACE(bp);
          // Can't use qx.core.Assert here since it throws an AssertionError which
          // calls getStackTrace in its constructor, leading to infinite recursion
          if(qx.core.Environment.get(g) && !qx.lang.Type.isArray(bp)){

            throw new Error(k);
          };
        };
        return bp;
      }
    }
  });
})();
(function(){

  var f = "e",d = "ecmascript.stacktrace",c = "qx.bom.client.EcmaScript",b = "stack",a = "stacktrace";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * The main purpose of this class to hold all checks about ECMAScript.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(c, {
    statics : {
      /**
       * Returns the name of the Error object property that holds stack trace
       * information or null if the client does not provide any.
       *
       * @internal
       * @return {String|null} <code>stack</code>, <code>stacktrace</code> or
       * <code>null</code>
       */
      getStackTrace : function(){

        var g;
        var e = new Error(f);
        g = e.stack ? b : e.stacktrace ? a : null;
        // only thrown errors have the stack property in IE10 and PhantomJS
        if(!g){

          try{

            throw e;
          } catch(h) {

            e = h;
          };
        };
        return e.stacktrace ? a : e.stack ? b : null;
      }
    },
    defer : function(i){

      qx.core.Environment.add(d, i.getStackTrace);
    }
  });
})();
(function(){

  var k = "Invalid parameter 'func'.",j = 'anonymous()',i = "Trying to call a bound function with a disposed object as context: ",h = "qx.globalErrorHandling",g = " :: ",f = "qx.lang.Function",e = ".constructor()",d = "qx.debug",c = ".",b = ".prototype.",a = "()";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Mootools
       http://mootools.net
       Version 1.1.1
  
       Copyright:
         2007 Valerio Proietti
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.lang.Array)
  #ignore(qx.core.Object)
  #ignore(qx.event.GlobalError)
  
  ************************************************************************ */
  /**
   * Collection of helper methods operating on functions.
   */
  qx.Bootstrap.define(f, {
    statics : {
      /**
       * Extract the caller of a function from the arguments variable.
       * This will not work in Opera < 9.6.
       *
       * @param args {arguments} The local arguments variable
       * @return {Function} A reference to the calling function or "undefined" if caller is not supported.
       */
      getCaller : function(l){

        return l.caller ? l.caller.callee : l.callee.caller;
      },
      /**
       * Try to get a sensible textual description of a function object.
       * This may be the class/mixin and method name of a function
       * or at least the signature of the function.
       *
       * @param fcn {Function} function the get the name for.
       * @return {String} Name of the function.
       */
      getName : function(m){

        if(m.displayName){

          return m.displayName;
        };
        if(m.$$original || m.wrapper || m.classname){

          return m.classname + e;
        };
        if(m.$$mixin){

          //members
          for(var o in m.$$mixin.$$members){

            if(m.$$mixin.$$members[o] == m){

              return m.$$mixin.name + b + o + a;
            };
          };
          // statics
          for(var o in m.$$mixin){

            if(m.$$mixin[o] == m){

              return m.$$mixin.name + c + o + a;
            };
          };
        };
        if(m.self){

          var p = m.self.constructor;
          if(p){

            // members
            for(var o in p.prototype){

              if(p.prototype[o] == m){

                return p.classname + b + o + a;
              };
            };
            // statics
            for(var o in p){

              if(p[o] == m){

                return p.classname + c + o + a;
              };
            };
          };
        };
        var n = m.toString().match(/function\s*(\w*)\s*\(.*/);
        if(n && n.length >= 1 && n[1]){

          return n[1] + a;
        };
        return j;
      },
      /**
       * Evaluates JavaScript code globally
       *
       * @lint ignoreDeprecated(eval)
       *
       * @param data {String} JavaScript commands
       * @return {var} Result of the execution
       */
      globalEval : function(q){

        if(window.execScript){

          return window.execScript(q);
        } else {

          return eval.call(window, q);
        };
      },
      /**
       * empty function
       */
      empty : function(){
      },
      /**
       * Simply return true.
       *
       * @return {Boolean} Always returns true.
       */
      returnTrue : function(){

        return true;
      },
      /**
       * Simply return false.
       *
       * @return {Boolean} Always returns false.
       */
      returnFalse : function(){

        return false;
      },
      /**
       * Simply return null.
       *
       * @return {var} Always returns null.
       */
      returnNull : function(){

        return null;
      },
      /**
       * Return "this".
       *
       * @return {Object} Always returns "this".
       */
      returnThis : function(){

        return this;
      },
      /**
       * Simply return 0.
       *
       * @return {Number} Always returns 0.
       */
      returnZero : function(){

        return 0;
      },
      /**
       * Base function for creating functional closures which is used by most other methods here.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var createdFunction = qx.lang.Function.create(myFunction, [options]);</pre>
       *
       * @param func {Function} Original function to wrap
       * @param options? {Map} Map of options
       * <ul>
       * <li><strong>self</strong>: The object that the "this" of the function will refer to. Default is the same as the wrapper function is called.</li>
       * <li><strong>args</strong>: An array of arguments that will be passed as arguments to the function when called.
       *     Default is no custom arguments; the function will receive the standard arguments when called.</li>
       * <li><strong>delay</strong>: If set, the returned function will delay the actual execution by this amount of milliseconds and return a timer handle when called.
       *     Default is no delay.</li>
       * <li><strong>periodical</strong>: If set the returned function will periodically perform the actual execution with this specified interval
       *      and return a timer handle when called. Default is no periodical execution.</li>
       * <li><strong>attempt</strong>: If set to true, the returned function will try to execute and return either the results or false on error. Default is false.</li>
       * </ul>
       *
       * @return {Function} Wrapped function
       */
      create : function(r, s){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertFunction(r, k);
        };
        // Nothing to be done when there are no options.
        if(!s){

          return r;
        };
        // Check for at least one attribute.
        if(!(s.self || s.args || s.delay != null || s.periodical != null || s.attempt)){

          return r;
        };
        return function(event){

          if(qx.core.Environment.get(d)){

            if(qx.core && qx.core.Object && s.self && qx.Bootstrap.isObject(s.self) && s.self.isDisposed && qx.Bootstrap.isFunction(s.self.isDisposed)){

              qx.core.Assert && qx.core.Assert.assertFalse(s.self.isDisposed(), i + s.self.toString() + g + qx.lang.Function.getName(r));
            };
          };
          // Convert (and copy) incoming arguments
          var u = qx.lang.Array.fromArguments(arguments);
          // Prepend static arguments
          if(s.args){

            u = s.args.concat(u);
          };
          if(s.delay || s.periodical){

            var t = function(){

              return r.apply(s.self || this, u);
            };
            if(qx.core.Environment.get(h)){

              t = qx.event.GlobalError.observeMethod(t);
            };
            if(s.delay){

              return window.setTimeout(t, s.delay);
            };
            if(s.periodical){

              return window.setInterval(t, s.periodical);
            };
          } else if(s.attempt){

            var v = false;
            try{

              v = r.apply(s.self || this, u);
            } catch(w) {
            };
            return v;
          } else {

            return r.apply(s.self || this, u);
          };
        };
      },
      /**
       * Returns a function whose "this" is altered.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.bind(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction()
       * {
       *   this.setStyle('color', 'red');
       *   // note that 'this' here refers to myFunction, not an element
       *   // we'll need to bind this function to the element we want to alter
       * };
       *
       * var myBoundFunction = qx.lang.Function.bind(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * If you find yourself using this static method a lot, you may be
       * interested in the bindTo() method in the mixin qx.core.MBindTo.
       *
       * @see qx.core.MBindTo
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Function} The bound function.
       */
      bind : function(x, self, y){

        return this.create(x, {
          self : self,
          args : arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
        });
      },
      /**
       * Returns a function whose arguments are pre-configured.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.curry(myFunction, [varargs...]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction(elem) {
       *   elem.setStyle('color', 'red');
       * };
       *
       * var myBoundFunction = qx.lang.Function.curry(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param varargs {arguments} The arguments to pass to the function.
       * @return {var} The pre-configured function.
       */
      curry : function(z, A){

        return this.create(z, {
          args : arguments.length > 1 ? qx.lang.Array.fromArguments(arguments, 1) : null
        });
      },
      /**
       * Returns a function which could be used as a listener for a native event callback.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.listener(myFunction, [self, [varargs...]]);</pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {var} The bound function.
       */
      listener : function(B, self, C){

        if(arguments.length < 3){

          return function(event){

            // Directly execute, but force first parameter to be the event object.
            return B.call(self || this, event || window.event);
          };
        } else {

          var D = qx.lang.Array.fromArguments(arguments, 2);
          return function(event){

            var E = [event || window.event];
            // Append static arguments
            E.push.apply(E, D);
            // Finally execute original method
            B.apply(self || this, E);
          };
        };
      },
      /**
       * Tries to execute the function.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var result = qx.lang.Function.attempt(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var myObject = {
       *   'cow': 'moo!'
       * };
       *
       * var myFunction = function()
       * {
       *   for(var i = 0; i < arguments.length; i++) {
       *     if(!this[arguments[i]]) throw('doh!');
       *   }
       * };
       *
       * var result = qx.lang.Function.attempt(myFunction, myObject, 'pig', 'cow'); // false
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Boolean|var} <code>false</code> if an exception is thrown, else the function's return.
       */
      attempt : function(F, self, G){

        return this.create(F, {
          self : self,
          attempt : true,
          args : arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
        })();
      },
      /**
       * Delays the execution of a function by a specified duration.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var timeoutID = qx.lang.Function.delay(myFunction, [delay, [self, [varargs...]]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var myFunction = function(){ alert('moo! Element id is: ' + this.id); };
       * //wait 50 milliseconds, then call myFunction and bind myElement to it
       * qx.lang.Function.delay(myFunction, 50, myElement); // alerts: 'moo! Element id is: ... '
       *
       * // An anonymous function, example
       * qx.lang.Function.delay(function(){ alert('one second later...'); }, 1000); //wait a second and alert
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param delay {Integer} The duration to wait (in milliseconds).
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Integer} The JavaScript Timeout ID (useful for clearing delays).
       */
      delay : function(H, I, self, J){

        return this.create(H, {
          delay : I,
          self : self,
          args : arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
        })();
      },
      /**
       * Executes a function in the specified intervals of time
       *
       * *Syntax*
       *
       * <pre class='javascript'>var intervalID = qx.lang.Function.periodical(myFunction, [period, [self, [varargs...]]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var Site = { counter: 0 };
       * var addCount = function(){ this.counter++; };
       * qx.lang.Function.periodical(addCount, 1000, Site); // will add the number of seconds at the Site
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param interval {Integer} The duration of the intervals between executions.
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Integer} The Interval ID (useful for clearing a periodical).
       */
      periodical : function(K, L, self, M){

        return this.create(K, {
          periodical : L,
          self : self,
          args : arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
        })();
      }
    }
  });
})();
(function(){

  var p = "-",o = "",n = "qx.core.ObjectRegistry",m = "-0",k = "Could not dispose object ",j = " objects",h = ": ",g = "Disposed ",f = "qx.debug.dispose",e = "$$hash",c = "qx.debug",d = "Invalid object: ";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.dev.Debug)
  
  ************************************************************************ */
  /**
   * Registration for all instances of qooxdoo classes. Mainly
   * used to manage them for the final shutdown sequence and to
   * use weak references when connecting widgets to DOM nodes etc.
   */
  qx.Class.define(n, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Boolean} Whether the application is in the shutdown phase */
      inShutDown : false,
      /** {Map} Internal data structure to store objects */
      __registry : {
      },
      /** {Integer} Next new hash code. */
      __nextHash : 0,
      /** {Array} List of all free hash codes */
      __freeHashes : [],
      /** {String} Post id for hash code creation. */
      __postId : o,
      /** {Map} Object hashes to stack traces (for dispose profiling only) */
      __stackTraces : {
      },
      /**
       * Registers an object into the database. This adds a hashcode
       * to the object (if not already done before) and stores it under
       * this hashcode. You can access this object later using the hashcode
       * by calling {@link #fromHashCode}.
       *
       * All registered objects are automatically disposed on application
       * shutdown. Each registered object must at least have a method
       * called <code>dispose</code>.
       *
       * @param obj {Object} Any object with a dispose() method
       * @return {void}
       */
      register : function(q){

        var t = this.__registry;
        if(!t){

          return;
        };
        var s = q.$$hash;
        if(s == null){

          // Create new hash code
          var r = this.__freeHashes;
          if(r.length > 0 && !qx.core.Environment.get(f)){

            s = r.pop();
          } else {

            s = (this.__nextHash++) + this.__postId;
          };
          // Store hash code
          q.$$hash = s;
          if(qx.core.Environment.get(f)){

            if(qx.dev && qx.dev.Debug && qx.dev.Debug.disposeProfilingActive){

              this.__stackTraces[s] = qx.dev.StackTrace.getStackTrace();
            };
          };
        };
        if(qx.core.Environment.get(c)){

          if(!q.dispose){

            throw new Error(d + q);
          };
        };
        t[s] = q;
      },
      /**
       * Removes the given object from the database.
       *
       * @param obj {Object} Any previously registered object
       * @return {void}
       */
      unregister : function(u){

        var v = u.$$hash;
        if(v == null){

          return;
        };
        var w = this.__registry;
        if(w && w[v]){

          delete w[v];
          this.__freeHashes.push(v);
        };
        // Delete the hash code
        try{

          delete u.$$hash;
        } catch(x) {

          // IE has trouble directly removing the hash
          // but it's ok with using removeAttribute
          if(u.removeAttribute){

            u.removeAttribute(e);
          };
        };
      },
      /**
       * Returns an unique identifier for the given object. If such an identifier
       * does not yet exist, create it.
       *
       * @param obj {Object} the object to get the hashcode for
       * @return {String} unique identifier for the given object
       */
      toHashCode : function(y){

        if(qx.core.Environment.get(c)){

          if(y == null){

            throw new Error(d + y);
          };
        };
        var A = y.$$hash;
        if(A != null){

          return A;
        };
        // Create new hash code
        var z = this.__freeHashes;
        if(z.length > 0){

          A = z.pop();
        } else {

          A = (this.__nextHash++) + this.__postId;
        };
        // Store
        return y.$$hash = A;
      },
      /**
       * Clears the unique identifier on the given object.
       *
       * @param obj {Object} the object to clear the hashcode for
       */
      clearHashCode : function(B){

        if(qx.core.Environment.get(c)){

          if(B == null){

            throw new Error(d + B);
          };
        };
        var C = B.$$hash;
        if(C != null){

          this.__freeHashes.push(C);
          // Delete the hash code
          try{

            delete B.$$hash;
          } catch(D) {

            // IE has trouble directly removing the hash
            // but it's ok with using removeAttribute
            if(B.removeAttribute){

              B.removeAttribute(e);
            };
          };
        };
      },
      /**
       * Get an object instance by its hash code as returned by {@link #toHashCode}.
       * If the object is already disposed or the hashCode is invalid,
       * <code>null</code> is returned.
       *
       * @param hash {String} The object's hash code.
       * @return {qx.core.Object} The corresponding object or <code>null</code>.
       */
      fromHashCode : function(E){

        return this.__registry[E] || null;
      },
      /**
       * Disposing all registered object and cleaning up registry. This is
       * automatically executed at application shutdown.
       *
       * @return {void}
       */
      shutdown : function(){

        this.inShutDown = true;
        var G = this.__registry;
        var I = [];
        for(var H in G){

          I.push(H);
        };
        // sort the objects! Remove the objecs created at startup
        // as late as possible
        I.sort(function(a, b){

          return parseInt(b, 10) - parseInt(a, 10);
        });
        var F,i = 0,l = I.length;
        while(true){

          try{

            for(;i < l;i++){

              H = I[i];
              F = G[H];
              if(F && F.dispose){

                F.dispose();
              };
            };
          } catch(J) {

            qx.Bootstrap.error(this, k + F.toString() + h + J, J);
            if(i !== l){

              i++;
              continue;
            };
          };
          break;
        };
        qx.Bootstrap.debug(this, g + l + j);
        delete this.__registry;
      },
      /**
       * Returns the object registry.
       *
       * @return {Object} The registry
       */
      getRegistry : function(){

        return this.__registry;
      },
      /**
       * Returns the next hash code that will be used
       *
       * @return {Integer} The next hash code
       * @internal
       */
      getNextHash : function(){

        return this.__nextHash;
      },
      /**
       * Returns the postfix that identifies the current iframe
       *
       * @return {Integer} The next hash code
       * @internal
       */
      getPostId : function(){

        return this.__postId;
      },
      /**
       * Returns the map of stack traces recorded when objects are registered
       * (for dispose profiling)
       * @return {Map} Map: object hash codes to stack traces
       * @internal
       */
      getStackTraces : function(){

        return this.__stackTraces;
      }
    },
    defer : function(K){

      if(window && window.top){

        var frames = window.top.frames;
        for(var i = 0;i < frames.length;i++){

          if(frames[i] === window){

            K.__postId = p + (i + 1);
            return;
          };
        };
      };
      K.__postId = m;
    }
  });
})();
(function(){

  var g = "prop",f = "qx.bom.client.Json",e = "JSON",d = '{"x":1}',c = "json",b = "val",a = "repl";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  /**
   * JSON detection.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(f, {
    statics : {
      /**
       * Checks if native JSON could be used and is full-featured.
       * @return {Boolean} <code>true</code>, if it could be used.
       * @internal
       */
      getJson : function(){

        return (// Exists
        qx.Bootstrap.getClass(window.JSON) == e && // Can parse
        JSON.parse(d).x === 1 && // Supports replacer
        //
        // Catches browser bug found in Firefox >=3.5 && < 4, see
        // https://bugzilla.mozilla.org/show_bug.cgi?id=509184
        JSON.stringify({
          "prop" : b
        }, function(k, v){

          return k === g ? a : v;
        }).indexOf(a) > 0);
      }
    },
    defer : function(h){

      qx.core.Environment.add(c, h.getJson);
    }
  });
})();
(function(){

  var p = 'String',o = 'Boolean',m = '\\\\',l = '\\f',h = '\\t',g = '{\n',f = '[]',e = "qx.lang.JsonImpl",d = 'Z',b = '\\n',ba = 'Object',Y = '{}',X = '@',W = '.',V = '(',U = 'Array',T = 'T',S = '\\r',R = '{',Q = 'JSON.parse',x = ' ',y = '[',u = 'Number',w = ')',s = '[\n',t = '\\"',q = '\\b',r = ': ',z = 'object',A = 'function',H = ',',F = '\n',K = '\\u',J = ',\n',M = '0000',L = 'string',C = "Cannot stringify a recursive object.",P = '0',O = '-',N = '}',B = ']',D = 'null',E = '"',G = ':',I = '';
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
     ________________________________________________________________________
  
     This class contains code based on the following work:
  
      http://www.JSON.org/json2.js
      2009-06-29
  
      Public Domain.
  
      NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
  
      See http://www.JSON.org/js.html
  
  ************************************************************************ */
  /**
   * Pure JavaScript implementation of the EcmaScript 3.1 JSON object. This class
   * is used, if the browser does not support it natively.
   *
   * @internal
   */
  qx.Bootstrap.define(e, {
    extend : Object,
    construct : function(){

      // bind parse and stringify so they can be called without a context.
      this.stringify = qx.lang.Function.bind(this.stringify, this);
      this.parse = qx.lang.Function.bind(this.parse, this);
    },
    members : {
      __gap : null,
      __indent : null,
      __rep : null,
      __stack : null,
      /**
       * This method produces a JSON text from a JavaScript value.
       *
       * @param value {var} any JavaScript value, usually an object or array.
       *
       * @param replacer {Function?} an optional parameter that determines how
       *    object values are stringified for objects. It can be a function or an
       *    array of strings.
       *
       * @param space {String?} an optional parameter that specifies the
       *    indentation of nested structures. If it is omitted, the text will
       *    be packed without extra whitespace. If it is a number, it will specify
       *    the number of spaces to indent at each level. If it is a string
       *    (such as '\t' or '&nbsp;'), it contains the characters used to indent
       *    at each level.
       *
       * @return {String} The JSON string of the value
       */
      stringify : function(bb, bc, bd){

        this.__gap = I;
        this.__indent = I;
        this.__stack = [];
        if(qx.lang.Type.isNumber(bd)){

          // If the space parameter is a number, make an indent string containing that
          // many spaces.
          var bd = Math.min(10, Math.floor(bd));
          for(var i = 0;i < bd;i += 1){

            this.__indent += x;
          };
        } else if(qx.lang.Type.isString(bd)){

          if(bd.length > 10){

            bd = bd.slice(0, 10);
          };
          // If the space parameter is a string, it will be used as the indent string.
          this.__indent = bd;
        };
        // If there is a replacer, it must be a function or an array.
        // Otherwise, ignore it.
        if(bc && (qx.lang.Type.isFunction(bc) || qx.lang.Type.isArray(bc))){

          this.__rep = bc;
        } else {

          this.__rep = null;
        };
        // Make a fake root object containing our value under the key of ''.
        // Return the result of stringifying the value.
        return this.__str(I, {
          '' : bb
        });
      },
      /**
       * Produce a string from holder[key].
       *
       * @param key {String} the map key
       * @param holder {Object} an object with the given key
       * @return {String} The string representation of holder[key]
       */
      __str : function(be, bf){

        var bi = this.__gap,bg,bj = bf[be];
        // If the value has a toJSON method, call it to obtain a replacement value.
        if(bj && qx.lang.Type.isFunction(bj.toJSON)){

          bj = bj.toJSON(be);
        } else if(qx.lang.Type.isDate(bj)){

          bj = this.dateToJSON(bj);
        };
        // If we were called with a replacer function, then call the replacer to
        // obtain a replacement value.
        if(typeof this.__rep === A){

          bj = this.__rep.call(bf, be, bj);
        };
        if(bj === null){

          return D;
        };
        if(bj === undefined){

          return undefined;
        };
        // What happens next depends on the value's type.
        switch(qx.lang.Type.getClass(bj)){case p:
        return this.__quote(bj);case u:
        // JSON numbers must be finite. Encode non-finite numbers as null.
        return isFinite(bj) ? String(bj) : D;case o:
        // If the value is a boolean or null, convert it to a string. Note:
        // typeof null does not produce 'null'. The case is included here in
        // the remote chance that this gets fixed someday.
        return String(bj);case U:
        // Make an array to hold the partial results of stringifying this array value.
        this.__gap += this.__indent;
        bg = [];
        if(this.__stack.indexOf(bj) !== -1){

          throw new TypeError(C);
        };
        this.__stack.push(bj);
        // The value is an array. Stringify every element. Use null as a placeholder
        // for non-JSON values.
        var length = bj.length;
        for(var i = 0;i < length;i += 1){

          bg[i] = this.__str(i, bj) || D;
        };
        this.__stack.pop();
        // Join all of the elements together, separated with commas, and wrap them in
        // brackets.
        if(bg.length === 0){

          var bh = f;
        } else if(this.__gap){

          bh = s + this.__gap + bg.join(J + this.__gap) + F + bi + B;
        } else {

          bh = y + bg.join(H) + B;
        };
        this.__gap = bi;
        return bh;case ba:
        // Make an array to hold the partial results of stringifying this object value.
        this.__gap += this.__indent;
        bg = [];
        if(this.__stack.indexOf(bj) !== -1){

          throw new TypeError(C);
        };
        this.__stack.push(bj);
        // If the replacer is an array, use it to select the members to be stringified.
        if(this.__rep && typeof this.__rep === z){

          var length = this.__rep.length;
          for(var i = 0;i < length;i += 1){

            var k = this.__rep[i];
            if(typeof k === L){

              var v = this.__str(k, bj);
              if(v){

                bg.push(this.__quote(k) + (this.__gap ? r : G) + v);
              };
            };
          };
        } else {

          // Otherwise, iterate through all of the keys in the object.
          for(var k in bj){

            if(Object.hasOwnProperty.call(bj, k)){

              var v = this.__str(k, bj);
              if(v){

                bg.push(this.__quote(k) + (this.__gap ? r : G) + v);
              };
            };
          };
        };
        this.__stack.pop();
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.
        if(bg.length === 0){

          var bh = Y;
        } else if(this.__gap){

          bh = g + this.__gap + bg.join(J + this.__gap) + F + bi + N;
        } else {

          bh = R + bg.join(H) + N;
        };
        this.__gap = bi;
        return bh;};
      },
      /**
       * Convert a date to JSON
       *
       * @param date {Date} The date to convert
       * @return {String} The JSON representation of the date
       */
      dateToJSON : function(bk){

        // Format integers to have at least two digits.
        var bl = function(n){

          return n < 10 ? P + n : n;
        };
        var bm = function(n){

          var bn = bl(n);
          return n < 100 ? P + bn : bn;
        };
        return isFinite(bk.valueOf()) ? bk.getUTCFullYear() + O + bl(bk.getUTCMonth() + 1) + O + bl(bk.getUTCDate()) + T + bl(bk.getUTCHours()) + G + bl(bk.getUTCMinutes()) + G + bl(bk.getUTCSeconds()) + W + bm(bk.getUTCMilliseconds()) + d : null;
      },
      /**
       * If the string contains no control characters, no quote characters, and no
       * backslash characters, then we can safely slap some quotes around it.
       * Otherwise we must also replace the offending characters with safe escape
       * sequences.
       *
       * @param string {String} The string to quote
       * @return {String} The quoted string
       */
      __quote : function(bo){

        var bp = {
          // table of character substitutions
          '\b' : q,
          '\t' : h,
          '\n' : b,
          '\f' : l,
          '\r' : S,
          '"' : t,
          '\\' : m
        };
        var bq = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        bq.lastIndex = 0;
        if(bq.test(bo)){

          return E + bo.replace(bq, function(a){

            var c = bp[a];
            return typeof c === L ? c : K + (M + a.charCodeAt(0).toString(16)).slice(-4);
          }) + E;
        } else {

          return E + bo + E;
        };
      },
      /**
       * This method parses a JSON text to produce an object or array.
       * It can throw a SyntaxError exception.
       *
       * @param text {String} JSON string to parse
       *
       * @param reviver {Function?} Optional reviver function to filter and
       *    transform the results
       *
       * @return {Object} The parsed JSON object
       *
       * @lint ignoreDeprecated(eval)
       */
      parse : function(br, bs){

        var bt = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        bt.lastIndex = 0;
        // Parsing happens in four stages. In the first stage, we replace certain
        // Unicode characters with escape sequences. JavaScript handles many characters
        // incorrectly, either silently deleting them, or treating them as line endings.
        if(bt.test(br)){

          br = br.replace(bt, function(a){

            return K + (M + a.charCodeAt(0).toString(16)).slice(-4);
          });
        };
        // In the second stage, we run the text against regular expressions that look
        // for non-JSON patterns. We are especially concerned with '()' and 'new'
        // because they can cause invocation, and '=' because it can cause mutation.
        // But just to be safe, we want to reject all unexpected forms.
        // We split the second stage into 4 regexp operations in order to work around
        // crippling inefficiencies in IE's and Safari's regexp engines. First we
        // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
        // replace all simple value tokens with ']' characters. Third, we delete all
        // open brackets that follow a colon or comma or that begin the text. Finally,
        // we look to see that the remaining characters are only whitespace or ']' or
        // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.
        if(/^[\],:{}\s]*$/.test(br.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, X).replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, B).replace(/(?:^|:|,)(?:\s*\[)+/g, I))){

          // In the third stage we use the eval function to compile the text into a
          // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
          // in JavaScript: it can begin a block or an object literal. We wrap the text
          // in parens to eliminate the ambiguity.
          var j = eval(V + br + w);
          // In the optional fourth stage, we recursively walk the new structure, passing
          // each name/value pair to a reviver function for possible transformation.
          return typeof bs === A ? this.__walk({
            '' : j
          }, I, bs) : j;
        };
        // If the text is not JSON parseable, then a SyntaxError is thrown.
        throw new SyntaxError(Q);
      },
      /**
       * The walk method is used to recursively walk the resulting structure so
       * that modifications can be made.
       *
       * @param holder {Object} the root object
       * @param key {String} walk holder[key]
       * @param reviver {Function} callback, which is called on every node.
       */
      __walk : function(bu, bv, bw){

        var bx = bu[bv];
        if(bx && typeof bx === z){

          for(var k in bx){

            if(Object.hasOwnProperty.call(bx, k)){

              var v = this.__walk(bx, k, bw);
              if(v !== undefined){

                bx[k] = v;
              } else {

                delete bx[k];
              };
            };
          };
        };
        return bw.call(bu, bv, bx);
      }
    }
  });
})();
(function(){

  var a = "qx.lang.Json";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
     ________________________________________________________________________
  
     This class contains code based on the following work:
  
      http://www.JSON.org/json2.js
      2009-06-29
  
      Public Domain.
  
      NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
  
      See http://www.JSON.org/js.html
  
  ************************************************************************ */
  /**
   * JSON (JavaScript Object Notation) parser, serializer for qooxdoo
   *
   * This class implements EcmaScript 3.1 JSON support.
   *
   * http://wiki.ecmascript.org/doku.php?id=es3.1:json_support
   *
   * If the browser supports native JSON the browser implementation is used.
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * {JSON} The JSON object to use. If the browser has native JSON support
       *   this member points to <code>window.JSON</code>. Otherwise it points to
       *   the qooxdoo implementation {@link JsonImpl}.
       */
      JSON : qx.core.Environment.get("json") ? window.JSON : new qx.lang.JsonImpl(),
      /**
       * This method produces a JSON text from a JavaScript value.
       *
       * When an object value is found, if the object contains a toJSON
       * method, its toJSON method will be called and the result will be
       * stringified. A toJSON method does not serialize: it returns the
       * value represented by the name/value pair that should be serialized,
       * or undefined if nothing should be serialized. The toJSON method
       * will be passed the key associated with the value, and this will be
       * bound to the object holding the key.
       *
       * For example, this would serialize Dates as ISO strings.
       *
       * <pre class="javascript">
       *     Date.prototype.toJSON = function (key) {
       *         function f(n) {
       *             // Format integers to have at least two digits.
       *             return n < 10 ? '0' + n : n;
       *         }
       *
       *         return this.getUTCFullYear()   + '-' +
       *              f(this.getUTCMonth() + 1) + '-' +
       *              f(this.getUTCDate())      + 'T' +
       *              f(this.getUTCHours())     + ':' +
       *              f(this.getUTCMinutes())   + ':' +
       *              f(this.getUTCSeconds())   + 'Z';
       *     };
       * </pre>
       *
       * You can provide an optional replacer method. It will be passed the
       * key and value of each member, with this bound to the containing
       * object. The value that is returned from your method will be
       * serialized. If your method returns undefined, then the member will
       * be excluded from the serialization.
       *
       * If the replacer parameter is an array of strings, then it will be
       * used to select the members to be serialized. It filters the results
       * such that only members with keys listed in the replacer array are
       * stringified.
       *
       * Values that do not have JSON representations, such as undefined or
       * functions, will not be serialized. Such values in objects will be
       * dropped; in arrays they will be replaced with null. You can use
       * a replacer function to replace those with JSON values.
       * JSON.stringify(undefined) returns undefined.
       *
       * The optional space parameter produces a stringification of the
       * value that is filled with line breaks and indentation to make it
       * easier to read.
       *
       * If the space parameter is a non-empty string, then that string will
       * be used for indentation. If the space parameter is a number, then
       * the indentation will be that many spaces.
       *
       * Example:
       *
       * <pre class="javascript">
       * text = JSON.stringify(['e', {pluribus: 'unum'}]);
       * // text is '["e",{"pluribus":"unum"}]'
       *
       *
       * text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
       * // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'
       *
       * text = JSON.stringify([new Date()], function (key, value) {
       *     return this[key] instanceof Date ?
       *         'Date(' + this[key] + ')' : value;
       * });
       * // text is '["Date(---current time---)"]'
       * </pre>
       *
       * @signature function(value, replacer, space)
       *
       * @param value {var} any JavaScript value, usually an object or array.
       *
       * @param replacer {Function?} an optional parameter that determines how
       *    object values are stringified for objects. It can be a function or an
       *    array of strings.
       *
       * @param space {String?} an optional parameter that specifies the
       *    indentation of nested structures. If it is omitted, the text will
       *    be packed without extra whitespace. If it is a number, it will specify
       *    the number of spaces to indent at each level. If it is a string
       *    (such as '\t' or '&nbsp;'), it contains the characters used to indent
       *    at each level.
       *
       * @return {String} The JSON string of the value
       */
      stringify : null,
      // will be set in the defer block
      /**
       * This method parses a JSON text to produce an object or array.
       * It can throw a SyntaxError exception.
       *
       * The optional reviver parameter is a function that can filter and
       * transform the results. It receives each of the keys and values,
       * and its return value is used instead of the original value.
       * If it returns what it received, then the structure is not modified.
       * If it returns undefined then the member is deleted.
       *
       * Example:
       *
       * <pre class="javascript">
       * // Parse the text. Values that look like ISO date strings will
       * // be converted to Date objects.
       *
       * myData = JSON.parse(text, function (key, value)
       * {
       *   if (typeof value === 'string')
       *   {
       *     var a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
       *     if (a) {
       *       return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
       *     }
       *   }
       *   return value;
       * });
       *
       * myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
       *     var d;
       *     if (typeof value === 'string' &&
       *             value.slice(0, 5) === 'Date(' &&
       *             value.slice(-1) === ')') {
       *         d = new Date(value.slice(5, -1));
       *         if (d) {
       *             return d;
       *         }
       *     }
       *     return value;
       * });
       * </pre>
       *
       * @signature function(text, reviver)
       *
       * @param text {String} JSON string to parse
       *
       * @param reviver {Function?} Optional reviver function to filter and
       *    transform the results
       *
       * @return {Object} The parsed JSON object
       */
      parse : null
    },
    defer : function(b){

      b.stringify = b.JSON.stringify;
      b.parse = b.JSON.parse;
    }
  });
})();
(function(){

  var a = "qx.lang.Date";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Sebastian Werner, http://sebastian-werner.net
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * jQuery
       http://jquery.com
       Version 1.3.1
  
       Copyright:
         2009 John Resig
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /**
   * Helper functions for dates.
   *
   * The native JavaScript Date is not modified by this class.
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * Returns the current time
       *
       * @return {Integer} Time in ms from 1970.
       */
      now : function(){

        return +new Date;
      }
    }
  });
})();
(function(){

  var c = "qx.event.type.Data",b = "qx.event.type.Event",a = "qx.data.IListData";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This interface defines a data structure compatible with the data binding
   * controllers.
   * It defines a minimum of functionality which the controller need to work.
   */
  qx.Interface.define(a, {
    events : {
      /**
       * The change event which will be fired if there is a change in the data
       * structure.The data should contain a map with three key value pairs:
       * <li>start: The start index of the change.</li>
       * <li>end: The end index of the change.</li>
       * <li>type: The type of the change as a String. This can be 'add',
       * 'remove' or 'order'</li>
       * <li>item: The item which has been changed.</li>
       */
      "change" : c,
      /**
       * The changeLength event will be fired every time the length of the
       * data structure changes.
       */
      "changeLength" : b
    },
    members : {
      /**
       * Returns the item at the given index
       *
       * @param index {Number} The index requested of the data element.
       *
       * @return {var} The element at the given index.
       */
      getItem : function(d){
      },
      /**
       * Sets the given item at the given position in the data structure. A
       * change event has to be fired.
       *
       * @param index {Number} The index of the data element.
       * @param item {var} The new item to set.
       */
      setItem : function(e, f){
      },
      /**
       * Method to remove and add new element to the data. For every remove or
       * add a change event should be fired.
       *
       * @param startIndex {Integer} The index where the splice should start
       * @param amount {Integer} Defines number of element which will be removed
       *   at the given position.
       * @param varargs {var} All following parameters will be added at the given
       *   position to the array.
       * @return {qx.data.Array} An array containing the removed elements.
       */
      splice : function(g, h, i){
      },
      /**
       * Check if the given item is in the current data structure.
       *
       * @param item {var} The item which is possibly in the data structure.
       * @return {boolean} true, if the array contains the given item.
       */
      contains : function(j){
      },
      /**
       * Returns the current length of the data structure.
       *
       * @return {Number} The current length of the data structure.
       */
      getLength : function(){
      },
      /**
       * Returns the list data as native array.
       *
       * @return {Array} The native array.
       */
      toArray : function(){
      }
    }
  });
})();
(function(){

  var a = "qx.core.ValidationError";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * A validation Error which should be thrown if a validation fails.
   */
  qx.Class.define(a, {
    extend : qx.type.BaseError
  });
})();
(function(){

  var a = "qx.lang.RingBuffer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * An memory container which stores arbitrary data up to a maximum number of
   * entries. When new entries come in an the maximum is reached, the oldest
   * entries are deleted.
   *
   * A mark feature also exists which can be used to remember a point in time.
   * When retrieving entriues, it is possible to get only those entries
   * after the marked time. This is useful if data from the buffer is extracted
   * and processed. Whenever this happens, a mark() call can be used so that the
   * next extraction will only get new data.
   */
  qx.Class.define(a, {
    extend : Object,
    /**
     * Constructor.
     *
     * @param maxEntries {Integer ? 50} Maximum number of entries in the buffer
     */
    construct : function(b){

      this.setMaxEntries(b || 50);
    },
    members : {
      //Next slot in ringbuffer to use
      __nextIndexToStoreTo : 0,
      //Number of elements in ring buffer
      __entriesStored : 0,
      //Was a mark set?
      __isMarkActive : false,
      //How many elements were stored since setting of mark?
      __entriesStoredSinceMark : 0,
      //ring buffer
      __entries : null,
      //Maximum number of messages to store. Could be converted to a qx property.
      __maxEntries : null,
      /**
       * Set the maximum number of messages to hold. If null the number of
       * messages is not limited.
       *
       * Warning: Changing this property will clear the events logged so far.
       *
       * @param maxEntries {Integer} the maximum number of messages to hold
       */
      setMaxEntries : function(c){

        this.__maxEntries = c;
        this.clear();
      },
      /**
       * Get the maximum number of entries to hold
       *
       * @return {Integer}
       */
      getMaxEntries : function(){

        return this.__maxEntries;
      },
      /**
       * Adds a single entry
       *
       * @param entry {var} The data to store
       */
      addEntry : function(d){

        this.__entries[this.__nextIndexToStoreTo] = d;
        this.__nextIndexToStoreTo = this.__addToIndex(this.__nextIndexToStoreTo, 1);
        //Count # of stored entries
        var e = this.getMaxEntries();
        if(this.__entriesStored < e){

          this.__entriesStored++;
        };
        //Count # of stored elements since last mark call
        if(this.__isMarkActive && (this.__entriesStoredSinceMark < e)){

          this.__entriesStoredSinceMark++;
        };
      },
      /**
       * Remembers the current position in the ring buffer
       *
       */
      mark : function(){

        this.__isMarkActive = true;
        this.__entriesStoredSinceMark = 0;
      },
      /**
       * Removes the current mark position
       */
      clearMark : function(){

        this.__isMarkActive = false;
      },
      /**
       * Returns all stored entries. Mark is ignored.
       *
       * @return {Array} array of stored entries
       */
      getAllEntries : function(){

        return this.getEntries(this.getMaxEntries(), false);
      },
      /**
       * Returns entries which have been added previously.
       *
       * @param count {Integer} The number of entries to retrieve. If there are
       *    more entries than the given count, the oldest ones will not be returned.
       *
       * @param startingFromMark {Boolean ? false} If true, only entries since
       *   the last call to mark() will be returned
       * @return {Array} array of stored entries
       */
      getEntries : function(f, g){

        //Trim count so it does not exceed ringbuffer size
        if(f > this.__entriesStored){

          f = this.__entriesStored;
        };
        // Trim count so it does not exceed last call to mark (if mark was called
        // and startingFromMark was true)
        if(g && this.__isMarkActive && (f > this.__entriesStoredSinceMark)){

          f = this.__entriesStoredSinceMark;
        };
        if(f > 0){

          var i = this.__addToIndex(this.__nextIndexToStoreTo, -1);
          var h = this.__addToIndex(i, -f + 1);
          var j;
          if(h <= i){

            //Requested segment not wrapping around ringbuffer boundary, get in one run
            j = this.__entries.slice(h, i + 1);
          } else {

            //Requested segment wrapping around ringbuffer boundary, get two parts & concat
            j = this.__entries.slice(h, this.__entriesStored).concat(this.__entries.slice(0, i + 1));
          };
        } else {

          j = [];
        };
        return j;
      },
      /**
       * Clears all entries
       */
      clear : function(){

        this.__entries = new Array(this.getMaxEntries());
        this.__entriesStored = 0;
        this.__entriesStoredSinceMark = 0;
        this.__nextIndexToStoreTo = 0;
      },
      /**
       * Adds a number to an ringbuffer index. Does a modulus calculation,
       * i. e. if the index leaves the ringbuffer space it will wrap around to
       * the other end of the ringbuffer.
       *
       * @param idx {Number} The current index.
       * @param addMe {Number} The number to add.
       */
      __addToIndex : function(k, l){

        var m = this.getMaxEntries();
        var n = (k + l) % m;
        //If negative, wrap up into the ringbuffer space
        if(n < 0){

          n += m;
        };
        return n;
      }
    }
  });
})();
(function(){

  var a = "qx.log.appender.RingBuffer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * An appender that writes all messages to a memory container. The messages
   * can be retrieved later, f. i. when an error dialog pops up and the question
   * arises what actions have caused the error.
   *
   * A mark feature also exists which can be used to remember a point in time.
   * When retrieving log events, it is possible to get only those events
   * after the marked time. This is useful if data from the buffer is extracted
   * and f. i. sent to a logging system. Whenever this happens, a mark() call
   * can be used so that the next extraction will only get new data.
   */
  qx.Class.define(a, {
    extend : qx.lang.RingBuffer,
    /**
     * @param maxMessages {Integer?50} Maximum number of messages in the buffer
     */
    construct : function(b){

      this.setMaxMessages(b || 50);
    },
    members : {
      /**
       * Set the maximum number of messages to hold. If null the number of
       * messages is not limited.
       *
       * Warning: Changing this property will clear the events logged so far.
       *
       * @param maxMessages {Integer} the maximum number of messages to hold
       */
      setMaxMessages : function(c){

        this.setMaxEntries(c);
      },
      /**
       * Get the maximum number of messages to hold
       *
       * @return {Integer} the maximum number of messages
       */
      getMaxMessages : function(){

        return this.getMaxEntries();
      },
      /**
       * Processes a single log entry
       *
       * @param entry {Map} The entry to process
       */
      process : function(d){

        this.addEntry(d);
      },
      /**
       * Returns all stored log events
       *
       * @return {Array} array of stored log events
       */
      getAllLogEvents : function(){

        return this.getAllEntries();
      },
      /**
       * Returns log events which have been logged previously.
       *
       * @param count {Integer} The number of events to retrieve. If there are
       *    more events than the given count, the oldest ones will not be returned.
       *
       * @param startingFromMark {Boolean ? false} If true, only entries since the last call to mark()
       *                                           will be returned
       * @return {Array} array of stored log events
       */
      retrieveLogEvents : function(e, f){

        return this.getEntries(e, f);
      },
      /**
       * Clears the log history
       */
      clearHistory : function(){

        this.clear();
      }
    }
  });
})();
(function(){

  var k = "qx.log.Logger",j = "[",h = "The mixin '",g = "warn",f = "The event '",e = "Please consult the API documentation of this method for alternatives.",d = "#",c = "document",b = "{...(",a = "' from class '",T = "The class '",S = "' overrides a deprecated method: ",R = "text[",Q = "[...(",P = "\n",O = ")}",N = ")]",M = "The constant '",L = "object",K = "...(+",s = "array",t = "The method '",q = ")",r = "instance",o = "info",p = "string",m = "null",n = "class",u = "Please consult the API documentation for alternatives.",v = "number",C = "stringify",A = "date",E = "function",D = "]",G = "boolean",F = "debug",x = "map",J = "node",I = "error",H = "Please consult the API documentation of this class for alternatives.",w = "undefined",y = "' is deprecated: ",z = "qx.debug",B = "unknown";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Main qooxdoo logging class.
   *
   * Used as central logging feature by qx.core.Object.
   *
   * Extremely modular and lightweight to support logging at bootstrap and
   * at shutdown as well.
   *
   * * Supports dynamic appenders to push the output to the user
   * * Supports buffering of the last 50 messages (configurable)
   * * Supports different debug levels ("debug", "info", "warn" or "error")
   * * Simple data serialization for incoming messages
   */
  /*
   #require(qx.dev.StackTrace)
   */
  qx.Class.define(k, {
    statics : {
      /*
      ---------------------------------------------------------------------------
        CONFIGURATION
      ---------------------------------------------------------------------------
      */
      __level : F,
      /**
       * Configures the minimum log level required for new messages.
       *
       * @param value {String} One of "debug", "info", "warn" or "error".
       * @return {void}
       */
      setLevel : function(U){

        this.__level = U;
      },
      /**
       * Returns the currently configured minimum log level required for new
       * messages.
       *
       * @return {Integer} Debug level
       */
      getLevel : function(){

        return this.__level;
      },
      /**
       * Configures the number of messages to be kept in the buffer.
       *
       * @param value {Integer} Any positive integer
       * @return {void}
       */
      setTreshold : function(V){

        this.__buffer.setMaxMessages(V);
      },
      /**
       * Returns the currently configured number of messages to be kept in the
       * buffer.
       *
       * @return {Integer} Treshold value
       */
      getTreshold : function(){

        return this.__buffer.getMaxMessages();
      },
      /*
      ---------------------------------------------------------------------------
        APPENDER MANAGEMENT
      ---------------------------------------------------------------------------
      */
      /** {Map} Map of all known appenders by ID */
      __appender : {
      },
      /** {Integer} Last free appender ID */
      __id : 0,
      /**
       * Registers the given appender and inserts the last cached messages.
       *
       * @param appender {Class} A static appender class supporting at
       *   least a <code>process()</code> method to handle incoming messages.
       * @return {void}
       */
      register : function(W){

        if(W.$$id){

          return;
        };
        // Register appender
        var Y = this.__id++;
        this.__appender[Y] = W;
        W.$$id = Y;
        var X = this.__levels;
        // Insert previous messages
        var ba = this.__buffer.getAllLogEvents();
        for(var i = 0,l = ba.length;i < l;i++){

          if(X[ba[i].level] >= X[this.__level]){

            W.process(ba[i]);
          };
        };
      },
      /**
       * Unregisters the given appender
       *
       * @param appender {Class} A static appender class
       * @return {void}
       */
      unregister : function(bb){

        var bc = bb.$$id;
        if(bc == null){

          return;
        };
        delete this.__appender[bc];
        delete bb.$$id;
      },
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Sending a message at level "debug" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      debug : function(bd, be){

        qx.log.Logger.__log(F, arguments);
      },
      /**
       * Sending a message at level "info" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      info : function(bf, bg){

        qx.log.Logger.__log(o, arguments);
      },
      /**
       * Sending a message at level "warn" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      warn : function(bh, bi){

        qx.log.Logger.__log(g, arguments);
      },
      /**
       * Sending a message at level "error" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       * @return {void}
       */
      error : function(bj, bk){

        qx.log.Logger.__log(I, arguments);
      },
      /**
       * Prints the current stack trace at level "info"
       *
       * @param object {Object?} Contextual object (either instance or static class)
       * @return {void}
       */
      trace : function(bl){

        var bm = qx.dev.StackTrace.getStackTrace();
        qx.log.Logger.__log(o, [(typeof bl !== w ? [bl].concat(bm) : bm).join(P)]);
      },
      /**
       * Prints a method deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>on</code>.
       *
       * @param fcn {Function} reference to the deprecated function. This is
       *     arguments.callee if the calling method is to be deprecated.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedMethodWarning : function(bn, bo){

        if(qx.core.Environment.get(z)){

          var bp = qx.lang.Function.getName(bn);
          this.warn(t + bp + y + (bo || e));
          this.trace();
        };
      },
      /**
       * Prints a class deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>on</code>.
       *
       * @param clazz {Class} reference to the deprecated class.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedClassWarning : function(bq, br){

        if(qx.core.Environment.get(z)){

          var bs = bq.classname || B;
          this.warn(T + bs + y + (br || H));
          this.trace();
        };
      },
      /**
       * Prints an event deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>on</code>.
       *
       * @param clazz {Class} reference to the deprecated class.
       * @param event {String} deprecated event name.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedEventWarning : function(bt, event, bu){

        if(qx.core.Environment.get(z)){

          var bv = bt.self ? bt.self.classname : B;
          this.warn(f + (event || B) + a + bv + y + (bu || H));
          this.trace();
        };
      },
      /**
       * Prints a mixin deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>on</code>.
       *
       * @param clazz {Class} reference to the deprecated mixin.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedMixinWarning : function(bw, bx){

        if(qx.core.Environment.get(z)){

          var by = bw ? bw.name : B;
          this.warn(h + by + y + (bx || H));
          this.trace();
        };
      },
      /**
       * Prints a constant deprecation warning and a stacktrace if the setting
       * <code>qx.debug</code> is set to <code>on</code> AND the browser supports
       * __defineGetter__!
       *
       * @param clazz {Class} The class the constant is attached to.
       * @param constant {String} The name of the constant as string.
       * @param msg {String} Optional message to be printed.
       */
      deprecatedConstantWarning : function(bz, bA, bB){

        if(qx.core.Environment.get(z)){

          // check if __defineGetter__ is available
          if(bz.__defineGetter__){

            var self = this;
            var bC = bz[bA];
            bz.__defineGetter__(bA, function(){

              self.warn(M + bA + y + (bB || u));
              self.trace();
              return bC;
            });
          };
        };
      },
      /**
       * Prints a deprecation waring and a stacktrace when a subclass overrides
       * the passed method name. The deprecation is only printed if the setting
       * <code>qx.debug</code> is set to <code>on</code>.
       *
       *
       * @param object {qx.core.Object} Instance to check for overriding.
       * @param baseclass {Class} The baseclass as starting point.
       * @param methodName {String} The method name which is deprecated for overriding.
       * @param msg {String|?} Optional message to be printed.
       */
      deprecateMethodOverriding : function(bD, bE, bF, bG){

        if(qx.core.Environment.get(z)){

          var bH = bD.constructor;
          while(bH.classname !== bE.classname){

            if(bH.prototype.hasOwnProperty(bF)){

              this.warn(t + qx.lang.Function.getName(bD[bF]) + S + (bG || u));
              this.trace();
              break;
            };
            bH = bH.superclass;
          };
        };
      },
      /**
       * Deletes the current buffer. Does not influence message handling of the
       * connected appenders.
       *
       * @return {void}
       */
      clear : function(){

        this.__buffer.clearHistory();
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL LOGGING IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      /** {qx.log.appender.RingBuffer} Message buffer of previously fired messages. */
      __buffer : new qx.log.appender.RingBuffer(50),
      /** {Map} Numeric translation of log levels */
      __levels : {
        debug : 0,
        info : 1,
        warn : 2,
        error : 3
      },
      /**
       * Internal logging main routine.
       *
       * @param level {String} One of "debug", "info", "warn" or "error"
       * @param args {Array} List of other arguments, where the first is
       *   taken as the context object.
       * @return {void}
       */
      __log : function(bI, bJ){

        // Filter according to level
        var bO = this.__levels;
        if(bO[bI] < bO[this.__level]){

          return;
        };
        // Serialize and cache
        var bL = bJ.length < 2 ? null : bJ[0];
        var bN = bL ? 1 : 0;
        var bK = [];
        for(var i = bN,l = bJ.length;i < l;i++){

          bK.push(this.__serialize(bJ[i], true));
        };
        // Build entry
        var bP = new Date;
        var bQ = {
          time : bP,
          offset : bP - qx.Bootstrap.LOADSTART,
          level : bI,
          items : bK,
          // store window to allow cross frame logging
          win : window
        };
        // Add relation fields
        if(bL){

          // Do not explicitly check for instanceof qx.core.Object, in order not
          // to introduce an unwanted load-time dependency
          if(bL.$$hash !== undefined){

            bQ.object = bL.$$hash;
          } else if(bL.$$type){

            bQ.clazz = bL;
          };
        };
        this.__buffer.process(bQ);
        // Send to appenders
        var bR = this.__appender;
        for(var bM in bR){

          bR[bM].process(bQ);
        };
      },
      /**
       * Detects the type of the variable given.
       *
       * @param value {var} Incoming value
       * @return {String} Type of the incoming value. Possible values:
       *   "undefined", "null", "boolean", "number", "string",
       *   "function", "array", "error", "map",
       *   "class", "instance", "node", "stringify", "unknown"
       */
      __detect : function(bS){

        if(bS === undefined){

          return w;
        } else if(bS === null){

          return m;
        };
        if(bS.$$type){

          return n;
        };
        var bT = typeof bS;
        if(bT === E || bT == p || bT === v || bT === G){

          return bT;
        } else if(bT === L){

          if(bS.nodeType){

            return J;
          } else if(bS.classname){

            return r;
          } else if(bS instanceof Array){

            return s;
          } else if(bS instanceof Error){

            return I;
          } else if(bS instanceof Date){

            return A;
          } else {

            return x;
          };;;;
        };
        if(bS.toString){

          return C;
        };
        return B;
      },
      /**
       * Serializes the incoming value. If it is a singular value, the result is
       * a simple string. For an array or a map the result can also be a
       * serialized string of a limited number of individual items.
       *
       * @param value {var} Incoming value
       * @param deep {Boolean?false} Whether arrays and maps should be
       *    serialized for a limited number of items
       * @return {Map} Contains the keys <code>type</code>, <code>text</code> and
       * <code>trace</code>.
       */
      __serialize : function(bU, bV){

        var cd = this.__detect(bU);
        var bY = B;
        var bX = [];
        switch(cd){case m:case w:
        bY = cd;
        break;case p:case v:case G:case A:
        bY = bU;
        break;case J:
        if(bU.nodeType === 9){

          bY = c;
        } else if(bU.nodeType === 3){

          bY = R + bU.nodeValue + D;
        } else if(bU.nodeType === 1){

          bY = bU.nodeName.toLowerCase();
          if(bU.id){

            bY += d + bU.id;
          };
        } else {

          bY = J;
        };;
        break;case E:
        bY = qx.lang.Function.getName(bU) || cd;
        break;case r:
        bY = bU.basename + j + bU.$$hash + D;
        break;case n:case C:
        bY = bU.toString();
        break;case I:
        bX = qx.dev.StackTrace.getStackTraceFromError(bU);
        bY = bU.toString();
        break;case s:
        if(bV){

          bY = [];
          for(var i = 0,l = bU.length;i < l;i++){

            if(bY.length > 20){

              bY.push(K + (l - i) + q);
              break;
            };
            bY.push(this.__serialize(bU[i], false));
          };
        } else {

          bY = Q + bU.length + N;
        };
        break;case x:
        if(bV){

          var bW;
          // Produce sorted key list
          var cc = [];
          for(var cb in bU){

            cc.push(cb);
          };
          cc.sort();
          // Temporary text list
          bY = [];
          for(var i = 0,l = cc.length;i < l;i++){

            if(bY.length > 20){

              bY.push(K + (l - i) + q);
              break;
            };
            // Additional storage of hash-key
            cb = cc[i];
            bW = this.__serialize(bU[cb], false);
            bW.key = cb;
            bY.push(bW);
          };
        } else {

          var ca = 0;
          for(var cb in bU){

            ca++;
          };
          bY = b + ca + O;
        };
        break;};
        return {
          type : cd,
          text : bY,
          trace : bX
        };
      }
    },
    defer : function(ce){

      var cf = qx.Bootstrap.$$logs;
      for(var i = 0;i < cf.length;i++){

        ce.__log(cf[i][0], cf[i][1]);
      };
      qx.Bootstrap.debug = ce.debug;
      qx.Bootstrap.info = ce.info;
      qx.Bootstrap.warn = ce.warn;
      qx.Bootstrap.error = ce.error;
      qx.Bootstrap.trace = ce.trace;
    }
  });
})();
(function(){

  var e = "info",d = "debug",c = "warn",b = "qx.core.MLogging",a = "error";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This mixin offers the basic logging features offered by {@link qx.log.Logger}.
   */
  qx.Mixin.define(b, {
    members : {
      /** {Class} Pointer to the regular logger class */
      __Logger : qx.log.Logger,
      /**
       * Logs a debug message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      debug : function(f){

        this.__logMessage(d, arguments);
      },
      /**
       * Logs an info message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      info : function(g){

        this.__logMessage(e, arguments);
      },
      /**
       * Logs a warning message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      warn : function(h){

        this.__logMessage(c, arguments);
      },
      /**
       * Logs an error message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      error : function(i){

        this.__logMessage(a, arguments);
      },
      /**
       * Prints the current stack trace
       *
       * @return {void}
       */
      trace : function(){

        this.__Logger.trace(this);
      },
      /**
       * Helper that calls the appropriate logger function with the current object
       * and any number of items.
       *
       * @param level {String} The log level of the message
       * @param varargs {arguments} Arguments list to be logged
       */
      __logMessage : function(j, k){

        var l = qx.lang.Array.fromArguments(k);
        l.unshift(this);
        this.__Logger[j].apply(this.__Logger, l);
      }
    }
  });
})();
(function(){

  var c = "qx.dom.Node",b = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Basic node creation and type detection
   */
  qx.Bootstrap.define(c, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /*
      ---------------------------------------------------------------------------
        NODE TYPES
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} Node type:
       *
       * * ELEMENT
       * * ATTRIBUTE
       * * TEXT
       * * CDATA_SECTION
       * * ENTITY_REFERENCE
       * * ENTITY
       * * PROCESSING_INSTRUCTION
       * * COMMENT
       * * DOCUMENT
       * * DOCUMENT_TYPE
       * * DOCUMENT_FRAGMENT
       * * NOTATION
       */
      ELEMENT : 1,
      ATTRIBUTE : 2,
      TEXT : 3,
      CDATA_SECTION : 4,
      ENTITY_REFERENCE : 5,
      ENTITY : 6,
      PROCESSING_INSTRUCTION : 7,
      COMMENT : 8,
      DOCUMENT : 9,
      DOCUMENT_TYPE : 10,
      DOCUMENT_FRAGMENT : 11,
      NOTATION : 12,
      /*
      ---------------------------------------------------------------------------
        DOCUMENT ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the owner document of the given node
       *
       * @param node {Node|Document|Window} the node which should be tested
       * @return {Document|null} The document of the given DOM node
       */
      getDocument : function(d){

        return d.nodeType === this.DOCUMENT ? d : // is document already
        d.ownerDocument || // is DOM node
        d.document;
      },
      /**
       * Returns the DOM2 <code>defaultView</code> (window).
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Window} the <code>defaultView</code> of the given node
       */
      getWindow : function(e){

        // is a window already
        if(e.nodeType == null){

          return e;
        };
        // jump to document
        if(e.nodeType !== this.DOCUMENT){

          e = e.ownerDocument;
        };
        // jump to window
        return e.defaultView || e.parentWindow;
      },
      /**
       * Returns the document element. (Logical root node)
       *
       * This is a convenience attribute that allows direct access to the child
       * node that is the root element of the document. For HTML documents,
       * this is the element with the tagName "HTML".
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Element} document element of the given node
       */
      getDocumentElement : function(f){

        return this.getDocument(f).documentElement;
      },
      /**
       * Returns the body element. (Visual root node)
       *
       * This normally only makes sense for HTML documents. It returns
       * the content area of the HTML document.
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Element} document body of the given node
       */
      getBodyElement : function(g){

        return this.getDocument(g).body;
      },
      /*
      ---------------------------------------------------------------------------
        TYPE TESTS
      ---------------------------------------------------------------------------
      */
      /**
       * Whether the given object is a DOM node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM node
       */
      isNode : function(h){

        return !!(h && h.nodeType != null);
      },
      /**
       * Whether the given object is a DOM element node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM element
       */
      isElement : function(j){

        return !!(j && j.nodeType === this.ELEMENT);
      },
      /**
       * Whether the given object is a DOM document node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true when the node is a DOM document
       */
      isDocument : function(k){

        return !!(k && k.nodeType === this.DOCUMENT);
      },
      /**
       * Whether the given object is a DOM text node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM text node
       */
      isText : function(l){

        return !!(l && l.nodeType === this.TEXT);
      },
      /**
       * Check whether the given object is a browser window object.
       *
       * @param obj {Object} the object which should be tested
       * @return {Boolean} true if the object is a window object
       */
      isWindow : function(m){

        return !!(m && m.history && m.location && m.document);
      },
      /**
       * Whether the node has the given node name
       *
       * @param node {Node} the node
       * @param nodeName {String} the node name to check for
       * @return {Boolean} Whether the node has the given node name
       */
      isNodeName : function(n, o){

        if(!o || !n || !n.nodeName){

          return false;
        };
        return o.toLowerCase() == qx.dom.Node.getName(n);
      },
      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Get the node name as lower case string
       *
       * @param node {Node} the node
       * @return {String} the node name
       */
      getName : function(p){

        if(!p || !p.nodeName){

          return null;
        };
        return p.nodeName.toLowerCase();
      },
      /**
       * Returns the text content of an node where the node may be of node type
       * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT or NODE_CDATA
       *
       * @param node {Node} the node from where the search should start.
       *     If the node has subnodes the text contents are recursively retreived and joined.
       * @return {String} the joined text content of the given node or null if not appropriate.
       * @signature function(node)
       */
      getText : function(q){

        if(!q || !q.nodeType){

          return null;
        };
        switch(q.nodeType){case 1:
        // NODE_ELEMENT
        var i,a = [],r = q.childNodes,length = r.length;
        for(i = 0;i < length;i++){

          a[i] = this.getText(r[i]);
        };
        return a.join(b);case 2:// NODE_ATTRIBUTE
        case 3:// NODE_TEXT
        case 4:
        // CDATA
        return q.nodeValue;};
        return null;
      },
      /**
       * Checks if the given node is a block node
       *
       * @param node {Node} Node
       * @return {Boolean} whether it is a block node
       */
      isBlockNode : function(s){

        if(!qx.dom.Node.isElement(s)){

          return false;
        };
        s = qx.dom.Node.getName(s);
        return /^(body|form|textarea|fieldset|ul|ol|dl|dt|dd|li|div|hr|p|h[1-6]|quote|pre|table|thead|tbody|tfoot|tr|td|th|iframe|address|blockquote)$/.test(s);
      }
    }
  });
})();
(function(){

  var m = "gecko",l = "engine.name",k = "qx.bom.Event",j = "mouseover",i = "No method available to remove native listener from ",h = "No method available to add native listener to ",g = "HTMLEvents",f = "return;",d = "qx.debug",c = "function",a = "undefined",b = "on";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
       * Alexander Steitz (aback)
       * Christian Hagendorn (chris_schmidt)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Juriy Zaytsev
       http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
  
       Copyright (c) 2009 Juriy Zaytsev
  
       Licence:
         BSD: http://github.com/kangax/iseventsupported/blob/master/LICENSE
  
       ----------------------------------------------------------------------
  
       http://github.com/kangax/iseventsupported/blob/master/LICENSE
  
       Copyright (c) 2009 Juriy Zaytsev
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without
       restriction, including without limitation the rights to use,
       copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the
       Software is furnished to do so, subject to the following
       conditions:
  
       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
       OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
       FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
       OTHER DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */
  /**
   * Wrapper around native event management capabilities of the browser.
   * This class should not be used directly normally. It's better
   * to use {@link qx.event.Registration} instead.
   */
  qx.Bootstrap.define(k, {
    statics : {
      /**
       * Use the low level browser functionality to attach event listeners
       * to DOM nodes.
       *
       * Use this with caution. This is only thought for event handlers and
       * qualified developers. These are not mem-leak protected!
       *
       * @param target {Object} Any valid native event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the function to assign
       * @param useCapture {Boolean ? false} A Boolean value that specifies the event phase to add
       *    the event handler for the capturing phase or the bubbling phase.
       */
      addNativeListener : function(n, o, p, q){

        if(n.addEventListener){

          n.addEventListener(o, p, !!q);
        } else if(n.attachEvent){

          n.attachEvent(b + o, p);
        } else if(typeof n[b + o] != a){

          n[b + o] = p;
        } else {

          if(qx.core.Environment.get(d)){

            qx.log.Logger.warn(h + n);
          };
        };;
      },
      /**
       * Use the low level browser functionality to remove event listeners
       * from DOM nodes.
       *
       * @param target {Object} Any valid native event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the function to assign
       * @param useCapture {Boolean ? false} A Boolean value that specifies the event phase to remove
       *    the event handler for the capturing phase or the bubbling phase.
       */
      removeNativeListener : function(r, s, t, u){

        if(r.removeEventListener){

          r.removeEventListener(s, t, !!u);
        } else if(r.detachEvent){

          try{

            r.detachEvent(b + s, t);
          } catch(e) {

            // IE7 sometimes dispatches "unload" events on protected windows
            // Ignore the "permission denied" errors.
            if(e.number !== -2146828218){

              throw e;
            };
          };
        } else if(typeof r[b + s] != a){

          r[b + s] = null;
        } else {

          if(qx.core.Environment.get(d)){

            qx.log.Logger.warn(i + r);
          };
        };;
      },
      /**
       * Returns the target of the event.
       *
       * @param e {Event} Native event object
       * @return {Object} Any valid native event target
       */
      getTarget : function(e){

        return e.target || e.srcElement;
      },
      /**
       * Computes the related target from the native DOM event
       *
       * @param e {Event} Native DOM event object
       * @return {Element} The related target
       */
      getRelatedTarget : function(e){

        if(e.relatedTarget !== undefined){

          // In Firefox the related target of mouse events is sometimes an
          // anonymous div inside of a text area, which raises an exception if
          // the nodeType is read. This is why the try/catch block is needed.
          if((qx.core.Environment.get(l) == m)){

            try{

              e.relatedTarget && e.relatedTarget.nodeType;
            } catch(e) {

              return null;
            };
          };
          return e.relatedTarget;
        } else if(e.fromElement !== undefined && e.type === j){

          return e.fromElement;
        } else if(e.toElement !== undefined){

          return e.toElement;
        } else {

          return null;
        };;
      },
      /**
       * Prevent the native default of the event to be processed.
       *
       * This is useful to stop native keybindings, native selection
       * and other native functionality behind events.
       *
       * @param e {Event} Native event object
       */
      preventDefault : function(e){

        if(e.preventDefault){

          e.preventDefault();
        } else {

          try{

            // this allows us to prevent some key press events in IE.
            // See bug #1049
            e.keyCode = 0;
          } catch(v) {
          };
          e.returnValue = false;
        };
      },
      /**
       * Stops the propagation of the given event to the parent element.
       *
       * Only useful for events which bubble e.g. mousedown.
       *
       * @param e {Event} Native event object
       */
      stopPropagation : function(e){

        if(e.stopPropagation){

          e.stopPropagation();
        } else {

          e.cancelBubble = true;
        };
      },
      /**
       * Fires a synthetic native event on the given element.
       *
       * @param target {Element} DOM element to fire event on
       * @param type {String} Name of the event to fire
       * @return {Boolean} A value that indicates whether any of the event handlers called {@link #preventDefault}.
       *  <code>true</code> The default action is permitted, <code>false</code> the caller should prevent the default action.
       */
      fire : function(w, x){

        // dispatch for standard first
        if(document.createEvent){

          var y = document.createEvent(g);
          y.initEvent(x, true, true);
          return !w.dispatchEvent(y);
        } else {

          var y = document.createEventObject();
          return w.fireEvent(b + x, y);
        };
      },
      /**
       * Whether the given target supports the given event type.
       *
       * Useful for testing for support of new features like
       * touch events, gesture events, orientation change, on/offline, etc.
       *
       * @signature function(target, type)
       * @param target {var} Any valid target e.g. window, dom node, etc.
       * @param type {String} Type of the event e.g. click, mousedown
       * @return {Boolean} Whether the given event is supported
       */
      supportsEvent : function(z, A){

        var B = b + A;
        var C = (B in z);
        if(!C){

          C = typeof z[B] == c;
          if(!C && z.setAttribute){

            z.setAttribute(B, f);
            C = typeof z[B] == c;
            z.removeAttribute(B);
          };
        };
        return C;
      }
    }
  });
})();
(function(){

  var k = "Failed to remove event listener for id '",j = "Invalid context for callback.",h = "Failed to add event listener for type '",g = "__handlers",f = "UNKNOWN_",e = "capture",d = "__dispatchers",c = "qx.event.Manager",b = "Could not dispatch event '",a = "DOM_",O = "No dispatcher can handle event of type ",N = "QX_",M = " to the target '",L = "Failed to remove event listener for type '",K = " on ",J = "Invalid id type.",I = "c",H = "DOCUMENT_",G = "WIN_",F = "Invalid event object.",s = "Invalid capture flag.",t = "Invalid event type.",q = "There is no event handler for the event '",r = " from the target '",o = "Invalid callback function",p = "'!",m = "Invalid event target.",n = "unload",u = "Invalid object: ",v = "'",y = "' on target '",x = "",A = "_",z = "Invalid Target.",C = "': ",B = "|",w = "|bubble",E = "|capture",D = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.bom.Event)
  
  ************************************************************************ */
  /**
   * Wrapper for browser DOM event handling for each browser window/frame.
   */
  qx.Class.define(c, {
    extend : Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Creates a new instance of the event handler.
     *
     * @param win {Window} The DOM window this manager handles the events for
     * @param registration {qx.event.Registration} The event registration to use
     */
    construct : function(P, Q){

      // Assign window object
      this.__window = P;
      this.__windowId = qx.core.ObjectRegistry.toHashCode(P);
      this.__registration = Q;
      // Register to the page unload event.
      // Only for iframes and other secondary documents.
      if(P.qx !== qx){

        var self = this;
        qx.bom.Event.addNativeListener(P, n, qx.event.GlobalError.observeMethod(function(){

          qx.bom.Event.removeNativeListener(P, n, arguments.callee);
          self.dispose();
        }));
      };
      // Registry for event listeners
      this.__listeners = {
      };
      // The handler and dispatcher instances
      this.__handlers = {
      };
      this.__dispatchers = {
      };
      this.__handlerCache = {
      };
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Last used ID for an event */
      __lastUnique : 0,
      /**
       * Returns an unique ID which may be used in combination with a target and
       * a type to identify an event entry.
       *
       * @return {String} The next free identifier (auto-incremented)
       */
      getNextUniqueId : function(){

        return (this.__lastUnique++) + x;
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __registration : null,
      __listeners : null,
      __dispatchers : null,
      __disposeWrapper : null,
      __handlers : null,
      __handlerCache : null,
      __window : null,
      __windowId : null,
      /*
      ---------------------------------------------------------------------------
        HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Get the window instance the event manager is responsible for
       *
       * @return {Window} DOM window instance
       */
      getWindow : function(){

        return this.__window;
      },
      /**
       * Get the hashcode of the manager's window
       *
       * @return {String} The window's hashcode
       */
      getWindowId : function(){

        return this.__windowId;
      },
      /**
       * Returns an instance of the given handler class for this manager(window).
       *
       * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}
       * @return {Object} The instance used by this manager
       */
      getHandler : function(R){

        var S = this.__handlers[R.classname];
        if(S){

          return S;
        };
        return this.__handlers[R.classname] = new R(this);
      },
      /**
       * Returns an instance of the given dispatcher class for this manager(window).
       *
       * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}
       * @return {Object} The instance used by this manager
       */
      getDispatcher : function(T){

        var U = this.__dispatchers[T.classname];
        if(U){

          return U;
        };
        return this.__dispatchers[T.classname] = new T(this, this.__registration);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER MANAGEMENT
      ---------------------------------------------------------------------------
      */
      /**
       * Get a copy of all event listeners for the given combination
       * of target, event type and phase.
       *
       * This method is especially useful and for event handlers to
       * to query the listeners registered in the manager.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type
       * @param capture {Boolean ? false} Whether the listener is for the
       *       capturing phase of the bubbling phase.
       * @return {Array | null} Array of registered event handlers. May return
       *       null when no listener were found.
       */
      getListeners : function(V, W, X){

        var Y = V.$$hash || qx.core.ObjectRegistry.toHashCode(V);
        var bb = this.__listeners[Y];
        if(!bb){

          return null;
        };
        var bc = W + (X ? E : w);
        var ba = bb[bc];
        return ba ? ba.concat() : null;
      },
      /**
       * Returns all registered listeners.
       *
       * @internal
       *
       * @return {Map} All registered listeners. The key is the hash code form an object.
       */
      getAllListeners : function(){

        return this.__listeners;
      },
      /**
       * Returns a serialized array of all events attached on the given target.
       *
       * @param target {Object} Any valid event target
       * @return {Map[]} Array of maps where everyone contains the keys:
       *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.
       */
      serializeListeners : function(bd){

        var bk = bd.$$hash || qx.core.ObjectRegistry.toHashCode(bd);
        var bm = this.__listeners[bk];
        var bi = [];
        if(bm){

          var bg,bl,be,bh,bj;
          for(var bf in bm){

            bg = bf.indexOf(B);
            bl = bf.substring(0, bg);
            be = bf.charAt(bg + 1) == I;
            bh = bm[bf];
            for(var i = 0,l = bh.length;i < l;i++){

              bj = bh[i];
              bi.push({
                self : bj.context,
                handler : bj.handler,
                type : bl,
                capture : be
              });
            };
          };
        };
        return bi;
      },
      /**
       * This method might be used to temporally remove all events
       * directly attached to the given target. This do not work
       * have any effect on bubbling events normally.
       *
       * This is mainly thought for detaching events in IE, before
       * cloning them. It also removes all leak scenarios
       * when unloading a document and may be used here as well.
       *
       * @internal
       * @param target {Object} Any valid event target
       * @param enable {Boolean} Whether to enable or disable the events
       */
      toggleAttachedEvents : function(bn, bo){

        var bt = bn.$$hash || qx.core.ObjectRegistry.toHashCode(bn);
        var bv = this.__listeners[bt];
        if(bv){

          var bq,bu,bp,br;
          for(var bs in bv){

            bq = bs.indexOf(B);
            bu = bs.substring(0, bq);
            bp = bs.charCodeAt(bq + 1) === 99;
            // checking for character "c".
            br = bv[bs];
            if(bo){

              this.__registerAtHandler(bn, bu, bp);
            } else {

              this.__unregisterAtHandler(bn, bu, bp);
            };
          };
        };
      },
      /**
       * Check whether there are one or more listeners for an event type
       * registered at the target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} The event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the target has event listeners of the given type.
       */
      hasListener : function(bw, bx, by){

        if(qx.core.Environment.get(D)){

          if(bw == null){

            qx.log.Logger.trace(this);
            throw new Error(u + bw);
          };
        };
        var bz = bw.$$hash || qx.core.ObjectRegistry.toHashCode(bw);
        var bB = this.__listeners[bz];
        if(!bB){

          return false;
        };
        var bC = bx + (by ? E : w);
        var bA = bB[bC];
        return !!(bA && bA.length > 0);
      },
      /**
       * Imports a list of event listeners at once. This only
       * works for newly created elements as it replaces
       * all existing data structures.
       *
       * Works with a map of data. Each entry in this map should be a
       * map again with the keys <code>type</code>, <code>listener</code>,
       * <code>self</code>, <code>capture</code> and an optional <code>unique</code>.
       *
       * The values are identical to the parameters of {@link #addListener}.
       * For details please have a look there.
       *
       * @param target {Object} Any valid event target
       * @param list {Map} A map where every listener has an unique key.
       * @return {void}
       */
      importListeners : function(bD, bE){

        if(qx.core.Environment.get(D)){

          if(bD == null){

            qx.log.Logger.trace(this);
            throw new Error(u + bD);
          };
        };
        var bK = bD.$$hash || qx.core.ObjectRegistry.toHashCode(bD);
        var bL = this.__listeners[bK] = {
        };
        var bH = qx.event.Manager;
        for(var bF in bE){

          var bI = bE[bF];
          var bJ = bI.type + (bI.capture ? E : w);
          var bG = bL[bJ];
          if(!bG){

            bG = bL[bJ] = [];
            // This is the first event listener for this type and target
            // Inform the event handler about the new event
            // they perform the event registration at DOM level if needed
            this.__registerAtHandler(bD, bI.type, bI.capture);
          };
          // Append listener to list
          bG.push({
            handler : bI.listener,
            context : bI.self,
            unique : bI.unique || (bH.__lastUnique++) + x
          });
        };
      },
      /**
       * Add an event listener to any valid target. The event listener is passed an
       * instance of {@link qx.event.type.Event} containing all relevant information
       * about the event as parameter.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event e.g. "click", "keydown", ...
       * @param listener {Function} Event listener function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque ID, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       * @throws an error if the parameters are wrong
       */
      addListener : function(bM, bN, bO, self, bP){

        if(qx.core.Environment.get(D)){

          var bT = h + bN + v + M + bM.classname + C;
          qx.core.Assert.assertObject(bM, bT + z);
          qx.core.Assert.assertString(bN, bT + t);
          qx.core.Assert.assertFunction(bO, bT + o);
          if(bP !== undefined){

            qx.core.Assert.assertBoolean(bP, s);
          };
        };
        var bU = bM.$$hash || qx.core.ObjectRegistry.toHashCode(bM);
        var bW = this.__listeners[bU];
        if(!bW){

          bW = this.__listeners[bU] = {
          };
        };
        var bS = bN + (bP ? E : w);
        var bR = bW[bS];
        if(!bR){

          bR = bW[bS] = [];
        };
        // This is the first event listener for this type and target
        // Inform the event handler about the new event
        // they perform the event registration at DOM level if needed
        if(bR.length === 0){

          this.__registerAtHandler(bM, bN, bP);
        };
        // Append listener to list
        var bV = (qx.event.Manager.__lastUnique++) + x;
        var bQ = {
          handler : bO,
          context : self,
          unique : bV
        };
        bR.push(bQ);
        return bS + B + bV;
      },
      /**
       * Get the event handler class matching the given event target and type
       *
       * @param target {var} The event target
       * @param type {String} The event type
       * @return {qx.event.IEventHandler|null} The best matching event handler or
       *     <code>null</code>.
       */
      findHandler : function(bX, bY){

        var cl = false,cd = false,cm = false,ca = false;
        var cj;
        if(bX.nodeType === 1){

          cl = true;
          cj = a + bX.tagName.toLowerCase() + A + bY;
        } else if(bX.nodeType === 9){

          ca = true;
          cj = H + bY;
        } else if(bX == this.__window){

          cd = true;
          cj = G + bY;
        } else if(bX.classname){

          cm = true;
          cj = N + bX.classname + A + bY;
        } else {

          cj = f + bX + A + bY;
        };;;
        var cf = this.__handlerCache;
        if(cf[cj]){

          return cf[cj];
        };
        var ci = this.__registration.getHandlers();
        var ce = qx.event.IEventHandler;
        var cg,ch,cc,cb;
        for(var i = 0,l = ci.length;i < l;i++){

          cg = ci[i];
          // shortcut type check
          cc = cg.SUPPORTED_TYPES;
          if(cc && !cc[bY]){

            continue;
          };
          // shortcut target check
          cb = cg.TARGET_CHECK;
          if(cb){

            // use bitwise & to compare for the bitmask!
            var ck = false;
            if(cl && ((cb & ce.TARGET_DOMNODE) != 0)){

              ck = true;
            } else if(cd && ((cb & ce.TARGET_WINDOW) != 0)){

              ck = true;
            } else if(cm && ((cb & ce.TARGET_OBJECT) != 0)){

              ck = true;
            } else if(ca && ((cb & ce.TARGET_DOCUMENT) != 0)){

              ck = true;
            };;;
            if(!ck){

              continue;
            };
          };
          ch = this.getHandler(ci[i]);
          if(cg.IGNORE_CAN_HANDLE || ch.canHandleEvent(bX, bY)){

            cf[cj] = ch;
            return ch;
          };
        };
        return null;
      },
      /**
       * This method is called each time an event listener for one of the
       * supported events is added using {qx.event.Manager#addListener}.
       *
       * @param target {Object} Any valid event target
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       * @throws an error if there is no handler for the event
       */
      __registerAtHandler : function(cn, co, cp){

        var cq = this.findHandler(cn, co);
        if(cq){

          cq.registerEvent(cn, co, cp);
          return;
        };
        if(qx.core.Environment.get(D)){

          qx.log.Logger.warn(this, q + co + y + cn + p);
        };
      },
      /**
       * Remove an event listener from an event target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the event listener
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener.
       * @param capture {Boolean ? false} Whether to remove the event listener of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed successfully (was existend)
       * @throws an error if the parameters are wrong
       */
      removeListener : function(cr, cs, ct, self, cu){

        if(qx.core.Environment.get(D)){

          var cy = L + cs + v + r + cr.classname + C;
          qx.core.Assert.assertObject(cr, cy + z);
          qx.core.Assert.assertString(cs, cy + t);
          qx.core.Assert.assertFunction(ct, cy + o);
          if(self !== undefined){

            qx.core.Assert.assertObject(self, j);
          };
          if(cu !== undefined){

            qx.core.Assert.assertBoolean(cu, s);
          };
        };
        var cz = cr.$$hash || qx.core.ObjectRegistry.toHashCode(cr);
        var cA = this.__listeners[cz];
        if(!cA){

          return false;
        };
        var cv = cs + (cu ? E : w);
        var cw = cA[cv];
        if(!cw){

          return false;
        };
        var cx;
        for(var i = 0,l = cw.length;i < l;i++){

          cx = cw[i];
          if(cx.handler === ct && cx.context === self){

            qx.lang.Array.removeAt(cw, i);
            if(cw.length == 0){

              this.__unregisterAtHandler(cr, cs, cu);
            };
            return true;
          };
        };
        return false;
      },
      /**
       * Removes an event listener from an event target by an ID returned by
       * {@link #addListener}.
       *
       * @param target {Object} The event target
       * @param id {String} The ID returned by {@link #addListener}
       */
      removeListenerById : function(cB, cC){

        if(qx.core.Environment.get(D)){

          var cI = k + cC + v + r + cB.classname + C;
          qx.core.Assert.assertObject(cB, cI + z);
          qx.core.Assert.assertString(cC, cI + J);
        };
        var cG = cC.split(B);
        var cL = cG[0];
        var cD = cG[1].charCodeAt(0) == 99;
        // detect leading "c"
        var cK = cG[2];
        var cJ = cB.$$hash || qx.core.ObjectRegistry.toHashCode(cB);
        var cM = this.__listeners[cJ];
        if(!cM){

          return false;
        };
        var cH = cL + (cD ? E : w);
        var cF = cM[cH];
        if(!cF){

          return false;
        };
        var cE;
        for(var i = 0,l = cF.length;i < l;i++){

          cE = cF[i];
          if(cE.unique === cK){

            qx.lang.Array.removeAt(cF, i);
            if(cF.length == 0){

              this.__unregisterAtHandler(cB, cL, cD);
            };
            return true;
          };
        };
        return false;
      },
      /**
       * Remove all event listeners, which are attached to the given event target.
       *
       * @param target {Object} The event target to remove all event listeners from.
       * @return {Boolean} Whether the events were existend and were removed successfully.
       */
      removeAllListeners : function(cN){

        var cR = cN.$$hash || qx.core.ObjectRegistry.toHashCode(cN);
        var cT = this.__listeners[cR];
        if(!cT){

          return false;
        };
        // Deregister from event handlers
        var cP,cS,cO;
        for(var cQ in cT){

          if(cT[cQ].length > 0){

            // This is quite expensive, see bug #1283
            cP = cQ.split(B);
            cS = cP[0];
            cO = cP[1] === e;
            this.__unregisterAtHandler(cN, cS, cO);
          };
        };
        delete this.__listeners[cR];
        return true;
      },
      /**
       * Internal helper for deleting the internal listener  data structure for
       * the given targetKey.
       *
       * @param targetKey {String} Hash code for the object to delete its
       *   listeners.
       *
       * @internal
       */
      deleteAllListeners : function(cU){

        delete this.__listeners[cU];
      },
      /**
       * This method is called each time the an event listener for one of the
       * supported events is removed by using {qx.event.Manager#removeListener}
       * and no other event listener is listening on this type.
       *
       * @param target {Object} Any valid event target
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       * @throws an error if there is no handler for the event
       */
      __unregisterAtHandler : function(cV, cW, cX){

        var cY = this.findHandler(cV, cW);
        if(cY){

          cY.unregisterEvent(cV, cW, cX);
          return;
        };
        if(qx.core.Environment.get(D)){

          qx.log.Logger.warn(this, q + cW + y + cV + p);
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCH
      ---------------------------------------------------------------------------
      */
      /**
       * Dispatches an event object using the qooxdoo event handler system. The
       * event will only be visible in event listeners attached using
       * {@link #addListener}. After dispatching the event object will be pooled
       * for later reuse or disposed.
       *
       * @param target {Object} Any valid event target
       * @param event {qx.event.type.Event} The event object to dispatch. The event
       *     object must be obtained using {@link qx.event.Registration#createEvent}
       *     and initialized using {@link qx.event.type.Event#init}.
       * @return {Boolean} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @throws an error if there is no dispatcher for the event
       */
      dispatchEvent : function(da, event){

        if(qx.core.Environment.get(D)){

          var df = b + event + y + da.classname + C;
          qx.core.Assert.assertNotUndefined(da, df + m);
          qx.core.Assert.assertNotNull(da, df + m);
          qx.core.Assert.assertInstance(event, qx.event.type.Event, df + F);
        };
        // Preparations
        var dg = event.getType();
        if(!event.getBubbles() && !this.hasListener(da, dg)){

          qx.event.Pool.getInstance().poolObject(event);
          return true;
        };
        if(!event.getTarget()){

          event.setTarget(da);
        };
        // Interation data
        var de = this.__registration.getDispatchers();
        var dd;
        // Loop through the dispatchers
        var dc = false;
        for(var i = 0,l = de.length;i < l;i++){

          dd = this.getDispatcher(de[i]);
          // Ask if the dispatcher can handle this event
          if(dd.canDispatchEvent(da, event, dg)){

            dd.dispatchEvent(da, event, dg);
            dc = true;
            break;
          };
        };
        if(!dc){

          if(qx.core.Environment.get(D)){

            qx.log.Logger.error(this, O + dg + K + da);
          };
          return true;
        };
        // check whether "preventDefault" has been called
        var db = event.getDefaultPrevented();
        // Release the event instance to the event pool
        qx.event.Pool.getInstance().poolObject(event);
        return !db;
      },
      /**
       * Dispose the event manager
       */
      dispose : function(){

        // Remove from manager list
        this.__registration.removeManager(this);
        qx.util.DisposeUtil.disposeMap(this, g);
        qx.util.DisposeUtil.disposeMap(this, d);
        // Dispose data fields
        this.__listeners = this.__window = this.__disposeWrapper = null;
        this.__registration = this.__handlerCache = null;
      }
    }
  });
})();
(function(){

  var b = "qx.event.GlobalError",a = "qx.globalErrorHandling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.core.Environment)
  
  ************************************************************************ */
  /**
   * The GlobalError class stores a reference to a global error handler function.
   *
   *  This function is called for each uncatched JavaScript exception. To enable
   *  global error handling the setting <code>qx.globalErrorHandling</code> must
   *  be enabled and an error handler must be registered.
   *  Further each JavaScript "entry point" must be wrapped with a call to
   *  {@link qx.event.GlobalError#observeMethod}.
   */
  qx.Bootstrap.define(b, {
    statics : {
      /**
       * Little helper to check if the global error handling is enabled.
       * @return {Boolean} <code>true</code>, if it is enabled.
       */
      __isGlobaErrorHandlingEnabled : function(){

        if(qx.core && qx.core.Environment){

          return qx.core.Environment.get(a);
        } else {

          return !!qx.Bootstrap.getEnvironmentSetting(a);
        };
      },
      /**
       * Set the global fallback error handler
       *
       * @param callback {Function} The error handler. The first argument is the
       *    exception, which caused the error
       * @param context {Object} The "this" context of the callback function
       */
      setErrorHandler : function(c, d){

        this.__callback = c || null;
        this.__context = d || window;
        if(this.__isGlobaErrorHandlingEnabled()){

          // wrap the original onerror
          if(c && window.onerror){

            var e = qx.Bootstrap.bind(this.__onErrorWindow, this);
            if(this.__originalOnError == null){

              this.__originalOnError = window.onerror;
            };
            var self = this;
            window.onerror = function(f, g, h){

              self.__originalOnError(f, g, h);
              e(f, g, h);
            };
          };
          if(c && !window.onerror){

            window.onerror = qx.Bootstrap.bind(this.__onErrorWindow, this);
          };
          // reset
          if(this.__callback == null){

            if(this.__originalOnError != null){

              window.onerror = this.__originalOnError;
              this.__originalOnError = null;
            } else {

              window.onerror = null;
            };
          };
        };
      },
      /**
       * Catches all errors of the <code>window.onerror</code> handler
       * and passes an {@link qx.core.WindowError} object to the error
       * handling.
       *
       * @param msg {String} browser error message
       * @param uri {String} uri to errornous script
       * @param lineNumber {Integer} line number of error
       */
      __onErrorWindow : function(i, j, k){

        if(this.__callback){

          this.handleError(new qx.core.WindowError(i, j, k));
          return true;
        };
      },
      /**
       * Wraps a method with error handling code. Only methods, which are called
       * directly by the browser (e.g. event handler) should be wrapped.
       *
       * @param method {Function} method to wrap
       * @return {Function} The function wrapped with error handling code
       */
      observeMethod : function(l){

        if(this.__isGlobaErrorHandlingEnabled()){

          var self = this;
          return function(){

            if(!self.__callback){

              return l.apply(this, arguments);
            };
            try{

              return l.apply(this, arguments);
            } catch(m) {

              self.handleError(new qx.core.GlobalError(m, arguments));
            };
          };
        } else {

          return l;
        };
      },
      /**
       * Delegates every given exception to the registered error handler
       *
       * @param ex {qx.core.WindowError|exception} Exception to delegate
       */
      handleError : function(n){

        if(this.__callback){

          this.__callback.call(this.__context, n);
        };
      }
    },
    defer : function(o){

      // only use the environment class if already loaded
      if(qx.core && qx.core.Environment){

        qx.core.Environment.add(a, true);
      } else {

        qx.Bootstrap.setEnvironmentSetting(a, true);
      };
      o.setErrorHandler(null, null);
    }
  });
})();
(function(){

  var b = "",a = "qx.core.WindowError";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This exception is thrown by the {@link qx.event.GlobalError} handler if a
   * <code>window.onerror</code> event occurs in the browser.
   */
  qx.Bootstrap.define(a, {
    extend : Error,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param failMessage {String} The error message
     * @param uri {String} URI where error was raised
     * @param lineNumber {Integer} The line number where the error was raised
     */
    construct : function(c, d, e){

      var f = Error.call(this, c);
      // map stack trace properties since they're not added by Error's constructor
      if(f.stack){

        this.stack = f.stack;
      };
      if(f.stacktrace){

        this.stacktrace = f.stacktrace;
      };
      this.__failMessage = c;
      this.__uri = d || b;
      this.__lineNumber = e === undefined ? -1 : e;
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __failMessage : null,
      __uri : null,
      __lineNumber : null,
      /**
       * Returns the error message.
       *
       * @return {String} error message
       */
      toString : function(){

        return this.__failMessage;
      },
      /**
       * Get the URI where error was raised
       *
       * @return {String} URI where error was raised
       */
      getUri : function(){

        return this.__uri;
      },
      /**
       * Get the line number where the error was raised
       *
       * @return {Integer} The line number where the error was raised
       */
      getLineNumber : function(){

        return this.__lineNumber;
      }
    }
  });
})();
(function(){

  var b = "GlobalError: ",a = "qx.core.GlobalError";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Michael Haitz (mhaitz)
  
  ************************************************************************ */
  /**
   * This exception is thrown by the {@link qx.event.GlobalError} handler if a
   * observed method throws an exception.
   */
  qx.Bootstrap.define(a, {
    extend : Error,
    /**
     * @param exc {Error} source exception
     * @param args {Array} arguments
     */
    construct : function(c, d){

      // Do not use the Environment class to keep the minimal
      // package size small [BUG #5068]
      if(qx.Bootstrap.DEBUG){

        qx.core.Assert.assertNotUndefined(c);
      };
      this.__failMessage = b + (c && c.message ? c.message : c);
      var e = Error.call(this, this.__failMessage);
      // map stack trace properties since they're not added by Error's constructor
      if(e.stack){

        this.stack = e.stack;
      };
      if(e.stacktrace){

        this.stacktrace = e.stacktrace;
      };
      this.__arguments = d;
      this.__exc = c;
    },
    members : {
      __exc : null,
      __arguments : null,
      __failMessage : null,
      /**
       * Returns the error message.
       *
       * @return {String} error message
       */
      toString : function(){

        return this.__failMessage;
      },
      /**
       * Returns the arguments which are
       *
       * @return {Object} arguments
       */
      getArguments : function(){

        return this.__arguments;
      },
      /**
       * Get the source exception
       *
       * @return {Error} source exception
       */
      getSourceException : function(){

        return this.__exc;
      }
    },
    destruct : function(){

      this.__exc = null;
      this.__arguments = null;
      this.__failMessage = null;
    }
  });
})();
(function(){

  var a = "qx.event.IEventHandler";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Event handler Interface.
   *
   * All custom event handler like mouse or keyboard event handler must implement
   * this interface.
   */
  qx.Interface.define(a, {
    statics : {
      /** {Integer} The event target must be a dom node */
      TARGET_DOMNODE : 1,
      /** {Integer} The event target must be a window object */
      TARGET_WINDOW : 2,
      /** {Integer} The event target must be a qooxdoo object */
      TARGET_OBJECT : 4,
      /** {Integer} The event target must be a document node */
      TARGET_DOCUMENT : 8
    },
    members : {
      /**
       * Whether the event handler can handle events of the given type. If the
       * event handler class has a static variable called <code>IGNORE_CAN_HANDLE</code>
       * with the value <code>true</code> this function is not called. Whether the
       * handler can handle the event is them only determined by the static variables
       * <code>SUPPORTED_TYPES</code> and <code>TARGET_CHECK</code>.
       *
       * @param target {var} The target to, which the event handler should
       *     be attached
       * @param type {String} event type
       * @return {Boolean} Whether the event handler can handle events of the
       *     given type.
       */
      canHandleEvent : function(b, c){
      },
      /**
       * This method is called each time an event listener, for one of the
       * supported events, is added using {@link qx.event.Manager#addListener}.
       *
       * @param target {var} The target to, which the event handler should
       *     be attached
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       */
      registerEvent : function(d, e, f){
      },
      /**
       * This method is called each time an event listener, for one of the
       * supported events, is removed by using {@link qx.event.Manager#removeListener}
       * and no other event listener is listening on this type.
       *
       * @param target {var} The target from, which the event handler should
       *     be removed
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       */
      unregisterEvent : function(g, h, i){
      }
    }
  });
})();
(function(){

  var n = "Invalid event dispatcher!",m = "': ",l = "Invalid event handler.",k = "' on target '",j = "Could not fire event '",i = "qx.event.Registration.getManager(null) was called!",h = "undefined",g = "qx.event.Registration",f = "Invalid event target.",e = "Create event of type ",c = " with undefined class. Please use null to explicit fallback to default event type!",d = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.Manager)
  #require(qx.dom.Node)
  #require(qx.lang.Function)
  
  ************************************************************************ */
  /**
   * Wrapper for browser generic event handling.
   *
   * Supported events differ from target to target. Generally the handlers
   * in {@link qx.event.handler} defines the available features.
   *
   */
  qx.Class.define(g, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Static list of all instantiated event managers. The key is the qooxdoo
       * hash value of the corresponding window
       */
      __managers : {
      },
      /**
       * Get an instance of the event manager, which can handle events for the
       * given target.
       *
       * @param target {Object} Any valid event target
       * @return {qx.event.Manager} The event manger for the target.
       */
      getManager : function(o){

        if(o == null){

          if(qx.core.Environment.get(d)){

            qx.log.Logger.error(i);
            qx.log.Logger.trace(this);
          };
          o = window;
        } else if(o.nodeType){

          o = qx.dom.Node.getWindow(o);
        } else if(!qx.dom.Node.isWindow(o)){

          o = window;
        };;
        var q = o.$$hash || qx.core.ObjectRegistry.toHashCode(o);
        var p = this.__managers[q];
        if(!p){

          p = new qx.event.Manager(o, this);
          this.__managers[q] = p;
        };
        return p;
      },
      /**
       * Removes a manager for a specific window from the list.
       *
       * Normally only used when the manager gets disposed through
       * an unload event of the attached window.
       *
       * @param mgr {qx.event.Manager} The manager to remove
       * @return {void}
       */
      removeManager : function(r){

        var s = r.getWindowId();
        delete this.__managers[s];
      },
      /**
       * Add an event listener to a DOM target. The event listener is passed an
       * instance of {@link qx.event.type.Event} containing all relevant information
       * about the event as parameter.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event e.g. "click", "keydown", ...
       * @param listener {Function} Event listener function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {var} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListener : function(t, u, v, self, w){

        return this.getManager(t).addListener(t, u, v, self, w);
      },
      /**
       * Remove an event listener from an event target.
       *
       * Note: All registered event listeners will automatically at page unload
       *   so it is not necessary to detach events in the destructor.
       *
       * @param target {Object} The event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the event listener
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener.
       * @param capture {Boolean} Whether to remove the event listener of
       *    the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed. Return <code>false</code> if
       *    the event was already removed before.
       */
      removeListener : function(x, y, z, self, A){

        return this.getManager(x).removeListener(x, y, z, self, A);
      },
      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param target {Object} The event target
       * @param id {var} The id returned by {@link #addListener}
       * @return {Boolean} Whether the event was removed. Return <code>false</code> if
       *    the event was already removed before.
       */
      removeListenerById : function(B, C){

        return this.getManager(B).removeListenerById(B, C);
      },
      /**
       * Remove all event listeners, which are attached to the given event target.
       *
       * @param target {Object} The event target to remove all event listeners from.
       * @return {Boolean} Whether the events were existend and were removed successfully.
       */
      removeAllListeners : function(D){

        return this.getManager(D).removeAllListeners(D);
      },
      /**
       * Internal helper for deleting the listeners map used during shutdown.
       *
       * @param target {Object} The event target to delete the internal map for
       *    all event listeners.
       *
       * @internal
       */
      deleteAllListeners : function(E){

        var F = E.$$hash;
        if(F){

          this.getManager(E).deleteAllListeners(F);
        };
      },
      /**
       * Check whether there are one or more listeners for an event type
       * registered at the target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} The event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the target has event listeners of the given type.
       */
      hasListener : function(G, H, I){

        return this.getManager(G).hasListener(G, H, I);
      },
      /**
       * Returns a serialized array of all events attached on the given target.
       *
       * @param target {Object} Any valid event target
       * @return {Map[]} Array of maps where everyone contains the keys:
       *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.
       */
      serializeListeners : function(J){

        return this.getManager(J).serializeListeners(J);
      },
      /**
       * Get an event instance of the given class, which can be dispatched using
       * an event manager. The created events must be initialized using
       * {@link qx.event.type.Event#init}.
       *
       * @param type {String} The type of the event to create
       * @param clazz {Object?qx.event.type.Event} The event class to use
       * @param args {Array?null} Array which will be passed to
       *       the event's init method.
       * @return {qx.event.type.Event} An instance of the given class.
       */
      createEvent : function(K, L, M){

        if(qx.core.Environment.get(d)){

          if(arguments.length > 1 && L === undefined){

            throw new Error(e + K + c);
          };
        };
        // Fallback to default
        if(L == null){

          L = qx.event.type.Event;
        };
        var N = qx.event.Pool.getInstance().getObject(L);
        // Initialize with given arguments
        M ? N.init.apply(N, M) : N.init();
        // Setup the type
        // Note: Native event may setup this later or using init() above
        // using the native information.
        if(K){

          N.setType(K);
        };
        return N;
      },
      /**
       * Dispatch an event object on the given target.
       *
       * It is normally better to use {@link #fireEvent} because it uses
       * the event pooling and is quite handy otherwise as well. After dispatching
       * the event object will be pooled for later reuse or disposed.
       *
       * @param target {Object} Any valid event target
       * @param event {qx.event.type.Event} The event object to dispatch. The event
       *       object must be obtained using {@link #createEvent} and initialized
       *       using {@link qx.event.type.Event#init}.
       * @return {Boolean} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      dispatchEvent : function(O, event){

        return this.getManager(O).dispatchEvent(O, event);
      },
      /**
       * Create an event object and dispatch it on the given target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @see #createEvent
       */
      fireEvent : function(P, Q, R, S){

        if(qx.core.Environment.get(d)){

          if(arguments.length > 2 && R === undefined && S !== undefined){

            throw new Error(e + Q + c);
          };
          var T = j + Q + k + (P ? P.classname : h) + m;
          qx.core.Assert.assertNotUndefined(P, T + f);
          qx.core.Assert.assertNotNull(P, T + f);
        };
        var U = this.createEvent(Q, R || null, S);
        return this.getManager(P).dispatchEvent(P, U);
      },
      /**
       * Create an event object and dispatch it on the given target.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @see #createEvent
       */
      fireNonBubblingEvent : function(V, W, X, Y){

        if(qx.core.Environment.get(d)){

          if(arguments.length > 2 && X === undefined && Y !== undefined){

            throw new Error(e + W + c);
          };
        };
        var ba = this.getManager(V);
        if(!ba.hasListener(V, W, false)){

          return true;
        };
        var bb = this.createEvent(W, X || null, Y);
        return ba.dispatchEvent(V, bb);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER/DISPATCHER PRIORITY
      ---------------------------------------------------------------------------
      */
      /** {Integer} Highest priority. Used by handlers and dispatchers. */
      PRIORITY_FIRST : -32000,
      /** {Integer} Default priority. Used by handlers and dispatchers. */
      PRIORITY_NORMAL : 0,
      /** {Integer} Lowest priority. Used by handlers and dispatchers. */
      PRIORITY_LAST : 32000,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER REGISTRATION
      ---------------------------------------------------------------------------
      */
      /** {Array} Contains all known event handlers */
      __handlers : [],
      /**
       * Register an event handler.
       *
       * @param handler {qx.event.IEventHandler} Event handler to add
       * @return {void}
       * @throws an error if the handler does not have the IEventHandler interface.
       */
      addHandler : function(bc){

        if(qx.core.Environment.get(d)){

          qx.core.Assert.assertInterface(bc, qx.event.IEventHandler, l);
        };
        // Append to list
        this.__handlers.push(bc);
        // Re-sort list
        this.__handlers.sort(function(a, b){

          return a.PRIORITY - b.PRIORITY;
        });
      },
      /**
       * Get a list of registered event handlers.
       *
       * @return {qx.event.IEventHandler[]} registered event handlers
       */
      getHandlers : function(){

        return this.__handlers;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER REGISTRATION
      ---------------------------------------------------------------------------
      */
      /** {Array} Contains all known event dispatchers */
      __dispatchers : [],
      /**
       * Register an event dispatcher.
       *
       * @param dispatcher {qx.event.IEventDispatcher} Event dispatcher to add
       * @param priority {Integer} One of
       * {@link qx.event.Registration#PRIORITY_FIRST},
       * {@link qx.event.Registration#PRIORITY_NORMAL}
       *       or {@link qx.event.Registration#PRIORITY_LAST}.
       * @return {void}
       * @throws an error if the dispatcher does not have the IEventHandler interface.
       */
      addDispatcher : function(bd, be){

        if(qx.core.Environment.get(d)){

          qx.core.Assert.assertInterface(bd, qx.event.IEventDispatcher, n);
        };
        // Append to list
        this.__dispatchers.push(bd);
        // Re-sort list
        this.__dispatchers.sort(function(a, b){

          return a.PRIORITY - b.PRIORITY;
        });
      },
      /**
       * Get a list of registered event dispatchers.
       *
       * @return {qx.event.IEventDispatcher[]} all registered event dispatcher
       */
      getDispatchers : function(){

        return this.__dispatchers;
      }
    }
  });
})();
(function(){

  var a = "qx.core.MEvents";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.event.dispatch.Direct)
  #use(qx.event.handler.Object)
  
  ************************************************************************ */
  /**
   * This mixin offers basic event handling capabilities. It includes the
   * commonly known methods for managing event listeners and firing events.
   */
  qx.Mixin.define(a, {
    members : {
      /** {Class} Pointer to the regular event registration class */
      __Registration : qx.event.Registration,
      /**
       * Add event listener to this object.
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListener : function(b, c, self, d){

        if(!this.$$disposed){

          return this.__Registration.addListener(this, b, c, self, d);
        };
        return null;
      },
      /**
       * Add event listener to this object, which is only called once. After the
       * listener is called the event listener gets removed.
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param self {Object ? window} reference to the 'this' variable inside the callback
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListenerOnce : function(f, g, self, h){

        var i = function(e){

          this.removeListener(f, i, this, h);
          g.call(self || this, e);
        };
        g.$$wrapped_callback = i;
        return this.addListener(f, i, this, h);
      },
      /**
       * Remove event listener from this object
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param self {Object ? null} reference to the 'this' variable inside the callback
       * @param capture {Boolean} Whether to remove the event listener of
       *   the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed successfully (has existed)
       */
      removeListener : function(j, k, self, l){

        if(!this.$$disposed){

          // special handling for wrapped once listener
          if(k.$$wrapped_callback){

            var m = k.$$wrapped_callback;
            delete k.$$wrapped_callback;
            k = m;
          };
          return this.__Registration.removeListener(this, j, k, self, l);
        };
        return false;
      },
      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param id {String} The id returned by {@link #addListener}
       * @return {Boolean} Whether the event was removed successfully (has existed)
       */
      removeListenerById : function(n){

        if(!this.$$disposed){

          return this.__Registration.removeListenerById(this, n);
        };
        return false;
      },
      /**
       * Check if there are one or more listeners for an event type.
       *
       * @param type {String} name of the event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the object has a listener of the given type.
       */
      hasListener : function(o, p){

        return this.__Registration.hasListener(this, o, p);
      },
      /**
       * Dispatch an event on this object
       *
       * @param evt {qx.event.type.Event} event to dispatch
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      dispatchEvent : function(q){

        if(!this.$$disposed){

          return this.__Registration.dispatchEvent(this, q);
        };
        return true;
      },
      /**
       * Creates and dispatches an event on this object.
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireEvent : function(r, s, t){

        if(!this.$$disposed){

          return this.__Registration.fireEvent(this, r, s, t);
        };
        return true;
      },
      /**
       * Create an event object and dispatch it on this object.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireNonBubblingEvent : function(u, v, w){

        if(!this.$$disposed){

          return this.__Registration.fireNonBubblingEvent(this, u, v, w);
        };
        return true;
      },
      /**
       * Creates and dispatches an non-bubbling data event on this object.
       *
       * @param type {String} Event type to fire
       * @param data {var} User defined data attached to the event object
       * @param oldData {var?null} The event's old data (optional)
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireDataEvent : function(x, y, z, A){

        if(!this.$$disposed){

          if(z === undefined){

            z = null;
          };
          return this.__Registration.fireNonBubblingEvent(this, x, qx.event.type.Data, [y, z, !!A]);
        };
        return true;
      }
    }
  });
})();
(function(){

  var a = "qx.event.IEventDispatcher";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * All event dispatchers must implement this interface. Event dispatchers must
   * register themselves at the event Manager using
   * {@link qx.event.Registration#addDispatcher}.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Whether the dispatcher is responsible for the this event.
       *
       * @param target {Element|qx.core.Event} The event dispatch target
       * @param event {qx.event.type.Event} The event object
       * @param type {String} the event type
       * @return {Boolean} Whether the event dispatcher is responsible for the this event
       */
      canDispatchEvent : function(b, event, c){

        this.assertInstance(event, qx.event.type.Event);
        this.assertString(c);
      },
      /**
       * This function dispatches the event to the event listeners.
       *
       * @param target {Element|qx.core.Event} The event dispatch target
       * @param event {qx.event.type.Event} event object to dispatch
       * @param type {String} the event type
       */
      dispatchEvent : function(d, event, e){

        this.assertInstance(event, qx.event.type.Event);
        this.assertString(e);
      }
    }
  });
})();
(function(){

  var e = "qx.core.MProperty",d = "get",c = "reset",b = "No such property: ",a = "set";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This mixin offers the bacis property features which include generic
   * setter, getter and resetter.
   */
  qx.Mixin.define(e, {
    members : {
      /**
       * Sets multiple properties at once by using a property list or
       * sets one property and its value by the first and second argument.
       * As a fallback, if no generated property setter could be found, a
       * handwritten setter will be searched and invoked if available.
       *
       * @param data {Map | String} a map of property values. The key is the name of the property.
       * @param value {var?} the value, only used when <code>data</code> is a string.
       * @return {Object} this instance.
       * @throws an Exception if a property defined does not exist
       */
      set : function(f, g){

        var i = qx.core.Property.$$method.set;
        if(qx.Bootstrap.isString(f)){

          if(!this[i[f]]){

            if(this[a + qx.Bootstrap.firstUp(f)] != undefined){

              this[a + qx.Bootstrap.firstUp(f)](g);
              return this;
            };
            throw new Error(b + f);
          };
          return this[i[f]](g);
        } else {

          for(var h in f){

            if(!this[i[h]]){

              if(this[a + qx.Bootstrap.firstUp(h)] != undefined){

                this[a + qx.Bootstrap.firstUp(h)](f[h]);
                continue;
              };
              throw new Error(b + h);
            };
            this[i[h]](f[h]);
          };
          return this;
        };
      },
      /**
       * Returns the value of the given property. If no generated getter could be
       * found, a fallback tries to access a handwritten getter.
       *
       * @param prop {String} Name of the property.
       * @return {var} The value of the value
       * @throws an Exception if a property defined does not exist
       */
      get : function(j){

        var k = qx.core.Property.$$method.get;
        if(!this[k[j]]){

          if(this[d + qx.Bootstrap.firstUp(j)] != undefined){

            return this[d + qx.Bootstrap.firstUp(j)]();
          };
          throw new Error(b + j);
        };
        return this[k[j]]();
      },
      /**
       * Resets the value of the given property. If no generated resetter could be
       * found, a handwritten resetter will be invoked, if available.
       *
       * @param prop {String} Name of the property.
       * @throws an Exception if a property defined does not exist
       */
      reset : function(l){

        var m = qx.core.Property.$$method.reset;
        if(!this[m[l]]){

          if(this[c + qx.Bootstrap.firstUp(l)] != undefined){

            this[c + qx.Bootstrap.firstUp(l)]();
            return;
          };
          throw new Error(b + l);
        };
        this[m[l]]();
      }
    }
  });
})();
(function(){

  var a = "qx.core.MAssert";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.core.Assert)
  
  ************************************************************************ */
  /**
   * This mixin includes all assertions from {@link qx.core.Assert} to conveniently
   * call assertions. It is included into {@link qx.core.Object} if debugging code
   * is enabled. It is further included into all unit tests
   * {@link qx.dev.unit.TestCase}.
   */
  qx.Mixin.define(a, {
    members : {
      /**
       * Assert that the condition evaluates to <code>true</code>.
       *
       * @param condition {var} Condition to check for. Must evaluate to
       *    <code>true</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assert : function(b, c){

        qx.core.Assert.assert(b, c);
      },
      /**
       * Raise an {@link AssertionError}
       *
       * @param msg {String} Message to be shown if the assertion fails.
       * @param compact {Boolean} Show less verbose message. Default: false.
       */
      fail : function(d, e){

        qx.core.Assert.fail(d, e);
      },
      /**
       * Assert that the value is <code>true</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>true</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertTrue : function(f, g){

        qx.core.Assert.assertTrue(f, g);
      },
      /**
       * Assert that the value is <code>false</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>false</code>.
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertFalse : function(h, i){

        qx.core.Assert.assertFalse(h, i);
      },
      /**
       * Assert that both values are equal. (Uses the equality operator
       * <code>==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertEquals : function(j, k, l){

        qx.core.Assert.assertEquals(j, k, l);
      },
      /**
       * Assert that both values are not equal. (Uses the not equality operator
       * <code>!=</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotEquals : function(m, n, o){

        qx.core.Assert.assertNotEquals(m, n, o);
      },
      /**
       * Assert that both values are identical. (Uses the identity operator
       * <code>===</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertIdentical : function(p, q, r){

        qx.core.Assert.assertIdentical(p, q, r);
      },
      /**
       * Assert that both values are not identical. (Uses the not identity operator
       * <code>!==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotIdentical : function(s, t, u){

        qx.core.Assert.assertNotIdentical(s, t, u);
      },
      /**
       * Assert that the value is not <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotUndefined : function(v, w){

        qx.core.Assert.assertNotUndefined(v, w);
      },
      /**
       * Assert that the value is <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertUndefined : function(x, y){

        qx.core.Assert.assertUndefined(x, y);
      },
      /**
       * Assert that the value is not <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNotNull : function(z, A){

        qx.core.Assert.assertNotNull(z, A);
      },
      /**
       * Assert that the value is <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNull : function(B, C){

        qx.core.Assert.assertNull(B, C);
      },
      /**
       * Assert that the first two arguments are equal, when serialized into
       * JSON.
       *
       * @param expected {var} The expected value
       * @param found {var} The found value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertJsonEquals : function(D, E, F){

        qx.core.Assert.assertJsonEquals(D, E, F);
      },
      /**
       * Assert that the given string matches the regular expression
       *
       * @param str {String} String, which should match the regular expression
       * @param re {RegExp} Regular expression to match
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertMatch : function(G, H, I){

        qx.core.Assert.assertMatch(G, H, I);
      },
      /**
       * Assert that the number of arguments is within the given range
       *
       * @param args {arguments} The <code>arguments<code> variable of a function
       * @param minCount {Integer} Minimal number of arguments
       * @param maxCount {Integer} Maximum number of arguments
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArgumentsCount : function(J, K, L, M){

        qx.core.Assert.assertArgumentsCount(J, K, L, M);
      },
      /**
       * Assert that an event is fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   fires the event.
       * @param listener {Function?null} The function which will be invoked in the
       *   listener. The function has one parameter called e which is the event.
       * @param msg {String?""} Message to be shows if the assertion fails.
       */
      assertEventFired : function(N, event, O, P, Q){

        qx.core.Assert.assertEventFired(N, event, O, P, Q);
      },
      /**
       * Assert that an event is not fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   should not fire the event.
       * @param msg {String} Message to be shows if the assertion fails.
       */
      assertEventNotFired : function(R, event, S, T){

        qx.core.Assert.assertEventNotFired(R, event, S, T);
      },
      /**
       * Asserts that the callback raises a matching exception.
       *
       * @param callback {Function} function to check
       * @param exception {Error?Error} Expected constructor of the exception.
       *   The assertion fails if the raised exception is not an instance of the
       *   parameter.
       * @param re {String|RegExp} The assertion fails if the error message does
       *   not match this parameter
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertException : function(U, V, W, X){

        qx.core.Assert.assertException(U, V, W, X);
      },
      /**
       * Assert that the value is an item in the given array.
       *
       * @param value {var} Value to check
       * @param array {Array} List of valid values
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInArray : function(Y, ba, bb){

        qx.core.Assert.assertInArray(Y, ba, bb);
      },
      /**
       * Assert that both array have identical array items.
       *
       * @param expected {Array} The expected array
       * @param found {Array} The found array
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArrayEquals : function(bc, bd, be){

        qx.core.Assert.assertArrayEquals(bc, bd, be);
      },
      /**
       * Assert that the value is a key in the given map.
       *
       * @param value {var} Value to check
       * @param map {map} Map, where the keys represent the valid values
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertKeyInMap : function(bf, bg, bh){

        qx.core.Assert.assertKeyInMap(bf, bg, bh);
      },
      /**
       * Assert that the value is a function.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertFunction : function(bi, bj){

        qx.core.Assert.assertFunction(bi, bj);
      },
      /**
       * Assert that the value is a string.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertString : function(bk, bl){

        qx.core.Assert.assertString(bk, bl);
      },
      /**
       * Assert that the value is a boolean.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertBoolean : function(bm, bn){

        qx.core.Assert.assertBoolean(bm, bn);
      },
      /**
       * Assert that the value is a number.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertNumber : function(bo, bp){

        qx.core.Assert.assertNumber(bo, bp);
      },
      /**
       * Assert that the value is a number >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertPositiveNumber : function(bq, br){

        qx.core.Assert.assertPositiveNumber(bq, br);
      },
      /**
       * Assert that the value is an integer.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInteger : function(bs, bt){

        qx.core.Assert.assertInteger(bs, bt);
      },
      /**
       * Assert that the value is an integer >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertPositiveInteger : function(bu, bv){

        qx.core.Assert.assertPositiveInteger(bu, bv);
      },
      /**
       * Assert that the value is inside the given range.
       *
       * @param value {var} Value to check
       * @param min {Number} lower bound
       * @param max {Number} upper bound
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInRange : function(bw, bx, by, bz){

        qx.core.Assert.assertInRange(bw, bx, by, bz);
      },
      /**
       * Assert that the value is an object.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertObject : function(bA, bB){

        qx.core.Assert.assertObject(bA, bB);
      },
      /**
       * Assert that the value is an array.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertArray : function(bC, bD){

        qx.core.Assert.assertArray(bC, bD);
      },
      /**
       * Assert that the value is a map either created using <code>new Object</code>
       * or by using the object literal notation <code>{ ... }</code>.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertMap : function(bE, bF){

        qx.core.Assert.assertMap(bE, bF);
      },
      /**
       * Assert that the value is a regular expression.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertRegExp : function(bG, bH){

        qx.core.Assert.assertRegExp(bG, bH);
      },
      /**
       * Assert that the value has the given type using the <code>typeof</code>
       * operator. Because the type is not always what it is supposed to be it is
       * better to use more explicit checks like {@link #assertString} or
       * {@link #assertArray}.
       *
       * @param value {var} Value to check
       * @param type {String} expected type of the value
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertType : function(bI, bJ, bK){

        qx.core.Assert.assertType(bI, bJ, bK);
      },
      /**
       * Assert that the value is an instance of the given class.
       *
       * @param value {var} Value to check
       * @param clazz {Class} The value must be an instance of this class
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInstance : function(bL, bM, bN){

        qx.core.Assert.assertInstance(bL, bM, bN);
      },
      /**
       * Assert that the value implements the given interface.
       *
       * @param value {var} Value to check
       * @param iface {Class} The value must implement this interface
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertInterface : function(bO, bP, bQ){

        qx.core.Assert.assertInterface(bO, bP, bQ);
      },
      /**
       * Assert that the value represents the given CSS color value. This method
       * parses the color strings and compares the RGB values. It is able to
       * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.
       *
       *  @param expected {String} The expected color
       *  @param value {String} The value to check
       *  @param msg {String} Message to be shown if the assertion fails.
       */
      assertCssColor : function(bR, bS, bT){

        qx.core.Assert.assertCssColor(bR, bS, bT);
      },
      /**
       * Assert that the value is a DOM element.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertElement : function(bU, bV){

        qx.core.Assert.assertElement(bU, bV);
      },
      /**
       * Assert that the value is an instance of {@link qx.core.Object}.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertQxObject : function(bW, bX){

        qx.core.Assert.assertQxObject(bW, bX);
      },
      /**
       * Assert that the value is an instance of {@link qx.ui.core.Widget}.
       *
       * @param value {var} Value to check
       * @param msg {String} Message to be shown if the assertion fails.
       */
      assertQxWidget : function(bY, ca){

        qx.core.Assert.assertQxWidget(bY, ca);
      }
    }
  });
})();
(function(){

  var t = "module.events",s = "Cloning only possible with properties.",r = "qx.core.Object",q = "$$user_",p = "Disposing ",o = "Cannot call super class. Method is not derived: ",n = "object",m = "Object",k = "]: ",j = "]",c = "rv:1.8.1",h = "' in ",f = "Missing destruct definition for '",b = "MSIE 6.0",a = "module.property",e = "qx.debug",d = "qx.debug.dispose.level",g = "[";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.core.ObjectRegistry)
  
  ************************************************************************ */
  /**
   * The qooxdoo root class. All other classes are direct or indirect subclasses of this one.
   *
   * This class contains methods for:
   *
   * * object management (creation and destruction)
   * * interfaces for event system
   * * generic setter/getter support
   * * interfaces for logging console
   * * user friendly OO interfaces like {@link #self} or {@link #base}
   */
  qx.Class.define(r, {
    extend : Object,
    include : qx.core.Environment.filter({
      "module.databinding" : qx.data.MBinding,
      "module.logger" : qx.core.MLogging,
      "module.events" : qx.core.MEvents,
      "module.property" : qx.core.MProperty,
      "qx.debug" : qx.core.MAssert
    }),
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     */
    construct : function(){

      qx.core.ObjectRegistry.register(this);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Internal type */
      $$type : m
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __Property : qx.core.Environment.get(a) ? qx.core.Property : null,
      /*
      ---------------------------------------------------------------------------
        BASICS
      ---------------------------------------------------------------------------
      */
      /**
       * Return unique hash code of object
       *
       * @return {Integer} unique hash code of the object
       */
      toHashCode : function(){

        return this.$$hash;
      },
      /**
       * Returns a string representation of the qooxdoo object.
       *
       * @return {String} string representation of the object
       */
      toString : function(){

        return this.classname + g + this.$$hash + j;
      },
      /**
       * Call the same method of the super class.
       *
       * @param args {arguments} the arguments variable of the calling method
       * @param varags {var} variable number of arguments passed to the overwritten function
       * @return {var} the return value of the method of the base class.
       */
      base : function(u, v){

        if(qx.core.Environment.get(e)){

          if(!qx.Bootstrap.isFunction(u.callee.base)){

            throw new Error(o + u.callee.displayName);
          };
        };
        if(arguments.length === 1){

          return u.callee.base.call(this);
        } else {

          return u.callee.base.apply(this, Array.prototype.slice.call(arguments, 1));
        };
      },
      /**
       * Returns the static class (to access static members of this class)
       *
       * @param args {arguments} the arguments variable of the calling method
       * @return {var} the return value of the method of the base class.
       */
      self : function(w){

        return w.callee.self;
      },
      /*
      ---------------------------------------------------------------------------
        CLONE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * EXPERIMENTAL - NOT READY FOR PRODUCTION
       *
       * Returns a clone of this object. Copies over all user configured
       * property values. Do not configure a parent nor apply the appearance
       * styles directly.
       *
       * @return {qx.core.Object} The clone
       */
      clone : function(){

        if(!qx.core.Environment.get(a)){

          throw new Error(s);
        };
        var y = this.constructor;
        var x = new y;
        var A = qx.Class.getProperties(y);
        var z = this.__Property.$$store.user;
        var B = this.__Property.$$method.set;
        var name;
        // Iterate through properties
        for(var i = 0,l = A.length;i < l;i++){

          name = A[i];
          if(this.hasOwnProperty(z[name])){

            x[B[name]](this[z[name]]);
          };
        };
        // Return clone
        return x;
      },
      /*
      ---------------------------------------------------------------------------
        USER DATA
      ---------------------------------------------------------------------------
      */
      /** {Map} stored user data */
      __userData : null,
      /**
       * Store user defined data inside the object.
       *
       * @param key {String} the key
       * @param value {Object} the value of the user data
       * @return {void}
       */
      setUserData : function(C, D){

        if(!this.__userData){

          this.__userData = {
          };
        };
        this.__userData[C] = D;
      },
      /**
       * Load user defined data from the object
       *
       * @param key {String} the key
       * @return {Object} the user data
       */
      getUserData : function(E){

        if(!this.__userData){

          return null;
        };
        var F = this.__userData[E];
        return F === undefined ? null : F;
      },
      /*
      ---------------------------------------------------------------------------
        DISPOSER
      ---------------------------------------------------------------------------
      */
      /**
       * Returns true if the object is disposed.
       *
       * @return {Boolean} Whether the object has been disposed
       */
      isDisposed : function(){

        return this.$$disposed || false;
      },
      /**
       * Dispose this object
       *
       * @return {void}
       */
      dispose : function(){

        // Check first
        if(this.$$disposed){

          return;
        };
        // Mark as disposed (directly, not at end, to omit recursions)
        this.$$disposed = true;
        this.$$instance = null;
        this.$$allowconstruct = null;
        // Debug output
        if(qx.core.Environment.get(e)){

          if(qx.core.Environment.get(d) > 2){

            qx.Bootstrap.debug(this, p + this.classname + g + this.toHashCode() + j);
          };
        };
        // Deconstructor support for classes
        var I = this.constructor;
        var G;
        while(I.superclass){

          // Processing this class...
          if(I.$$destructor){

            I.$$destructor.call(this);
          };
          // Destructor support for mixins
          if(I.$$includes){

            G = I.$$flatIncludes;
            for(var i = 0,l = G.length;i < l;i++){

              if(G[i].$$destructor){

                G[i].$$destructor.call(this);
              };
            };
          };
          // Jump up to next super class
          I = I.superclass;
        };
        // remove all property references for IE6 and FF2
        if(this.__removePropertyReferences){

          this.__removePropertyReferences();
        };
        // Additional checks
        if(qx.core.Environment.get(e)){

          if(qx.core.Environment.get(d) > 0){

            var J,H;
            for(J in this){

              H = this[J];
              // Check for Objects but respect values attached to the prototype itself
              if(H !== null && typeof H === n && !(qx.Bootstrap.isString(H))){

                // Check prototype value
                // undefined is the best, but null may be used as a placeholder for
                // private variables (hint: checks in qx.Class.define). We accept both.
                if(this.constructor.prototype[J] != null){

                  continue;
                };
                var L = navigator.userAgent.indexOf(c) != -1;
                var K = navigator.userAgent.indexOf(b) != -1;
                // keep the old behavior for IE6 and FF2
                if(L || K){

                  if(H instanceof qx.core.Object || qx.core.Environment.get(d) > 1){

                    qx.Bootstrap.warn(this, f + J + h + this.classname + g + this.toHashCode() + k + H);
                    delete this[J];
                  };
                } else {

                  if(qx.core.Environment.get(d) > 1){

                    qx.Bootstrap.warn(this, f + J + h + this.classname + g + this.toHashCode() + k + H);
                    delete this[J];
                  };
                };
              };
            };
          };
        };
      },
      /**
       * Possible reference to special method for IE6 and FF2
       * {@link #__removePropertyReferencesOld}
       *
       * @signature function()
       */
      __removePropertyReferences : null,
      /**
       * Special method for IE6 and FF2 which removes all $$user_ references
       * set up by the properties.
       * @signature function()
       */
      __removePropertyReferencesOld : function(){

        // remove all property references
        var M = qx.Class.getProperties(this.constructor);
        for(var i = 0,l = M.length;i < l;i++){

          delete this[q + M[i]];
        };
      },
      /*
      ---------------------------------------------------------------------------
        DISPOSER UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Disconnects and disposes given objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param varargs {arguments} Names of fields (which store objects) to dispose
       */
      _disposeObjects : function(N){

        qx.util.DisposeUtil.disposeObjects(this, arguments);
      },
      /**
       * Disconnects and disposes given singleton objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param varargs {arguments} Names of fields (which store objects) to dispose
       */
      _disposeSingletonObjects : function(O){

        qx.util.DisposeUtil.disposeObjects(this, arguments, true);
      },
      /**
       * Disposes all members of the given array and deletes
       * the field which refers to the array afterwards.
       *
       * @param field {String} Name of the field which refers to the array
       */
      _disposeArray : function(P){

        qx.util.DisposeUtil.disposeArray(this, P);
      },
      /**
       * Disposes all members of the given map and deletes
       * the field which refers to the map afterwards.
       *
       * @param field {String} Name of the field which refers to the map
       */
      _disposeMap : function(Q){

        qx.util.DisposeUtil.disposeMap(this, Q);
      }
    },
    /*
    *****************************************************************************
       ENVIRONMENT SETTINGS
    *****************************************************************************
    */
    environment : {
      "qx.debug.dispose.level" : 0
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(R, S){

      // special treatment for IE6 and FF2
      var U = navigator.userAgent.indexOf(b) != -1;
      var T = navigator.userAgent.indexOf(c) != -1;
      // patch the remove property method for IE6 and FF2
      if(U || T){

        S.__removePropertyReferences = S.__removePropertyReferencesOld;
      };
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(qx.core.Environment.get(t)){

        if(!qx.core.ObjectRegistry.inShutDown){

          // Cleanup event listeners
          qx.event.Registration.removeAllListeners(this);
        } else {

          // on shutdown, just clear the internal listener map
          qx.event.Registration.deleteAllListeners(this);
        };
      };
      // Cleanup object registry
      qx.core.ObjectRegistry.unregister(this);
      // Cleanup user data
      this.__userData = null;
      // only of properties are available
      if(qx.core.Environment.get(a)){

        // Cleanup properties
        var X = this.constructor;
        var bc;
        var bd = this.__Property.$$store;
        var ba = bd.user;
        var bb = bd.theme;
        var V = bd.inherit;
        var Y = bd.useinit;
        var W = bd.init;
        while(X){

          bc = X.$$properties;
          if(bc){

            for(var name in bc){

              if(bc[name].dereference){

                this[ba[name]] = this[bb[name]] = this[V[name]] = this[Y[name]] = this[W[name]] = undefined;
              };
            };
          };
          X = X.superclass;
        };
      };
    }
  });
})();
(function(){

  var q = "Container must be a instance of qx.ui.container.Composite or ",p = " is a singleton! Please use disposeSingleton instead.",o = "undefined",n = "qx.debug",m = "qx.ui.container.SlideBar or qx.ui.container.Stack!",k = "qx.util.DisposeUtil",j = "!",h = "The map field: ",g = "First argument must be a container widget!",f = "qx.ui.container.Scroll or qx.ui.container.Resizer or ",c = "The array field: ",e = "The object stored in key ",d = "Has no disposable object under key: ",b = " of object: ",a = " has non disposable entries: ";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.log.Logger)
  #ignore(qx.log)
  #ignore(qx.ui.container.Composite)
  #ignore(qx.ui.container.Scroll)
  #ignore(qx.ui.container.SlideBar)
  #ignore(qx.ui.container.Stack)
  
  ************************************************************************ */
  /**
   * Methods to cleanup fields from maps/objects.
   */
  qx.Class.define(k, {
    statics : {
      /**
       * Disconnects and disposes given objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param obj {Object} Object which contains the fields
       * @param arr {Array} List of fields (which store objects) to dispose
       * @param disposeSingletons {Boolean?} true, if singletons should be disposed
       */
      disposeObjects : function(r, s, t){

        var name;
        for(var i = 0,l = s.length;i < l;i++){

          name = s[i];
          if(r[name] == null || !r.hasOwnProperty(name)){

            continue;
          };
          if(!qx.core.ObjectRegistry.inShutDown){

            if(r[name].dispose){

              // singletons
              if(!t && r[name].constructor.$$instance){

                throw new Error(e + name + p);
              } else {

                r[name].dispose();
              };
            } else {

              throw new Error(d + name + j);
            };
          };
          r[name] = null;
        };
      },
      /**
       * Disposes all members of the given array and deletes
       * the field which refers to the array afterwards.
       *
       * @param obj {Object} Object which contains the field
       * @param field {String} Name of the field which refers to the array
       * @return {void}
       */
      disposeArray : function(u, v){

        var x = u[v];
        if(!x){

          return;
        };
        // Fast path for application shutdown
        if(qx.core.ObjectRegistry.inShutDown){

          u[v] = null;
          return;
        };
        // Dispose all content
        try{

          var w;
          for(var i = x.length - 1;i >= 0;i--){

            w = x[i];
            if(w){

              w.dispose();
            };
          };
        } catch(y) {

          throw new Error(c + v + b + u + a + y);
        };
        // Reduce array size to zero
        x.length = 0;
        // Finally remove field
        u[v] = null;
      },
      /**
       * Disposes all members of the given map and deletes
       * the field which refers to the map afterwards.
       *
       * @param obj {Object} Object which contains the field
       * @param field {String} Name of the field which refers to the array
       * @return {void}
       */
      disposeMap : function(z, A){

        var C = z[A];
        if(!C){

          return;
        };
        // Fast path for application shutdown
        if(qx.core.ObjectRegistry.inShutDown){

          z[A] = null;
          return;
        };
        // Dispose all content
        try{

          var B;
          for(var D in C){

            B = C[D];
            if(C.hasOwnProperty(D) && B){

              B.dispose();
            };
          };
        } catch(E) {

          throw new Error(h + A + b + z + a + E);
        };
        // Finally remove field
        z[A] = null;
      },
      /**
       * Disposes a given object when another object is disposed
       *
       * @param disposeMe {Object} Object to dispose when other object is disposed
       * @param trigger {Object} Other object
       *
       */
      disposeTriggeredBy : function(F, G){

        var H = G.dispose;
        G.dispose = function(){

          H.call(G);
          F.dispose();
        };
      },
      /**
       * Destroys a container and all of its children recursivly.
       * @param container {qx.ui.container.Composite || qx.ui.container.Scroll ||
       *   qx.ui.container.SlideBar || qx.ui.container.Stack} Container to be destroyed
       */
      destroyContainer : function(I){

        if(qx.core.Environment.get(n)){

          qx.core.Assert.assertQxWidget(I, g);
          qx.core.Assert.assertTrue(this.__isChildrenContainer(I), q + f + m);
        };
        var J = [];
        this._collectContainerChildren(I, J);
        var K = J.length;
        for(var i = K - 1;i >= 0;i--){

          J[i].destroy();
        };
        I.destroy();
      },
      /**
       * Helper function to collect all children widgets of an container recursivly.
       * @param container {qx.ui.container.Composite || qx.ui.container.Scroll || qx.ui.container.SlideBar || qx.ui.container.Stack} Container to be destroyed
       * @param arr {Array} Array wich holds all children widgets
       */
      _collectContainerChildren : function(L, M){

        var O = L.getChildren();
        for(var i = 0;i < O.length;i++){

          var N = O[i];
          M.push(N);
          if(this.__isChildrenContainer(N)){

            this._collectContainerChildren(N, M);
          };
        };
      },
      /**
       * Checks if the given object is a qx container widget
       *
       * @param obj {Object} The object to check
       * @return {Boolean} <code>true</code> if the object is a container for
       * child widgets
       */
      __isChildrenContainer : function(P){

        var Q = [qx.ui.container.Composite, qx.ui.container.Scroll, qx.ui.container.SlideBar, qx.ui.container.Stack];
        for(var i = 0,l = Q.length;i < l;i++){

          if(typeof Q[i] !== o && qx.Class.isSubClassOf(P.constructor, Q[i])){

            return true;
          };
        };
        return false;
      }
    }
  });
})();
(function(){

  var f = "Cannot stop propagation on a non bubbling event: ",e = "Invalid argument value 'cancelable'.",d = "Cannot prevent default action on a non cancelable event: ",c = "Invalid argument value 'canBubble'.",b = "qx.event.type.Event",a = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.event.Registration)
  
  ************************************************************************ */
  /**
   * Basic event object.
   *
   * Please note:
   * Event objects are only valid during the event dispatch. After the dispatch
   * event objects are pooled or disposed. If you want to safe a reference to an
   * event instance use the {@link #clone} method.
   *
   * The interface is modeled after the DOM level 2 event interface:
   * http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** The current event phase is the capturing phase. */
      CAPTURING_PHASE : 1,
      /** The event is currently being evaluated at the target */
      AT_TARGET : 2,
      /** The current event phase is the bubbling phase. */
      BUBBLING_PHASE : 3
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param canBubble {Boolean?false} Whether or not the event is a bubbling event.
       *     If the event is bubbling, the bubbling can be stopped using
       *     {@link #stopPropagation}
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link #preventDefault}
       * @return {qx.event.type.Event} The initialized event instance
       */
      init : function(g, h){

        if(qx.core.Environment.get(a)){

          if(g !== undefined){

            qx.core.Assert.assertBoolean(g, c);
          };
          if(h !== undefined){

            qx.core.Assert.assertBoolean(h, e);
          };
        };
        this._type = null;
        this._target = null;
        this._currentTarget = null;
        this._relatedTarget = null;
        this._originalTarget = null;
        this._stopPropagation = false;
        this._preventDefault = false;
        this._bubbles = !!g;
        this._cancelable = !!h;
        this._timeStamp = (new Date()).getTime();
        this._eventPhase = null;
        return this;
      },
      /**
       * Create a clone of the event object, which is not automatically disposed
       * or pooled after an event dispatch.
       *
       * @param embryo {qx.event.type.Event?null} Optional event class, which will
       *     be configured using the data of this event instance. The event must be
       *     an instance of this event class. If the value is <code>null</code>,
       *     a new pooled instance is created.
       * @return {qx.event.type.Event} a clone of this class.
       */
      clone : function(i){

        if(i){

          var j = i;
        } else {

          var j = qx.event.Pool.getInstance().getObject(this.constructor);
        };
        j._type = this._type;
        j._target = this._target;
        j._currentTarget = this._currentTarget;
        j._relatedTarget = this._relatedTarget;
        j._originalTarget = this._originalTarget;
        j._stopPropagation = this._stopPropagation;
        j._bubbles = this._bubbles;
        j._preventDefault = this._preventDefault;
        j._cancelable = this._cancelable;
        return j;
      },
      /**
       * Stops event from all further processing. Execute this when the
       * current handler should have "exclusive rights" to the event
       * and no further reaction by anyone else should happen.
       */
      stop : function(){

        if(this._bubbles){

          this.stopPropagation();
        };
        if(this._cancelable){

          this.preventDefault();
        };
      },
      /**
       * This method is used to prevent further propagation of an event during event
       * flow. If this method is called by any event listener the event will cease
       * propagating through the tree. The event will complete dispatch to all listeners
       * on the current event target before event flow stops.
       *
       * @return {void}
       */
      stopPropagation : function(){

        if(qx.core.Environment.get(a)){

          this.assertTrue(this._bubbles, f + this.getType());
        };
        this._stopPropagation = true;
      },
      /**
       * Get whether further event propagation has been stopped.
       *
       * @return {Boolean} Whether further propagation has been stopped.
       */
      getPropagationStopped : function(){

        return !!this._stopPropagation;
      },
      /**
       * Prevent the default action of cancelable events, e.g. opening the context
       * menu, ...
       *
       * @return {void}
       */
      preventDefault : function(){

        if(qx.core.Environment.get(a)){

          this.assertTrue(this._cancelable, d + this.getType());
        };
        this._preventDefault = true;
      },
      /**
       * Get whether the default action has been prevented
       *
       * @return {Boolean} Whether the default action has been prevented
       */
      getDefaultPrevented : function(){

        return !!this._preventDefault;
      },
      /**
       * The name of the event
       *
       * @return {String} name of the event
       */
      getType : function(){

        return this._type;
      },
      /**
       * Override the event type
       *
       * @param type {String} new event type
       * @return {void}
       */
      setType : function(k){

        this._type = k;
      },
      /**
       * Used to indicate which phase of event flow is currently being evaluated.
       *
       * @return {Integer} The current event phase. Possible values are
       *         {@link #CAPTURING_PHASE}, {@link #AT_TARGET} and {@link #BUBBLING_PHASE}.
       */
      getEventPhase : function(){

        return this._eventPhase;
      },
      /**
       * Override the event phase
       *
       * @param eventPhase {Integer} new event phase
       * @return {void}
       */
      setEventPhase : function(l){

        this._eventPhase = l;
      },
      /**
       * The time (in milliseconds relative to the epoch) at which the event was created.
       *
       * @return {Integer} the timestamp the event was created.
       */
      getTimeStamp : function(){

        return this._timeStamp;
      },
      /**
       * Returns the event target to which the event was originally
       * dispatched.
       *
       * @return {Element} target to which the event was originally
       *       dispatched.
       */
      getTarget : function(){

        return this._target;
      },
      /**
       * Override event target.
       *
       * @param target {Element} new event target
       * @return {void}
       */
      setTarget : function(m){

        this._target = m;
      },
      /**
       * Get the event target node whose event listeners are currently being
       * processed. This is particularly useful during event capturing and
       * bubbling.
       *
       * @return {Element} The target the event listener is currently
       *       dispatched on.
       */
      getCurrentTarget : function(){

        return this._currentTarget || this._target;
      },
      /**
       * Override current target.
       *
       * @param currentTarget {Element} new current target
       * @return {void}
       */
      setCurrentTarget : function(n){

        this._currentTarget = n;
      },
      /**
       * Get the related event target. This is only configured for
       * events which also had an influences on another element e.g.
       * mouseover/mouseout, focus/blur, ...
       *
       * @return {Element} The related target
       */
      getRelatedTarget : function(){

        return this._relatedTarget;
      },
      /**
       * Override related target.
       *
       * @param relatedTarget {Element} new related target
       * @return {void}
       */
      setRelatedTarget : function(o){

        this._relatedTarget = o;
      },
      /**
       * Get the original event target. This is only configured
       * for events which are fired by another event (often when
       * the target should be reconfigured for another view) e.g.
       * low-level DOM event to widget event.
       *
       * @return {Element} The original target
       */
      getOriginalTarget : function(){

        return this._originalTarget;
      },
      /**
       * Override original target.
       *
       * @param originalTarget {Element} new original target
       * @return {void}
       */
      setOriginalTarget : function(p){

        this._originalTarget = p;
      },
      /**
       * Check whether or not the event is a bubbling event. If the event can
       * bubble the value is true, else the value is false.
       *
       * @return {Boolean} Whether the event bubbles
       */
      getBubbles : function(){

        return this._bubbles;
      },
      /**
       * Set whether the event bubbles.
       *
       * @param bubbles {Boolean} Whether the event bubbles
       * @return {void}
       */
      setBubbles : function(q){

        this._bubbles = q;
      },
      /**
       * Get whether the event is cancelable
       *
       * @return {Boolean} Whether the event is cancelable
       */
      isCancelable : function(){

        return this._cancelable;
      },
      /**
       * Set whether the event is cancelable
       *
       * @param cancelable {Boolean} Whether the event is cancelable
       * @return {void}
       */
      setCancelable : function(r){

        this._cancelable = r;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._target = this._currentTarget = this._relatedTarget = this._originalTarget = null;
    }
  });
})();
(function(){

  var d = "qx.util.ObjectPool",c = "Class needs to be defined!",b = "Object is already pooled: ",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       Simon Bull
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Simon Bull (sbull)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This class manages pooled Object instances.
   *
   * It exists mainly to minimise the amount of browser memory usage by reusing
   * window instances after they have been closed.  However, it could equally be
   * used to pool instances of any type of Object (expect singletons).
   *
   * It is the client's responsibility to ensure that pooled objects are not
   * referenced or used from anywhere else in the application.
   */
  qx.Class.define(d, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param size {Integer} Size of each class pool
     */
    construct : function(e){

      qx.core.Object.call(this);
      this.__pool = {
      };
      if(e != null){

        this.setSize(e);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        PROPERTIES
      ---------------------------------------------------------------------------
      */
      /**
       * Number of objects of each class, which are pooled.
       *
       * A size of "null" represents an unlimited pool.
       */
      size : {
        check : a,
        init : Infinity
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {Map} Stores arrays of instances for all managed classes */
      __pool : null,
      /*
      ---------------------------------------------------------------------------
        IMPL
      ---------------------------------------------------------------------------
      */
      /**
       * This method finds and returns an instance of a requested type in the pool,
       * if there is one.  Note that the pool determines which instance (if any) to
       * return to the client.  The client cannot get a specific instance from the
       * pool.
       *
       * @param clazz {Class} A reference to a class from which an instance should be created.
       * @return {Object} An instance of the requested type. If non existed in the pool a new
       *   one is transparently created and returned.
       */
      getObject : function(f){

        if(this.$$disposed){

          return new f;
        };
        if(!f){

          throw new Error(c);
        };
        var g = null;
        var h = this.__pool[f.classname];
        if(h){

          g = h.pop();
        };
        if(g){

          g.$$pooled = false;
        } else {

          g = new f;
        };
        return g;
      },
      /**
       * This method places an Object in a pool of Objects of its type. Note that
       * once an instance has been pooled, there is no means to get that exact
       * instance back. The instance may be discarded for garbage collection if
       * the pool of its type is already full.
       *
       * It is assumed that no other references exist to this Object, and that it will
       * not be used at all while it is pooled.
       *
       * @param obj {Object} An Object instance to pool.
       */
      poolObject : function(j){

        // Dispose check
        if(!this.__pool){

          return;
        };
        var k = j.classname;
        var m = this.__pool[k];
        if(j.$$pooled){

          throw new Error(b + j);
        };
        if(!m){

          this.__pool[k] = m = [];
        };
        // Check to see whether the pool for this type is already full
        if(m.length > this.getSize()){

          // Use enhanced destroy() method instead of simple dispose
          // when available to work together with queues etc.
          if(j.destroy){

            j.destroy();
          } else {

            j.dispose();
          };
          return;
        };
        j.$$pooled = true;
        m.push(j);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      var p = this.__pool;
      var n,o,i,l;
      for(n in p){

        o = p[n];
        for(i = 0,l = o.length;i < l;i++){

          o[i].dispose();
        };
      };
      delete this.__pool;
    }
  });
})();
(function(){

  var b = "singleton",a = "qx.event.Pool";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Central instance pool for event objects. All event objects dispatched by the
   * event loader are pooled using this class.
   */
  qx.Class.define(a, {
    extend : qx.util.ObjectPool,
    type : b,
    // Even though this class contains almost no code it is required because the
    // legacy code needs a place to patch the event pooling behavior.
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.util.ObjectPool.call(this, 30);
    }
  });
})();
(function(){

  var n = "' declared in the class '",m = "'",k = "' but found '",j = "The context object '",h = " is not an available class': ",g = "Expected event type to be instanceof '",f = "' for the event '",e = "' of '",d = "The event type '",c = "'is already disposed.",a = "qx.event.dispatch.Direct",b = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Dispatches events directly on the event target (no bubbling nor capturing).
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventDispatcher,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(o){

      this._manager = o;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this dispatcher */
      PRIORITY : qx.event.Registration.PRIORITY_LAST
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canDispatchEvent : function(p, event, q){

        return !event.getBubbles();
      },
      // interface implementation
      dispatchEvent : function(r, event, s){

        if(qx.core.Environment.get(b)){

          if(r instanceof qx.core.Object){

            var v = qx.Class.getEventType(r.constructor, s);
            var t = qx.Class.getByName(v);
            if(!t){

              this.error(d + s + n + r.constructor + h + v);
            } else if(!(event instanceof t)){

              this.error(g + v + k + event.classname + m);
            };
          };
        };
        event.setEventPhase(qx.event.type.Event.AT_TARGET);
        var w = this._manager.getListeners(r, s, false);
        if(w){

          for(var i = 0,l = w.length;i < l;i++){

            var u = w[i].context || r;
            if(qx.core.Environment.get(b)){

              // warn if the context is disposed
              if(u && u.isDisposed && u.isDisposed()){

                this.warn(j + u + f + s + e + r + c);
              };
            };
            w[i].handler.call(u, event);
          };
        };
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(x){

      qx.event.Registration.addDispatcher(x);
    }
  });
})();
(function(){

  var a = "qx.event.handler.Object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This class provides qooxdoo object event support.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_LAST,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : null,
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_OBJECT,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(b, c){

        return qx.Class.supportsEvent(b.constructor, c);
      },
      // interface implementation
      registerEvent : function(d, e, f){
      },
      // interface implementation
      unregisterEvent : function(g, h, i){
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(j){

      qx.event.Registration.addHandler(j);
    }
  });
})();
(function(){

  var a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Event object for data holding event or data changes.
   */
  qx.Class.define(a, {
    extend : qx.event.type.Event,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __data : null,
      __old : null,
      /**
       * Initializes an event object.
       *
       * @param data {var} The event's new data
       * @param old {var?null} The event's old data (optional)
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @return {qx.event.type.Data} the initialized instance.
       */
      init : function(b, c, d){

        qx.event.type.Event.prototype.init.call(this, false, d);
        this.__data = b;
        this.__old = c;
        return this;
      },
      /**
       * Get a copy of this object
       *
       * @param embryo {qx.event.type.Data?null} Optional event class, which will
       *     be configured using the data of this event instance. The event must be
       *     an instance of this event class. If the data is <code>null</code>,
       *     a new pooled instance is created.
       * @return {qx.event.type.Data} a copy of this object
       */
      clone : function(e){

        var f = qx.event.type.Event.prototype.clone.call(this, e);
        f.__data = this.__data;
        f.__old = this.__old;
        return f;
      },
      /**
       * The new data of the event sending this data event.
       * The return data type is the same as the event data type.
       *
       * @return {var} The new data of the event
       */
      getData : function(){

        return this.__data;
      },
      /**
       * The old data of the event sending this data event.
       * The return data type is the same as the event data type.
       *
       * @return {var} The old data of the event
       */
      getOldData : function(){

        return this.__old;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__data = this.__old = null;
    }
  });
})();
(function(){

  var b = "qx.locale.MTranslation",a = "To enable localization please include qx.locale.Manager into your build!";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.locale.Manager)
  
  ************************************************************************ */
  /**
   * This mixin contains the methods needed to use the translation features
   * of qooxdoo.
   */
  qx.Mixin.define(b, {
    members : {
      /**
       * Translate a message
       * Mark the message for translation.
       *
       * @param messageId {String} message id (may contain format strings)
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       */
      tr : function(c, d){

        var e = qx.locale.Manager;
        if(e){

          return e.tr.apply(e, arguments);
        };
        throw new Error(a);
      },
      /**
       * Translate a plural message
       * Mark the messages for translation.
       *
       * Depending on the third argument the plural or the singular form is chosen.
       *
       * @param singularMessageId {String} message id of the singular form (may contain format strings)
       * @param pluralMessageId {String} message id of the plural form (may contain format strings)
       * @param count {Integer} if greater than 1 the plural form otherwise the singular form is returned.
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       */
      trn : function(f, g, h, i){

        var j = qx.locale.Manager;
        if(j){

          return j.trn.apply(j, arguments);
        };
        throw new Error(a);
      },
      /**
       * Translate a message with translation hint
       * Mark the messages for translation.
       *
       * @param hint {String} hint for the translator of the message. Will be included in the .po file.
       * @param messageId {String} message id (may contain format strings)
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       */
      trc : function(k, l, m){

        var n = qx.locale.Manager;
        if(n){

          return n.trc.apply(n, arguments);
        };
        throw new Error(a);
      },
      /**
       * Mark the message for translation but return the original message.
       *
       * @param messageId {String} the message ID
       * @return {String} messageId
       */
      marktr : function(o){

        var p = qx.locale.Manager;
        if(p){

          return p.marktr.apply(p, arguments);
        };
        throw new Error(a);
      }
    }
  });
})();
(function(){

  var a = "qx.application.IApplication";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This interface defines what an application class has to implement.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Called when the application relevant classes are loaded and ready.
       *
       * @return {void}
       */
      main : function(){
      },
      /**
       * Called when the application's main method was executed to handle
       * "final" tasks like rendering or retrieving data.
       *
       * @return {void}
       */
      finalize : function(){
      },
      /**
       * Called in the document.beforeunload event of the browser. If the method
       * returns a string value, the user will be asked by the browser, whether
       * he really wants to leave the page. The return string will be displayed in
       * the message box.
       *
       * @return {String?null} message text on unloading the page
       */
      close : function(){
      },
      /**
       * This method contains the last code which is run inside the page and may contain cleanup code.
       *
       * @return {void}
       */
      terminate : function(){
      }
    }
  });
})();
(function(){

  var o = "qx.core.BaseInit",n = "engine.name",m = "Main runtime: ",l = "qx.application",k = "os.name",j = "engine.version",i = "Missing application class: ",h = "Load runtime: ",g = "Could not detect engine!",f = "Finalize runtime: ",b = "Could not detect operating system!",d = "Could not detect the version of the engine!",c = "",a = "ms";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Daniel Wagner (d_wagner)
       * John Spackman
  
  ************************************************************************ */
  /**
   * This is the base class for non-browser qooxdoo applications.
   */
  qx.Class.define(o, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the instantiated qooxdoo application.
       *
       * @return {qx.core.Object} The application instance.
       */
      getApplication : function(){

        return this.__application || null;
      },
      /**
       * Runs when the application is loaded. Automatically creates an instance
       * of the class defined by the setting <code>qx.application</code>.
       *
       * @return {void}
       */
      ready : function(){

        if(this.__application){

          return;
        };
        if(qx.core.Environment.get(n) == c){

          qx.log.Logger.warn(g);
        };
        if(qx.core.Environment.get(j) == c){

          qx.log.Logger.warn(d);
        };
        if(qx.core.Environment.get(k) == c){

          qx.log.Logger.warn(b);
        };
        qx.log.Logger.debug(this, h + (new Date - qx.Bootstrap.LOADSTART) + a);
        var q = qx.core.Environment.get(l);
        var r = qx.Class.getByName(q);
        if(r){

          this.__application = new r;
          var p = new Date;
          this.__application.main();
          qx.log.Logger.debug(this, m + (new Date - p) + a);
          var p = new Date;
          this.__application.finalize();
          qx.log.Logger.debug(this, f + (new Date - p) + a);
        } else {

          qx.log.Logger.warn(i + q);
        };
      },
      /**
       * Runs before the document is unloaded. Calls the application's close
       * method to check if the unload process should be stopped.
       *
       * @param e {qx.event.type.Native} Incoming beforeunload event.
       * @return {void}
       */
      __close : function(e){

        var s = this.__application;
        if(s){

          s.close();
        };
      },
      /**
       * Runs when the document is unloaded. Automatically terminates a previously
       * created application instance.
       *
       * @return {void}
       */
      __shutdown : function(){

        var t = this.__application;
        if(t){

          t.terminate();
        };
        // Execute registry shutdown
        qx.core.ObjectRegistry.shutdown();
      }
    }
  });
})();
(function(){

  var j = "rim_tabletos",i = "Darwin",h = "os.version",g = "2003",f = ")",e = "iPhone",d = "android",c = "unix",b = "ce",a = "7",bg = "SymbianOS",bf = "os.name",be = "|",bd = "MacPPC",bc = "iPod",bb = "\.",ba = "Win64",Y = "linux",X = "me",W = "Macintosh",q = "Windows",r = "ios",o = "vista",p = "8",m = "blackberry",n = "(",k = "win",l = "Linux",u = "BSD",v = "Mac OS X",D = "iPad",B = "X11",L = "xp",G = "symbian",S = "qx.bom.client.OperatingSystem",Q = "g",x = "Win32",V = "osx",U = "webOS",T = "RIM Tablet OS",w = "BlackBerry",z = "nt4",A = ".",C = "MacIntel",E = "webos",H = "10.1",N = "10.3",R = "10.7",s = "10.5",t = "95",y = "10.2",K = "Android",J = "98",I = "2000",P = "10.6",O = "10.0",F = "10.4",M = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Fastner (fastner)
  
  ************************************************************************ */
  /**
   * This class is responsible for checking the operating systems name.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(S, {
    statics : {
      /**
       * Checks for the name of the operating system.
       * @return {String} The name of the operating system.
       * @internal
       */
      getName : function(){

        if(!navigator){

          return M;
        };
        var bh = navigator.platform || M;
        var bi = navigator.userAgent || M;
        if(bh.indexOf(q) != -1 || bh.indexOf(x) != -1 || bh.indexOf(ba) != -1){

          return k;
        } else if(bh.indexOf(W) != -1 || bh.indexOf(bd) != -1 || bh.indexOf(C) != -1 || bh.indexOf(v) != -1){

          return V;
        } else if(bi.indexOf(T) != -1){

          return j;
        } else if(bi.indexOf(U) != -1){

          return E;
        } else if(bh.indexOf(bc) != -1 || bh.indexOf(e) != -1 || bh.indexOf(D) != -1){

          return r;
        } else if(bi.indexOf(K) != -1){

          return d;
        } else if(bh.indexOf(l) != -1){

          return Y;
        } else if(bh.indexOf(B) != -1 || bh.indexOf(u) != -1 || bh.indexOf(i) != -1){

          return c;
        } else if(bh.indexOf(bg) != -1){

          return G;
        } else if(bh.indexOf(w) != -1){

          return m;
        };;;;;;;;;
        // don't know
        return M;
      },
      /** Maps user agent names to system IDs */
      __ids : {
        // Windows
        "Windows NT 6.2" : p,
        "Windows NT 6.1" : a,
        "Windows NT 6.0" : o,
        "Windows NT 5.2" : g,
        "Windows NT 5.1" : L,
        "Windows NT 5.0" : I,
        "Windows 2000" : I,
        "Windows NT 4.0" : z,
        "Win 9x 4.90" : X,
        "Windows CE" : b,
        "Windows 98" : J,
        "Win98" : J,
        "Windows 95" : t,
        "Win95" : t,
        // OS X
        "Mac OS X 10_7" : R,
        "Mac OS X 10.7" : R,
        "Mac OS X 10_6" : P,
        "Mac OS X 10.6" : P,
        "Mac OS X 10_5" : s,
        "Mac OS X 10.5" : s,
        "Mac OS X 10_4" : F,
        "Mac OS X 10.4" : F,
        "Mac OS X 10_3" : N,
        "Mac OS X 10.3" : N,
        "Mac OS X 10_2" : y,
        "Mac OS X 10.2" : y,
        "Mac OS X 10_1" : H,
        "Mac OS X 10.1" : H,
        "Mac OS X 10_0" : O,
        "Mac OS X 10.0" : O
      },
      /**
       * Checks for the version of the operating system using the internal map.
       *
       * @internal
       * @return {String} The version as strin or an empty string if the version
       *   could not be detected.
       */
      getVersion : function(){

        var bj = qx.bom.client.OperatingSystem.__getVersionForDesktopOs(navigator.userAgent);
        if(bj == null){

          bj = qx.bom.client.OperatingSystem.__getVersionForMobileOs(navigator.userAgent);
        };
        if(bj != null){

          return bj;
        } else {

          return M;
        };
      },
      /**
       * Detect OS version for desktop devices
       * @param userAgent {String} userAgent parameter, needed for detection.
       * @return {String} version number as string or null.
       */
      __getVersionForDesktopOs : function(bk){

        var bn = [];
        for(var bm in qx.bom.client.OperatingSystem.__ids){

          bn.push(bm);
        };
        var bo = new RegExp(n + bn.join(be).replace(/\./g, bb) + f, Q);
        var bl = bo.exec(bk);
        if(bl && bl[1]){

          return qx.bom.client.OperatingSystem.__ids[bl[1]];
        };
        return null;
      },
      /**
       * Detect OS version for mobile devices
       * @param userAgent {String} userAgent parameter, needed for detection.
       * @return {String} version number as string or null.
       */
      __getVersionForMobileOs : function(bp){

        var bt = bp.indexOf(K) != -1;
        var bq = bp.match(/(iPad|iPhone|iPod)/i) ? true : false;
        if(bt){

          var bs = new RegExp(/ Android (\d+(?:\.\d+)+)/i);
          var bu = bs.exec(bp);
          if(bu && bu[1]){

            return bu[1];
          };
        } else if(bq){

          var bv = new RegExp(/(CPU|iPhone|iPod) OS (\d+)_(\d+)\s+/);
          var br = bv.exec(bp);
          if(br && br[2] && br[3]){

            return br[2] + A + br[3];
          };
        };
        return null;
      }
    },
    defer : function(bw){

      qx.core.Environment.add(bf, bw.getName);
      qx.core.Environment.add(h, bw.getVersion);
    }
  });
})();
(function(){

  var a = "qx.event.type.Native";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Common base class for all native events (DOM events, IO events, ...).
   */
  qx.Class.define(a, {
    extend : qx.event.type.Event,
    members : {
      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param nativeEvent {Event} The DOM event to use
       * @param target {Object?} The event target
       * @param relatedTarget {Object?null} The related event target
       * @param canBubble {Boolean?false} Whether or not the event is a bubbling event.
       *     If the event is bubbling, the bubbling can be stopped using
       *     {@link qx.event.type.Event#stopPropagation}
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link #preventDefault}
       * @return {qx.event.type.Event} The initialized event instance
       */
      init : function(b, c, d, e, f){

        qx.event.type.Event.prototype.init.call(this, e, f);
        this._target = c || qx.bom.Event.getTarget(b);
        this._relatedTarget = d || qx.bom.Event.getRelatedTarget(b);
        if(b.timeStamp){

          this._timeStamp = b.timeStamp;
        };
        this._native = b;
        this._returnValue = null;
        return this;
      },
      // overridden
      clone : function(g){

        var h = qx.event.type.Event.prototype.clone.call(this, g);
        var i = {
        };
        h._native = this._cloneNativeEvent(this._native, i);
        h._returnValue = this._returnValue;
        return h;
      },
      /**
       * Clone the native browser event
       *
       * @param nativeEvent {Event} The native browser event
       * @param clone {Object} The initialized clone.
       * @return {Object} The cloned event
       */
      _cloneNativeEvent : function(j, k){

        k.preventDefault = qx.lang.Function.empty;
        return k;
      },
      /**
       * Prevent browser default behavior, e.g. opening the context menu, ...
       */
      preventDefault : function(){

        qx.event.type.Event.prototype.preventDefault.call(this);
        qx.bom.Event.preventDefault(this._native);
      },
      /**
       * Get the native browser event object of this event.
       *
       * @return {Event} The native browser event
       */
      getNativeEvent : function(){

        return this._native;
      },
      /**
       * Sets the event's return value. If the return value is set in a
       * beforeunload event, the user will be asked by the browser, whether
       * he really wants to leave the page. The return string will be displayed in
       * the message box.
       *
       * @param returnValue {String?null} Return value
       */
      setReturnValue : function(l){

        this._returnValue = l;
      },
      /**
       * Retrieves the event's return value.
       *
       * @return {String?null} The return value
       */
      getReturnValue : function(){

        return this._returnValue;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._native = this._returnValue = null;
    }
  });
})();
(function(){

  var a = "qx.event.handler.Window";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /*
   #require(qx.event.type.Native)
   #require(qx.event.Pool)
  */
  /**
   * This handler provides event for the window object.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(b){

      qx.core.Object.call(this);
      // Define shorthands
      this._manager = b;
      this._window = b.getWindow();
      // Initialize observers
      this._initWindowObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        error : 1,
        load : 1,
        beforeunload : 1,
        unload : 1,
        resize : 1,
        scroll : 1,
        beforeshutdown : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(c, d){
      },
      // interface implementation
      registerEvent : function(f, g, h){
      },
      // interface implementation
      unregisterEvent : function(i, j, k){
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT/STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native mouse event listeners.
       *
       * @return {void}
       */
      _initWindowObserver : function(){

        this._onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
        var m = qx.event.handler.Window.SUPPORTED_TYPES;
        for(var l in m){

          qx.bom.Event.addNativeListener(this._window, l, this._onNativeWrapper);
        };
      },
      /**
       * Disconnect the native mouse event listeners.
       *
       * @return {void}
       */
      _stopWindowObserver : function(){

        var o = qx.event.handler.Window.SUPPORTED_TYPES;
        for(var n in o){

          qx.bom.Event.removeNativeListener(this._window, n, this._onNativeWrapper);
        };
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Native listener for all supported events.
       *
       * @signature function(e)
       * @param e {Event} Native event
       */
      _onNative : qx.event.GlobalError.observeMethod(function(e){

        if(this.isDisposed()){

          return;
        };
        var q = this._window;
        try{

          var t = q.document;
        } catch(e) {

          // IE7 sometimes dispatches "unload" events on protected windows
          // Ignore these events
          return;
        };
        var r = t.documentElement;
        // At least Safari 3.1 and Opera 9.2.x have a bubbling scroll event
        // which needs to be ignored here.
        //
        // In recent WebKit nightlies scroll events do no longer bubble
        //
        // Internet Explorer does not have a target in resize events.
        var p = qx.bom.Event.getTarget(e);
        if(p == null || p === q || p === t || p === r){

          var event = qx.event.Registration.createEvent(e.type, qx.event.type.Native, [e, q]);
          qx.event.Registration.dispatchEvent(q, event);
          var s = event.getReturnValue();
          if(s != null){

            e.returnValue = s;
            return s;
          };
        };
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopWindowObserver();
      this._manager = this._window = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(u){

      qx.event.Registration.addHandler(u);
    }
  });
})();
(function(){

  var n = "qx.event.handler.Application",m = "complete",l = "webkit",k = "gecko",j = "opera",i = "left",h = "DOMContentLoaded",g = "shutdown",f = "mshtml",d = "load",a = "unload",c = "ready",b = "engine.name";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This handler provides events for qooxdoo application startup/shutdown logic.
   */
  qx.Class.define(n, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(o){

      qx.core.Object.call(this);
      // Define shorthands
      this._window = o.getWindow();
      this.__domReady = false;
      this.__loaded = false;
      this.__isReady = false;
      this.__isUnloaded = false;
      // Initialize observers
      this._initObserver();
      // Store instance (only supported for main app window, this
      // is the reason why this is OK here)
      qx.event.handler.Application.$$instance = this;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        ready : 1,
        shutdown : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true,
      /**
       * Sends the currently running application the ready signal. Used
       * exclusively by package loader system.
       *
       * @internal
       * @return {void}
       */
      onScriptLoaded : function(){

        var p = qx.event.handler.Application.$$instance;
        if(p){

          p.__fireReady();
        };
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(q, r){
      },
      // interface implementation
      registerEvent : function(s, t, u){
      },
      // interface implementation
      unregisterEvent : function(v, w, x){
      },
      __isReady : null,
      __domReady : null,
      __loaded : null,
      __isUnloaded : null,
      /*
      ---------------------------------------------------------------------------
        USER ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Fires a global ready event.
       *
       * @return {void}
       */
      __fireReady : function(){

        // Wrapper qxloader needed to be compatible with old generator
        if(!this.__isReady && this.__domReady && qx.$$loader.scriptLoaded){

          // If qooxdoo is loaded within a frame in IE, the document is ready before
          // the "ready" listener can be added. To avoid any startup issue check
          // for the availability of the "ready" listener before firing the event.
          // So at last the native "load" will trigger the "ready" event.
          if((qx.core.Environment.get(b) == f)){

            if(qx.event.Registration.hasListener(this._window, c)){

              this.__isReady = true;
              // Fire user event
              qx.event.Registration.fireEvent(this._window, c);
            };
          } else {

            this.__isReady = true;
            // Fire user event
            qx.event.Registration.fireEvent(this._window, c);
          };
        };
      },
      /**
       * Whether the application is ready.
       *
       * @return {Boolean} ready status
       */
      isApplicationReady : function(){

        return this.__isReady;
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT/STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native mouse event listeners.
       *
       * @return {void}
       */
      _initObserver : function(){

        // in Firefox the loader script sets the ready state
        if(qx.$$domReady || document.readyState == m || document.readyState == c){

          this.__domReady = true;
          this.__fireReady();
        } else {

          this._onNativeLoadWrapped = qx.lang.Function.bind(this._onNativeLoad, this);
          if(qx.core.Environment.get(b) == k || qx.core.Environment.get(b) == j || qx.core.Environment.get(b) == l){

            // Using native method supported by Mozilla, Webkits and Opera >= 9.0
            qx.bom.Event.addNativeListener(this._window, h, this._onNativeLoadWrapped);
          } else if((qx.core.Environment.get(b) == f)){

            var self = this;
            // Continually check to see if the document is ready
            var y = function(){

              try{

                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll(i);
                if(document.body){

                  self._onNativeLoadWrapped();
                };
              } catch(z) {

                window.setTimeout(y, 100);
              };
            };
            y();
          };
          // Additional load listener as fallback
          qx.bom.Event.addNativeListener(this._window, d, this._onNativeLoadWrapped);
        };
        this._onNativeUnloadWrapped = qx.lang.Function.bind(this._onNativeUnload, this);
        qx.bom.Event.addNativeListener(this._window, a, this._onNativeUnloadWrapped);
      },
      /**
       * Disconnect the native mouse event listeners.
       *
       * @return {void}
       */
      _stopObserver : function(){

        if(this._onNativeLoadWrapped){

          qx.bom.Event.removeNativeListener(this._window, d, this._onNativeLoadWrapped);
        };
        qx.bom.Event.removeNativeListener(this._window, a, this._onNativeUnloadWrapped);
        this._onNativeLoadWrapped = null;
        this._onNativeUnloadWrapped = null;
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE LISTENER
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for native load event
       *
       * @signature function()
       */
      _onNativeLoad : qx.event.GlobalError.observeMethod(function(){

        this.__domReady = true;
        this.__fireReady();
      }),
      /**
       * Event listener for native unload event
       *
       * @signature function()
       */
      _onNativeUnload : qx.event.GlobalError.observeMethod(function(){

        if(!this.__isUnloaded){

          this.__isUnloaded = true;
          try{

            // Fire user event
            qx.event.Registration.fireEvent(this._window, g);
          } catch(e) {

            // IE doesn't execute the "finally" block if no "catch" block is present
            throw e;
          }finally{

            // Execute registry shutdown
            qx.core.ObjectRegistry.shutdown();
          };
        };
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopObserver();
      this._window = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(A){

      qx.event.Registration.addHandler(A);
    }
  });
})();
(function(){

  var d = "ready",c = "shutdown",b = "beforeunload",a = "qx.core.Init";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.Application)
  #require(qx.event.handler.Window)
  #require(qx.event.dispatch.Direct)
  
  ************************************************************************ */
  /**
   * This is the base class for all qooxdoo applications.
   */
  qx.Class.define(a, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the instantiated qooxdoo application.
       *
       * @return {qx.core.Object} The application instance.
       */
      getApplication : qx.core.BaseInit.getApplication,
      /**
       * Runs when the application is loaded. Automatically creates an instance
       * of the class defined by the setting <code>qx.application</code>.
       *
       * @return {void}
       */
      ready : qx.core.BaseInit.ready,
      /**
       * Runs before the document is unloaded. Calls the application's close
       * method to check if the unload process should be stopped.
       *
       * @param e {qx.event.type.Native} Incoming beforeunload event.
       * @return {void}
       */
      __close : function(e){

        var f = this.getApplication();
        if(f){

          e.setReturnValue(f.close());
        };
      },
      /**
       * Runs when the document is unloaded. Automatically terminates a previously
       * created application instance.
       *
       * @return {void}
       */
      __shutdown : function(){

        var g = this.getApplication();
        if(g){

          g.terminate();
        };
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(h){

      qx.event.Registration.addListener(window, d, h.ready, h);
      qx.event.Registration.addListener(window, c, h.__shutdown, h);
      qx.event.Registration.addListener(window, b, h.__close, h);
    }
  });
})();
(function(){

  var c = "Abstract method call",b = "abstract",a = "qx.application.AbstractGui";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.core.Init)
  
  ************************************************************************ */
  /**
   * Abstract base class for GUI applications using qooxdoo widgets.
   */
  qx.Class.define(a, {
    type : b,
    extend : qx.core.Object,
    implement : [qx.application.IApplication],
    include : qx.locale.MTranslation,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {qx.ui.core.Widget} The root widget */
      __root : null,
      /**
       * Create the root widget. This method is abstract and must be overridden
       * by sub classes.
       *
       * @return {qx.ui.core.Widget} The root widget. This widget must be configured
       *     with a {@link qx.ui.layout.Basic} or {@link qx.ui.layout.Canvas} layout.
       */
      _createRootWidget : function(){

        throw new Error(c);
      },
      /**
       * Returns the application's root widget. The root widgets can act as container
       * for popups. It is configured with a {@link qx.ui.layout.Basic} (if the
       * application is an inline application) layout or a {@link qx.ui.layout.Canvas}
       * (if the application is a standalone application) layout .
       *
       * The root has the same add method as the configured layout
       * ({@link qx.ui.layout.Basic} or {@link qx.ui.layout.Canvas}).
       *
       * @return {qx.ui.core.Widget} The application's root widget.
       */
      getRoot : function(){

        return this.__root;
      },
      // interface method
      main : function(){

        // Initialize themes
        qx.theme.manager.Meta.getInstance().initialize();
        // Initialize tooltip manager
        qx.ui.tooltip.Manager.getInstance();
        this.__root = this._createRootWidget();
      },
      // interface method
      finalize : function(){

        this.render();
      },
      /**
       * Updates the GUI rendering
       *
       * @return {void}
       */
      render : function(){

        qx.ui.core.queue.Manager.flush();
      },
      // interface method
      close : function(d){
      },
      // interface method
      terminate : function(){
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__root = null;
    }
  });
})();
(function(){

  var g = "The theme to use is not available: ",f = "_applyTheme",e = "qx.theme",d = "qx.theme.manager.Meta",c = "qx.theme.Modern",b = "Theme",a = "singleton";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Manager for meta themes
   */
  qx.Class.define(d, {
    type : a,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Meta theme. Applies the defined color, decoration, ... themes to
       * the corresponding managers.
       */
      theme : {
        check : b,
        nullable : true,
        apply : f
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // property apply
      _applyTheme : function(h, i){

        var l = null;
        var o = null;
        var r = null;
        var s = null;
        var n = null;
        if(h){

          l = h.meta.color || null;
          o = h.meta.decoration || null;
          r = h.meta.font || null;
          s = h.meta.icon || null;
          n = h.meta.appearance || null;
        };
        var p = qx.theme.manager.Color.getInstance();
        var q = qx.theme.manager.Decoration.getInstance();
        var j = qx.theme.manager.Font.getInstance();
        var m = qx.theme.manager.Icon.getInstance();
        var k = qx.theme.manager.Appearance.getInstance();
        p.setTheme(l);
        q.setTheme(o);
        j.setTheme(r);
        m.setTheme(s);
        k.setTheme(n);
      },
      /**
       * Initialize the themes which were selected using the settings. Should only
       * be called from qooxdoo based application.
       */
      initialize : function(){

        var v = qx.core.Environment;
        var t,u;
        t = v.get(e);
        if(t){

          u = qx.Theme.getByName(t);
          if(!u){

            throw new Error(g + t);
          };
          this.setTheme(u);
        };
      }
    },
    /*
    *****************************************************************************
       ENVIRONMENT SETTINGS
    *****************************************************************************
    */
    environment : {
      "qx.theme" : c
    }
  });
})();
(function(){

  var b = "qx.util.ValueManager",a = "abstract";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Abstract base class for all managers of themed values.
   */
  qx.Class.define(b, {
    type : a,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      // Create empty dynamic map
      this._dynamic = {
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _dynamic : null,
      /**
       * Returns the dynamically interpreted result for the incoming value
       *
       * @param value {String} dynamically interpreted identifier
       * @return {var} return the (translated) result of the incoming value
       */
      resolveDynamic : function(c){

        return this._dynamic[c];
      },
      /**
       * Whether a value is interpreted dynamically
       *
       * @param value {String} dynamically interpreted identifier
       * @return {Boolean} returns true if the value is interpreted dynamically
       */
      isDynamic : function(d){

        return !!this._dynamic[d];
      },
      /**
       * Returns the dynamically interpreted result for the incoming value,
       * (if available), otherwise returns the original value
       * @param value {String} Value to resolve
       * @return {var} either returns the (translated) result of the incoming
       * value or the value itself
       */
      resolve : function(e){

        if(e && this._dynamic[e]){

          return this._dynamic[e];
        };
        return e;
      },
      /**
       * Sets the dynamics map.
       * @param value {Map} The map.
       */
      _setDynamic : function(f){

        this._dynamic = f;
      },
      /**
       * Returns the dynamics map.
       * @return {Map} The map.
       */
      _getDynamic : function(){

        return this._dynamic;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._dynamic = null;
    }
  });
})();
(function(){

  var g = "_applyTheme",f = "qx.theme.manager.Color",e = "Theme",d = "changeTheme",c = "string",b = "singleton",a = "Could not parse color: ";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Manager for color themes
   */
  qx.Class.define(f, {
    type : b,
    extend : qx.util.ValueManager,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** the currently selected color theme */
      theme : {
        check : e,
        nullable : true,
        apply : g,
        event : d
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _applyTheme : function(h){

        var i = {
        };
        if(h){

          var j = h.colors;
          var k = qx.util.ColorUtil;
          var l;
          for(var m in j){

            l = j[m];
            if(typeof l === c){

              if(!k.isCssString(l)){

                throw new Error(a + l);
              };
            } else if(l instanceof Array){

              l = k.rgbToRgbString(l);
            } else {

              throw new Error(a + l);
            };
            i[m] = l;
          };
        };
        this._setDynamic(i);
      },
      /**
       * Returns the dynamically interpreted result for the incoming value,
       * (if available), otherwise returns the original value
       * @param value {String} Value to resolve
       * @return {var} either returns the (translated) result of the incoming
       * value or the value itself
       */
      resolve : function(n){

        var q = this._dynamic;
        var o = q[n];
        if(o){

          return o;
        };
        // If the font instance is not yet cached create a new one to return
        // This is true whenever a runtime include occurred (using "qx.Theme.include"
        // or "qx.Theme.patch"), since these methods only merging the keys of
        // the theme and are not updating the cache
        var p = this.getTheme();
        if(p !== null && p.colors[n]){

          return q[n] = p.colors[n];
        };
        return n;
      },
      /**
       * Whether a value is interpreted dynamically
       *
       * @param value {String} dynamically interpreted identifier
       * @return {Boolean} returns true if the value is interpreted dynamically
       */
      isDynamic : function(r){

        var t = this._dynamic;
        if(r && (t[r] !== undefined)){

          return true;
        };
        // If the font instance is not yet cached create a new one to return
        // This is true whenever a runtime include occurred (using "qx.Theme.include"
        // or "qx.Theme.patch"), since these methods only merging the keys of
        // the theme and are not updating the cache
        var s = this.getTheme();
        if(s !== null && r && (s.colors[r] !== undefined)){

          t[r] = s.colors[r];
          return true;
        };
        return false;
      }
    }
  });
})();
(function(){

  var o = "Invalid hex value: ",n = "qx.util.ColorUtil",m = ")",l = "#",k = "Invalid hex3 value: ",j = "qx.theme.manager.Color",h = "rgb(",e = "Invalid hex6 value: ",d = "Could not parse color: ",c = "Could not convert system colors to RGB: ",a = ",";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Christian Hagendorn (cs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.theme.*)
  #ignore(qx.theme)
  #ignore(qx.Class)
  
  ************************************************************************ */
  /**
   * Methods to convert colors between different color spaces.
   */
  qx.Bootstrap.define(n, {
    statics : {
      /**
       * Regular expressions for color strings
       */
      REGEXP : {
        hex3 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        rgb : /^rgb\(\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*\)$/,
        rgba : /^rgba\(\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*\)$/
      },
      /**
       * CSS3 system color names.
       */
      SYSTEM : {
        activeborder : true,
        activecaption : true,
        appworkspace : true,
        background : true,
        buttonface : true,
        buttonhighlight : true,
        buttonshadow : true,
        buttontext : true,
        captiontext : true,
        graytext : true,
        highlight : true,
        highlighttext : true,
        inactiveborder : true,
        inactivecaption : true,
        inactivecaptiontext : true,
        infobackground : true,
        infotext : true,
        menu : true,
        menutext : true,
        scrollbar : true,
        threeddarkshadow : true,
        threedface : true,
        threedhighlight : true,
        threedlightshadow : true,
        threedshadow : true,
        window : true,
        windowframe : true,
        windowtext : true
      },
      /**
       * Named colors, only the 16 basic colors plus the following ones:
       * transparent, grey, magenta, orange and brown
       */
      NAMED : {
        black : [0, 0, 0],
        silver : [192, 192, 192],
        gray : [128, 128, 128],
        white : [255, 255, 255],
        maroon : [128, 0, 0],
        red : [255, 0, 0],
        purple : [128, 0, 128],
        fuchsia : [255, 0, 255],
        green : [0, 128, 0],
        lime : [0, 255, 0],
        olive : [128, 128, 0],
        yellow : [255, 255, 0],
        navy : [0, 0, 128],
        blue : [0, 0, 255],
        teal : [0, 128, 128],
        aqua : [0, 255, 255],
        // Additional values
        transparent : [-1, -1, -1],
        magenta : [255, 0, 255],
        // alias for fuchsia
        orange : [255, 165, 0],
        brown : [165, 42, 42]
      },
      /**
       * Whether the incoming value is a named color.
       *
       * @param value {String} the color value to test
       * @return {Boolean} true if the color is a named color
       */
      isNamedColor : function(s){

        return this.NAMED[s] !== undefined;
      },
      /**
       * Whether the incoming value is a system color.
       *
       * @param value {String} the color value to test
       * @return {Boolean} true if the color is a system color
       */
      isSystemColor : function(u){

        return this.SYSTEM[u] !== undefined;
      },
      /**
       * Whether the color theme manager is loaded. Generally
       * part of the GUI of qooxdoo.
       *
       * @return {Boolean} <code>true</code> when color theme support is ready.
       **/
      supportsThemes : function(){

        if(qx.Class){

          return qx.Class.isDefined(j);
        };
        return false;
      },
      /**
       * Whether the incoming value is a themed color.
       *
       * @param value {String} the color value to test
       * @return {Boolean} true if the color is a themed color
       */
      isThemedColor : function(v){

        if(!this.supportsThemes()){

          return false;
        };
        if(qx.theme && qx.theme.manager && qx.theme.manager.Color){

          return qx.theme.manager.Color.getInstance().isDynamic(v);
        };
        return false;
      },
      /**
       * Try to convert an incoming string to an RGB array.
       * Supports themed, named and system colors, but also RGB strings,
       * hex3 and hex6 values.
       *
       * @param str {String} any string
       * @return {Array} returns an array of red, green, blue on a successful transformation
       * @throws an error if the string could not be parsed
       */
      stringToRgb : function(w){

        if(this.supportsThemes() && this.isThemedColor(w)){

          var w = qx.theme.manager.Color.getInstance().resolveDynamic(w);
        };
        if(this.isNamedColor(w)){

          return this.NAMED[w];
        } else if(this.isSystemColor(w)){

          throw new Error(c + w);
        } else if(this.isRgbString(w)){

          return this.__rgbStringToRgb();
        } else if(this.isHex3String(w)){

          return this.__hex3StringToRgb();
        } else if(this.isHex6String(w)){

          return this.__hex6StringToRgb();
        };;;;
        throw new Error(d + w);
      },
      /**
       * Try to convert an incoming string to an RGB array.
       * Support named colors, RGB strings, hex3 and hex6 values.
       *
       * @param str {String} any string
       * @return {Array} returns an array of red, green, blue on a successful transformation
       * @throws an error if the string could not be parsed
       */
      cssStringToRgb : function(x){

        if(this.isNamedColor(x)){

          return this.NAMED[x];
        } else if(this.isSystemColor(x)){

          throw new Error(c + x);
        } else if(this.isRgbString(x)){

          return this.__rgbStringToRgb();
        } else if(this.isRgbaString(x)){

          return this.__rgbaStringToRgb();
        } else if(this.isHex3String(x)){

          return this.__hex3StringToRgb();
        } else if(this.isHex6String(x)){

          return this.__hex6StringToRgb();
        };;;;;
        throw new Error(d + x);
      },
      /**
       * Try to convert an incoming string to an RGB string, which can be used
       * for all color properties.
       * Supports themed, named and system colors, but also RGB strings,
       * hex3 and hex6 values.
       *
       * @param str {String} any string
       * @return {String} a RGB string
       * @throws an error if the string could not be parsed
       */
      stringToRgbString : function(y){

        return this.rgbToRgbString(this.stringToRgb(y));
      },
      /**
       * Converts a RGB array to an RGB string
       *
       * @param rgb {Array} an array with red, green and blue
       * @return {String} a RGB string
       */
      rgbToRgbString : function(z){

        return h + z[0] + a + z[1] + a + z[2] + m;
      },
      /**
       * Converts a RGB array to an hex6 string
       *
       * @param rgb {Array} an array with red, green and blue
       * @return {String} a hex6 string (#xxxxxx)
       */
      rgbToHexString : function(A){

        return (l + qx.lang.String.pad(A[0].toString(16).toUpperCase(), 2) + qx.lang.String.pad(A[1].toString(16).toUpperCase(), 2) + qx.lang.String.pad(A[2].toString(16).toUpperCase(), 2));
      },
      /**
       * Detects if a string is a valid qooxdoo color
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid qooxdoo color
       */
      isValidPropertyValue : function(B){

        return (this.isThemedColor(B) || this.isNamedColor(B) || this.isHex3String(B) || this.isHex6String(B) || this.isRgbString(B) || this.isRgbaString(B));
      },
      /**
       * Detects if a string is a valid CSS color string
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid CSS color string
       */
      isCssString : function(C){

        return (this.isSystemColor(C) || this.isNamedColor(C) || this.isHex3String(C) || this.isHex6String(C) || this.isRgbString(C) || this.isRgbaString(C));
      },
      /**
       * Detects if a string is a valid hex3 string
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid hex3 string
       */
      isHex3String : function(D){

        return this.REGEXP.hex3.test(D);
      },
      /**
       * Detects if a string is a valid hex6 string
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid hex6 string
       */
      isHex6String : function(E){

        return this.REGEXP.hex6.test(E);
      },
      /**
       * Detects if a string is a valid RGB string
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid RGB string
       */
      isRgbString : function(F){

        return this.REGEXP.rgb.test(F);
      },
      /**
       * Detects if a string is a valid RGBA string
       *
       * @param str {String} any string
       * @return {Boolean} true when the incoming value is a valid RGBA string
       */
      isRgbaString : function(G){

        return this.REGEXP.rgba.test(G);
      },
      /**
       * Converts a regexp object match of a rgb string to an RGB array.
       *
       * @return {Array} an array with red, green, blue
       */
      __rgbStringToRgb : function(){

        var J = parseInt(RegExp.$1, 10);
        var I = parseInt(RegExp.$2, 10);
        var H = parseInt(RegExp.$3, 10);
        return [J, I, H];
      },
      /**
       * Converts a regexp object match of a rgba string to an RGB array.
       *
       * @return {Array} an array with red, green, blue
       */
      __rgbaStringToRgb : function(){

        var M = parseInt(RegExp.$1, 10);
        var L = parseInt(RegExp.$2, 10);
        var K = parseInt(RegExp.$3, 10);
        return [M, L, K];
      },
      /**
       * Converts a regexp object match of a hex3 string to an RGB array.
       *
       * @return {Array} an array with red, green, blue
       */
      __hex3StringToRgb : function(){

        var P = parseInt(RegExp.$1, 16) * 17;
        var O = parseInt(RegExp.$2, 16) * 17;
        var N = parseInt(RegExp.$3, 16) * 17;
        return [P, O, N];
      },
      /**
       * Converts a regexp object match of a hex6 string to an RGB array.
       *
       * @return {Array} an array with red, green, blue
       */
      __hex6StringToRgb : function(){

        var S = (parseInt(RegExp.$1, 16) * 16) + parseInt(RegExp.$2, 16);
        var R = (parseInt(RegExp.$3, 16) * 16) + parseInt(RegExp.$4, 16);
        var Q = (parseInt(RegExp.$5, 16) * 16) + parseInt(RegExp.$6, 16);
        return [S, R, Q];
      },
      /**
       * Converts a hex3 string to an RGB array
       *
       * @param value {String} a hex3 (#xxx) string
       * @return {Array} an array with red, green, blue
       */
      hex3StringToRgb : function(T){

        if(this.isHex3String(T)){

          return this.__hex3StringToRgb(T);
        };
        throw new Error(k + T);
      },
      /**
       * Converts a hex3 (#xxx) string to a hex6 (#xxxxxx) string.
       *
       * @param value {String} a hex3 (#xxx) string
       * @return {String} The hex6 (#xxxxxx) string or the passed value when the
       *   passed value is not an hex3 (#xxx) value.
       */
      hex3StringToHex6String : function(U){

        if(this.isHex3String(U)){

          return this.rgbToHexString(this.hex3StringToRgb(U));
        };
        return U;
      },
      /**
       * Converts a hex6 string to an RGB array
       *
       * @param value {String} a hex6 (#xxxxxx) string
       * @return {Array} an array with red, green, blue
       */
      hex6StringToRgb : function(V){

        if(this.isHex6String(V)){

          return this.__hex6StringToRgb(V);
        };
        throw new Error(e + V);
      },
      /**
       * Converts a hex string to an RGB array
       *
       * @param value {String} a hex3 (#xxx) or hex6 (#xxxxxx) string
       * @return {Array} an array with red, green, blue
       */
      hexStringToRgb : function(W){

        if(this.isHex3String(W)){

          return this.__hex3StringToRgb(W);
        };
        if(this.isHex6String(W)){

          return this.__hex6StringToRgb(W);
        };
        throw new Error(o + W);
      },
      /**
       * Convert RGB colors to HSB
       *
       * @param rgb {Number[]} red, blue and green as array
       * @return {Array} an array with hue, saturation and brightness
       */
      rgbToHsb : function(X){

        var ba,bb,bd;
        var bj = X[0];
        var bg = X[1];
        var Y = X[2];
        var bi = (bj > bg) ? bj : bg;
        if(Y > bi){

          bi = Y;
        };
        var bc = (bj < bg) ? bj : bg;
        if(Y < bc){

          bc = Y;
        };
        bd = bi / 255.0;
        if(bi != 0){

          bb = (bi - bc) / bi;
        } else {

          bb = 0;
        };
        if(bb == 0){

          ba = 0;
        } else {

          var bf = (bi - bj) / (bi - bc);
          var bh = (bi - bg) / (bi - bc);
          var be = (bi - Y) / (bi - bc);
          if(bj == bi){

            ba = be - bh;
          } else if(bg == bi){

            ba = 2.0 + bf - be;
          } else {

            ba = 4.0 + bh - bf;
          };
          ba = ba / 6.0;
          if(ba < 0){

            ba = ba + 1.0;
          };
        };
        return [Math.round(ba * 360), Math.round(bb * 100), Math.round(bd * 100)];
      },
      /**
       * Convert HSB colors to RGB
       *
       * @param hsb {Number[]} an array with hue, saturation and brightness
       * @return {Integer[]} an array with red, green, blue
       */
      hsbToRgb : function(bk){

        var i,f,p,q,t;
        var bl = bk[0] / 360;
        var bm = bk[1] / 100;
        var bn = bk[2] / 100;
        if(bl >= 1.0){

          bl %= 1.0;
        };
        if(bm > 1.0){

          bm = 1.0;
        };
        if(bn > 1.0){

          bn = 1.0;
        };
        var bo = Math.floor(255 * bn);
        var bp = {
        };
        if(bm == 0.0){

          bp.red = bp.green = bp.blue = bo;
        } else {

          bl *= 6.0;
          i = Math.floor(bl);
          f = bl - i;
          p = Math.floor(bo * (1.0 - bm));
          q = Math.floor(bo * (1.0 - (bm * f)));
          t = Math.floor(bo * (1.0 - (bm * (1.0 - f))));
          switch(i){case 0:
          bp.red = bo;
          bp.green = t;
          bp.blue = p;
          break;case 1:
          bp.red = q;
          bp.green = bo;
          bp.blue = p;
          break;case 2:
          bp.red = p;
          bp.green = bo;
          bp.blue = t;
          break;case 3:
          bp.red = p;
          bp.green = q;
          bp.blue = bo;
          break;case 4:
          bp.red = t;
          bp.green = p;
          bp.blue = bo;
          break;case 5:
          bp.red = bo;
          bp.green = p;
          bp.blue = q;
          break;};
        };
        return [bp.red, bp.green, bp.blue];
      },
      /**
       * Creates a random color.
       *
       * @return {String} a valid qooxdoo/CSS rgb color string.
       */
      randomColor : function(){

        var r = Math.round(Math.random() * 255);
        var g = Math.round(Math.random() * 255);
        var b = Math.round(Math.random() * 255);
        return this.rgbToRgbString([r, g, b]);
      }
    }
  });
})();
(function(){

  var o = "__dynamic",n = "_applyTheme",m = "",l = "_",k = "Missing definition of which decorator to use in entry: ",j = "!",h = "qx.ui.decoration.",g = "qx.theme.manager.Decoration",f = ".",e = "Theme",b = "changeTheme",d = "string",c = "singleton",a = "object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Manager for decoration themes
   */
  qx.Class.define(g, {
    type : c,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Selected decoration theme */
      theme : {
        check : e,
        nullable : true,
        apply : n,
        event : b
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __dynamic : null,
      /**
       * Returns the dynamically interpreted result for the incoming value
       *
       * @param value {String} dynamically interpreted idenfier
       * @return {var} return the (translated) result of the incoming value
       */
      resolve : function(p){

        if(!p){

          return null;
        };
        if(typeof p === a){

          return p;
        };
        var u = this.getTheme();
        if(!u){

          return null;
        };
        var r = this.__dynamic;
        if(!r){

          r = this.__dynamic = {
          };
        };
        var q = r[p];
        if(q){

          return q;
        };
        var x = u.decorations[p];
        if(!x){

          return null;
        };
        // create empty style map if necessary
        if(!x.style){

          x.style = {
          };
        };
        // check for inheritance
        var s = x;
        while(s.include){

          s = u.decorations[s.include];
          // decoration key
          if(!x.decorator && s.decorator){

            x.decorator = s.decorator;
          };
          // styles key
          if(s.style){

            for(var w in s.style){

              if(x.style[w] == undefined){

                x.style[w] = s.style[w];
              };
            };
          };
        };
        var t = x.decorator;
        if(t == null){

          throw new Error(k + p + j);
        };
        // check if an array is given and the decorator should be build on runtime
        if(t instanceof Array){

          var v = t.concat([]);
          for(var i = 0;i < v.length;i++){

            v[i] = v[i].basename.replace(f, m);
          };
          var name = h + v.join(l);
          if(!qx.Class.getByName(name)){

            qx.Class.define(name, {
              extend : qx.ui.decoration.DynamicDecorator,
              include : t
            });
          };
          t = qx.Class.getByName(name);
        };
        return r[p] = (new t).set(x.style);
      },
      /**
       * Whether the given value is valid for being used in a property
       * with the 'check' configured to 'Decorator'.
       *
       * @param value {var} Incoming value
       * @return {Boolean} Whether the value is valid for being used in a Decorator property
       */
      isValidPropertyValue : function(y){

        if(typeof y === d){

          return this.isDynamic(y);
        } else if(typeof y === a){

          var z = y.constructor;
          return qx.Class.hasInterface(z, qx.ui.decoration.IDecorator);
        };
        return false;
      },
      /**
       * Whether a value is interpreted dynamically
       *
       * @param value {String} dynamically interpreted idenfier
       * @return {Boolean} returns true if the value is interpreted dynamically
       */
      isDynamic : function(A){

        if(!A){

          return false;
        };
        var B = this.getTheme();
        if(!B){

          return false;
        };
        return !!B.decorations[A];
      },
      /**
       * Whether the given decorator is cached
       *
       * @param decorator {qx.ui.decoration.IDecorator} The decorator to check
       * @return {Boolean} <code>true</code> if the decorator is cached
       * @internal
       */
      isCached : function(C){

        return !this.__dynamic ? false : qx.lang.Object.contains(this.__dynamic, C);
      },
      // property apply
      _applyTheme : function(D, E){

        var G = qx.util.AliasManager.getInstance();
        if(E){

          for(var F in E.aliases){

            G.remove(F);
          };
        };
        if(D){

          for(var F in D.aliases){

            G.add(F, D.aliases[F]);
          };
        };
        if(!D){

          this.__dynamic = {
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeMap(o);
    }
  });
})();
(function(){

  var a = "qx.ui.decoration.IDecorator";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A decorator is responsible for rendering a widget's background and
   * border. It is passed the widget's decoration element {@link qx.html.Element}
   * and configures it to display the decoration.
   *
   * To use the decorator first call the {@link #getMarkup} method. This method
   * will return an HTML fragment containing the decoration. After the decoration
   * has been inserted into the DOM e.g. by using <code>innerHTML</code> the
   * {@link #resize} method must be called to give the decoration the proper size.
   * The first parameter of this call is the root DOM element of the decoration.
   * The resize call can be repeated as needed.
   *
   * It is also possible to alter the background color of an decoration using the
   * {@link #tint} method.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Returns the basic markup structure used for this decoration.
       * This later updated on DOM to resize or tint the element.
       *
       * @return {String} Basic markup
       */
      getMarkup : function(){
      },
      /**
       * Resizes the element respecting the configured borders
       * to the given width and height. Should automatically
       * respect the box model of the client to correctly
       * compute the dimensions.
       *
       * @param element {qx.html.Element} The element to update
       * @param width {Integer} Width of the element
       * @param height {Integer} Height of the element
       */
      resize : function(b, c, d){
      },
      /**
       * Applies the given background color to the element
       * or fallback to the background color defined
       * by the decoration itself.
       *
       * @param element {qx.html.Element} The element to update
       * @param bgcolor {Color} The color to apply or <code>null</code>
       */
      tint : function(e, f){
      },
      /**
       * Get the amount of space, the decoration needs for its border on each
       * side.
       *
       * @return {Map} the desired insed a map with the keys <code>top</code>,
       *     <code>right</code>, <code>bottom</code>, <code>left</code>.
       */
      getInsets : function(){
      }
    }
  });
})();
(function(){

  var l = "abstract",k = "insetRight",j = "insetTop",i = "qx.debug",h = "insetBottom",g = "qx.ui.decoration.Abstract",f = "This decorator is already in-use. Modification is not possible anymore!",e = "shorthand",d = "insetLeft",c = "Abstract method called.",a = "Number",b = "_applyInsets";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This class acts as abstract class for all decorators. It offers the
   * properties for the insets handling. Every decorator has to define its own
   * default insets by implementing the template method
   * (http://en.wikipedia.org/wiki/Template_Method) <code>_getDefaultInsets</code>
   * . Another template method called <code>_isInitialized</code> should return
   * weather the decorator is initialized of not.
   */
  qx.Class.define(g, {
    extend : qx.core.Object,
    implement : [qx.ui.decoration.IDecorator],
    type : l,
    properties : {
      /** Width of the left inset (keep this margin to the outer box) */
      insetLeft : {
        check : a,
        nullable : true,
        apply : b
      },
      /** Width of the right inset (keep this margin to the outer box) */
      insetRight : {
        check : a,
        nullable : true,
        apply : b
      },
      /** Width of the bottom inset (keep this margin to the outer box) */
      insetBottom : {
        check : a,
        nullable : true,
        apply : b
      },
      /** Width of the top inset (keep this margin to the outer box) */
      insetTop : {
        check : a,
        nullable : true,
        apply : b
      },
      /** Property group for insets */
      insets : {
        group : [j, k, h, d],
        mode : e
      }
    },
    members : {
      __insets : null,
      /**
       * Abstract method. Should return a map containing the default insets of
       * the decorator. This could look like this:
       * <pre>
       * return {
       *   top : 0,
       *   right : 0,
       *   bottom : 0,
       *   left : 0
       * };
       * </pre>
       * @return {Map} Map containing the insets.
       */
      _getDefaultInsets : function(){

        throw new Error(c);
      },
      /**
       * Abstract method. Should return an boolean value if the decorator is
       * already initialized or not.
       * @return {Boolean} True, if the decorator is initialized.
       */
      _isInitialized : function(){

        throw new Error(c);
      },
      /**
       * Resets the insets.
       */
      _resetInsets : function(){

        this.__insets = null;
      },
      // interface implementation
      getInsets : function(){

        if(this.__insets){

          return this.__insets;
        };
        var m = this._getDefaultInsets();
        return this.__insets = {
          left : this.getInsetLeft() == null ? m.left : this.getInsetLeft(),
          right : this.getInsetRight() == null ? m.right : this.getInsetRight(),
          bottom : this.getInsetBottom() == null ? m.bottom : this.getInsetBottom(),
          top : this.getInsetTop() == null ? m.top : this.getInsetTop()
        };
      },
      // property apply
      _applyInsets : function(){

        if(qx.core.Environment.get(i)){

          if(this._isInitialized()){

            throw new Error(f);
          };
        };
        this.__insets = null;
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct : function(){

      this.__insets = null;
    }
  });
})();
(function(){

  var p = "_tint",o = "abstract",n = '<div style="',m = "_style",l = "_getDefaultInsetsFor",k = "",j = "left",h = '</div>',g = "qx.ui.decoration.DynamicDecorator",f = '">',c = "bottom",e = "_resize",d = "right",b = "top",a = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class is an abstract base calls and used by
   * {@link qx.theme.manager.Decoration}. It's main purpose is to combine the
   * included mixins into one working decorator.
   */
  qx.Class.define(g, {
    extend : qx.ui.decoration.Abstract,
    type : o,
    members : {
      /**
       * Returns the styles of the decorator as a map with property names written
       * in javascript style (e.g. <code>fontWeight</code> instead of <code>font-weight</code>).
       *
       * @return {Map} style information
       */
      getStyles : function(){

        var s = {
        };
        var r = this._getStyles();
        for(var q in r){

          s[qx.lang.String.camelCase(q)] = r[q];
        };
        return s;
      },
      /**
       * Collects all the style information of the decorators which is necessary
       * to create the markup.
       *
       * @return {Map} style information
       */
      _getStyles : function(){

        var t = {
        };
        for(var name in this){

          if(name.indexOf(m) == 0 && this[name] instanceof Function){

            this[name](t);
          };
        };
        return t;
      },
      // overridden
      getMarkup : function(){

        if(this._markup){

          return this._markup;
        };
        // get the styles
        var u = this._getStyles();
        // build the markup
        if(!this._generateMarkup){

          var v = [n];
          v.push(qx.bom.element.Style.compile(u));
          v.push(f);
          if(this._getContent){

            v.push(this._getContent());
          };
          v.push(h);
          v = v.join(k);
        } else {

          var v = this._generateMarkup(u);
        };
        return this._markup = v;
      },
      // overridden
      resize : function(w, x, y){

        // get the left and top of the mixins
        var A = {
        };
        for(var name in this){

          if(name.indexOf(e) == 0 && this[name] instanceof Function){

            var z = this[name](w, x, y);
            if(A.left == undefined){

              A.left = z.left;
              A.top = z.top;
            };
            if(A.width == undefined){

              A.width = z.width;
              A.height = z.height;
            };
            if(z.elementToApplyDimensions){

              A.elementToApplyDimensions = z.elementToApplyDimensions;
            };
            // use the lowest left and top coordinate to make sure everything
            // is visible
            A.left = z.left < A.left ? z.left : A.left;
            A.top = z.top < A.top ? z.top : A.top;
            // use the biggest width and height
            A.width = z.width > A.width ? z.width : A.width;
            A.height = z.height > A.height ? z.height : A.height;
          };
        };
        // apply only if a mixin requires
        if(A.left != undefined){

          w.style.left = A.left + a;
          w.style.top = A.top + a;
        };
        // apply the width if required
        if(A.width != undefined){

          // Fix to keep applied size above zero
          // Makes issues in IE7 when applying value like '-4px'
          if(A.width < 0){

            A.width = 0;
          };
          if(A.height < 0){

            A.height = 0;
          };
          if(A.elementToApplyDimensions){

            w = A.elementToApplyDimensions;
          };
          w.style.width = A.width + a;
          w.style.height = A.height + a;
        };
      },
      // overridden
      tint : function(B, C){

        for(var name in this){

          if(name.indexOf(p) == 0 && this[name] instanceof Function){

            this[name](B, C, B.style);
          };
        };
      },
      // overridden
      _isInitialized : function(){

        return !!this._markup;
      },
      // overridden
      _getDefaultInsets : function(){

        var G = [b, d, c, j];
        var E = {
        };
        for(var name in this){

          if(name.indexOf(l) == 0 && this[name] instanceof Function){

            var F = this[name]();
            for(var i = 0;i < G.length;i++){

              var D = G[i];
              // initialize with the first insets found
              if(E[D] == undefined){

                E[D] = F[D];
              };
              // take the smallest inset
              if(F[D] < E[D]){

                E[D] = F[D];
              };
            };
          };
        };
        // check if the mixins have created a default insets
        if(E[b] != undefined){

          return E;
        };
        // return a fallback which is 0 for all insets
        return {
          top : 0,
          right : 0,
          bottom : 0,
          left : 0
        };
      }
    }
  });
})();
(function(){

  var p = "clip:auto;",o = "rect(",n = ")",m = ");",l = "",k = "Could not parse clip string: ",j = "qx.bom.element.Clip",i = "string",h = "clip:rect(",g = " ",c = "clip",f = "rect(auto,auto,auto,auto)",e = "rect(auto, auto, auto, auto)",b = ",",a = "px",d = "auto";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains methods to control and query the element's clip property
   */
  qx.Bootstrap.define(j, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Compiles the given clipping into a CSS compatible string. This
       * is a simple square which describes the visible area of an DOM element.
       * Changing the clipping does not change the dimensions of
       * an element.
       *
       * @param map {Map}  Map which contains <code>left</code>, <code>top</code>
       *   <code>width</code> and <code>height</code> of the clipped area.
       * @return {String} CSS compatible string
       */
      compile : function(q){

        if(!q){

          return p;
        };
        var v = q.left;
        var top = q.top;
        var u = q.width;
        var t = q.height;
        var r,s;
        if(v == null){

          r = (u == null ? d : u + a);
          v = d;
        } else {

          r = (u == null ? d : v + u + a);
          v = v + a;
        };
        if(top == null){

          s = (t == null ? d : t + a);
          top = d;
        } else {

          s = (t == null ? d : top + t + a);
          top = top + a;
        };
        return h + top + b + r + b + s + b + v + m;
      },
      /**
       * Gets the clipping of the given element.
       *
       * @param element {Element} DOM element to query
       * @param mode {Number} Choose one of the modes {@link qx.bom.element.Style#COMPUTED_MODE},
       *   {@link qx.bom.element.Style#CASCADED_MODE}, {@link qx.bom.element.Style#LOCAL_MODE}.
       *   The computed mode is the default one.
       * @return {Map} Map which contains <code>left</code>, <code>top</code>
       *   <code>width</code> and <code>height</code> of the clipped area.
       *   Each one could be null or any integer value.
       */
      get : function(w, x){

        var z = qx.bom.element.Style.get(w, c, x, false);
        var F,top,D,C;
        var y,A;
        if(typeof z === i && z !== d && z !== l){

          z = qx.lang.String.trim(z);
          // Do not use "global" here. This will break Firefox because of
          // an issue that the lastIndex will not be resetted on separate calls.
          if(/\((.*)\)/.test(z)){

            var E = RegExp.$1;
            // Process result
            // Some browsers store values space-separated, others comma-separated.
            // Handle both cases by means of feature-detection.
            if(/,/.test(E)){

              var B = E.split(b);
            } else {

              var B = E.split(g);
            };
            top = qx.lang.String.trim(B[0]);
            y = qx.lang.String.trim(B[1]);
            A = qx.lang.String.trim(B[2]);
            F = qx.lang.String.trim(B[3]);
            // Normalize "auto" to null
            if(F === d){

              F = null;
            };
            if(top === d){

              top = null;
            };
            if(y === d){

              y = null;
            };
            if(A === d){

              A = null;
            };
            // Convert to integer values
            if(top != null){

              top = parseInt(top, 10);
            };
            if(y != null){

              y = parseInt(y, 10);
            };
            if(A != null){

              A = parseInt(A, 10);
            };
            if(F != null){

              F = parseInt(F, 10);
            };
            // Compute width and height
            if(y != null && F != null){

              D = y - F;
            } else if(y != null){

              D = y;
            };
            if(A != null && top != null){

              C = A - top;
            } else if(A != null){

              C = A;
            };
          } else {

            throw new Error(k + z);
          };
        };
        // Return map when any value is available.
        return {
          left : F || null,
          top : top || null,
          width : D || null,
          height : C || null
        };
      },
      /**
       * Sets the clipping of the given element. This is a simple
       * square which describes the visible area of an DOM element.
       * Changing the clipping does not change the dimensions of
       * an element.
       *
       * @param element {Element} DOM element to modify
       * @param map {Map} A map with one or more of these available keys:
       *   <code>left</code>, <code>top</code>, <code>width</code>, <code>height</code>.
       * @return {void}
       */
      set : function(G, H){

        if(!H){

          G.style.clip = f;
          return;
        };
        var M = H.left;
        var top = H.top;
        var L = H.width;
        var K = H.height;
        var I,J;
        if(M == null){

          I = (L == null ? d : L + a);
          M = d;
        } else {

          I = (L == null ? d : M + L + a);
          M = M + a;
        };
        if(top == null){

          J = (K == null ? d : K + a);
          top = d;
        } else {

          J = (K == null ? d : top + K + a);
          top = top + a;
        };
        G.style.clip = o + top + b + I + b + J + b + M + n;
      },
      /**
       * Resets the clipping of the given DOM element.
       *
       * @param element {Element} DOM element to modify
       * @return {void}
       */
      reset : function(N){

        N.style.clip = e;
      }
    }
  });
})();
(function(){

  var d = "qx.bom.Style",c = "string",b = "",a = "-";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */
  /**
   * Responsible class for everything concerning styles without the need of
   * an element.
   *
   * If you want to query or modify styles of HTML elements,
   * take a look at {@see qx.bom.element.Style}.
   */
  qx.Bootstrap.define(d, {
    statics : {
      /** Vendor-specific style property prefixes **/
      VENDOR_PREFIXES : ["Webkit", "Moz", "O", "ms", "Khtml"],
      /**
       * Takes the name of a style property and returns the name the browser uses
       * for its implementation, which might include a vendor prefix.
       *
       * @param propertyName {String} Style property name to check
       * @return {String|null} The supported property name or <code>null</code> if
       * not supported
       */
      getPropertyName : function(e){

        var f = document.documentElement.style;
        if(f[e] !== undefined){

          return e;
        };
        for(var i = 0,l = this.VENDOR_PREFIXES.length;i < l;i++){

          var g = this.VENDOR_PREFIXES[i] + qx.lang.String.firstUp(e);
          if(f[g] !== undefined){

            return g;
          };
        };
        return null;
      },
      /**
       * Detects CSS support by applying a style to a DOM element of the given type
       * and verifying the result. Also checks for vendor-prefixed variants of the
       * value, e.g. "linear-gradient" -> "-webkit-linear-gradient". Returns the
       * (possibly vendor-prefixed) value if successful or <code>null</code> if
       * the property and/or value are not supported.
       *
       * @param element {DOMelement} element to be used for the detection
       * @param propertyName {String} the style property to be tested
       * @param value {String} style property value to be tested
       * @param prefixed {Boolean?} try to determine the appropriate vendor prefix
       * for the value. Default: <code>true</code>
       * @return {String|null} prefixed style value or <code>null</code> if not supported
       * @internal
       */
      getAppliedStyle : function(h, j, k, m){

        var n = (m !== false) ? [null].concat(this.VENDOR_PREFIXES) : [null];
        for(var i = 0,l = n.length;i < l;i++){

          var o = n[i] ? a + n[i].toLowerCase() + a + k : k;
          // IE might throw an exception
          try{

            h.style[j] = o;
            if(typeof h.style[j] == c && h.style[j] !== b){

              return o;
            };
          } catch(p) {
          };
        };
        return null;
      }
    }
  });
})();
(function(){

  var k = "This client does not support the boxSizing value",j = "border-box",i = "qx.bom.element.BoxSizing",h = "boxSizing",g = "content-box",f = ":",e = ";",d = "",c = "This client does not support dynamic modification of the boxSizing property.",b = "qx.debug",a = "css.boxsizing";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains methods to control and query the element's box-sizing property.
   *
   * Supported values:
   *
   * * "content-box" = W3C model (dimensions are content specific)
   * * "border-box" = Microsoft model (dimensions are box specific incl. border and padding)
   */
  qx.Bootstrap.define(i, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Map} Internal data structure for __usesNativeBorderBox() */
      __nativeBorderBox : {
        tags : {
          button : true,
          select : true
        },
        types : {
          search : true,
          button : true,
          submit : true,
          reset : true,
          checkbox : true,
          radio : true
        }
      },
      /**
       * Whether the given elements defaults to the "border-box" Microsoft model in all cases.
       *
       * @param element {Element} DOM element to query
       * @return {Boolean} true when the element uses "border-box" independently from the doctype
       */
      __usesNativeBorderBox : function(l){

        var m = this.__nativeBorderBox;
        return m.tags[l.tagName.toLowerCase()] || m.types[l.type];
      },
      /**
       * Compiles the given box sizing into a CSS compatible string.
       *
       * @param value {String} Valid CSS box-sizing value
       * @return {String} CSS string
       */
      compile : function(n){

        if(qx.core.Environment.get(a)){

          var o = qx.lang.String.hyphenate(qx.core.Environment.get(a));
          return o + f + n + e;
        } else {

          if(qx.core.Environment.get(b)){

            qx.log.Logger.warn(this, c);
            qx.log.Logger.trace();
          };
        };
      },
      /**
       * Returns the box sizing for the given element.
       *
       * @param element {Element} The element to query
       * @return {String} Box sizing value of the given element.
       */
      get : function(p){

        if(qx.core.Environment.get(a)){

          return qx.bom.element.Style.get(p, h, null, false) || d;
        };
        if(qx.bom.Document.isStandardMode(qx.dom.Node.getWindow(p))){

          if(!this.__usesNativeBorderBox(p)){

            return g;
          };
        };
        return j;
      },
      /**
       * Applies a new box sizing to the given element
       *
       * @param element {Element} The element to modify
       * @param value {String} New box sizing value to set
       * @return {void}
       */
      set : function(q, r){

        if(qx.core.Environment.get(a)){

          // IE8 bombs when trying to apply an unsupported value
          try{

            q.style[qx.core.Environment.get(a)] = r;
          } catch(s) {

            if(qx.core.Environment.get(b)){

              qx.log.Logger.warn(this, k, r);
            };
          };
        } else {

          if(qx.core.Environment.get(b)){

            qx.log.Logger.warn(this, c);
          };
        };
      },
      /**
       * Removes the local box sizing applied to the element
       *
       * @param element {Element} The element to modify
       * @return {void}
       */
      reset : function(t){

        this.set(t, d);
      }
    }
  });
})();
(function(){

  var n = "css.float",m = "css.borderimage.standardsyntax",l = "borderRadius",k = "boxSizing",j = "stretch",h = 'm11',g = "content",f = "css.inlineblock",e = "css.gradient.filter",d = "css.appearance",bs = "css.opacity",br = "css.gradient.radial",bq = "input",bp = "userSelect",bo = "css.overflowxy",bn = "styleFloat",bm = "css.textShadow.filter",bl = "css.usermodify",bk = "css.boxsizing",bj = 'url("foo.png") 4 4 4 4 fill stretch',u = "css.boxmodel",v = "qx.bom.client.Css",s = "appearance",t = "placeholder",q = "css.textShadow",r = "DXImageTransform.Microsoft.Shadow",o = "css.boxshadow",p = "css.gradient.legacywebkit",C = "css.borderradius",D = "linear-gradient(0deg, #fff, #000)",O = "textShadow",L = "css.borderimage",W = "rgba(1, 2, 3, 0.5)",R = "color=#666666,direction=45",bf = "radial-gradient(0px 0px, cover, red 50%, blue 100%)",bc = "rgba",H = "(",bi = 'url("foo.png") 4 4 4 4 stretch',bh = "css.gradient.linear",bg = "DXImageTransform.Microsoft.Gradient",G = "css.userselect",J = "-webkit-gradient(linear,0% 0%,100% 100%,from(white), to(red))",K = "mshtml",N = "css.rgba",P = ");",S = "4 fill",Y = 'WebKitCSSMatrix',be = "red 1px 1px 3px",w = "none",x = "startColorStr=#550000FF, endColorStr=#55FFFF00",I = "progid:",V = "css.placeholder",U = "css.userselect.none",T = "css.textoverflow",bb = "textOverflow",ba = "userModify",Q = "boxShadow",X = "cssFloat",a = "border",bd = "color",y = "borderImage",z = "foo.png",M = "span",b = "string",c = "-moz-none",F = "backgroundImage",A = "inline-block",B = "-moz-inline-box",E = "div";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(WebKitCSSMatrix)
  
  ************************************************************************ */
  /**
   * The purpose of this class is to contain all checks about css.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(v, {
    statics : {
      __WEBKIT_LEGACY_GRADIENT : null,
      /**
       * Checks what box model is used in the current environemnt.
       * @return {String} It either returns "content" or "border".
       * @internal
       */
      getBoxModel : function(){

        var content = qx.bom.client.Engine.getName() !== K || !qx.bom.client.Browser.getQuirksMode();
        return content ? g : a;
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>textOverflow</code> style property.
       *
       * @return {String|null} textOverflow property name or <code>null</code> if
       * textOverflow is not supported.
       * @internal
       */
      getTextOverflow : function(){

        return qx.bom.Style.getPropertyName(bb);
      },
      /**
       * Checks if a placeholder could be used.
       * @return {Boolean} <code>true</code>, if it could be used.
       * @internal
       */
      getPlaceholder : function(){

        var i = document.createElement(bq);
        return t in i;
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>appearance</code> style property.
       *
       * @return {String|null} appearance property name or <code>null</code> if
       * appearance is not supported.
       * @internal
       */
      getAppearance : function(){

        return qx.bom.Style.getPropertyName(s);
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>borderRadius</code> style property.
       *
       * @return {String|null} borderRadius property name or <code>null</code> if
       * borderRadius is not supported.
       * @internal
       */
      getBorderRadius : function(){

        return qx.bom.Style.getPropertyName(l);
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>boxShadow</code> style property.
       *
       * @return {String|null} boxShadow property name or <code>null</code> if
       * boxShadow is not supported.
       * @internal
       */
      getBoxShadow : function(){

        return qx.bom.Style.getPropertyName(Q);
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>borderImage</code> style property.
       *
       * @return {String|null} borderImage property name or <code>null</code> if
       * borderImage is not supported.
       * @internal
       */
      getBorderImage : function(){

        return qx.bom.Style.getPropertyName(y);
      },
      /**
       * Returns the type of syntax this client supports for its CSS border-image
       * implementation. Some browsers do not support the "fill" keyword defined
       * in the W3C draft (http://www.w3.org/TR/css3-background/) and will not
       * show the border image if it's set. Others follow the standard closely and
       * will omit the center image if "fill" is not set.
       *
       * @return {Boolean|null} <code>true</code> if the standard syntax is supported.
       * <code>null</code> if the supported syntax could not be detected.
       * @internal
       */
      getBorderImageSyntax : function(){

        var bu = qx.bom.client.Css.getBorderImage();
        if(!bu){

          return null;
        };
        var bt = document.createElement(E);
        if(bu === y){

          // unprefixed implementation: check individual properties
          bt.style[bu] = bj;
          if(bt.style.borderImageSource.indexOf(z) >= 0 && bt.style.borderImageSlice.indexOf(S) >= 0 && bt.style.borderImageRepeat.indexOf(j) >= 0){

            return true;
          };
        } else {

          // prefixed implementation, assume no support for "fill"
          bt.style[bu] = bi;
          // serialized value is unreliable, so just a simple check
          if(bt.style[bu].indexOf(z) >= 0){

            return false;
          };
        };
        // unable to determine syntax
        return null;
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>userSelect</code> style property.
       *
       * @return {String|null} userSelect property name or <code>null</code> if
       * userSelect is not supported.
       * @internal
       */
      getUserSelect : function(){

        return qx.bom.Style.getPropertyName(bp);
      },
      /**
       * Returns the (possibly vendor-prefixed) value for the
       * <code>userSelect</code> style property that disables selection. For Gecko,
       * "-moz-none" is returned since "none" only makes the target element appear
       * as if its text could not be selected
       *
       * @internal
       * @return {String|null} the userSelect property value that disables
       * selection or <code>null</code> if userSelect is not supported
       */
      getUserSelectNone : function(){

        var bw = qx.bom.client.Css.getUserSelect();
        if(bw){

          var bv = document.createElement(M);
          bv.style[bw] = c;
          return bv.style[bw] === c ? c : w;
        };
        return null;
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>userModify</code> style property.
       *
       * @return {String|null} userModify property name or <code>null</code> if
       * userModify is not supported.
       * @internal
       */
      getUserModify : function(){

        return qx.bom.Style.getPropertyName(ba);
      },
      /**
       * Returns the vendor-specific name of the <code>float</code> style property
       *
       * @return {String|null} <code>cssFloat</code> for standards-compliant
       * browsers, <code>styleFloat</code> for legacy IEs, <code>null</code> if
       * the client supports neither property.
       * @internal
       */
      getFloat : function(){

        var bx = document.documentElement.style;
        return bx.cssFloat !== undefined ? X : bx.styleFloat !== undefined ? bn : null;
      },
      /**
       * Checks if translate3d can be used.
       * @return {Boolean} <code>true</code>, if it could be used.
       * @internal
       * @lint ignoreUndefined(WebKitCSSMatrix)
       */
      getTranslate3d : function(){

        return Y in window && h in new WebKitCSSMatrix();
      },
      /**
       * Returns the (possibly vendor-prefixed) name this client uses for
       * <code>linear-gradient</code>.
       * http://dev.w3.org/csswg/css3-images/#linear-gradients
       *
       * @return {String|null} Prefixed linear-gradient name or <code>null</code>
       * if linear gradients are not supported
       * @internal
       */
      getLinearGradient : function(){

        qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT = false;
        var bB = D;
        var by = document.createElement(E);
        var bz = qx.bom.Style.getAppliedStyle(by, F, bB);
        if(!bz){

          //try old WebKit syntax (versions 528 - 534.16)
          bB = J;
          var bz = qx.bom.Style.getAppliedStyle(by, F, bB, false);
          if(bz){

            qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT = true;
          };
        };
        // not supported
        if(!bz){

          return null;
        };
        var bA = /(.*?)\(/.exec(bz);
        return bA ? bA[1] : null;
      },
      /**
       * Returns <code>true</code> if the browser supports setting gradients
       * using the filter style. This usually only applies for IE browsers
       * starting from IE5.5.
       * http://msdn.microsoft.com/en-us/library/ms532997(v=vs.85).aspx
       *
       * @return {Boolean} <code>true</code> if supported.
       * @internal
       */
      getFilterGradient : function(){

        return qx.bom.client.Css.__isFilterSupported(bg, x);
      },
      /**
       * Returns the (possibly vendor-prefixed) name this client uses for
       * <code>radial-gradient</code>.
       *
       * @return {String|null} Prefixed radial-gradient name or <code>null</code>
       * if radial gradients are not supported
       * @internal
       */
      getRadialGradient : function(){

        var bF = bf;
        var bC = document.createElement(E);
        var bD = qx.bom.Style.getAppliedStyle(bC, F, bF);
        if(!bD){

          return null;
        };
        var bE = /(.*?)\(/.exec(bD);
        return bE ? bE[1] : null;
      },
      /**
       * Checks if **only** the old WebKit (version < 534.16) syntax for
       * linear gradients is supported, e.g.
       * <code>linear-gradient(0deg, #fff, #000)</code>
       *
       * @return {Boolean} <code>true</code> if the legacy syntax must be used
       * @internal
       */
      getLegacyWebkitGradient : function(){

        if(qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT === null){

          qx.bom.client.Css.getLinearGradient();
        };
        return qx.bom.client.Css.__WEBKIT_LEGACY_GRADIENT;
      },
      /**
       * Checks if rgba colors can be used:
       * http://www.w3.org/TR/2010/PR-css3-color-20101028/#rgba-color
       *
       * @return {Boolean} <code>true</code>, if rgba colors are supported.
       * @internal
       */
      getRgba : function(){

        var bG;
        try{

          bG = document.createElement(E);
        } catch(bH) {

          bG = document.createElement();
        };
        // try catch for IE
        try{

          bG.style[bd] = W;
          if(bG.style[bd].indexOf(bc) != -1){

            return true;
          };
        } catch(bI) {
        };
        return false;
      },
      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>boxSizing</code> style property.
       *
       * @return {String|null} boxSizing property name or <code>null</code> if
       * boxSizing is not supported.
       * @internal
       */
      getBoxSizing : function(){

        return qx.bom.Style.getPropertyName(k);
      },
      /**
       * Returns the browser-specific name used for the <code>display</code> style
       * property's <code>inline-block</code> value.
       *
       * @internal
       * @return {String|null}
       */
      getInlineBlock : function(){

        var bJ = document.createElement(M);
        bJ.style.display = A;
        if(bJ.style.display == A){

          return A;
        };
        bJ.style.display = B;
        if(bJ.style.display !== B){

          return B;
        };
        return null;
      },
      /**
       * Checks if CSS opacity is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if opacity is supported
       */
      getOpacity : function(){

        return (typeof document.documentElement.style.opacity == b);
      },
      /**
       * Checks if the overflowX and overflowY style properties are supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if overflow-x and overflow-y can be
       * used
       */
      getOverflowXY : function(){

        return (typeof document.documentElement.style.overflowX == b) && (typeof document.documentElement.style.overflowY == b);
      },
      /**
       * Checks if CSS texShadow is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if textShadow is supported
       */
      getTextShadow : function(){

        var bM = be;
        var bK = document.createElement(E);
        var bL = qx.bom.Style.getAppliedStyle(bK, O, bM);
        return !bL;
      },
      /**
       * Returns <code>true</code> if the browser supports setting text shadow
       * using the filter style. This usually only applies for IE browsers
       * starting from IE5.5.
       *
       * @internal
       * @return {Boolean} <code>true</code> if textShadow is supported
       */
      getFilterTextShadow : function(){

        return qx.bom.client.Css.__isFilterSupported(r, R);
      },
      /**
       * Checks if the given filter is supported.
       *
       * @param filterClass {String} The name of the filter class
       * @param initParams {String} Init values for the filter
       * @return {Boolean} <code>true</code> if the given filter is supported
       */
      __isFilterSupported : function(bN, bO){

        var bQ = false;
        var bR = I + bN + H + bO + P;
        var bP = document.createElement(E);
        document.body.appendChild(bP);
        bP.style.filter = bR;
        if(bP.filters && bP.filters.length > 0 && bP.filters.item(bN).enabled == true){

          bQ = true;
        };
        document.body.removeChild(bP);
        return bQ;
      }
    },
    defer : function(bS){

      qx.core.Environment.add(T, bS.getTextOverflow);
      qx.core.Environment.add(V, bS.getPlaceholder);
      qx.core.Environment.add(C, bS.getBorderRadius);
      qx.core.Environment.add(o, bS.getBoxShadow);
      qx.core.Environment.add(bh, bS.getLinearGradient);
      qx.core.Environment.add(e, bS.getFilterGradient);
      qx.core.Environment.add(br, bS.getRadialGradient);
      qx.core.Environment.add(p, bS.getLegacyWebkitGradient);
      qx.core.Environment.add(u, bS.getBoxModel);
      qx.core.Environment.add(N, bS.getRgba);
      qx.core.Environment.add(L, bS.getBorderImage);
      qx.core.Environment.add(m, bS.getBorderImageSyntax);
      qx.core.Environment.add(bl, bS.getUserModify);
      qx.core.Environment.add(G, bS.getUserSelect);
      qx.core.Environment.add(U, bS.getUserSelectNone);
      qx.core.Environment.add(d, bS.getAppearance);
      qx.core.Environment.add(n, bS.getFloat);
      qx.core.Environment.add(bk, bS.getBoxSizing);
      qx.core.Environment.add(f, bS.getInlineBlock);
      qx.core.Environment.add(bs, bS.getOpacity);
      qx.core.Environment.add(bo, bS.getOverflowXY);
      qx.core.Environment.add(q, bS.getTextShadow);
      qx.core.Environment.add(bm, bS.getFilterTextShadow);
    }
  });
})();
(function(){

  var j = "CSS1Compat",i = "android",h = "operamini",g = "gecko",f = "browser.quirksmode",e = "browser.name",d = "mobile chrome",c = "iemobile",b = "prism|Fennec|Camino|Kmeleon|Galeon|Netscape|SeaMonkey|Namoroka|Firefox",a = "opera mobi",H = "Mobile Safari",G = "Maple",F = "operamobile",E = "ie",D = "mobile safari",C = "IEMobile|Maxthon|MSIE",B = "qx.bom.client.Browser",A = "(Maple )([0-9]+\.[0-9]+\.[0-9]*)",z = "opera mini",y = "browser.version",q = "opera",r = "Opera Mini|Opera Mobi|Opera",o = "AdobeAIR|Titanium|Fluid|Chrome|Android|Epiphany|Konqueror|iCab|OmniWeb|Maxthon|Pre|Mobile Safari|Safari",p = "webkit",m = "browser.documentmode",n = "5.0",k = "Mobile/",l = "msie",s = "maple",t = ")(/| )([0-9]+\.[0-9])",v = "(",u = "ce",x = "",w = "mshtml";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
     ======================================================================
  
     This class contains code from:
  
       Copyright:
         2009 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         LGPL: http://www.gnu.org/licenses/lgpl.html
         EPL: http://www.eclipse.org/org/documents/epl-v10.php
  
       Authors:
         * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code from:
  
       Copyright:
         2011 Pocket Widget S.L., Spain, http://www.pocketwidget.com
  
       License:
         LGPL: http://www.gnu.org/licenses/lgpl.html
         EPL: http://www.eclipse.org/org/documents/epl-v10.php
  
       Authors:
         * Javier Martinez Villacampa
  
  
  ************************************************************************ */
  /**
  #require(qx.bom.client.OperatingSystem#getVersion)
  */
  /**
   * Basic browser detection for qooxdoo.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(B, {
    statics : {
      /**
       * Checks for the name of the browser and returns it.
       * @return {String} The name of the current browser.
       * @internal
       */
      getName : function(){

        var L = navigator.userAgent;
        var K = new RegExp(v + qx.bom.client.Browser.__agents + t);
        var J = L.match(K);
        if(!J){

          return x;
        };
        var name = J[1].toLowerCase();
        var I = qx.bom.client.Engine.getName();
        if(I === p){

          if(name === i){

            // Fix Chrome name (for instance wrongly defined in user agent on Android 1.6)
            name = d;
          } else if(L.indexOf(H) !== -1 || L.indexOf(k) !== -1){

            // Fix Safari name
            name = D;
          };
        } else if(I === w){

          if(name === l){

            name = E;
            // Fix IE mobile before Microsoft added IEMobile string
            if(qx.bom.client.OperatingSystem.getVersion() === u){

              name = c;
            };
          };
        } else if(I === q){

          if(name === a){

            name = F;
          } else if(name === z){

            name = h;
          };
        } else if(I === g){

          if(L.indexOf(G) !== -1){

            name = s;
          };
        };;;
        return name;
      },
      /**
       * Determines the version of the current browser.
       * @return {String} The name of the current browser.
       * @internal
       */
      getVersion : function(){

        var P = navigator.userAgent;
        var O = new RegExp(v + qx.bom.client.Browser.__agents + t);
        var N = P.match(O);
        if(!N){

          return x;
        };
        var name = N[1].toLowerCase();
        var M = N[3];
        // Support new style version string used by Opera and Safari
        if(P.match(/Version(\/| )([0-9]+\.[0-9])/)){

          M = RegExp.$2;
        };
        if(qx.bom.client.Engine.getName() == w){

          // Use the Engine version, because IE8 and higher change the user agent
          // string to an older version in compatibility mode
          M = qx.bom.client.Engine.getVersion();
          if(name === l && qx.bom.client.OperatingSystem.getVersion() == u){

            // Fix IE mobile before Microsoft added IEMobile string
            M = n;
          };
        };
        if(qx.bom.client.Browser.getName() == s){

          // Fix version detection for Samsung Smart TVs Maple browser from 2010 and 2011 models
          O = new RegExp(A);
          N = P.match(O);
          if(!N){

            return x;
          };
          M = N[2];
        };
        return M;
      },
      /**
       * Returns in which document mode the current document is (only for IE).
       *
       * @internal
       * @return {Number} The mode in which the browser is.
       */
      getDocumentMode : function(){

        if(document.documentMode){

          return document.documentMode;
        };
        return 0;
      },
      /**
       * Check if in quirks mode.
       *
       * @internal
       * @return {Boolean} <code>true</code>, if the environment is in quirks mode
       */
      getQuirksMode : function(){

        if(qx.bom.client.Engine.getName() == w && parseFloat(qx.bom.client.Engine.getVersion()) >= 8){

          return qx.bom.client.Engine.DOCUMENT_MODE === 5;
        } else {

          return document.compatMode !== j;
        };
      },
      /**
       * Internal helper map for picking the right browser names to check.
       */
      __agents : {
        // Safari should be the last one to check, because some other Webkit-based browsers
        // use this identifier together with their own one.
        // "Version" is used in Safari 4 to define the Safari version. After "Safari" they place the
        // Webkit version instead. Silly.
        // Palm Pre uses both Safari (contains Webkit version) and "Version" contains the "Pre" version. But
        // as "Version" is not Safari here, we better detect this as the Pre-Browser version. So place
        // "Pre" in front of both "Version" and "Safari".
        "webkit" : o,
        // Better security by keeping Firefox the last one to match
        "gecko" : b,
        // No idea what other browsers based on IE's engine
        "mshtml" : C,
        // Keep "Opera" the last one to correctly prefer/match the mobile clients
        "opera" : r
      }[qx.bom.client.Engine.getName()]
    },
    defer : function(Q){

      qx.core.Environment.add(e, Q.getName),qx.core.Environment.add(y, Q.getVersion),qx.core.Environment.add(m, Q.getDocumentMode),qx.core.Environment.add(f, Q.getQuirksMode);
    }
  });
})();
(function(){

  var k = "engine.name",j = "",i = "cursor:",h = ";",g = "qx.bom.element.Cursor",f = "cursor",e = "hand",d = "nw-resize",c = "ne-resize",b = "n-resize",a = "e-resize";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains methods to control and query the element's cursor property
   */
  qx.Bootstrap.define(g, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Internal helper structure to map cursor values to supported ones */
      __map : qx.core.Environment.select(k, {
        "mshtml" : {
          "cursor" : e,
          "ew-resize" : a,
          "ns-resize" : b,
          "nesw-resize" : c,
          "nwse-resize" : d
        },
        "opera" : {
          "col-resize" : a,
          "row-resize" : b,
          "ew-resize" : a,
          "ns-resize" : b,
          "nesw-resize" : c,
          "nwse-resize" : d
        },
        "default" : {
        }
      }),
      /**
       * Compiles the given cursor into a CSS compatible string.
       *
       * @param cursor {String} Valid CSS cursor name
       * @return {String} CSS string
       */
      compile : function(l){

        return i + (this.__map[l] || l) + h;
      },
      /**
       * Returns the computed cursor style for the given element.
       *
       * @param element {Element} The element to query
       * @param mode {Number} Choose one of the modes {@link qx.bom.element.Style#COMPUTED_MODE},
       *   {@link qx.bom.element.Style#CASCADED_MODE}, {@link qx.bom.element.Style#LOCAL_MODE}.
       *   The computed mode is the default one.
       * @return {String} Computed cursor value of the given element.
       */
      get : function(m, n){

        return qx.bom.element.Style.get(m, f, n, false);
      },
      /**
       * Applies a new cursor style to the given element
       *
       * @param element {Element} The element to modify
       * @param value {String} New cursor value to set
       * @return {void}
       */
      set : function(o, p){

        o.style.cursor = this.__map[p] || p;
      },
      /**
       * Removes the local cursor style applied to the element
       *
       * @param element {Element} The element to modify
       * @return {void}
       */
      reset : function(q){

        q.style.cursor = j;
      }
    }
  });
})();
(function(){

  var r = "&",q = "function",p = "Invalid argument 'array'",o = "Invalid argument 'minLength'",n = "Invalid argument 'source'",m = " at array index ",k = "Could not convert complex objects like ",j = "qx.lang.Object",h = "undefined",g = " to map syntax",c = "object",f = "+",e = "Invalid argument 'target'",b = "=",a = "Invalid argument 'map'",d = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Helper functions to handle Object as a Hash map.
   */
  qx.Bootstrap.define(j, {
    statics : {
      /**
       * Clears the map from all values
       *
       * @param map {Object} the map to clear
       */
      empty : function(s){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(s, a);
        };
        for(var t in s){

          if(s.hasOwnProperty(t)){

            delete s[t];
          };
        };
      },
      /**
       * Check if the hash has any keys
       *
       * @signature function(map)
       * @param map {Object} the map to check
       * @return {Boolean} whether the map has any keys
       */
      isEmpty : function(u){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(u, a);
        };
        for(var v in u){

          return false;
        };
        return true;
      },
      /**
       * Check whether the number of objects in the maps is at least "length"
       *
       * @signature function(map, minLength)
       * @param map {Object} the map to check
       * @param minLength {Integer} minimum number of objects in the map
       * @return {Boolean} whether the map contains at least "length" objects.
       */
      hasMinLength : function(w, x){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(w, a);
          qx.core.Assert && qx.core.Assert.assertInteger(x, o);
        };
        if(x <= 0){

          return true;
        };
        var length = 0;
        for(var y in w){

          if((++length) >= x){

            return true;
          };
        };
        return false;
      },
      /**
       * Get the number of objects in the map
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Integer} number of objects in the map
       */
      getLength : qx.Bootstrap.objectGetLength,
      /**
       * Get the keys of a map as array as returned by a "for ... in" statement.
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Array} array of the keys of the map
       */
      getKeys : qx.Bootstrap.getKeys,
      /**
       * Get the keys of a map as string
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {String} String of the keys of the map
       *         The keys are separated by ", "
       */
      getKeysAsString : qx.Bootstrap.getKeysAsString,
      /**
       * Get the values of a map as array
       *
       * @param map {Object} the map
       * @return {Array} array of the values of the map
       */
      getValues : function(z){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(z, a);
        };
        var B = [];
        var A = this.getKeys(z);
        for(var i = 0,l = A.length;i < l;i++){

          B.push(z[A[i]]);
        };
        return B;
      },
      /**
       * Inserts all keys of the source object into the
       * target objects. Attention: The target map gets modified.
       *
       * @signature function(target, source, overwrite)
       * @param target {Object} target object
       * @param source {Object} object to be merged
       * @param overwrite {Boolean ? true} If enabled existing keys will be overwritten
       * @return {Object} Target with merged values from the source object
       */
      mergeWith : qx.Bootstrap.objectMergeWith,
      /**
       * Inserts all key/value pairs of the source object into the
       * target object but doesn't override existing keys
       *
       * @param target {Object} target object
       * @param source {Object} object to be merged
       * @return {Object} target with merged values from source
       */
      carefullyMergeWith : function(C, D){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(C, e);
          qx.core.Assert && qx.core.Assert.assertMap(D, n);
        };
        return qx.lang.Object.mergeWith(C, D, false);
      },
      /**
       * Merge a number of objects.
       *
       * @param target {Object} target object
       * @param varargs {Object} variable number of objects to merged with target
       * @return {Object} target with merged values from the other objects
       */
      merge : function(E, F){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(E, e);
        };
        var G = arguments.length;
        for(var i = 1;i < G;i++){

          qx.lang.Object.mergeWith(E, arguments[i]);
        };
        return E;
      },
      /**
       * Return a copy of an Object
       *
       * @param source {Object} Object to copy
       * @param deep {Boolean} If the clone should be a deep clone.
       * @return {Object} A copy of the object
       */
      clone : function(H, I){

        if(qx.lang.Type.isObject(H)){

          var J = {
          };
          for(var K in H){

            if(I){

              J[K] = qx.lang.Object.clone(H[K], I);
            } else {

              J[K] = H[K];
            };
          };
          return J;
        } else if(qx.lang.Type.isArray(H)){

          var J = [];
          for(var i = 0;i < H.length;i++){

            if(I){

              J[i] = qx.lang.Object.clone(H[i]);
            } else {

              J[i] = H[i];
            };
          };
          return J;
        };
        return H;
      },
      /**
       * Inverts a map by exchanging the keys with the values.
       *
       * If the map has the same values for different keys, information will get lost.
       * The values will be converted to strings using the toString methods.
       *
       * @param map {Object} Map to invert
       * @return {Object} inverted Map
       */
      invert : function(L){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(L, a);
        };
        var M = {
        };
        for(var N in L){

          M[L[N].toString()] = N;
        };
        return M;
      },
      /**
       * Get the key of the given value from a map.
       * If the map has more than one key matching the value, the first match is returned.
       * If the map does not contain the value, <code>null</code> is returned.
       *
       * @param map {Object} Map to search for the key
       * @param value {var} Value to look for
       * @return {String|null} Name of the key (null if not found).
       */
      getKeyFromValue : function(O, P){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(O, a);
        };
        for(var Q in O){

          if(O.hasOwnProperty(Q) && O[Q] === P){

            return Q;
          };
        };
        return null;
      },
      /**
       * Whether the map contains the given value.
       *
       * @param map {Object} Map to search for the value
       * @param value {var} Value to look for
       * @return {Boolean} Whether the value was found in the map.
       */
      contains : function(R, S){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(R, a);
        };
        return this.getKeyFromValue(R, S) !== null;
      },
      /**
      * Selects the value with the given key from the map.
      *
      * @param key {String} name of the key to get the value from
      * @param map {Object} map to get the value from
      * @return {var} value for the given key from the map
      */
      select : function(T, U){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertMap(U, a);
        };
        return U[T];
      },
      /**
      * Convert an array into a map.
      *
      * All elements of the array become keys of the returned map by
      * calling <code>toString</code> on the array elements. The values of the
      * map are set to <code>true</code>
      *
      * @param array {Array} array to convert
      * @return {Map} the array converted to a map.
      */
      fromArray : function(V){

        if(qx.core.Environment.get(d)){

          qx.core.Assert && qx.core.Assert.assertArray(V, p);
        };
        var W = {
        };
        for(var i = 0,l = V.length;i < l;i++){

          if(qx.core.Environment.get(d)){

            switch(typeof V[i]){case c:case q:case h:
            throw new Error(k + V[i] + m + i + g);};
          };
          W[V[i].toString()] = true;
        };
        return W;
      },
      /**
       * Serializes an object to URI parameters (also known as query string).
       *
       * Escapes characters that have a special meaning in URIs as well as
       * umlauts. Uses the global function encodeURIComponent, see
       * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/encodeURIComponent
       *
       * Note: For URI parameters that are to be sent as
       * application/x-www-form-urlencoded (POST), spaces should be encoded
       * with "+".
       *
       * @param obj {Object}   Object to serialize.
       * @param post {Boolean} Whether spaces should be encoded with "+".
       * @return {String}      Serialized object. Safe to append to URIs or send as
       *                       URL encoded string.
       *
       */
      toUriParameter : function(X, Y){

        var bc,ba = [];
        for(bc in X){

          if(X.hasOwnProperty(bc)){

            var bb = X[bc];
            if(bb instanceof Array){

              for(var i = 0;i < bb.length;i++){

                this.__toUriParameter(bc, bb[i], ba, Y);
              };
            } else {

              this.__toUriParameter(bc, bb, ba, Y);
            };
          };
        };
        return ba.join(r);
      },
      /**
       * Encodes key/value to URI safe string and pushes to given array.
       *
       * @param key {String} Key.
       * @param value {String} Value.
       * @param parts {Array} Array to push to.
       * @param post {Boolean} Whether spaces should be encoded with "+".
       */
      __toUriParameter : function(bd, be, bf, bg){

        var bh = window.encodeURIComponent;
        if(bg){

          bf.push(bh(bd).replace(/%20/g, f) + b + bh(be).replace(/%20/g, f));
        } else {

          bf.push(bh(bd) + b + bh(be));
        };
      }
    }
  });
})();
(function(){

  var k = "borderLeftStyle",j = "borderRightStyle",i = "div",h = "borderRightWidth",g = "overflow-y",f = "borderLeftWidth",e = "-moz-scrollbars-vertical",d = ":",b = "100px",a = "overflow:",B = "qx.bom.element.Overflow",A = "overflow-x",z = "overflowX",y = ";",x = "overflowY",w = "engine.version",v = "none",u = "scroll",r = "gecko",q = "overflow",o = "",p = "engine.name",m = "-moz-scrollbars-none",n = "hidden",l = "css.overflowxy";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains methods to control and query the element's overflow properties.
   */
  qx.Bootstrap.define(B, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * The default width which is used for the width of the scroll bar if
       * overlayed.
       */
      DEFAULT_SCROLLBAR_WIDTH : 14,
      /** {Integer} The typical native scrollbar size in the environment */
      __scrollbarSize : null,
      /**
       * Get the typical native scrollbar size in the environment
       *
       * @return {Integer} The native scrollbar size
       */
      getScrollbarWidth : function(){

        if(this.__scrollbarSize !== null){

          return this.__scrollbarSize;
        };
        var C = qx.bom.element.Style;
        var E = function(I, J){

          return parseInt(C.get(I, J), 10) || 0;
        };
        var F = function(K){

          return (C.get(K, j) == v ? 0 : E(K, h));
        };
        var D = function(L){

          return (C.get(L, k) == v ? 0 : E(L, f));
        };
        var H = qx.core.Environment.select(p, {
          "mshtml" : function(M){

            if(C.get(M, x) == n || M.clientWidth == 0){

              return F(M);
            };
            return Math.max(0, M.offsetWidth - M.clientLeft - M.clientWidth);
          },
          "default" : function(N){

            // Alternative method if clientWidth is unavailable
            // clientWidth == 0 could mean both: unavailable or really 0
            if(N.clientWidth == 0){

              var O = C.get(N, q);
              var P = (O == u || O == e ? 16 : 0);
              return Math.max(0, F(N) + P);
            };
            return Math.max(0, (N.offsetWidth - N.clientWidth - D(N)));
          }
        });
        var G = function(Q){

          return H(Q) - F(Q);
        };
        var t = document.createElement(i);
        var s = t.style;
        s.height = s.width = b;
        s.overflow = u;
        document.body.appendChild(t);
        var c = G(t);
        this.__scrollbarSize = c;
        document.body.removeChild(t);
        return this.__scrollbarSize;
      },
      /**
       * Compiles the given property into a cross-browser style string.
       *
       * @signature function(prop, value)
       * @param prop {String} Property name (overflowX or overflowY)
       * @param value {String} Overflow value for the given axis
       * @return {String} CSS string
       */
      _compile : function(R, S){

        if(!qx.core.Environment.get(l)){

          R = a;
          if(qx.core.Environment.get(p) === r && S == n){

            S = m;
          };
        };
        return R + d + S + y;
      },
      /**
       * Compiles the horizontal overflow property into a cross-browser style string.
       *
       * @param value {String} Overflow value
       * @return {String} CSS string
       */
      compileX : function(T){

        return this._compile(A, T);
      },
      /**
       * Compiles the vertical overflow property into a cross-browser style string.
       *
       * @param value {String} Overflow value
       * @return {String} CSS string
       */
      compileY : function(U){

        return this._compile(g, U);
      },
      // Mozilla notes (http://developer.mozilla.org/en/docs/Mozilla_CSS_Extensions):
      // -moz-scrollbars-horizontal: Indicates that horizontal scrollbars should
      //    always appear and vertical scrollbars should never appear.
      // -moz-scrollbars-vertical: Indicates that vertical scrollbars should
      //    always appear and horizontal scrollbars should never appear.
      // -moz-scrollbars-none: Indicates that no scrollbars should appear but
      //    the element should be scrollable from script. (This is the same as
      //    hidden, and has been since Mozilla 1.6alpha.)
      //
      // Also a lot of interesting bugs:
      // * https://bugzilla.mozilla.org/show_bug.cgi?id=42676
      // * https://bugzilla.mozilla.org/show_bug.cgi?id=47710
      // * https://bugzilla.mozilla.org/show_bug.cgi?id=235524
      /**
       * Returns the computed value of the horizontal overflow
       *
       * @param element {Element} DOM element to query
       * @param mode {Number} Choose one of the modes {@link qx.bom.element.Style#COMPUTED_MODE},
       *   {@link qx.bom.element.Style#CASCADED_MODE}, {@link qx.bom.element.Style#LOCAL_MODE}.
       *   The computed mode is the default one.
       * @return {String} computed overflow value
       */
      getX : function(V, W){

        if(qx.core.Environment.get(l)){

          return qx.bom.element.Style.get(V, z, W, false);
        };
        var X = qx.bom.element.Style.get(V, q, W, false);
        if(X === m){

          X = n;
        };
        return X;
      },
      /**
       * Sets the local horizontal overflow value to the given value
       *
       * @param element {Element} DOM element to modify
       * @param value {String} Any of "visible", "scroll", "hidden", "auto" or ""
       * @return {void}
       */
      setX : function(Y, ba){

        if(qx.core.Environment.get(l)){

          Y.style.overflowX = ba;
        } else {

          if(ba === n && qx.core.Environment.get(p) === r && parseFloat(qx.core.Environment.get(w)) < 1.8){

            ba = m;
          };
          Y.style.overflow = ba;
        };
      },
      /**
       * Removes the locally configured horizontal overflow property
       *
       * @param element {Element} DOM element to modify
       * @return {void}
       */
      resetX : function(bb){

        if(qx.core.Environment.get(l)){

          bb.style.overflowX = o;
        } else {

          bb.style.overflow = o;
        };
      },
      /**
       * Returns the computed value of the vertical overflow
       *
       * @param element {Element} DOM element to query
       * @param mode {Number} Choose one of the modes {@link qx.bom.element.Style#COMPUTED_MODE},
       *   {@link qx.bom.element.Style#CASCADED_MODE}, {@link qx.bom.element.Style#LOCAL_MODE}.
       *   The computed mode is the default one.
       * @return {String} computed overflow value
       */
      getY : function(bc, bd){

        if(qx.core.Environment.get(l)){

          return qx.bom.element.Style.get(bc, x, bd, false);
        };
        var be = qx.bom.element.Style.get(bc, q, bd, false);
        if(be === m){

          be = n;
        };
        return be;
      },
      /**
       * Sets the local vertical overflow value to the given value
       *
       * @param element {Element} DOM element to modify
       * @param value {String} Any of "visible", "scroll", "hidden", "auto" or ""
       * @return {void}
       */
      setY : function(bf, bg){

        if(qx.core.Environment.get(l)){

          bf.style.overflowY = bg;
        } else {

          if(bg === n && qx.core.Environment.get(p) === r && parseFloat(qx.core.Environment.get(w)) < 1.8){

            bg = m;
          };
          bf.style.overflow = bg;
        };
      },
      /**
       * Removes the locally configured vertical overflow property
       *
       * @param element {Element} DOM element to modify
       * @return {void}
       */
      resetY : function(bh){

        if(qx.core.Environment.get(l)){

          bh.style.overflowY = o;
        } else {

          bh.style.overflow = o;
        };
      }
    }
  });
})();
(function(){

  var m = "MozOpacity",l = ");",k = ")",j = "zoom:1;filter:alpha(opacity=",i = "qx.bom.element.Opacity",h = "css.opacity",g = "alpha(opacity=",f = ";",e = "opacity:",d = "opacity",a = "filter",c = "engine.name",b = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Christian Hagendorn (chris_schmidt)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Prototype JS
       http://www.prototypejs.org/
       Version 1.5
  
       Copyright:
         (c) 2006-2007, Prototype Core Team
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Prototype Core Team
  
     ----------------------------------------------------------------------
  
       Copyright (c) 2005-2008 Sam Stephenson
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */
  /**
   * Cross-browser opacity support.
   *
   * Optimized for animations (contains workarounds for typical flickering
   * in some browsers). Reduced class dependencies for optimal size and
   * performance.
   */
  qx.Bootstrap.define(i, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * {Boolean} <code>true</code> when the style attribute "opacity" is supported,
       * <code>false</code> otherwise.
       */
      SUPPORT_CSS3_OPACITY : false,
      /**
       * Compiles the given opacity value into a cross-browser CSS string.
       * Accepts numbers between zero and one
       * where "0" means transparent, "1" means opaque.
       *
       * @signature function(opacity)
       * @param opacity {Float} A float number between 0 and 1
       * @return {String} CSS compatible string
       */
      compile : qx.core.Environment.select(c, {
        "mshtml" : function(n){

          if(n >= 1){

            n = 1;
          };
          if(n < 0.00001){

            n = 0;
          };
          if(qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            return e + n + f;
          } else {

            return j + (n * 100) + l;
          };
        },
        "gecko" : function(o){

          // Animations look better when not using 1.0 in gecko
          if(o >= 1){

            o = 0.999999;
          };
          return e + o + f;
        },
        "default" : function(p){

          if(p >= 1){

            return b;
          };
          return e + p + f;
        }
      }),
      /**
       * Sets opacity of given element. Accepts numbers between zero and one
       * where "0" means transparent, "1" means opaque.
       *
       * @param element {Element} DOM element to modify
       * @param opacity {Float} A float number between 0 and 1
       * @return {void}
       * @signature function(element, opacity)
       */
      set : qx.core.Environment.select(c, {
        "mshtml" : function(q, r){

          if(qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            if(r >= 1){

              r = b;
            };
            q.style.opacity = r;
          } else {

            // Read in computed filter
            var s = qx.bom.element.Style.get(q, a, qx.bom.element.Style.COMPUTED_MODE, false);
            if(r >= 1){

              r = 1;
            };
            if(r < 0.00001){

              r = 0;
            };
            // IE has trouble with opacity if it does not have layout (hasLayout)
            // Force it by setting the zoom level
            if(!q.currentStyle || !q.currentStyle.hasLayout){

              q.style.zoom = 1;
            };
            // Remove old alpha filter and add new one
            q.style.filter = s.replace(/alpha\([^\)]*\)/gi, b) + g + r * 100 + k;
          };
        },
        "gecko" : function(t, u){

          // Animations look better when not using 1.0 in gecko
          if(u >= 1){

            u = 0.999999;
          };
          if(!qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            t.style.MozOpacity = u;
          } else {

            t.style.opacity = u;
          };
        },
        "default" : function(v, w){

          if(w >= 1){

            w = b;
          };
          v.style.opacity = w;
        }
      }),
      /**
       * Resets opacity of given element.
       *
       * @param element {Element} DOM element to modify
       * @return {void}
       * @signature function(element)
       */
      reset : qx.core.Environment.select(c, {
        "mshtml" : function(x){

          if(qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            x.style.opacity = b;
          } else {

            // Read in computed filter
            var y = qx.bom.element.Style.get(x, a, qx.bom.element.Style.COMPUTED_MODE, false);
            // Remove old alpha filter
            x.style.filter = y.replace(/alpha\([^\)]*\)/gi, b);
          };
        },
        "gecko" : function(z){

          if(!qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            z.style.MozOpacity = b;
          } else {

            z.style.opacity = b;
          };
        },
        "default" : function(A){

          A.style.opacity = b;
        }
      }),
      /**
       * Gets computed opacity of given element. Accepts numbers between zero and one
       * where "0" means transparent, "1" means opaque.
       *
       * @param element {Element} DOM element to modify
       * @param mode {Number} Choose one of the modes {@link qx.bom.element.Style#COMPUTED_MODE},
       *   {@link qx.bom.element.Style#CASCADED_MODE}, {@link qx.bom.element.Style#LOCAL_MODE}.
       *   The computed mode is the default one.
       * @return {Float} A float number between 0 and 1
       * @signature function(element, mode)
       */
      get : qx.core.Environment.select(c, {
        "mshtml" : function(B, C){

          if(qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY){

            var D = qx.bom.element.Style.get(B, d, C, false);
            if(D != null){

              return parseFloat(D);
            };
            return 1.0;
          } else {

            var E = qx.bom.element.Style.get(B, a, C, false);
            if(E){

              var D = E.match(/alpha\(opacity=(.*)\)/);
              if(D && D[1]){

                return parseFloat(D[1]) / 100;
              };
            };
            return 1.0;
          };
        },
        "gecko" : function(F, G){

          var H = qx.bom.element.Style.get(F, !qx.bom.element.Opacity.SUPPORT_CSS3_OPACITY ? m : d, G, false);
          if(H == 0.999999){

            H = 1.0;
          };
          if(H != null){

            return parseFloat(H);
          };
          return 1.0;
        },
        "default" : function(I, J){

          var K = qx.bom.element.Style.get(I, d, J, false);
          if(K != null){

            return parseFloat(K);
          };
          return 1.0;
        }
      })
    },
    defer : function(L){

      L.SUPPORT_CSS3_OPACITY = qx.core.Environment.get(h);
    }
  });
})();
(function(){

  var j = "css.float",i = "px",h = "Cascaded styles are not supported in this browser!",g = "css.appearance",f = "pixelRight",e = "css.userselect",d = "css.boxsizing",c = "css.textoverflow",b = "pixelHeight",a = ":",E = "pixelTop",D = "css.borderimage",C = "Invalid argument 'name'",B = "pixelLeft",A = "css.usermodify",z = "qx.bom.element.Style",y = ". Only pixel values work well across different clients.",x = "pixelBottom",w = "Invalid argument 'styles'",v = "pixelWidth",q = "Untranslated computed property value: ",r = ";",o = "float",p = "qx.debug",m = "browser.documentmode",n = "mshtml",k = "Invalid argument 'smart'",l = "Invalid argument 'element'",s = "style",t = "engine.name",u = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Prototype JS
       http://www.prototypejs.org/
       Version 1.5
  
       Copyright:
         (c) 2006-2007, Prototype Core Team
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Prototype Core Team
  
     ----------------------------------------------------------------------
  
       Copyright (c) 2005-2008 Sam Stephenson
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.lang.String)
  #require(qx.bom.client.Css)
  
  #require(qx.bom.element.Clip#set)
  #require(qx.bom.element.Cursor#set)
  #require(qx.bom.element.Opacity#set)
  #require(qx.bom.element.BoxSizing#set)
  #require(qx.bom.element.Overflow#setY)
  #require(qx.bom.element.Overflow#setX)
  
  #require(qx.bom.element.Clip#get)
  #require(qx.bom.element.Cursor#get)
  #require(qx.bom.element.Opacity#get)
  #require(qx.bom.element.BoxSizing#get)
  #require(qx.bom.element.Overflow#getX)
  #require(qx.bom.element.Overflow#getY)
  
  #require(qx.bom.element.Clip#reset)
  #require(qx.bom.element.Cursor#reset)
  #require(qx.bom.element.Opacity#reset)
  #require(qx.bom.element.BoxSizing#reset)
  #require(qx.bom.element.Overflow#resetX)
  #require(qx.bom.element.Overflow#resetY)
  
  #require(qx.bom.element.Clip#compile)
  #require(qx.bom.element.Cursor#compile)
  #require(qx.bom.element.Opacity#compile)
  #require(qx.bom.element.BoxSizing#compile)
  #require(qx.bom.element.Overflow#compileX)
  #require(qx.bom.element.Overflow#compileY)
  
  ************************************************************************ */
  /**
   * Style querying and modification of HTML elements.
   *
   * Automatically normalizes cross-browser differences for setting and reading
   * CSS attributes. Optimized for performance.
   */
  qx.Bootstrap.define(z, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Detect vendor specific properties.
       */
      __detectVendorProperties : function(){

        var G = {
          "appearance" : qx.core.Environment.get(g),
          "userSelect" : qx.core.Environment.get(e),
          "textOverflow" : qx.core.Environment.get(c),
          "borderImage" : qx.core.Environment.get(D),
          "float" : qx.core.Environment.get(j),
          "userModify" : qx.core.Environment.get(A),
          "boxSizing" : qx.core.Environment.get(d)
        };
        this.__cssNames = {
        };
        for(var F in qx.lang.Object.clone(G)){

          if(!G[F]){

            delete G[F];
          } else {

            this.__cssNames[F] = F == o ? o : qx.lang.String.hyphenate(G[F]);
          };
        };
        this.__styleNames = G;
      },
      /**
       * Gets the (possibly vendor-prefixed) name of a style property and stores
       * it to avoid multiple checks.
       *
       * @param name {String} Style property name to check
       * @return {String|null} The client-specific name of the property, or
       * <code>null</code> if it's not supported.
       */
      __getStyleName : function(name){

        var H = qx.bom.Style.getPropertyName(name);
        if(H){

          this.__styleNames[name] = H;
        };
        return H;
      },
      /**
       * Mshtml has proprietary pixel* properties for locations and dimensions
       * which return the pixel value. Used by getComputed() in mshtml variant.
       *
       * @internal
       */
      __mshtmlPixel : {
        width : v,
        height : b,
        left : B,
        right : f,
        top : E,
        bottom : x
      },
      /**
       * Whether a special class is available for the processing of this style.
       *
       * @internal
       */
      __special : {
        clip : qx.bom.element.Clip,
        cursor : qx.bom.element.Cursor,
        opacity : qx.bom.element.Opacity,
        boxSizing : qx.bom.element.BoxSizing,
        overflowX : {
          set : qx.lang.Function.bind(qx.bom.element.Overflow.setX, qx.bom.element.Overflow),
          get : qx.lang.Function.bind(qx.bom.element.Overflow.getX, qx.bom.element.Overflow),
          reset : qx.lang.Function.bind(qx.bom.element.Overflow.resetX, qx.bom.element.Overflow),
          compile : qx.lang.Function.bind(qx.bom.element.Overflow.compileX, qx.bom.element.Overflow)
        },
        overflowY : {
          set : qx.lang.Function.bind(qx.bom.element.Overflow.setY, qx.bom.element.Overflow),
          get : qx.lang.Function.bind(qx.bom.element.Overflow.getY, qx.bom.element.Overflow),
          reset : qx.lang.Function.bind(qx.bom.element.Overflow.resetY, qx.bom.element.Overflow),
          compile : qx.lang.Function.bind(qx.bom.element.Overflow.compileY, qx.bom.element.Overflow)
        }
      },
      /*
      ---------------------------------------------------------------------------
        COMPILE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Compiles the given styles into a string which can be used to
       * concat a HTML string for innerHTML usage.
       *
       * @param map {Map} Map of style properties to compile
       * @return {String} Compiled string of given style properties.
       */
      compile : function(I){

        var K = [];
        var L = this.__special;
        var M = this.__cssNames;
        var name,J;
        for(name in I){

          // read value
          J = I[name];
          if(J == null){

            continue;
          };
          // normalize name
          name = this.__styleNames[name] || this.__getStyleName(name) || name;
          // process special properties
          if(L[name]){

            K.push(L[name].compile(J));
          } else {

            if(!M[name]){

              M[name] = qx.lang.String.hyphenate(name);
            };
            K.push(M[name], a, J, r);
          };
        };
        return K.join(u);
      },
      /*
      ---------------------------------------------------------------------------
        CSS TEXT SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Set the full CSS content of the style attribute
       *
       * @param element {Element} The DOM element to modify
       * @param value {String} The full CSS string
       * @return {void}
       */
      setCss : function(N, O){

        if(qx.core.Environment.get(t) === n && parseInt(qx.core.Environment.get(m), 10) < 8){

          N.style.cssText = O;
        } else {

          N.setAttribute(s, O);
        };
      },
      /**
       * Returns the full content of the style attribute.
       *
       * @param element {Element} The DOM element to query
       * @return {String} the full CSS string
       * @signature function(element)
       */
      getCss : function(P){

        if(qx.core.Environment.get(t) === n && parseInt(qx.core.Environment.get(m), 10) < 8){

          return P.style.cssText.toLowerCase();
        } else {

          return P.getAttribute(s);
        };
      },
      /*
      ---------------------------------------------------------------------------
        STYLE ATTRIBUTE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Checks whether the browser supports the given CSS property.
       *
       * @param propertyName {String} The name of the property
       * @return {Boolean} Whether the property id supported
       */
      isPropertySupported : function(Q){

        return (this.__special[Q] || this.__styleNames[Q] || Q in document.documentElement.style);
      },
      /** {Integer} Computed value of a style property. Compared to the cascaded style,
       * this one also interprets the values e.g. translates <code>em</code> units to
       * <code>px</code>.
       */
      COMPUTED_MODE : 1,
      /** {Integer} Cascaded value of a style property. */
      CASCADED_MODE : 2,
      /**
       * {Integer} Local value of a style property. Ignores inheritance cascade.
       *   Does not interpret values.
       */
      LOCAL_MODE : 3,
      /**
       * Sets the value of a style property
       *
       * @param element {Element} The DOM element to modify
       * @param name {String} Name of the style attribute (js variant e.g. marginTop, wordSpacing)
       * @param value {var} The value for the given style
       * @param smart {Boolean?true} Whether the implementation should automatically use
       *    special implementations for some properties
       */
      set : function(R, name, S, T){

        if(qx.core.Environment.get(p)){

          qx.core.Assert.assertElement(R, l);
          qx.core.Assert.assertString(name, C);
          if(T !== undefined){

            qx.core.Assert.assertBoolean(T, k);
          };
        };
        // normalize name
        name = this.__styleNames[name] || this.__getStyleName(name) || name;
        // special handling for specific properties
        // through this good working switch this part costs nothing when
        // processing non-smart properties
        if(T !== false && this.__special[name]){

          return this.__special[name].set(R, S);
        } else {

          R.style[name] = S !== null ? S : u;
        };
      },
      /**
       * Convenience method to modify a set of styles at once.
       *
       * @param element {Element} The DOM element to modify
       * @param styles {Map} a map where the key is the name of the property
       *    and the value is the value to use.
       * @param smart {Boolean?true} Whether the implementation should automatically use
       *    special implementations for some properties
       * @return {void}
       */
      setStyles : function(U, V, W){

        if(qx.core.Environment.get(p)){

          qx.core.Assert.assertElement(U, l);
          qx.core.Assert.assertMap(V, w);
          if(W !== undefined){

            qx.core.Assert.assertBoolean(W, k);
          };
        };
        // inline calls to "set" and "reset" because this method is very
        // performance critical!
        var ba = this.__styleNames;
        var bc = this.__special;
        var X = U.style;
        for(var bb in V){

          var Y = V[bb];
          var name = ba[bb] || this.__getStyleName(bb) || bb;
          if(Y === undefined){

            if(W !== false && bc[name]){

              bc[name].reset(U);
            } else {

              X[name] = u;
            };
          } else {

            if(W !== false && bc[name]){

              bc[name].set(U, Y);
            } else {

              X[name] = Y !== null ? Y : u;
            };
          };
        };
      },
      /**
       * Resets the value of a style property
       *
       * @param element {Element} The DOM element to modify
       * @param name {String} Name of the style attribute (js variant e.g. marginTop, wordSpacing)
       * @param smart {Boolean?true} Whether the implementation should automatically use
       *    special implementations for some properties
       * @return {void}
       */
      reset : function(bd, name, be){

        // normalize name
        name = this.__styleNames[name] || this.__getStyleName(name) || name;
        // special handling for specific properties
        if(be !== false && this.__special[name]){

          return this.__special[name].reset(bd);
        } else {

          bd.style[name] = u;
        };
      },
      /**
       * Gets the value of a style property.
       *
       * *Computed*
       *
       * Returns the computed value of a style property. Compared to the cascaded style,
       * this one also interprets the values e.g. translates <code>em</code> units to
       * <code>px</code>.
       *
       * *Cascaded*
       *
       * Returns the cascaded value of a style property.
       *
       * *Local*
       *
       * Ignores inheritance cascade. Does not interpret values.
       *
       * @signature function(element, name, mode, smart)
       * @param element {Element} The DOM element to modify
       * @param name {String} Name of the style attribute (js variant e.g. marginTop, wordSpacing)
       * @param mode {Number} Choose one of the modes {@link #COMPUTED_MODE}, {@link #CASCADED_MODE},
       *   {@link #LOCAL_MODE}. The computed mode is the default one.
       * @param smart {Boolean?true} Whether the implementation should automatically use
       *    special implementations for some properties
       * @return {var} The value of the property
       */
      get : qx.core.Environment.select(t, {
        "mshtml" : function(bf, name, bg, bh){

          // normalize name
          name = this.__styleNames[name] || this.__getStyleName(name) || name;
          // special handling
          if(bh !== false && this.__special[name]){

            return this.__special[name].get(bf, bg);
          };
          // if the element is not inserted into the document "currentStyle"
          // may be undefined. In this case always return the local style.
          if(!bf.currentStyle){

            return bf.style[name] || u;
          };
          // switch to right mode
          switch(bg){case this.LOCAL_MODE:
          return bf.style[name] || u;case this.CASCADED_MODE:
          return bf.currentStyle[name] || u;default:
          // Read cascaded style
          var bl = bf.currentStyle[name] || u;
          // Pixel values are always OK
          if(/^-?[\.\d]+(px)?$/i.test(bl)){

            return bl;
          };
          // Try to convert non-pixel values
          var bk = this.__mshtmlPixel[name];
          if(bk){

            // Backup local and runtime style
            var bi = bf.style[name];
            // Overwrite local value with cascaded value
            // This is needed to have the pixel value setupped
            bf.style[name] = bl || 0;
            // Read pixel value and add "px"
            var bj = bf.style[bk] + i;
            // Recover old local value
            bf.style[name] = bi;
            // Return value
            return bj;
          };
          // Non-Pixel values may be problematic
          if(/^-?[\.\d]+(em|pt|%)?$/i.test(bl)){

            throw new Error(q + name + y);
          };
          // Just the current style
          return bl;};
        },
        "default" : function(bm, name, bn, bo){

          // normalize name
          name = this.__styleNames[name] || this.__getStyleName(name) || name;
          // special handling
          if(bo !== false && this.__special[name]){

            return this.__special[name].get(bm, bn);
          };
          // switch to right mode
          switch(bn){case this.LOCAL_MODE:
          return bm.style[name] || u;case this.CASCADED_MODE:
          // Currently only supported by Opera and Internet Explorer
          if(bm.currentStyle){

            return bm.currentStyle[name] || u;
          };
          throw new Error(h);// Support for the DOM2 getComputedStyle method
          //
          // Safari >= 3 & Gecko > 1.4 expose all properties to the returned
          // CSSStyleDeclaration object. In older browsers the function
          // "getPropertyValue" is needed to access the values.
          //
          // On a computed style object all properties are read-only which is
          // identical to the behavior of MSHTML's "currentStyle".
          default:
          // Opera, Mozilla and Safari 3+ also have a global getComputedStyle which is identical
          // to the one found under document.defaultView.
          // The problem with this is however that this does not work correctly
          // when working with frames and access an element of another frame.
          // Then we must use the <code>getComputedStyle</code> of the document
          // where the element is defined.
          var bp = qx.dom.Node.getDocument(bm);
          var bq = bp.defaultView.getComputedStyle(bm, null);
          // All relevant browsers expose the configured style properties to
          // the CSSStyleDeclaration objects
          return bq ? bq[name] : u;};
        }
      })
    },
    defer : function(br){

      br.__detectVendorProperties();
    }
  });
})();
(function(){

  var g = "engine.name",f = "position:absolute;width:0;height:0;width:1",e = "engine.version",d = "qx.bom.Document",c = "1px",b = "div",a = "CSS1Compat";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Yahoo! UI Library
         http://developer.yahoo.com/yui
         Version 2.2.0
  
       Copyright:
         (c) 2007, Yahoo! Inc.
  
       License:
         BSD: http://developer.yahoo.com/yui/license.txt
  
     ----------------------------------------------------------------------
  
       http://developer.yahoo.com/yui/license.html
  
       Copyright (c) 2009, Yahoo! Inc.
       All rights reserved.
  
       Redistribution and use of this software in source and binary forms,
       with or without modification, are permitted provided that the
       following conditions are met:
  
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of Yahoo! Inc. nor the names of its contributors
         may be used to endorse or promote products derived from this
         software without specific prior written permission of Yahoo! Inc.
  
       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
       COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
       SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
       HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
       STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
       ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
       OF THE POSSIBILITY OF SUCH DAMAGE.
  
  ************************************************************************ */
  /**
   * Includes library functions to work with the current document.
   */
  qx.Bootstrap.define(d, {
    statics : {
      /**
       * Whether the document is in quirks mode (e.g. non XHTML, HTML4 Strict or missing doctype)
       *
       * @signature function(win)
       * @param win {Window?window} The window to query
       * @return {Boolean} true when containing document is in quirks mode
       */
      isQuirksMode : qx.core.Environment.select(g, {
        "mshtml" : function(h){

          if(qx.core.Environment.get(e) >= 8){

            return (h || window).document.documentMode === 5;
          } else {

            return (h || window).document.compatMode !== a;
          };
        },
        "webkit" : function(i){

          if(document.compatMode === undefined){

            var j = (i || window).document.createElement(b);
            j.style.cssText = f;
            return j.style.width === c ? true : false;
          } else {

            return (i || window).document.compatMode !== a;
          };
        },
        "default" : function(k){

          return (k || window).document.compatMode !== a;
        }
      }),
      /**
       * Whether the document is in standard mode (e.g. XHTML, HTML4 Strict or doctype defined)
       *
       * @param win {Window?window} The window to query
       * @return {Boolean} true when containing document is in standard mode
       */
      isStandardMode : function(l){

        return !this.isQuirksMode(l);
      },
      /**
       * Returns the width of the document.
       *
       * Internet Explorer in standard mode stores the proprietary <code>scrollWidth</code> property
       * on the <code>documentElement</code>, but in quirks mode on the body element. All
       * other known browsers simply store the correct value on the <code>documentElement</code>.
       *
       * If the viewport is wider than the document the viewport width is returned.
       *
       * As the html element has no visual appearance it also can not scroll. This
       * means that we must use the body <code>scrollWidth</code> in all non mshtml clients.
       *
       * Verified to correctly work with:
       *
       * * Mozilla Firefox 2.0.0.4
       * * Opera 9.2.1
       * * Safari 3.0 beta (3.0.2)
       * * Internet Explorer 7.0
       *
       * @param win {Window?window} The window to query
       * @return {Integer} The width of the actual document (which includes the body and its margin).
       *
       * NOTE: Opera 9.5x and 9.6x have wrong value for the scrollWidth property,
       * if an element use negative value for top and left to be outside the viewport!
       * See: http://bugzilla.qooxdoo.org/show_bug.cgi?id=2869
       */
      getWidth : function(m){

        var n = (m || window).document;
        var o = qx.bom.Viewport.getWidth(m);
        var scroll = this.isStandardMode(m) ? n.documentElement.scrollWidth : n.body.scrollWidth;
        return Math.max(scroll, o);
      },
      /**
       * Returns the height of the document.
       *
       * Internet Explorer in standard mode stores the proprietary <code>scrollHeight</code> property
       * on the <code>documentElement</code>, but in quirks mode on the body element. All
       * other known browsers simply store the correct value on the <code>documentElement</code>.
       *
       * If the viewport is higher than the document the viewport height is returned.
       *
       * As the html element has no visual appearance it also can not scroll. This
       * means that we must use the body <code>scrollHeight</code> in all non mshtml clients.
       *
       * Verified to correctly work with:
       *
       * * Mozilla Firefox 2.0.0.4
       * * Opera 9.2.1
       * * Safari 3.0 beta (3.0.2)
       * * Internet Explorer 7.0
       *
       * @param win {Window?window} The window to query
       * @return {Integer} The height of the actual document (which includes the body and its margin).
       *
       * NOTE: Opera 9.5x and 9.6x have wrong value for the scrollWidth property,
       * if an element use negative value for top and left to be outside the viewport!
       * See: http://bugzilla.qooxdoo.org/show_bug.cgi?id=2869
       */
      getHeight : function(p){

        var q = (p || window).document;
        var r = qx.bom.Viewport.getHeight(p);
        var scroll = this.isStandardMode(p) ? q.documentElement.scrollHeight : q.body.scrollHeight;
        return Math.max(scroll, r);
      }
    }
  });
})();
(function(){

  var b = "qx.bom.Viewport",a = "undefined";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Sebastian Fastner (fastner)
       * Tino Butz (tbtz)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
     * Yahoo! UI Library
         http://developer.yahoo.com/yui
         Version 2.2.0
  
       Copyright:
         (c) 2007, Yahoo! Inc.
  
       License:
         BSD: http://developer.yahoo.com/yui/license.txt
  
     ----------------------------------------------------------------------
  
       http://developer.yahoo.com/yui/license.html
  
       Copyright (c) 2009, Yahoo! Inc.
       All rights reserved.
  
       Redistribution and use of this software in source and binary forms,
       with or without modification, are permitted provided that the
       following conditions are met:
  
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of Yahoo! Inc. nor the names of its contributors
         may be used to endorse or promote products derived from this
         software without specific prior written permission of Yahoo! Inc.
  
       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
       COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
       SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
       HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
       STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
       ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
       OF THE POSSIBILITY OF SUCH DAMAGE.
  
  ************************************************************************ */
  /**
   * Includes library functions to work with the client's viewport (window).
   * Orientation related functions are point to window.top as default.
   */
  qx.Bootstrap.define(b, {
    statics : {
      /**
       * Returns the current width of the viewport (excluding the vertical scrollbar
       * if present).
       *
       * @param win {Window?window} The window to query
       * @return {Integer} The width of the viewable area of the page (excluding scrollbars).
       */
      getWidth : function(c){

        var c = c || window;
        var d = c.document;
        return qx.bom.Document.isStandardMode(c) ? d.documentElement.clientWidth : d.body.clientWidth;
      },
      /**
       * Returns the current height of the viewport (excluding the horizontal scrollbar
       * if present).
       *
       * @param win {Window?window} The window to query
       * @return {Integer} The Height of the viewable area of the page (excluding scrollbars).
       */
      getHeight : function(e){

        var e = e || window;
        var f = e.document;
        return qx.bom.Document.isStandardMode(e) ? f.documentElement.clientHeight : f.body.clientHeight;
      },
      /**
       * Returns the scroll position of the viewport
       *
       * All clients except IE < 9 support the non-standard property <code>pageXOffset</code>.
       * As this is easier to evaluate we prefer this property over <code>scrollLeft</code>.
       * Since the window could differ from the one the application is running in, we can't
       * use a one-time environment check to decide which property to use.
       *
       * @param win {Window?window} The window to query
       * @return {Integer} Scroll position in pixels from left edge, always a positive integer or zero
       */
      getScrollLeft : function(g){

        var g = g ? g : window;
        if(typeof g.pageXOffset !== a){

          return g.pageXOffset;
        };
        // Firefox is using 'documentElement.scrollLeft' and Chrome is using
        // 'document.body.scrollLeft'. For the other value each browser is returning
        // 0, so we can use this check to get the positive value without using specific
        // browser checks.
        var h = g.document;
        return h.documentElement.scrollLeft || h.body.scrollLeft;
      },
      /**
       * Returns the scroll position of the viewport
       *
       * All clients except MSHTML support the non-standard property <code>pageYOffset</code>.
       * As this is easier to evaluate we prefer this property over <code>scrollTop</code>.
       * Since the window could differ from the one the application is running in, we can't
       * use a one-time environment check to decide which property to use.
       *
       * @param win {Window?window} The window to query
       * @return {Integer} Scroll position in pixels from top edge, always a positive integer or zero
       */
      getScrollTop : function(i){

        var i = i ? i : window;
        if(typeof i.pageYOffeset !== a){

          return i.pageYOffset;
        };
        // Firefox is using 'documentElement.scrollTop' and Chrome is using
        // 'document.body.scrollTop'. For the other value each browser is returning
        // 0, so we can use this check to get the positive value without using specific
        // browser checks.
        var j = i.document;
        return j.documentElement.scrollTop || j.body.scrollTop;
      },
      /**
       * Returns an orientation normalizer value that should be added to device orientation
       * to normalize behaviour on different devices.
       *
       * @param win {Window} The window to query
       * @return {Map} Orientation normalizing value
       */
      __getOrientationNormalizer : function(k){

        // Calculate own understanding of orientation (0 = portrait, 90 = landscape)
        var l = this.getWidth(k) > this.getHeight(k) ? 90 : 0;
        var m = k.orientation;
        if(m == null || Math.abs(m % 180) == l){

          // No device orientation available or device orientation equals own understanding of orientation
          return {
            "-270" : 90,
            "-180" : 180,
            "-90" : -90,
            "0" : 0,
            "90" : 90,
            "180" : 180,
            "270" : -90
          };
        } else {

          // Device orientation is not equal to own understanding of orientation
          return {
            "-270" : 180,
            "-180" : -90,
            "-90" : 0,
            "0" : 90,
            "90" : 180,
            "180" : -90,
            "270" : 0
          };
        };
      },
      // Cache orientation normalizer map on start
      __orientationNormalizer : null,
      /**
       * Returns the current orientation of the viewport in degree.
       *
       * All possible values and their meaning:
       *
       * * <code>-90</code>: "Landscape"
       * * <code>0</code>: "Portrait"
       * * <code>90</code>: "Landscape"
       * * <code>180</code>: "Portrait"
       *
       * @param win {Window?window.top} The window to query. (Default = top window)
       * @return {Integer} The current orientation in degree
       */
      getOrientation : function(n){

        // Set window.top as default, because orientationChange event is only fired top window
        var n = n || window.top;
        // The orientation property of window does not have the same behaviour over all devices
        // iPad has 0degrees = Portrait, Playbook has 90degrees = Portrait, same for Android Honeycomb
        //
        // To fix this an orientationNormalizer map is calculated on application start
        //
        // The calculation of getWidth and getHeight returns wrong values if you are in an input field
        // on iPad and rotate your device!
        var o = n.orientation;
        if(o == null){

          // Calculate orientation from window width and window height
          o = this.getWidth(n) > this.getHeight(n) ? 90 : 0;
        } else {

          if(this.__orientationNormalizer == null){

            this.__orientationNormalizer = this.__getOrientationNormalizer(n);
          };
          // Normalize orientation value
          o = this.__orientationNormalizer[o];
        };
        return o;
      },
      /**
       * Whether the viewport orientation is currently in landscape mode.
       *
       * @param win {Window?window} The window to query
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in landscape mode.
       */
      isLandscape : function(p){

        return this.getWidth(p) >= this.getHeight(p);
      },
      /**
       * Whether the viewport orientation is currently in portrait mode.
       *
       * @param win {Window?window} The window to query
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in portrait mode.
       */
      isPortrait : function(q){

        return this.getWidth(q) < this.getHeight(q);
      }
    }
  });
})();
(function(){

  var j = "0",i = "qx/static",h = "http://",g = "https://",f = "file://",e = "qx.util.AliasManager",d = "singleton",c = ".",b = "static",a = "/";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This singleton manages global resource aliases.
   *
   * The AliasManager supports simple prefix replacement on strings. There are
   * some pre-defined aliases, and you can register your own with {@link #add}.
   * The AliasManager is automatically invoked in various situations, e.g. when
   * resolving the icon image for a button, so it is common to register aliases for
   * <a href="http://manual.qooxdoo.org/${qxversion}/pages/desktop/ui_resources.html">resource id's</a>.
   * You can of course call the AliasManager's {@link #resolve}
   * explicitly to get an alias resolution in any situation, but keep that
   * automatic invocation of the AliasManager in mind when defining new aliases as
   * they will be applied globally in many classes, not only your own.
   *
   * Examples:
   * <ul>
   *  <li> <code>foo</code> -> <code>bar/16pt/baz</code>  (resolves e.g. __"foo/a/b/c.png"__ to
   *    __"bar/16pt/baz/a/b/c.png"__)
   *  <li> <code>imgserver</code> -> <code>http&#058;&#047;&#047;imgs03.myserver.com/my/app/</code>
   *    (resolves e.g. __"imgserver/a/b/c.png"__ to
   *    __"http&#058;&#047;&#047;imgs03.myserver.com/my/app/a/b/c.png"__)
   * </ul>
   *
   * For resources, only aliases that resolve to proper resource id's can be __managed__
   * resources, and will be considered __unmanaged__ resources otherwise.
   */
  qx.Class.define(e, {
    type : d,
    extend : qx.util.ValueManager,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.util.ValueManager.call(this);
      // Contains defined aliases (like icons/, widgets/, application/, ...)
      this.__aliases = {
      };
      // Define static alias from setting
      this.add(b, i);
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __aliases : null,
      /**
       * pre-process incoming dynamic value
       *
       * @param value {String} incoming value
       * @return {String} pre processed value
       */
      _preprocess : function(k){

        var n = this._getDynamic();
        if(n[k] === false){

          return k;
        } else if(n[k] === undefined){

          if(k.charAt(0) === a || k.charAt(0) === c || k.indexOf(h) === 0 || k.indexOf(g) === j || k.indexOf(f) === 0){

            n[k] = false;
            return k;
          };
          if(this.__aliases[k]){

            return this.__aliases[k];
          };
          var m = k.substring(0, k.indexOf(a));
          var l = this.__aliases[m];
          if(l !== undefined){

            n[k] = l + k.substring(m.length);
          };
        };
        return k;
      },
      /**
       * Define an alias to a resource path
       *
       * @param alias {String} alias name for the resource path/url
       * @param base {String} first part of URI for all images which use this alias
       * @return {void}
       */
      add : function(o, p){

        // Store new alias value
        this.__aliases[o] = p;
        // Localify stores
        var r = this._getDynamic();
        // Update old entries which use this alias
        for(var q in r){

          if(q.substring(0, q.indexOf(a)) === o){

            r[q] = p + q.substring(o.length);
          };
        };
      },
      /**
       * Remove a previously defined alias
       *
       * @param alias {String} alias name for the resource path/url
       * @return {void}
       */
      remove : function(s){

        delete this.__aliases[s];
      },
      /**
       * Resolves a given path
       *
       * @param path {String} input path
       * @return {String} resulting path (with interpreted aliases)
       */
      resolve : function(t){

        var u = this._getDynamic();
        if(t != null){

          t = this._preprocess(t);
        };
        return u[t] || t;
      },
      /**
       * Get registered aliases
       *
       * @return {Map} the map of the currently registered alias:resolution pairs
       */
      getAliases : function(){

        var v = {
        };
        for(var w in this.__aliases){

          v[w] = this.__aliases[w];
        };
        return v;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__aliases = null;
    }
  });
})();
(function(){

  var f = "_applyTheme",e = "qx.theme.manager.Font",d = "_dynamic",c = "Theme",b = "changeTheme",a = "singleton";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Manager for font themes
   */
  qx.Class.define(e, {
    type : a,
    extend : qx.util.ValueManager,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** the currently selected font theme */
      theme : {
        check : c,
        nullable : true,
        apply : f,
        event : b
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Returns the dynamically interpreted result for the incoming value
       *
       * @param value {String} dynamically interpreted identifier
       * @return {var} return the (translated) result of the incoming value
       */
      resolveDynamic : function(g){

        var h = this._dynamic;
        return g instanceof qx.bom.Font ? g : h[g];
      },
      /**
       * Returns the dynamically interpreted result for the incoming value,
       * (if available), otherwise returns the original value
       * @param value {String} Value to resolve
       * @return {var} either returns the (translated) result of the incoming
       * value or the value itself
       */
      resolve : function(i){

        var l = this._dynamic;
        var j = l[i];
        if(j){

          return j;
        };
        // If the font instance is not yet cached create a new one to return
        // This is true whenever a runtime include occurred (using "qx.Theme.include"
        // or "qx.Theme.patch"), since these methods only merging the keys of
        // the theme and are not updating the cache
        var k = this.getTheme();
        if(k !== null && k.fonts[i]){

          var m = this.__getFontClass(k.fonts[i]);
          return l[i] = (new m).set(k.fonts[i]);
        };
        return i;
      },
      /**
       * Whether a value is interpreted dynamically
       *
       * @param value {String} dynamically interpreted identifier
       * @return {Boolean} returns true if the value is interpreted dynamically
       */
      isDynamic : function(n){

        var q = this._dynamic;
        if(n && (n instanceof qx.bom.Font || q[n] !== undefined)){

          return true;
        };
        // If the font instance is not yet cached create a new one to return
        // This is true whenever a runtime include occurred (using "qx.Theme.include"
        // or "qx.Theme.patch"), since these methods only merging the keys of
        // the theme and are not updating the cache
        var p = this.getTheme();
        if(p !== null && n && p.fonts[n]){

          var o = this.__getFontClass(p.fonts[n]);
          q[n] = (new o).set(p.fonts[n]);
          return true;
        };
        return false;
      },
      /**
       * Checks for includes and resolves them recursively
       *
       * @param fonts {Map} all fonts of the theme
       * @param fontName {String} font name to include
       */
      __resolveInclude : function(r, s){

        if(r[s].include){

          // get font infos out of the font theme
          var t = r[r[s].include];
          // delete 'include' key - not part of the merge
          r[s].include = null;
          delete r[s].include;
          r[s] = qx.lang.Object.mergeWith(r[s], t, false);
          this.__resolveInclude(r, s);
        };
      },
      // apply method
      _applyTheme : function(u){

        var v = this._getDynamic();
        for(var y in v){

          if(v[y].themed){

            v[y].dispose();
            delete v[y];
          };
        };
        if(u){

          var w = u.fonts;
          for(var y in w){

            if(w[y].include && w[w[y].include]){

              this.__resolveInclude(w, y);
            };
            var x = this.__getFontClass(w[y]);
            v[y] = (new x).set(w[y]);
            v[y].themed = true;
          };
        };
        this._setDynamic(v);
      },
      /**
       * Decides which Font class should be used based on the theme configuration
       *
       * @param config {Map} The font's configuration map
       * @return {Class}
       */
      __getFontClass : function(z){

        if(z.sources){

          return qx.bom.webfonts.WebFont;
        };
        return qx.bom.Font;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeMap(d);
    }
  });
})();
(function(){

  var k = "_applyItalic",j = "_applyBold",h = "_applyTextShadow",g = "Integer",f = "_applyFamily",e = "_applyLineHeight",d = "Array",c = "line-through",b = "overline",a = "Color",B = "String",A = "qx.bom.Font",z = "Number",y = "_applyDecoration",x = " ",w = "_applySize",v = ",",u = "_applyColor",t = "Boolean",s = "px",q = '"',r = "italic",o = "normal",p = "bold",m = "underline",n = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  /**
   * A wrapper for CSS font styles. Fond objects can be applied to instances
   * of {@link qx.html.Element}.
   */
  qx.Class.define(A, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param size {String} The font size (Unit: pixel)
     * @param family {String[]} A sorted list of font families
     */
    construct : function(C, D){

      qx.core.Object.call(this);
      this.__lookupMap = {
        fontFamily : n,
        fontSize : null,
        fontWeight : null,
        fontStyle : null,
        textDecoration : null,
        lineHeight : null,
        color : null,
        textShadow : null
      };
      if(C !== undefined){

        this.setSize(C);
      };
      if(D !== undefined){

        this.setFamily(D);
      };
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Converts a typical CSS font definition string to an font object
       *
       * Example string: <code>bold italic 20px Arial</code>
       *
       * @param str {String} the CSS string
       * @return {qx.bom.Font} the created instance
       */
      fromString : function(E){

        var I = new qx.bom.Font();
        var G = E.split(/\s+/);
        var name = [];
        var H;
        for(var i = 0;i < G.length;i++){

          switch(H = G[i]){case p:
          I.setBold(true);
          break;case r:
          I.setItalic(true);
          break;case m:
          I.setDecoration(m);
          break;default:
          var F = parseInt(H, 10);
          if(F == H || qx.lang.String.contains(H, s)){

            I.setSize(F);
          } else {

            name.push(H);
          };
          break;};
        };
        if(name.length > 0){

          I.setFamily(name);
        };
        return I;
      },
      /**
       * Converts a map property definition into a font object.
       *
       * @param config {Map} map of property values
       * @return {qx.bom.Font} the created instance
       */
      fromConfig : function(J){

        var K = new qx.bom.Font;
        K.set(J);
        return K;
      },
      /** {Map} Default (empty) CSS styles */
      __defaultStyles : {
        fontFamily : n,
        fontSize : n,
        fontWeight : n,
        fontStyle : n,
        textDecoration : n,
        lineHeight : 1.2,
        color : n,
        textShadow : n
      },
      /**
       * Returns a map of all properties in empty state.
       *
       * This is useful for resetting previously configured
       * font styles.
       *
       * @return {Map} Default styles
       */
      getDefaultStyles : function(){

        return this.__defaultStyles;
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The font size (Unit: pixel) */
      size : {
        check : g,
        nullable : true,
        apply : w
      },
      /**
       * The line height as scaling factor of the default line height. A value
       * of 1 corresponds to the default line height
       */
      lineHeight : {
        check : z,
        nullable : true,
        apply : e
      },
      /** A sorted list of font families */
      family : {
        check : d,
        nullable : true,
        apply : f
      },
      /** Whether the font is bold */
      bold : {
        check : t,
        nullable : true,
        apply : j
      },
      /** Whether the font is italic */
      italic : {
        check : t,
        nullable : true,
        apply : k
      },
      /** The text decoration for this font */
      decoration : {
        check : [m, c, b],
        nullable : true,
        apply : y
      },
      /** The text color for this font */
      color : {
        check : a,
        nullable : true,
        apply : u
      },
      /** The text shadow for this font */
      textShadow : {
        nullable : true,
        check : B,
        apply : h
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lookupMap : null,
      // property apply
      _applySize : function(L, M){

        this.__lookupMap.fontSize = L === null ? null : L + s;
      },
      _applyLineHeight : function(N, O){

        this.__lookupMap.lineHeight = N === null ? null : N;
      },
      // property apply
      _applyFamily : function(P, Q){

        var R = n;
        for(var i = 0,l = P.length;i < l;i++){

          // in FireFox 2 and WebKit fonts like 'serif' or 'sans-serif' must
          // not be quoted!
          if(P[i].indexOf(x) > 0){

            R += q + P[i] + q;
          } else {

            R += P[i];
          };
          if(i !== l - 1){

            R += v;
          };
        };
        // font family is a special case. In order to render the labels correctly
        // we have to return a font family - even if it's an empty string to prevent
        // the browser from applying the element style
        this.__lookupMap.fontFamily = R;
      },
      // property apply
      _applyBold : function(S, T){

        this.__lookupMap.fontWeight = S == null ? null : S ? p : o;
      },
      // property apply
      _applyItalic : function(U, V){

        this.__lookupMap.fontStyle = U == null ? null : U ? r : o;
      },
      // property apply
      _applyDecoration : function(W, X){

        this.__lookupMap.textDecoration = W == null ? null : W;
      },
      // property apply
      _applyColor : function(Y, ba){

        this.__lookupMap.color = null;
        if(Y){

          this.__lookupMap.color = qx.theme.manager.Color.getInstance().resolve(Y);
        };
      },
      // property apply
      _applyTextShadow : function(bb, bc){

        this.__lookupMap.textShadow = bb == null ? null : bb;
      },
      /**
       * Get a map of all CSS styles, which will be applied to the widget. Only
       * the styles which are set are returned.
       *
       * @return {Map} Map containing the current styles. The keys are property
       * names which can directly be used with the <code>set</code> method of each
       * widget.
       */
      getStyles : function(){

        return this.__lookupMap;
      }
    }
  });
})();
(function(){

  var h = "qx.bom.webfonts.WebFont",g = "",f = "qx.debug",e = "changeStatus",d = "_applySources",c = "qx.event.type.Data",b = " was not applied, perhaps the source file could not be loaded.",a = "WebFont ";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  /**
   * Requests web fonts from {@link qx.bom.webfonts.Manager} and fires events
   * when their loading status is known.
   */
  qx.Class.define(h, {
    extend : qx.bom.Font,
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired when the status of a web font has been determined. The event data
       * is a map with the keys "family" (the font-family name) and "valid"
       * (Boolean).
       */
      "changeStatus" : c
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * TODOC
       */
      sources : {
        nullable : true,
        apply : d
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __families : null,
      // property apply
      _applySources : function(j, k){

        var o = [];
        for(var i = 0,l = j.length;i < l;i++){

          var n = this._quoteFontFamily(j[i].family);
          o.push(n);
          var m = j[i].source;
          qx.bom.webfonts.Manager.getInstance().require(n, m, this._onWebFontChangeStatus, this);
        };
        this.setFamily(o.concat(this.getFamily()));
      },
      /**
       * Propagates web font status changes
       *
       * @param ev {qx.event.type.Data} "changeStatus"
       */
      _onWebFontChangeStatus : function(p){

        var q = p.getData();
        this.fireDataEvent(e, q);
        if(qx.core.Environment.get(f)){

          if(q.valid === false){

            this.warn(a + q.family + b);
          };
        };
      },
      /**
       * Makes sure font-family names containing spaces are properly quoted
       *
       * @param familyName {String} A font-family CSS value
       * @return {String} The quoted family name
       */
      _quoteFontFamily : function(r){

        return r.replace(/["']/g, g);
      }
    }
  });
})();
(function(){

  var n = "m",k = "os.name",h = ")",g = "os.version",f = "qx.bom.webfonts.Manager",e = "singleton",d = ",\n",c = "src: ",b = "mobileSafari",a = "'eot)",bd = "');",bc = "qx.debug",bb = "interval",ba = "!",Y = "'eot')",X = "\.(",W = "}\n",V = "font-family: ",U = "mobile safari",T = "safari",u = "@font-face.*?",v = ";\n",s = "') format('woff')",t = "('embedded-opentype')",q = "browser.version",r = "opera",o = "Couldn't create @font-face rule for WebFont ",p = "') format('svg')",z = "src: url('",A = "('embedded-opentype)",H = "\nfont-style: normal;\nfont-weight: normal;",F = "?#iefix') format('embedded-opentype')",L = ";",J = "Error while adding @font-face rule:",P = "@font-face {",N = "') format('truetype')",C = "svg",S = "#",R = "chrome",Q = "firefox",B = "eot",D = "ios",E = "ttf",G = "changeStatus",I = "woff",K = "browser.documentmode",M = "browser.name",O = "ie",w = "url('",y = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  /**
   * Manages font-face definitions, making sure that each rule is only applied
   * once.
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    type : e,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__createdStyles = [];
      this.__validators = {
      };
      this.__queue = [];
      this.__preferredFormats = this.getPreferredFormats();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * List of known font definition formats (i.e. file extensions). Used to
       * identify the type of each font file configured for a web font.
       */
      FONT_FORMATS : ["eot", "woff", "ttf", "svg"],
      /**
       * Timeout (in ms) to wait before deciding that a web font was not loaded.
       */
      VALIDATION_TIMEOUT : 5000
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __createdStyles : null,
      __styleSheet : null,
      __validators : null,
      __preferredFormats : null,
      __queue : null,
      __queueInterval : null,
      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Adds the necessary font-face rule for a web font to the document. Also
       * creates a web font Validator ({@link qx.bom.webfonts.Validator}) that
       * checks if the webFont was applied correctly.
       *
       * @param familyName {String} Name of the web font
       * @param sourcesList {String[]} List of source URLs. For maximum compatibility,
       * this should include EOT, WOFF and TTF versions of the font.
       * @param callback {Function?} Optional event listener callback that will be
       * executed once the validator has determined whether the webFont was
       * applied correctly.
       * See {@link qx.bom.webfonts.Validator#changeStatus}
       * @param context {Object?} Optional context for the callback function
       */
      require : function(be, bf, bg, bh){

        var bi = [];
        for(var i = 0,l = bf.length;i < l;i++){

          var bk = bf[i].split(S);
          var bj = qx.util.ResourceManager.getInstance().toUri(bk[0]);
          if(bk.length > 1){

            bj = bj + S + bk[1];
          };
          bi.push(bj);
        };
        // old IEs need a break in between adding @font-face rules
        if(!(qx.core.Environment.get(M) == O && qx.bom.client.Browser.getVersion() < 9)){

          this.__require(be, bi, bg, bh);
          return;
        };
        if(!this.__queueInterval){

          this.__queueInterval = new qx.event.Timer(100);
          this.__queueInterval.addListener(bb, this.__flushQueue, this);
        };
        if(!this.__queueInterval.isEnabled()){

          this.__queueInterval.start();
        };
        this.__queue.push([be, bi, bg, bh]);
      },
      /**
       * Removes a font's font-face definition from the style sheet. This means
       * the font will no longer be available and any elements using it will
       * fall back to the their regular font-families.
       *
       * @param familyName {String} font-family name
       */
      remove : function(bl){

        var bm = null;
        for(var i = 0,l = this.__createdStyles.length;i < l;i++){

          if(this.__createdStyles[i] == bl){

            bm = i;
            this.__removeRule(bl);
            break;
          };
        };
        if(bm){

          qx.lang.Array.removeAt(this.__createdStyles, bm);
        };
        if(bl in this.__validators){

          this.__validators[bl].dispose();
          delete this.__validators[bl];
        };
      },
      /**
       * Returns the preferred font format(s) for the currently used browser. Some
       * browsers support multiple formats, e.g. WOFF and TTF or WOFF and EOT. In
       * those cases, WOFF is considered the preferred format.
       *
       * @return {String[]} List of supported font formats ordered by preference
       * or empty Array if none could be determined
       */
      getPreferredFormats : function(){

        var bn = [];
        var br = qx.core.Environment.get(M);
        var bo = qx.core.Environment.get(q);
        var bq = qx.core.Environment.get(k);
        var bp = qx.core.Environment.get(g);
        if((br == O && qx.core.Environment.get(K) >= 9) || (br == Q && bo >= 3.6) || (br == R && bo >= 6)){

          bn.push(I);
        };
        if((br == r && bo >= 10) || (br == T && bo >= 3.1) || (br == Q && bo >= 3.5) || (br == R && bo >= 4) || (br == U && bq == D && bp >= 4.2)){

          bn.push(E);
        };
        if(br == O && bo >= 4){

          bn.push(B);
        };
        if(br == b && bq == D && bp >= 4.1){

          bn.push(C);
        };
        return bn;
      },
      /**
       * Removes the styleSheet element used for all web font definitions from the
       * document. This means all web fonts declared by the manager will no longer
       * be available and elements using them will fall back to their regular
       * font-families
       */
      removeStyleSheet : function(){

        this.__createdStyles = [];
        if(this.__styleSheet){

          qx.bom.Stylesheet.removeSheet(this.__styleSheet);
        };
        this.__styleSheet = null;
      },
      /*
      ---------------------------------------------------------------------------
        PRIVATE API
      ---------------------------------------------------------------------------
      */
      /**
       * Does the actual work of adding stylesheet rules and triggering font
       * validation
       *
       * @param familyName {String} Name of the web font
       * @param sources {String[]} List of source URLs. For maximum compatibility,
       * this should include EOT, WOFF and TTF versions of the font.
       * @param callback {Function?} Optional event listener callback that will be
       * executed once the validator has determined whether the webFont was
       * applied correctly.
       * @param context {Object?} Optional context for the callback function
       */
      __require : function(bs, bt, bu, bv){

        if(!qx.lang.Array.contains(this.__createdStyles, bs)){

          var by = this.__getSourcesMap(bt);
          var bx = this.__getRule(bs, by);
          if(!bx){

            throw new Error(o + bs + ba);
          };
          if(!this.__styleSheet){

            this.__styleSheet = qx.bom.Stylesheet.createElement();
          };
          try{

            this.__addRule(bx);
          } catch(bz) {

            if(qx.core.Environment.get(bc)){

              this.warn(J, bz.message);
              return;
            };
          };
          this.__createdStyles.push(bs);
        };
        if(!this.__validators[bs]){

          this.__validators[bs] = new qx.bom.webfonts.Validator(bs);
          this.__validators[bs].setTimeout(qx.bom.webfonts.Manager.VALIDATION_TIMEOUT);
          this.__validators[bs].addListenerOnce(G, this.__onFontChangeStatus, this);
        };
        if(bu){

          var bw = bv || window;
          this.__validators[bs].addListenerOnce(G, bu, bw);
        };
        this.__validators[bs].validate();
      },
      /**
       * Processes the next item in the queue
       */
      __flushQueue : function(){

        if(this.__queue.length == 0){

          this.__queueInterval.stop();
          return;
        };
        var bA = this.__queue.shift();
        this.__require.apply(this, bA);
      },
      /**
       * Removes the font-face declaration if a font could not be validated
       *
       * @param ev {qx.event.type.Data} qx.bom.webfonts.Validator#changeStatus
       */
      __onFontChangeStatus : function(bB){

        var bC = bB.getData();
        if(bC.valid === false){

          qx.event.Timer.once(function(){

            this.remove(bC.family);
          }, this, 250);
        };
      },
      /**
       * Uses a naive regExp match to determine the format of each defined source
       * file for a webFont. Returns a map with the format names as keys and the
       * corresponding source URLs as values.
       *
       * @param sources {String[]} Array of source URLs
       * @return {Map} Map of formats and URLs
       */
      __getSourcesMap : function(bD){

        var bF = qx.bom.webfonts.Manager.FONT_FORMATS;
        var bI = {
        };
        for(var i = 0,l = bD.length;i < l;i++){

          var bG = null;
          for(var x = 0;x < bF.length;x++){

            var bH = new RegExp(X + bF[x] + h);
            var bE = bH.exec(bD[i]);
            if(bE){

              bG = bE[1];
            };
          };
          if(bG){

            bI[bG] = bD[i];
          };
        };
        return bI;
      },
      /**
       * Assembles the body of a font-face rule for a single webFont.
       *
       * @param familyName {String} Font-family name
       * @param sourcesMap {Map} Map of font formats and sources
       * @return {String} The computed CSS rule
       */
      __getRule : function(bJ, bK){

        var bN = [];
        var bL = this.__preferredFormats.length > 0 ? this.__preferredFormats : qx.bom.webfonts.Manager.FONT_FORMATS;
        for(var i = 0,l = bL.length;i < l;i++){

          var bM = bL[i];
          if(bK[bM]){

            bN.push(this.__getSourceForFormat(bM, bK[bM]));
          };
        };
        var bO = c + bN.join(d) + L;
        bO = V + bJ + v + bO;
        bO = bO + H;
        return bO;
      },
      /**
       * Returns the full src value for a given font URL depending on the type
      
       * @param format {String} The font format, one of eot, woff, ttf, svg
       * @param url {String} The font file's URL
       * @return {String} The src directive
       */
      __getSourceForFormat : function(bP, bQ){

        switch(bP){case B:
        return w + bQ + bd + z + bQ + F;case I:
        return w + bQ + s;case E:
        return w + bQ + N;case C:
        return w + bQ + p;default:
        return null;};
      },
      /**
       * Adds a font-face rule to the document
       *
       * @param rule {String} The body of the CSS rule
       */
      __addRule : function(bR){

        var bT = P + bR + W;
        if(qx.core.Environment.get(M) == O && qx.core.Environment.get(K) < 9){

          var bS = this.__fixCssText(this.__styleSheet.cssText);
          bS += bT;
          this.__styleSheet.cssText = bS;
        } else {

          this.__styleSheet.insertRule(bT, this.__styleSheet.cssRules.length);
        };
      },
      /**
       * Removes the font-face declaration for the given font-family from the
       * stylesheet
       *
       * @param familyName {String} The font-family name
       */
      __removeRule : function(bU){

        var bX = new RegExp(u + bU, n);
        for(var i = 0,l = document.styleSheets.length;i < l;i++){

          var bV = document.styleSheets[i];
          if(bV.cssText){

            var bW = bV.cssText.replace(/\n/g, y).replace(/\r/g, y);
            bW = this.__fixCssText(bW);
            if(bX.exec(bW)){

              bW = bW.replace(bX, y);
            };
            bV.cssText = bW;
          } else if(bV.cssRules){

            for(var j = 0,m = bV.cssRules.length;j < m;j++){

              var bW = bV.cssRules[j].cssText.replace(/\n/g, y).replace(/\r/g, y);
              if(bX.exec(bW)){

                this.__styleSheet.deleteRule(j);
                return;
              };
            };
          };
        };
      },
      /**
       * IE 6 and 7 omit the trailing quote after the format name when
       * querying cssText. This needs to be fixed before cssText is replaced
       * or all rules will be invalid and no web fonts will work any more.
       *
       * @param cssText {String} CSS text
       * @return {String} Fixed CSS text
       */
      __fixCssText : function(bY){

        return bY.replace(a, Y).replace(A, t);
      }
    },
    /*
    *****************************************************************************
      DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      delete this.__createdStyles;
      this.removeStyleSheet();
      for(var ca in this.__validators){

        this.__validators[ca].dispose();
      };
      qx.bom.webfonts.Validator.removeDefaultHelperElements();
    }
  });
})();
(function(){

  var b = "singleton",a = "qx.util.LibraryManager";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Author:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */
  /**
   * Provides read/write access to library-specific information such as
   * source/resource URIs.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    type : b,
    statics : {
      /** {Map} The libraries used by this application */
      __libs : qx.$$libraries || {
      }
    },
    members : {
      /**
       * Checks whether the library with the given namespace is known to the
       * application.
       * @param namespace {String} The library's namespace
       * @return {Boolean} <code>true</code> if the given library is known
       */
      has : function(c){

        return !!this.self(arguments).__libs[c];
      },
      /**
       * Returns the value of an attribute of the given library
       * @param namespace {String} The library's namespace
       * @param key {String} Name of the attribute
       * @return {var|null} The attribute's value or <code>null</code> if it's not defined
       */
      get : function(d, e){

        return this.self(arguments).__libs[d][e] ? this.self(arguments).__libs[d][e] : null;
      },
      /**
       * Sets an attribute on the given library.
       *
       * @param namespace {String} The library's namespace
       * @param key {String} Name of the attribute
       * @param value {var} Value of the attribute
       */
      set : function(f, g, h){

        this.self(arguments).__libs[f][g] = h;
      }
    }
  });
})();
(function(){

  var n = "Microsoft.XMLHTTP",m = "io.ssl",l = "io.xhr",k = "",j = "file:",i = "https:",h = "webkit",g = "gecko",f = "activex",e = "opera",b = ".",d = "io.maxrequests",c = "qx.bom.client.Transport",a = "xhr";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fbjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Determines browser-dependent information about the transport layer.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(c, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the maximum number of parallel requests the current browser
       * supports per host addressed.
       *
       * Note that this assumes one connection can support one request at a time
       * only. Technically, this is not correct when pipelining is enabled (which
       * it currently is only for IE 8 and Opera). In this case, the number
       * returned will be too low, as one connection supports multiple pipelined
       * requests. This is accepted for now because pipelining cannot be
       * detected from JavaScript and because modern browsers have enough
       * parallel connections already - it's unlikely an app will require more
       * than 4 parallel XMLHttpRequests to one server at a time.
       *
       * @internal
       */
      getMaxConcurrentRequestCount : function(){

        var o;
        // Parse version numbers.
        var r = qx.bom.client.Engine.getVersion().split(b);
        var p = 0;
        var s = 0;
        var q = 0;
        // Main number
        if(r[0]){

          p = r[0];
        };
        // Major number
        if(r[1]){

          s = r[1];
        };
        // Minor number
        if(r[2]){

          q = r[2];
        };
        // IE 8 gives the max number of connections in a property
        // see http://msdn.microsoft.com/en-us/library/cc197013(VS.85).aspx
        if(window.maxConnectionsPerServer){

          o = window.maxConnectionsPerServer;
        } else if(qx.bom.client.Engine.getName() == e){

          // Opera: 8 total
          // see http://operawiki.info/HttpProtocol
          o = 8;
        } else if(qx.bom.client.Engine.getName() == h){

          // Safari: 4
          // http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/
          // TODO: Distinguish Chrome from Safari, Chrome has 6 connections
          //       according to
          //      http://stackoverflow.com/questions/561046/how-many-concurrent-ajax-xmlhttprequest-requests-are-allowed-in-popular-browser
          o = 4;
        } else if(qx.bom.client.Engine.getName() == g && ((p > 1) || ((p == 1) && (s > 9)) || ((p == 1) && (s == 9) && (q >= 1)))){

          // FF 3.5 (== Gecko 1.9.1): 6 Connections.
          // see  http://gemal.dk/blog/2008/03/18/firefox_3_beta_5_will_have_improved_connection_parallelism/
          o = 6;
        } else {

          // Default is 2, as demanded by RFC 2616
          // see http://blogs.msdn.com/ie/archive/2005/04/11/407189.aspx
          o = 2;
        };;;
        return o;
      },
      /**
       * Checks whether the app is loaded with SSL enabled which means via https.
       *
       * @internal
       * @return {Boolean} <code>true</code>, if the app runs on https
       */
      getSsl : function(){

        return window.location.protocol === i;
      },
      /**
       * Checks what kind of XMLHttpRequest object the browser supports
       * for the current protocol, if any.
       *
       * The standard XMLHttpRequest is preferred over ActiveX XMLHTTP.
       *
       * @internal
       * @return {String}
       *  <code>"xhr"</code>, if the browser provides standard XMLHttpRequest.<br/>
       *  <code>"activex"</code>, if the browser provides ActiveX XMLHTTP.<br/>
       *  <code>""</code>, if there is not XHR support at all.
       */
      getXmlHttpRequest : function(){

        // Standard XHR can be disabled in IE's security settings,
        // therefore provide ActiveX as fallback. Additionaly,
        // standard XHR in IE7 is broken for file protocol.
        var t = window.ActiveXObject ? (function(){

          if(window.location.protocol !== j){

            try{

              new window.XMLHttpRequest();
              return a;
            } catch(u) {
            };
          };
          try{

            new window.ActiveXObject(n);
            return f;
          } catch(v) {
          };
        })() : (function(){

          try{

            new window.XMLHttpRequest();
            return a;
          } catch(w) {
          };
        })();
        return t || k;
      }
    },
    defer : function(x){

      qx.core.Environment.add(d, x.getMaxConcurrentRequestCount);
      qx.core.Environment.add(m, x.getSsl);
      qx.core.Environment.add(l, x.getXmlHttpRequest);
    }
  });
})();
(function(){

  var q = "//",p = "encoding",o = "?",n = "data",m = "type",l = "data:image/",k = ";",j = "qx.util.ResourceManager",i = "singleton",h = ",",c = "mshtml",g = "engine.name",f = "io.ssl",b = "string",a = "/",e = "resourceUri",d = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Contains information about images (size, format, clipping, ...) and
   * other resources like CSS files, local data, ...
   */
  qx.Class.define(j, {
    extend : qx.core.Object,
    type : i,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Map} the shared image registry */
      __registry : qx.$$resources || {
      },
      /** {Map} prefix per library used in HTTPS mode for IE */
      __urlPrefix : {
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Whether the registry has information about the given resource.
       *
       * @param id {String} The resource to get the information for
       * @return {Boolean} <code>true</code> when the resource is known.
       */
      has : function(r){

        return !!this.self(arguments).__registry[r];
      },
      /**
       * Get information about an resource.
       *
       * @param id {String} The resource to get the information for
       * @return {Array} Registered data or <code>null</code>
       */
      getData : function(s){

        return this.self(arguments).__registry[s] || null;
      },
      /**
       * Returns the width of the given resource ID,
       * when it is not a known image <code>0</code> is
       * returned.
       *
       * @param id {String} Resource identifier
       * @return {Integer} The image width, maybe <code>null</code> when the width is unknown
       */
      getImageWidth : function(t){

        var u = this.self(arguments).__registry[t];
        return u ? u[0] : null;
      },
      /**
       * Returns the height of the given resource ID,
       * when it is not a known image <code>0</code> is
       * returned.
       *
       * @param id {String} Resource identifier
       * @return {Integer} The image height, maybe <code>null</code> when the height is unknown
       */
      getImageHeight : function(v){

        var w = this.self(arguments).__registry[v];
        return w ? w[1] : null;
      },
      /**
       * Returns the format of the given resource ID,
       * when it is not a known image <code>null</code>
       * is returned.
       *
       * @param id {String} Resource identifier
       * @return {String} File format of the image
       */
      getImageFormat : function(x){

        var y = this.self(arguments).__registry[x];
        return y ? y[2] : null;
      },
      /**
       * Returns the format of the combined image (png, gif, ...), if the given
       * resource identifier is an image contained in one, or the empty string
       * otherwise.
       *
       * @param id {String} Resource identifier
       * @return {String} The type of the combined image containing id
       */
      getCombinedFormat : function(z){

        var C = d;
        var B = this.self(arguments).__registry[z];
        var A = B && B.length > 4 && typeof (B[4]) == b && this.constructor.__registry[B[4]];
        if(A){

          var E = B[4];
          var D = this.constructor.__registry[E];
          C = D[2];
        };
        return C;
      },
      /**
       * Converts the given resource ID to a full qualified URI
       *
       * @param id {String} Resource ID
       * @return {String} Resulting URI
       */
      toUri : function(F){

        if(F == null){

          return F;
        };
        var G = this.self(arguments).__registry[F];
        if(!G){

          return F;
        };
        if(typeof G === b){

          var I = G;
        } else {

          var I = G[3];
          // no lib reference
          // may mean that the image has been registered dynamically
          if(!I){

            return F;
          };
        };
        var H = d;
        if((qx.core.Environment.get(g) == c) && qx.core.Environment.get(f)){

          H = this.self(arguments).__urlPrefix[I];
        };
        return H + qx.util.LibraryManager.getInstance().get(I, e) + a + F;
      },
      /**
       * Construct a data: URI for an image resource.
       *
       * Constructs a data: URI for a given resource id, if this resource is
       * contained in a base64 combined image. If this is not the case (e.g.
       * because the combined image has not been loaded yet), returns the direct
       * URI to the image file itself.
       *
       * @param resid {String} resource id of the image
       * @return {String} "data:" or "http:" URI
       */
      toDataUri : function(J){

        var L = this.constructor.__registry[J];
        var M = this.constructor.__registry[L[4]];
        var N;
        if(M){

          var K = M[4][J];
          N = l + K[m] + k + K[p] + h + K[n];
        } else {

          N = this.toUri(J);
        };
        return N;
      }
    },
    defer : function(O){

      if((qx.core.Environment.get(g) == c)){

        // To avoid a "mixed content" warning in IE when the application is
        // delivered via HTTPS a prefix has to be added. This will transform the
        // relative URL to an absolute one in IE.
        // Though this warning is only displayed in conjunction with images which
        // are referenced as a CSS "background-image", every resource path is
        // changed when the application is served with HTTPS.
        if(qx.core.Environment.get(f)){

          for(var S in qx.$$libraries){

            var Q;
            if(qx.util.LibraryManager.getInstance().get(S, e)){

              Q = qx.util.LibraryManager.getInstance().get(S, e);
            } else {

              // default for libraries without a resourceUri set
              O.__urlPrefix[S] = d;
              continue;
            };
            // It is valid to to begin a URL with "//" so this case has to
            // be considered. If the to resolved URL begins with "//" the
            // manager prefixes it with "https:" to avoid any problems for IE
            if(Q.match(/^\/\//) != null){

              O.__urlPrefix[S] = window.location.protocol;
            } else if(Q.match(/^\//) != null){

              O.__urlPrefix[S] = window.location.protocol + q + window.location.host;
            } else if(Q.match(/^\.\//) != null){

              var P = document.URL;
              O.__urlPrefix[S] = P.substring(0, P.lastIndexOf(a) + 1);
            } else if(Q.match(/^http/) != null){

              // Let absolute URLs pass through
              O.__urlPrefix[S] = d;
            } else {

              // check for parameters with URLs as value
              var T = window.location.href.indexOf(o);
              var R;
              if(T == -1){

                R = window.location.href;
              } else {

                R = window.location.href.substring(0, T);
              };
              O.__urlPrefix[S] = R.substring(0, R.lastIndexOf(a) + 1);
            };;;
          };
        };
      };
    }
  });
})();
(function(){

  var k = "qx.event.Timer",j = "_applyInterval",i = "func is not a function",h = "Boolean",g = "qx.debug",f = "No timeout given",d = "Integer",c = "qx.event.type.Event",b = "_applyEnabled",a = "interval";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Global timer support.
   *
   * This class can be used to periodically fire an event. This event can be
   * used to simulate e.g. a background task. The static method
   * {@link #once} is a special case. It will call a function deferred after a
   * given timeout.
   */
  qx.Class.define(k, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param interval {Number} initial interval in milliseconds of the timer.
     */
    construct : function(l){

      qx.core.Object.call(this);
      this.setEnabled(false);
      if(l != null){

        this.setInterval(l);
      };
      // don't use qx.lang.Function.bind because this function would add a
      // disposed check, which could break the functionality. In IE the handler
      // may get called after "clearInterval" (i.e. after the timer is disposed)
      // and we must be able to handle this.
      var self = this;
      this.__oninterval = function(){

        self._oninterval.call(self);
      };
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** This event if fired each time the interval time has elapsed */
      "interval" : c
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Start a function after a given timeout.
       *
       * @param func {Function} Function to call
       * @param obj {Object} context (this), the function is called with
       * @param timeout {Number} Number of milliseconds to wait before the
       *   function is called.
       * @return {qx.event.Timer} The timer object used for the timeout. This
       *    object can be used to cancel the timeout. Note that the timer is
       *    only valid until the timer has been executed.
       */
      once : function(m, n, o){

        if(qx.core.Environment.get(g)){

          // check the given parameter
          qx.core.Assert.assertFunction(m, i);
          qx.core.Assert.assertNotUndefined(o, f);
        };
        // Create time instance
        var p = new qx.event.Timer(o);
        // Bug #3481: append original function to timer instance so it can be
        // read by a debugger
        p.__onceFunc = m;
        // Add event listener to interval
        p.addListener(a, function(e){

          p.stop();
          m.call(n, e);
          p.dispose();
          n = null;
        }, n);
        // Directly start timer
        p.start();
        return p;
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * With the enabled property the Timer can be started and suspended.
       * Setting it to "true" is equivalent to {@link #start}, setting it
       * to "false" is equivalent to {@link #stop}.
       */
      enabled : {
        init : true,
        check : h,
        apply : b
      },
      /**
       * Time in milliseconds between two callback calls.
       * This property can be set to modify the interval of
       * a running timer.
       */
      interval : {
        check : d,
        init : 1000,
        apply : j
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __intervalHandler : null,
      __oninterval : null,
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      /**
       * Apply the interval of the timer.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyInterval : function(q, r){

        if(this.getEnabled()){

          this.restart();
        };
      },
      /**
       * Apply the enabled state of the timer.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyEnabled : function(s, t){

        if(t){

          window.clearInterval(this.__intervalHandler);
          this.__intervalHandler = null;
        } else if(s){

          this.__intervalHandler = window.setInterval(this.__oninterval, this.getInterval());
        };
      },
      /*
      ---------------------------------------------------------------------------
        USER-ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Start the timer
       *
       */
      start : function(){

        this.setEnabled(true);
      },
      /**
       * Start the timer with a given interval
       *
       * @param interval {Integer} Time in milliseconds between two callback calls.
       */
      startWith : function(u){

        this.setInterval(u);
        this.start();
      },
      /**
       * Stop the timer.
       *
       */
      stop : function(){

        this.setEnabled(false);
      },
      /**
       * Restart the timer.
       * This makes it possible to change the interval of a running timer.
       *
       */
      restart : function(){

        this.stop();
        this.start();
      },
      /**
       * Restart the timer. with a given interval.
       *
       * @param interval {Integer} Time in milliseconds between two callback calls.
       */
      restartWith : function(v){

        this.stop();
        this.startWith(v);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT-MAPPER
      ---------------------------------------------------------------------------
      */
      /**
       * timer callback
       *
       * @signature function()
       */
      _oninterval : qx.event.GlobalError.observeMethod(function(){

        if(this.$$disposed){

          return;
        };
        if(this.getEnabled()){

          this.fireEvent(a);
        };
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__intervalHandler){

        window.clearInterval(this.__intervalHandler);
      };
      this.__intervalHandler = this.__oninterval = null;
    }
  });
})();
(function(){

  var p = "stylesheet",o = "html.stylesheet.addimport",n = "html.stylesheet.insertrule",m = "}",l = "html.stylesheet.createstylesheet",k = '@import "',j = "{",h = '";',g = "qx.bom.Stylesheet",f = "link",c = "style",e = "head",d = "text/css",b = "html.stylesheet.removeimport",a = "html.stylesheet.deleterule";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Andreas Junghans (lucidcake)
  
  ************************************************************************ */
  /**
   * Cross-browser wrapper to work with CSS stylesheets.
   */
  qx.Bootstrap.define(g, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Include a CSS file
       *
       * <em>Note:</em> Using a resource ID as the <code>href</code> parameter
       * will no longer be supported. Call
       * <code>qx.util.ResourceManager.getInstance().toUri(href)</code> to get
       * valid URI to be used with this method.
       *
       * @param href {String} Href value
       * @param doc? {Document} Document to modify
       * @return {void}
       */
      includeFile : function(q, r){

        if(!r){

          r = document;
        };
        var s = r.createElement(f);
        s.type = d;
        s.rel = p;
        s.href = q;
        var t = r.getElementsByTagName(e)[0];
        t.appendChild(s);
      },
      /**
       * Create a new Stylesheet node and append it to the document
       *
       * @param text? {String} optional string of css rules
       * @return {Stylesheet} the generates stylesheet element
       */
      createElement : function(u){

        if(qx.core.Environment.get(l)){

          var v = document.createStyleSheet();
          if(u){

            v.cssText = u;
          };
          return v;
        } else {

          var w = document.createElement(c);
          w.type = d;
          if(u){

            w.appendChild(document.createTextNode(u));
          };
          document.getElementsByTagName(e)[0].appendChild(w);
          return w.sheet;
        };
      },
      /**
       * Insert a new CSS rule into a given Stylesheet
       *
       * @param sheet {Object} the target Stylesheet object
       * @param selector {String} the selector
       * @param entry {String} style rule
       */
      addRule : function(x, y, z){

        if(qx.core.Environment.get(n)){

          x.insertRule(y + j + z + m, x.cssRules.length);
        } else {

          x.addRule(y, z);
        };
      },
      /**
       * Remove a CSS rule from a stylesheet
       *
       * @param sheet {Object} the Stylesheet
       * @param selector {String} the Selector of the rule to remove
       * @return {void}
       */
      removeRule : function(A, B){

        if(qx.core.Environment.get(a)){

          var C = A.cssRules;
          var D = C.length;
          for(var i = D - 1;i >= 0;--i){

            if(C[i].selectorText == B){

              A.deleteRule(i);
            };
          };
        } else {

          var C = A.rules;
          var D = C.length;
          for(var i = D - 1;i >= 0;--i){

            if(C[i].selectorText == B){

              A.removeRule(i);
            };
          };
        };
      },
      /**
       * Remove the given sheet from its owner.
       * @param sheet {Object} the stylesheet object
       */
      removeSheet : function(E){

        var F = E.ownerNode ? E.ownerNode : E.owningElement;
        qx.dom.Element.removeChild(F, F.parentNode);
      },
      /**
       * Remove all CSS rules from a stylesheet
       *
       * @param sheet {Object} the stylesheet object
       * @return {void}
       */
      removeAllRules : function(G){

        if(qx.core.Environment.get(a)){

          var H = G.cssRules;
          var I = H.length;
          for(var i = I - 1;i >= 0;i--){

            G.deleteRule(i);
          };
        } else {

          var H = G.rules;
          var I = H.length;
          for(var i = I - 1;i >= 0;i--){

            G.removeRule(i);
          };
        };
      },
      /**
       * Add an import of an external CSS file to a stylesheet
       *
       * @param sheet {Object} the stylesheet object
       * @param url {String} URL of the external stylesheet file
       * @return {void}
       */
      addImport : function(J, K){

        if(qx.core.Environment.get(o)){

          J.addImport(K);
        } else {

          J.insertRule(k + K + h, J.cssRules.length);
        };
      },
      /**
       * Removes an import from a stylesheet
       *
       * @param sheet {Object} the stylesheet object
       * @param url {String} URL of the imported CSS file
       * @return {void}
       */
      removeImport : function(L, M){

        if(qx.core.Environment.get(b)){

          var N = L.imports;
          var P = N.length;
          for(var i = P - 1;i >= 0;i--){

            if(N[i].href == M || N[i].href == qx.util.Uri.getAbsolute(M)){

              L.removeImport(i);
            };
          };
        } else {

          var O = L.cssRules;
          var P = O.length;
          for(var i = P - 1;i >= 0;i--){

            if(O[i].href == M){

              L.deleteRule(i);
            };
          };
        };
      },
      /**
       * Remove all imports from a stylesheet
       *
       * @param sheet {Object} the stylesheet object
       * @return {void}
       */
      removeAllImports : function(Q){

        if(qx.core.Environment.get(b)){

          var R = Q.imports;
          var T = R.length;
          for(var i = T - 1;i >= 0;i--){

            Q.removeImport(i);
          };
        } else {

          var S = Q.cssRules;
          var T = S.length;
          for(var i = T - 1;i >= 0;i--){

            if(S[i].type == S[i].IMPORT_RULE){

              Q.deleteRule(i);
            };
          };
        };
      }
    }
  });
})();
(function(){

  var h = "qx.bom.client.Stylesheet",g = "html.stylesheet.deleterule",f = "html.stylesheet.insertrule",e = "html.stylesheet.createstylesheet",d = "html.stylesheet.addimport",c = "html.stylesheet.removeimport",b = "function",a = "object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  /**
   * Internal class which contains the checks used by {@link qx.core.Environment}.
   * All checks in here are marked as internal which means you should never use
   * them directly.
   *
   * This class contains checks related to Stylesheet objects.
   *
   * @internal
   */
  qx.Bootstrap.define(h, {
    statics : {
      /**
       * Returns a stylesheet to be used for feature checks
       *
       * @return {Stylesheet} Stylesheet element
       */
      __getStylesheet : function(){

        if(!qx.bom.client.Stylesheet.__stylesheet){

          qx.bom.client.Stylesheet.__stylesheet = qx.bom.Stylesheet.createElement();
        };
        return qx.bom.client.Stylesheet.__stylesheet;
      },
      /**
       * Check for IE's non-standard document.createStyleSheet function.
       * In IE9 (standards mode), the typeof check returns "function" so false is
       * returned. This is intended since IE9 supports the DOM-standard
       * createElement("style") which should be used instead.
       *
       * @internal
       * @return {Boolean} <code>true</code> if the browser supports
       * document.createStyleSheet
       */
      getCreateStyleSheet : function(){

        return typeof document.createStyleSheet === a;
      },
      /**
       * Check for stylesheet.insertRule. Legacy IEs do not support this.
       *
       * @internal
       * @return {Boolean} <code>true</code> if insertRule is supported
       */
      getInsertRule : function(){

        return typeof qx.bom.client.Stylesheet.__getStylesheet().insertRule === b;
      },
      /**
       * Check for stylesheet.deleteRule. Legacy IEs do not support this.
       *
       * @internal
       * @return {Boolean} <code>true</code> if deleteRule is supported
       */
      getDeleteRule : function(){

        return typeof qx.bom.client.Stylesheet.__getStylesheet().deleteRule === b;
      },
      /**
       * Decides whether to use the legacy IE-only stylesheet.addImport or the
       * DOM-standard stylesheet.insertRule('@import [...]')
       *
       * @internal
       * @return {Boolean} <code>true</code> if stylesheet.addImport is supported
       */
      getAddImport : function(){

        return (typeof qx.bom.client.Stylesheet.__getStylesheet().addImport === a);
      },
      /**
       * Decides whether to use the legacy IE-only stylesheet.removeImport or the
       * DOM-standard stylesheet.deleteRule('@import [...]')
       *
       * @internal
       * @return {Boolean} <code>true</code> if stylesheet.removeImport is supported
       */
      getRemoveImport : function(){

        return (typeof qx.bom.client.Stylesheet.__getStylesheet().removeImport === a);
      }
    },
    defer : function(i){

      qx.core.Environment.add(e, i.getCreateStyleSheet);
      qx.core.Environment.add(f, i.getInsertRule);
      qx.core.Environment.add(g, i.getDeleteRule);
      qx.core.Environment.add(d, i.getAddImport);
      qx.core.Environment.add(c, i.getRemoveImport);
    }
  });
})();
(function(){

  var q = "engine.name",p = "='",o = "none",n = "<INPUT TYPE='RADIO' NAME='RADIOTEST' VALUE='Second Choice'>",m = "qx.dom.Element",k = "webkit",j = "The tag name is missing!",h = "div",g = "' ",f = "></",b = "<",d = " ",c = ">",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Manages children structures of an element. Easy and convenient APIs
   * to insert, remove and replace children.
   */
  qx.Bootstrap.define(m, {
    statics : {
      /**
       * {Map} A list of all attributes which needs to be part of the initial element to work correctly
       *
       * @internal
       */
      __initialAttributes : {
        "onload" : true,
        "onpropertychange" : true,
        "oninput" : true,
        "onchange" : true,
        "name" : true,
        "type" : true,
        "checked" : true,
        "disabled" : true
      },
      /**
       * Whether the given <code>child</code> is a child of <code>parent</code>
       *
       * @param parent {Element} parent element
       * @param child {Node} child node
       * @return {Boolean} true when the given <code>child</code> is a child of <code>parent</code>
       */
      hasChild : function(parent, r){

        return r.parentNode === parent;
      },
      /**
       * Whether the given <code>element</code> has children.
       *
       * @param element {Element} element to test
       * @return {Boolean} true when the given <code>element</code> has at least one child node
       */
      hasChildren : function(s){

        return !!s.firstChild;
      },
      /**
       * Whether the given <code>element</code> has any child elements.
       *
       * @param element {Element} element to test
       * @return {Boolean} true when the given <code>element</code> has at least one child element
       */
      hasChildElements : function(t){

        t = t.firstChild;
        while(t){

          if(t.nodeType === 1){

            return true;
          };
          t = t.nextSibling;
        };
        return false;
      },
      /**
       * Returns the parent element of the given element.
       *
       * @param element {Element} Element to find the parent for
       * @return {Element} The parent element
       */
      getParentElement : function(u){

        return u.parentNode;
      },
      /**
       * Checks if the <code>element</code> is in the DOM, but note that
       * the method is very expensive!
       *
       * @param element {Element} The DOM element to check.
       * @param win {Window} The window to check for.
       * @return {Boolean} <code>true</code> if the <code>element</code> is in
       *          the DOM, <code>false</code> otherwise.
       */
      isInDom : function(v, w){

        if(!w){

          w = window;
        };
        var x = w.document.getElementsByTagName(v.nodeName);
        for(var i = 0,l = x.length;i < l;i++){

          if(x[i] === v){

            return true;
          };
        };
        return false;
      },
      /*
      ---------------------------------------------------------------------------
        INSERTION
      ---------------------------------------------------------------------------
      */
      /**
       * Inserts <code>node</code> at the given <code>index</code>
       * inside <code>parent</code>.
       *
       * @param node {Node} node to insert
       * @param parent {Element} parent element node
       * @param index {Integer} where to insert
       * @return {Boolean} returns true (successful)
       */
      insertAt : function(y, parent, z){

        var A = parent.childNodes[z];
        if(A){

          parent.insertBefore(y, A);
        } else {

          parent.appendChild(y);
        };
        return true;
      },
      /**
       * Insert <code>node</code> into <code>parent</code> as first child.
       * Indexes of other children will be incremented by one.
       *
       * @param node {Node} Node to insert
       * @param parent {Element} parent element node
       * @return {Boolean} returns true (successful)
       */
      insertBegin : function(B, parent){

        if(parent.firstChild){

          this.insertBefore(B, parent.firstChild);
        } else {

          parent.appendChild(B);
        };
      },
      /**
       * Insert <code>node</code> into <code>parent</code> as last child.
       *
       * @param node {Node} Node to insert
       * @param parent {Element} parent element node
       * @return {Boolean} returns true (successful)
       */
      insertEnd : function(C, parent){

        parent.appendChild(C);
      },
      /**
       * Inserts <code>node</code> before <code>ref</code> in the same parent.
       *
       * @param node {Node} Node to insert
       * @param ref {Node} Node which will be used as reference for insertion
       * @return {Boolean} returns true (successful)
       */
      insertBefore : function(D, E){

        E.parentNode.insertBefore(D, E);
        return true;
      },
      /**
       * Inserts <code>node</code> after <code>ref</code> in the same parent.
       *
       * @param node {Node} Node to insert
       * @param ref {Node} Node which will be used as reference for insertion
       * @return {Boolean} returns true (successful)
       */
      insertAfter : function(F, G){

        var parent = G.parentNode;
        if(G == parent.lastChild){

          parent.appendChild(F);
        } else {

          return this.insertBefore(F, G.nextSibling);
        };
        return true;
      },
      /*
      ---------------------------------------------------------------------------
        REMOVAL
      ---------------------------------------------------------------------------
      */
      /**
       * Removes the given <code>node</code> from its parent element.
       *
       * @param node {Node} Node to remove
       * @return {Boolean} <code>true</code> when node was successfully removed,
       *   otherwise <code>false</code>
       */
      remove : function(H){

        if(!H.parentNode){

          return false;
        };
        H.parentNode.removeChild(H);
        return true;
      },
      /**
       * Removes the given <code>node</code> from the <code>parent</code>.
       *
       * @param node {Node} Node to remove
       * @param parent {Element} parent element which contains the <code>node</code>
       * @return {Boolean} <code>true</code> when node was successfully removed,
       *   otherwise <code>false</code>
       */
      removeChild : function(I, parent){

        if(I.parentNode !== parent){

          return false;
        };
        parent.removeChild(I);
        return true;
      },
      /**
       * Removes the node at the given <code>index</code>
       * from the <code>parent</code>.
       *
       * @param index {Integer} position of the node which should be removed
       * @param parent {Element} parent DOM element
       * @return {Boolean} <code>true</code> when node was successfully removed,
       *   otherwise <code>false</code>
       */
      removeChildAt : function(J, parent){

        var K = parent.childNodes[J];
        if(!K){

          return false;
        };
        parent.removeChild(K);
        return true;
      },
      /*
      ---------------------------------------------------------------------------
        REPLACE
      ---------------------------------------------------------------------------
      */
      /**
       * Replaces <code>oldNode</code> with <code>newNode</code> in the current
       * parent of <code>oldNode</code>.
       *
       * @param newNode {Node} DOM node to insert
       * @param oldNode {Node} DOM node to remove
       * @return {Boolean} <code>true</code> when node was successfully replaced
       */
      replaceChild : function(L, M){

        if(!M.parentNode){

          return false;
        };
        M.parentNode.replaceChild(L, M);
        return true;
      },
      /**
       * Replaces the node at <code>index</code> with <code>newNode</code> in
       * the given parent.
       *
       * @param newNode {Node} DOM node to insert
       * @param index {Integer} position of old DOM node
       * @param parent {Element} parent DOM element
       * @return {Boolean} <code>true</code> when node was successfully replaced
       */
      replaceAt : function(N, O, parent){

        var P = parent.childNodes[O];
        if(!P){

          return false;
        };
        parent.replaceChild(N, P);
        return true;
      },
      /**
       * Stores helper element for element creation in WebKit
       *
       * @internal
       */
      __helperElement : {
      },
      /**
       * Saves whether a helper element is needed for each window.
       *
       * @internal
       */
      __allowMarkup : {
      },
      /**
       * Detects if the DOM support a <code>document.createElement</code> call with a
       * <code>String</code> as markup like:
       *
       * <pre class="javascript">
       * document.createElement("<INPUT TYPE='RADIO' NAME='RADIOTEST' VALUE='Second Choice'>");
       * </pre>
       *
       * Element creation with markup is not standard compatible with Document Object Model (Core) Level 1, but
       * Internet Explorer supports it. With an exception that IE9 in IE9 standard mode is standard compatible and
       * doesn't support element creation with markup.
       *
       * @param win {Window?} Window to check for
       * @return {Boolean} <code>true</code> if the DOM supports it, <code>false</code> otherwise.
       */
      _allowCreationWithMarkup : function(Q){

        if(!Q){

          Q = window;
        };
        // key is needed to allow using different windows
        var R = Q.location.href;
        if(qx.dom.Element.__allowMarkup[R] == undefined){

          try{

            Q.document.createElement(n);
            qx.dom.Element.__allowMarkup[R] = true;
          } catch(e) {

            qx.dom.Element.__allowMarkup[R] = false;
          };
        };
        return qx.dom.Element.__allowMarkup[R];
      },
      /**
           * Creates and returns a DOM helper element.
           *
           * @param win {Window?} Window to create the element for
           * @return {Element} The created element node
           */
      getHelperElement : function(S){

        if(!S){

          S = window;
        };
        // key is needed to allow using different windows
        var U = S.location.href;
        if(!qx.dom.Element.__helperElement[U]){

          var T = qx.dom.Element.__helperElement[U] = S.document.createElement(h);
          // innerHTML will only parsed correctly if element is appended to document
          if(qx.core.Environment.get(q) == k){

            T.style.display = o;
            S.document.body.appendChild(T);
          };
        };
        return qx.dom.Element.__helperElement[U];
      },
      /**
       * Creates a DOM element.
       *
       * Attributes may be given directly with this call. This is critical
       * for some attributes e.g. name, type, ... in many clients.
       *
       * Depending on the kind of attributes passed, <code>innerHTML</code> may be
       * used internally to assemble the element. Please make sure you understand
       * the security implications. See {@link qx.bom.Html#clean}.
       *
       * @param name {String} Tag name of the element
       * @param attributes {Map?} Map of attributes to apply
       * @param win {Window?} Window to create the element for
       * @return {Element} The created element node
       */
      create : function(name, V, W){

        if(!W){

          W = window;
        };
        if(!name){

          throw new Error(j);
        };
        var Y = this.__initialAttributes;
        var X = a;
        for(var bb in V){

          if(Y[bb]){

            X += bb + p + V[bb] + g;
          };
        };
        var bc;
        // If specific attributes are defined we need to process
        // the element creation in a more complex way.
        if(X != a){

          if(qx.dom.Element._allowCreationWithMarkup(W)){

            bc = W.document.createElement(b + name + d + X + c);
          } else {

            var ba = qx.dom.Element.getHelperElement(W);
            ba.innerHTML = b + name + d + X + f + name + c;
            bc = ba.firstChild;
          };
        } else {

          bc = W.document.createElement(name);
        };
        for(var bb in V){

          if(!Y[bb]){

            qx.bom.element.Attribute.set(bc, bb, V[bb]);
          };
        };
        return bc;
      },
      /**
       * Removes all content from the given element
       *
       * @param element {Element} element to clean
       * @return {String} empty string (new HTML content)
       */
      empty : function(bd){

        return bd.innerHTML = a;
      }
    }
  });
})();
(function(){

  var o = "function",n = "html.video.h264",m = "html.element.contains",l = 'video/ogg; codecs="theora, vorbis"',k = "html.console",j = "html.xul",i = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",h = "html.video.ogg",g = "http://www.w3.org/TR/SVG11/feature#BasicStructure",f = "html.storage.local",bq = "qx.bom.client.Html",bp = 'audio',bo = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',bn = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",bm = "html.audio",bl = "url(#default#VML)",bk = "audio/mpeg",bj = "org.w3c.dom.svg",bi = "html.classlist",bh = "html.svg",w = "html.video",x = "html.geolocation",t = "DOMTokenList",u = "html.storage.session",r = "1.1",s = "object",p = "html.image.naturaldimensions",q = "html.audio.aif",C = "audio/x-wav",D = '<v:shape id="vml_flag1" adj="1" />',M = "html.canvas",J = "audio/ogg",U = "html.storage.userdata",P = "html.element.compareDocumentPosition",bd = "audio/x-aiff",ba = "html.audio.au",F = "img",bg = "html.xpath",bf = "qxtest",be = 'video',E = "span",H = "html.element.textcontent",I = "html.audio.mp3",L = "html.vml",N = "html.audio.ogg",Q = "none",W = "label",bc = 'video/webm; codecs="vp8, vorbis"',y = "html.dataurl",z = "html.webworker",G = "html.dataset",T = "1.0",S = "html.audio.wav",R = "html.filereader",Y = "audio/basic",X = "#default#userdata",O = "html.video.webm",V = "display",b = "div",bb = "head",A = "number",B = "video",K = "undefined",c = "audio",d = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Internal class which contains the checks used by {@link qx.core.Environment}.
   * All checks in here are marked as internal which means you should never use
   * them directly.
   *
   * This class should contain all checks about HTML.
   *
   * @internal
   */
  qx.Bootstrap.define(bq, {
    statics : {
      /**
       * Whether the client supports Web Workers.
       *
       * @internal
       * @return {Boolean} <code>true</code> if webworkers are supported
       */
      getWebWorker : function(){

        return window.Worker != null;
      },
      /**
       * Whether the client supports File Readers
       *
       * @internal
       * @return {Boolean} <code>true</code> if FileReaders are supported
       */
      getFileReader : function(){

        return window.FileReader != null;
      },
      /**
       * Whether the client supports Geo Location.
       *
       * @internal
       * @return {Boolean} <code>true</code> if geolocation supported
       */
      getGeoLocation : function(){

        return navigator.geolocation != null;
      },
      /**
       * Whether the client supports audio.
       *
       * @internal
       * @return {Boolean} <code>true</code> if audio is supported
       */
      getAudio : function(){

        return !!document.createElement(bp).canPlayType;
      },
      /**
       * Whether the client can play ogg audio format.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getAudioOgg : function(){

        if(!qx.bom.client.Html.getAudio()){

          return d;
        };
        var a = document.createElement(c);
        return a.canPlayType(J);
      },
      /**
       * Whether the client can play mp3 audio format.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getAudioMp3 : function(){

        if(!qx.bom.client.Html.getAudio()){

          return d;
        };
        var a = document.createElement(c);
        return a.canPlayType(bk);
      },
      /**
       * Whether the client can play wave audio wave format.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getAudioWav : function(){

        if(!qx.bom.client.Html.getAudio()){

          return d;
        };
        var a = document.createElement(c);
        return a.canPlayType(C);
      },
      /**
       * Whether the client can play au audio format.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getAudioAu : function(){

        if(!qx.bom.client.Html.getAudio()){

          return d;
        };
        var a = document.createElement(c);
        return a.canPlayType(Y);
      },
      /**
       * Whether the client can play aif audio format.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getAudioAif : function(){

        if(!qx.bom.client.Html.getAudio()){

          return d;
        };
        var a = document.createElement(c);
        return a.canPlayType(bd);
      },
      /**
       * Whether the client supports video.
       *
       * @internal
       * @return {Boolean} <code>true</code> if video is supported
       */
      getVideo : function(){

        return !!document.createElement(be).canPlayType;
      },
      /**
       * Whether the client supports ogg video.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getVideoOgg : function(){

        if(!qx.bom.client.Html.getVideo()){

          return d;
        };
        var v = document.createElement(B);
        return v.canPlayType(l);
      },
      /**
       * Whether the client supports mp4 video.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getVideoH264 : function(){

        if(!qx.bom.client.Html.getVideo()){

          return d;
        };
        var v = document.createElement(B);
        return v.canPlayType(bo);
      },
      /**
       * Whether the client supports webm video.
       *
       * @internal
       * @return {String} "" or "maybe" or "probably"
       */
      getVideoWebm : function(){

        if(!qx.bom.client.Html.getVideo()){

          return d;
        };
        var v = document.createElement(B);
        return v.canPlayType(bc);
      },
      /**
       * Whether the client supports local storage.
       *
       * @internal
       * @return {Boolean} <code>true</code> if local storage is supported
       */
      getLocalStorage : function(){

        try{

          return window.localStorage != null;
        } catch(br) {

          // Firefox Bug: Local execution of window.sessionStorage throws error
          // see https://bugzilla.mozilla.org/show_bug.cgi?id=357323
          return false;
        };
      },
      /**
       * Whether the client supports session storage.
       *
       * @internal
       * @return {Boolean} <code>true</code> if session storage is supported
       */
      getSessionStorage : function(){

        try{

          return window.sessionStorage != null;
        } catch(bs) {

          // Firefox Bug: Local execution of window.sessionStorage throws error
          // see https://bugzilla.mozilla.org/show_bug.cgi?id=357323
          return false;
        };
      },
      /**
       * Whether the client supports user data to persist data. This is only
       * relevant for IE < 8.
       *
       * @internal
       * @return {Boolean} <code>true</code> if the user data is supported.
       */
      getUserDataStorage : function(){

        var bt = document.createElement(b);
        bt.style[V] = Q;
        document.getElementsByTagName(bb)[0].appendChild(bt);
        var bu = false;
        try{

          bt.addBehavior(X);
          bt.load(bf);
          bu = true;
        } catch(e) {
        };
        document.getElementsByTagName(bb)[0].removeChild(bt);
        return bu;
      },
      /**
       * Whether the browser supports CSS class lists.
       * https://developer.mozilla.org/en/DOM/element.classList
       *
       * @internal
       * @return {Boolean} <code>true</code> if class list is supported.
       */
      getClassList : function(){

        return !!(document.documentElement.classList && qx.Bootstrap.getClass(document.documentElement.classList) === t);
      },
      /**
       * Checks if XPath could be used.
       *
       * @internal
       * @return {Boolean} <code>true</code> if xpath is supported.
       */
      getXPath : function(){

        return !!document.evaluate;
      },
      /**
       * Checks if XUL could be used.
       *
       * @internal
       * @return {Boolean} <code>true</code> if XUL is supported.
       */
      getXul : function(){

        try{

          document.createElementNS(i, W);
          return true;
        } catch(e) {

          return false;
        };
      },
      /**
       * Checks if SVG could be used
       *
       * @internal
       * @return {Boolean} <code>true</code> if SVG is supported.
       */
      getSvg : function(){

        return document.implementation && document.implementation.hasFeature && (document.implementation.hasFeature(bj, T) || document.implementation.hasFeature(g, r));
      },
      /**
       * Checks if VML is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if VML is supported.
       */
      getVml : function(){

        var bv = document.createElement(b);
        document.body.appendChild(bv);
        bv.innerHTML = D;
        bv.firstChild.style.behavior = bl;
        var bw = typeof bv.firstChild.adj == s;
        document.body.removeChild(bv);
        return bw;
      },
      /**
       * Checks if canvas could be used
       *
       * @internal
       * @return {Boolean} <code>true</code> if canvas is supported.
       */
      getCanvas : function(){

        return !!window.CanvasRenderingContext2D;
      },
      /**
       * Asynchronous check for using data urls.
       *
       * @internal
       * @param callback {Function} The function which should be executed as
       *   soon as the check is done.
       */
      getDataUrl : function(bx){

        var by = new Image();
        by.onload = by.onerror = function(){

          // wrap that into a timeout because IE might execute it synchronously
          window.setTimeout(function(){

            bx.call(null, (by.width == 1 && by.height == 1));
          }, 0);
        };
        by.src = bn;
      },
      /**
       * Checks if dataset could be used
       *
       * @internal
       * @return {Boolean} <code>true</code> if dataset is supported.
       */
      getDataset : function(){

        return !!document.documentElement.dataset;
      },
      /**
       * Check for element.contains
       *
       * @internal
       * @return {Boolean} <code>true</code> if element.contains is supported
       */
      getContains : function(){

        // "object" in IE6/7/8, "function" in IE9
        return (typeof document.documentElement.contains !== K);
      },
      /**
       * Check for element.compareDocumentPosition
       *
       * @internal
       * @return {Boolean} <code>true</code> if element.compareDocumentPosition is supported
       */
      getCompareDocumentPosition : function(){

        return (typeof document.documentElement.compareDocumentPosition === o);
      },
      /**
       * Check for element.textContent. Legacy IEs do not support this, use
       * innerText instead.
       *
       * @internal
       * @return {Boolean} <code>true</code> if textContent is supported
       */
      getTextContent : function(){

        var bz = document.createElement(E);
        return (typeof bz.textContent !== K);
      },
      /**
       * Check for a console object.
       *
       * @internal
       * @return {Boolean} <code>true</code> if a console is available.
       */
      getConsole : function(){

        return typeof window.console !== K;
      },
      /**
       * Check for the <code>naturalHeight</code> and <code>naturalWidth</code>
       * image element attributes.
       *
       * @internal
       * @return {Boolean} <code>true</code> if both attributes are supported
       */
      getNaturalDimensions : function(){

        var bA = document.createElement(F);
        return typeof bA.naturalHeight === A && typeof bA.naturalWidth === A;
      }
    },
    defer : function(bB){

      qx.core.Environment.add(z, bB.getWebWorker);
      qx.core.Environment.add(R, bB.getFileReader);
      qx.core.Environment.add(x, bB.getGeoLocation);
      qx.core.Environment.add(bm, bB.getAudio);
      qx.core.Environment.add(N, bB.getAudioOgg);
      qx.core.Environment.add(I, bB.getAudioMp3);
      qx.core.Environment.add(S, bB.getAudioWav);
      qx.core.Environment.add(ba, bB.getAudioAu);
      qx.core.Environment.add(q, bB.getAudioAif);
      qx.core.Environment.add(w, bB.getVideo);
      qx.core.Environment.add(h, bB.getVideoOgg);
      qx.core.Environment.add(n, bB.getVideoH264);
      qx.core.Environment.add(O, bB.getVideoWebm);
      qx.core.Environment.add(f, bB.getLocalStorage);
      qx.core.Environment.add(u, bB.getSessionStorage);
      qx.core.Environment.add(U, bB.getUserDataStorage);
      qx.core.Environment.add(bi, bB.getClassList);
      qx.core.Environment.add(bg, bB.getXPath);
      qx.core.Environment.add(j, bB.getXul);
      qx.core.Environment.add(M, bB.getCanvas);
      qx.core.Environment.add(bh, bB.getSvg);
      qx.core.Environment.add(L, bB.getVml);
      qx.core.Environment.add(G, bB.getDataset);
      qx.core.Environment.addAsync(y, bB.getDataUrl);
      qx.core.Environment.add(m, bB.getContains);
      qx.core.Environment.add(P, bB.getCompareDocumentPosition);
      qx.core.Environment.add(H, bB.getTextContent);
      qx.core.Environment.add(k, bB.getConsole);
      qx.core.Environment.add(p, bB.getNaturalDimensions);
    }
  });
})();
(function(){

  var j = "readOnly",i = "accessKey",h = "qx.bom.element.Attribute",g = "rowSpan",f = "vAlign",e = "className",d = "textContent",c = "'",b = "htmlFor",a = "longDesc",A = "cellSpacing",z = "frameBorder",y = "='",x = "useMap",w = "innerText",v = "innerHTML",u = "tabIndex",t = "dateTime",s = "maxLength",r = "html.element.textcontent",p = "mshtml",q = "cellPadding",n = "browser.documentmode",o = "colSpan",l = "engine.name",m = "undefined",k = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Alexander Steitz (aback)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Prototype JS
       http://www.prototypejs.org/
       Version 1.5
  
       Copyright:
         (c) 2006-2007, Prototype Core Team
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Prototype Core Team
  
     ----------------------------------------------------------------------
  
       Copyright (c) 2005-2008 Sam Stephenson
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */
  /**
   * Attribute/Property handling for DOM HTML elements.
   *
   * Also includes support for HTML properties like <code>checked</code>
   * or <code>value</code>. This feature set is supported cross-browser
   * through one common interface and is independent of the differences between
   * the multiple implementations.
   *
   * Supports applying text and HTML content using the attribute names
   * <code>text</code> and <code>html</code>.
   */
  qx.Bootstrap.define(h, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Internal map of attribute conversions */
      __hints : {
        // Name translation table (camelcase is important for some attributes)
        names : {
          "class" : e,
          "for" : b,
          html : v,
          text : qx.core.Environment.get(r) ? d : w,
          colspan : o,
          rowspan : g,
          valign : f,
          datetime : t,
          accesskey : i,
          tabindex : u,
          maxlength : s,
          readonly : j,
          longdesc : a,
          cellpadding : q,
          cellspacing : A,
          frameborder : z,
          usemap : x
        },
        // Attributes which are only applyable on a DOM element (not using compile())
        runtime : {
          "html" : 1,
          "text" : 1
        },
        // Attributes which are (forced) boolean
        bools : {
          compact : 1,
          nowrap : 1,
          ismap : 1,
          declare : 1,
          noshade : 1,
          checked : 1,
          disabled : 1,
          readOnly : 1,
          multiple : 1,
          selected : 1,
          noresize : 1,
          defer : 1,
          allowTransparency : 1
        },
        // Interpreted as property (element.property)
        property : {
          // Used by qx.html.Element
          $$html : 1,
          // Used by qx.ui.core.Widget
          $$widget : 1,
          // Native properties
          disabled : 1,
          checked : 1,
          readOnly : 1,
          multiple : 1,
          selected : 1,
          value : 1,
          maxLength : 1,
          className : 1,
          innerHTML : 1,
          innerText : 1,
          textContent : 1,
          htmlFor : 1,
          tabIndex : 1
        },
        qxProperties : {
          $$widget : 1,
          $$html : 1
        },
        // Default values when "null" is given to a property
        propertyDefault : {
          disabled : false,
          checked : false,
          readOnly : false,
          multiple : false,
          selected : false,
          value : k,
          className : k,
          innerHTML : k,
          innerText : k,
          textContent : k,
          htmlFor : k,
          tabIndex : 0,
          maxLength : qx.core.Environment.select(l, {
            "mshtml" : 2147483647,
            "webkit" : 524288,
            "default" : -1
          })
        },
        // Properties which can be removed to reset them
        removeableProperties : {
          disabled : 1,
          multiple : 1,
          maxLength : 1
        },
        // Use getAttribute(name, 2) for these to query for the real value, not
        // the interpreted one.
        original : {
          href : 1,
          src : 1,
          type : 1
        }
      },
      /**
       * Compiles an incoming attribute map to a string which
       * could be used when building HTML blocks using innerHTML.
       *
       * This method silently ignores runtime attributes like
       * <code>html</code> or <code>text</code>.
       *
       * @param map {Map} Map of attributes. The key is the name of the attribute.
       * @return {String} Returns a compiled string ready for usage.
       */
      compile : function(B){

        var C = [];
        var E = this.__hints.runtime;
        for(var D in B){

          if(!E[D]){

            C.push(D, y, B[D], c);
          };
        };
        return C.join(k);
      },
      /**
       * Returns the value of the given HTML attribute
       *
       * @param element {Element} The DOM element to query
       * @param name {String} Name of the attribute
       * @return {var} The value of the attribute
       */
      get : function(F, name){

        var H = this.__hints;
        var G;
        // normalize name
        name = H.names[name] || name;
        // respect original values
        // http://msdn2.microsoft.com/en-us/library/ms536429.aspx
        if(qx.core.Environment.get(l) == p && parseInt(qx.core.Environment.get(n), 10) < 8 && H.original[name]){

          G = F.getAttribute(name, 2);
        } else if(H.property[name]){

          G = F[name];
          if(typeof H.propertyDefault[name] !== m && G == H.propertyDefault[name]){

            // only return null for all non-boolean properties
            if(typeof H.bools[name] === m){

              return null;
            } else {

              return G;
            };
          };
        } else {

          // fallback to attribute
          G = F.getAttribute(name);
        };
        // TODO: Is this enough, what's about string false values?
        if(H.bools[name]){

          return !!G;
        };
        return G;
      },
      /**
       * Sets an HTML attribute on the given DOM element
       *
       * @param element {Element} The DOM element to modify
       * @param name {String} Name of the attribute
       * @param value {var} New value of the attribute
       * @return {void}
       */
      set : function(I, name, J){

        if(typeof J === m){

          return;
        };
        var K = this.__hints;
        // normalize name
        name = K.names[name] || name;
        // respect booleans
        if(K.bools[name]){

          J = !!J;
        };
        // apply attribute
        // only properties which can be applied by the browser or qxProperties
        // otherwise use the attribute methods
        if(K.property[name] && (!(I[name] === undefined) || K.qxProperties[name])){

          // resetting the attribute/property
          if(J == null){

            // for properties which need to be removed for a correct reset
            if(K.removeableProperties[name]){

              I.removeAttribute(name);
              return;
            } else if(typeof K.propertyDefault[name] !== m){

              J = K.propertyDefault[name];
            };
          };
          I[name] = J;
        } else {

          if(J === true){

            I.setAttribute(name, name);
          } else if(J === false || J === null){

            I.removeAttribute(name);
          } else {

            I.setAttribute(name, J);
          };
        };
      },
      /**
       * Resets an HTML attribute on the given DOM element
       *
       * @param element {Element} The DOM element to modify
       * @param name {String} Name of the attribute
       * @return {void}
       */
      reset : function(L, name){

        this.set(L, name, null);
      }
    }
  });
})();
(function(){

  var k = "file",j = "strict",h = "anchor",g = "div",f = "query",e = "source",d = "password",c = "host",b = "protocol",a = "qx.debug",C = "user",B = "directory",A = "loose",z = "relative",y = "queryKey",x = "qx.util.Uri",w = "",v = "path",u = "authority",t = '">0</a>',r = "&",s = "port",p = "params must be either string or object",q = '<a href="',l = "userInfo",n = "?";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tristan Koch (tristankoch)
  
  ************************************************************************ */
  /**
   * Static helpers for parsing and modifying URIs.
   */
  qx.Bootstrap.define(x, {
    statics : {
      /**
       * Split URL
       *
       * Code taken from:
       *   parseUri 1.2.2
       *   (c) Steven Levithan <stevenlevithan.com>
       *   MIT License
       *
       *
       * @param str {String} String to parse as URI
       * @param strict {Boolean} Whether to parse strictly by the rules
       * @return {Object} Map with parts of URI as properties
       */
      parseUri : function(D, E){

        var F = {
          key : [e, b, u, l, C, d, c, s, z, v, B, k, f, h],
          q : {
            name : y,
            parser : /(?:^|&)([^&=]*)=?([^&]*)/g
          },
          parser : {
            strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
          }
        };
        var o = F,m = F.parser[E ? j : A].exec(D),G = {
        },i = 14;
        while(i--){

          G[o.key[i]] = m[i] || w;
        };
        G[o.q.name] = {
        };
        G[o.key[12]].replace(o.q.parser, function(H, I, J){

          if(I){

            G[o.q.name][I] = J;
          };
        });
        return G;
      },
      /**
       * Append string to query part of URL. Respects existing query.
       *
       * @param url {String} URL to append string to.
       * @param params {String} Parameters to append to URL.
       * @return {String} URL with string appended in query part.
       */
      appendParamsToUrl : function(K, L){

        if(L === undefined){

          return K;
        };
        if(qx.core.Environment.get(a)){

          if(!(qx.lang.Type.isString(L) || qx.lang.Type.isObject(L))){

            throw new Error(p);
          };
        };
        if(qx.lang.Type.isObject(L)){

          L = qx.lang.Object.toUriParameter(L);
        };
        if(!L){

          return K;
        };
        return K += (/\?/).test(K) ? r + L : n + L;
      },
      /**
       * Takes a relative URI and returns an absolute one.
       *
       * @param uri {String} relative URI
       * @return {String} absolute URI
       */
      getAbsolute : function(M){

        var N = document.createElement(g);
        N.innerHTML = q + M + t;
        return N.firstChild.href;
      }
    }
  });
})();
(function(){

  var i = "qx.event.type.Data",h = "qx.bom.webfonts.Validator",g = "_applyFontFamily",f = "__checkTimer",e = "span",d = "Integer",c = "interval",b = "changeStatus",a = ",";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */
  /**
   * Checks whether a given font is available on the document and fires events
   * accordingly.
   */
  qx.Class.define(h, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param fontFamily {String} The name of the font to be verified
     */
    construct : function(j){

      qx.core.Object.call(this);
      if(j){

        this.setFontFamily(j);
      };
      this.__requestedHelpers = this._getRequestedHelpers();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Sets of serif and sans-serif fonts to be used for size comparisons.
       * At least one of these fonts should be present on any system
       */
      COMPARISON_FONTS : {
        sans : ["Arial", "Helvetica", "sans-serif"],
        serif : ["Times New Roman", "Georgia", "serif"]
      },
      /**
       * Map of common CSS attributes to be used for all  size comparison elements
       */
      HELPER_CSS : {
        position : "absolute",
        margin : "0",
        padding : "0",
        top : "-1000px",
        left : "-1000px",
        fontSize : "350px",
        width : "auto",
        height : "auto",
        lineHeight : "normal",
        fontVariant : "normal"
      },
      /**
       * The string to be used in the size comparison elements.
       */
      COMPARISON_STRING : "WEei",
      __defaultSizes : null,
      __defaultHelpers : null,
      /**
       * Removes the two common helper elements used for all size comparisons from
       * the DOM
       */
      removeDefaultHelperElements : function(){

        var k = qx.bom.webfonts.Validator.__defaultHelpers;
        if(k){

          for(var l in k){

            document.body.removeChild(k[l]);
          };
        };
        delete qx.bom.webfonts.Validator.__defaultHelpers;
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The font-family this validator should check
       */
      fontFamily : {
        nullable : true,
        init : null,
        apply : g
      },
      /**
       * Time in milliseconds from the beginning of the check until it is assumed
       * that a font is not available
       */
      timeout : {
        check : d,
        init : 5000
      }
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired when the status of a web font has been determined. The event data
       * is a map with the keys "family" (the font-family name) and "valid"
       * (Boolean).
       */
      "changeStatus" : i
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __requestedHelpers : null,
      __checkTimer : null,
      __checkStarted : null,
      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Validates the font
       */
      validate : function(){

        this.__checkStarted = new Date().getTime();
        if(this.__checkTimer){

          this.__checkTimer.restart();
        } else {

          this.__checkTimer = new qx.event.Timer(100);
          this.__checkTimer.addListener(c, this.__onTimerInterval, this);
          // Give the browser a chance to render the new elements
          qx.event.Timer.once(function(){

            this.__checkTimer.start();
          }, this, 0);
        };
      },
      /*
      ---------------------------------------------------------------------------
        PROTECTED API
      ---------------------------------------------------------------------------
      */
      /**
       * Removes the helper elements from the DOM
       */
      _reset : function(){

        if(this.__requestedHelpers){

          for(var n in this.__requestedHelpers){

            var m = this.__requestedHelpers[n];
            document.body.removeChild(m);
          };
          this.__requestedHelpers = null;
        };
      },
      /**
       * Checks if the font is available by comparing the widths of the elements
       * using the generic fonts to the widths of the elements using the font to
       * be validated
       *
       * @return {Boolean} Whether or not the font caused the elements to differ
       * in size
       */
      _isFontValid : function(){

        if(!qx.bom.webfonts.Validator.__defaultSizes){

          this.__init();
        };
        if(!this.__requestedHelpers){

          this.__requestedHelpers = this._getRequestedHelpers();
        };
        var p = qx.bom.element.Dimension.getWidth(this.__requestedHelpers.sans);
        var o = qx.bom.element.Dimension.getWidth(this.__requestedHelpers.serif);
        var q = qx.bom.webfonts.Validator;
        if(p !== q.__defaultSizes.sans && o !== q.__defaultSizes.serif){

          return true;
        };
        return false;
      },
      /**
       * Creates the two helper elements styled with the font to be checked
       *
       * @return {Map} A map with the keys <pre>sans</pre> and <pre>serif</pre>
       * and the created span elements as values
       */
      _getRequestedHelpers : function(){

        var r = [this.getFontFamily()].concat(qx.bom.webfonts.Validator.COMPARISON_FONTS.sans);
        var s = [this.getFontFamily()].concat(qx.bom.webfonts.Validator.COMPARISON_FONTS.serif);
        return {
          sans : this._getHelperElement(r),
          serif : this._getHelperElement(s)
        };
      },
      /**
       * Creates a span element with the comparison text ({@link #COMPARISON_STRING})
       * and styled with the default CSS ({@link #HELPER_CSS}) plus the given
       * font-family value and appends it to the DOM
       *
       * @param fontFamily {String} font-family string
       * @return {DOMElement} the created DOM element
       */
      _getHelperElement : function(t){

        var u = qx.lang.Object.clone(qx.bom.webfonts.Validator.HELPER_CSS);
        if(t){

          if(u.fontFamily){

            u.fontFamily += a + t.join(a);
          } else {

            u.fontFamily = t.join(a);
          };
        };
        var v = document.createElement(e);
        v.innerHTML = qx.bom.webfonts.Validator.COMPARISON_STRING;
        qx.bom.element.Style.setStyles(v, u);
        document.body.appendChild(v);
        return v;
      },
      // property apply
      _applyFontFamily : function(w, x){

        if(w !== x){

          this._reset();
        };
      },
      /*
      ---------------------------------------------------------------------------
        PRIVATE API
      ---------------------------------------------------------------------------
      */
      /**
       * Creates the default helper elements and gets their widths
       */
      __init : function(){

        var y = qx.bom.webfonts.Validator;
        if(!y.__defaultHelpers){

          y.__defaultHelpers = {
            sans : this._getHelperElement(y.COMPARISON_FONTS.sans),
            serif : this._getHelperElement(y.COMPARISON_FONTS.serif)
          };
        };
        y.__defaultSizes = {
          sans : qx.bom.element.Dimension.getWidth(y.__defaultHelpers.sans),
          serif : qx.bom.element.Dimension.getWidth(y.__defaultHelpers.serif)
        };
      },
      /**
       * Triggers helper element size comparison and fires a ({@link #changeStatus})
       * event with the result.
       */
      __onTimerInterval : function(){

        if(this._isFontValid()){

          this.__checkTimer.stop();
          this._reset();
          this.fireDataEvent(b, {
            family : this.getFontFamily(),
            valid : true
          });
        } else {

          var z = new Date().getTime();
          if(z - this.__checkStarted >= this.getTimeout()){

            this.__checkTimer.stop();
            this._reset();
            this.fireDataEvent(b, {
              family : this.getFontFamily(),
              valid : false
            });
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._reset();
      this.__checkTimer.stop();
      this.__checkTimer.removeListener(c, this.__onTimerInterval, this);
      this._disposeObjects(f);
    }
  });
})();
(function(){

  var j = "qx.bom.element.Dimension",i = "paddingRight",h = "paddingLeft",g = "opera",f = "paddingBottom",e = "paddingTop",d = "mshtml",c = "engine.version",b = "0px",a = "engine.name";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Contains support for calculating dimensions of HTML elements.
   *
   * We differ between the box (or border) size which is available via
   * {@link #getWidth} and {@link #getHeight} and the content or scroll
   * sizes which are available via {@link #getContentWidth} and
   * {@link #getContentHeight}.
   */
  qx.Bootstrap.define(j, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the rendered width of the given element.
       *
       * This is the visible width of the object, which need not to be identical
       * to the width configured via CSS. This highly depends on the current
       * box-sizing for the document and maybe even for the element.
       *
       * @signature function(element)
       * @param element {Element} element to query
       * @return {Integer} width of the element
       */
      getWidth : qx.core.Environment.select(a, {
        "gecko" : function(k){

          // offsetWidth in Firefox does not always return the rendered pixel size
          // of an element.
          // Starting with Firefox 3 the rendered size can be determined by using
          // getBoundingClientRect
          // https://bugzilla.mozilla.org/show_bug.cgi?id=450422
          if(k.getBoundingClientRect){

            var l = k.getBoundingClientRect();
            return Math.round(l.right) - Math.round(l.left);
          } else {

            return k.offsetWidth;
          };
        },
        "default" : function(m){

          return m.offsetWidth;
        }
      }),
      /**
       * Returns the rendered height of the given element.
       *
       * This is the visible height of the object, which need not to be identical
       * to the height configured via CSS. This highly depends on the current
       * box-sizing for the document and maybe even for the element.
       *
       * @signature function(element)
       * @param element {Element} element to query
       * @return {Integer} height of the element
       */
      getHeight : qx.core.Environment.select(a, {
        "gecko" : function(n){

          if(n.getBoundingClientRect){

            var o = n.getBoundingClientRect();
            return Math.round(o.bottom) - Math.round(o.top);
          } else {

            return n.offsetHeight;
          };
        },
        "default" : function(p){

          return p.offsetHeight;
        }
      }),
      /**
       * Returns the rendered size of the given element.
       *
       * @param element {Element} element to query
       * @return {Map} map containing the width and height of the element
       */
      getSize : function(q){

        return {
          width : this.getWidth(q),
          height : this.getHeight(q)
        };
      },
      /** {Map} Contains all overflow values where scrollbars are invisible */
      __hiddenScrollbars : {
        visible : true,
        hidden : true
      },
      /**
       * Returns the content width.
       *
       * The content width is basically the maximum
       * width used or the maximum width which can be used by the content. This
       * excludes all kind of styles of the element like borders, paddings, margins,
       * and even scrollbars.
       *
       * Please note that with visible scrollbars the content width returned
       * may be larger than the box width returned via {@link #getWidth}.
       *
       * @param element {Element} element to query
       * @return {Integer} Computed content width
       */
      getContentWidth : function(r){

        var s = qx.bom.element.Style;
        var t = qx.bom.element.Overflow.getX(r);
        var u = parseInt(s.get(r, h) || b, 10);
        var x = parseInt(s.get(r, i) || b, 10);
        if(this.__hiddenScrollbars[t]){

          var w = r.clientWidth;
          if((qx.core.Environment.get(a) == g) || qx.dom.Node.isBlockNode(r)){

            w = w - u - x;
          };
          return w;
        } else {

          if(r.clientWidth >= r.scrollWidth){

            // Scrollbars visible, but not needed? We need to substract both paddings
            return Math.max(r.clientWidth, r.scrollWidth) - u - x;
          } else {

            // Scrollbars visible and needed. We just remove the left padding,
            // as the right padding is not respected in rendering.
            var v = r.scrollWidth - u;
            // IE renders the paddingRight as well with scrollbars on
            if(qx.core.Environment.get(a) == d && qx.core.Environment.get(c) >= 6){

              v -= x;
            };
            return v;
          };
        };
      },
      /**
       * Returns the content height.
       *
       * The content height is basically the maximum
       * height used or the maximum height which can be used by the content. This
       * excludes all kind of styles of the element like borders, paddings, margins,
       * and even scrollbars.
       *
       * Please note that with visible scrollbars the content height returned
       * may be larger than the box height returned via {@link #getHeight}.
       *
       * @param element {Element} element to query
       * @return {Integer} Computed content height
       */
      getContentHeight : function(y){

        var z = qx.bom.element.Style;
        var C = qx.bom.element.Overflow.getY(y);
        var B = parseInt(z.get(y, e) || b, 10);
        var A = parseInt(z.get(y, f) || b, 10);
        if(this.__hiddenScrollbars[C]){

          return y.clientHeight - B - A;
        } else {

          if(y.clientHeight >= y.scrollHeight){

            // Scrollbars visible, but not needed? We need to substract both paddings
            return Math.max(y.clientHeight, y.scrollHeight) - B - A;
          } else {

            // Scrollbars visible and needed. We just remove the top padding,
            // as the bottom padding is not respected in rendering.
            var D = y.scrollHeight - B;
            // IE renders the paddingBottom as well with scrollbars on
            if(qx.core.Environment.get(a) == d && qx.core.Environment.get(c) == 6){

              D -= A;
            };
            return D;
          };
        };
      },
      /**
       * Returns the rendered content size of the given element.
       *
       * @param element {Element} element to query
       * @return {Map} map containing the content width and height of the element
       */
      getContentSize : function(E){

        return {
          width : this.getContentWidth(E),
          height : this.getContentHeight(E)
        };
      }
    }
  });
})();
(function(){

  var e = "qx.theme.manager.Icon",d = "Theme",c = "changeTheme",b = "_applyTheme",a = "singleton";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Manager for icon themes
   */
  qx.Class.define(e, {
    type : a,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** currently used icon theme */
      theme : {
        check : d,
        nullable : true,
        apply : b,
        event : c
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // property apply
      _applyTheme : function(f, g){

        var i = qx.util.AliasManager.getInstance();
        if(g){

          for(var h in g.aliases){

            i.remove(h);
          };
        };
        if(f){

          for(var h in f.aliases){

            i.add(h, f.aliases[h]);
          };
        };
      }
    }
  });
})();
(function(){

  var j = "Missing appearance: ",h = "_applyTheme",g = "qx.theme.manager.Appearance",f = ":",e = "Theme",d = "changeTheme",c = "/",b = "singleton",a = "string";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Manager for appearance themes
   */
  qx.Class.define(g, {
    type : b,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__styleCache = {
      };
      this.__aliasMap = {
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** currently used appearance theme */
      theme : {
        check : e,
        nullable : true,
        event : d,
        apply : h
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * @lint ignoreReferenceField(__defaultStates)
       */
      __defaultStates : {
      },
      __styleCache : null,
      __aliasMap : null,
      // property apply
      _applyTheme : function(k, l){

        // empty the caches
        this.__aliasMap = {
        };
        this.__styleCache = {
        };
      },
      /*
      ---------------------------------------------------------------------------
        THEME HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the appearance entry ID to use
       * when all aliases etc. are processed.
       *
       * @param id {String} ID to resolve.
       * @param theme {Theme} Theme to use for lookup.
       * @param defaultId {String} ID for a fallback.
       * @return {String} Resolved ID
       */
      __resolveId : function(m, n, o){

        var t = n.appearances;
        var w = t[m];
        if(!w){

          var x = c;
          var q = [];
          var v = m.split(x);
          var u;
          while(!w && v.length > 0){

            q.unshift(v.pop());
            var r = v.join(x);
            w = t[r];
            if(w){

              u = w.alias || w;
              if(typeof u === a){

                var s = u + x + q.join(x);
                return this.__resolveId(s, n, o);
              };
            };
          };
          // check if we find a control fitting in the appearance [BUG #4020]
          for(var i = 0;i < q.length - 1;i++){

            // remove the first id, it has already been checked at startup
            q.shift();
            // build a new subid without the former first id
            var r = q.join(x);
            var p = this.__resolveId(r, n);
            if(p){

              return p;
            };
          };
          // check for the fallback
          if(o != null){

            return this.__resolveId(o, n);
          };
          return null;
        } else if(typeof w === a){

          return this.__resolveId(w, n, o);
        } else if(w.include && !w.style){

          return this.__resolveId(w.include, n, o);
        };;
        return m;
      },
      /**
       * Get the result of the "state" function for a given id and states
       *
       * @param id {String} id of the appearance (e.g. "button", "label", ...)
       * @param states {Map} hash map defining the set states
       * @param theme {Theme?} appearance theme
       * @param defaultId {String} fallback id.
       * @return {Map} map of widget properties as returned by the "state" function
       */
      styleFrom : function(y, z, A, B){

        if(!A){

          A = this.getTheme();
        };
        // Resolve ID
        var G = this.__aliasMap;
        var C = G[y];
        if(!C){

          C = G[y] = this.__resolveId(y, A, B);
        };
        // Query theme for ID
        var M = A.appearances[C];
        if(!M){

          this.warn(j + y);
          return null;
        };
        // Entries with includes, but without style are automatically merged
        // by the ID handling in {@link #getEntry}. When there is no style method in the
        // final object the appearance is empty and null could be returned.
        if(!M.style){

          return null;
        };
        // Build an unique cache name from ID and state combination
        var N = C;
        if(z){

          // Create data fields
          var O = M.$$bits;
          if(!O){

            O = M.$$bits = {
            };
            M.$$length = 0;
          };
          // Compute sum
          var E = 0;
          for(var I in z){

            if(!z[I]){

              continue;
            };
            if(O[I] == null){

              O[I] = 1 << M.$$length++;
            };
            E += O[I];
          };
          // Only append the sum if it is bigger than zero
          if(E > 0){

            N += f + E;
          };
        };
        // Using cache if available
        var F = this.__styleCache;
        if(F[N] !== undefined){

          return F[N];
        };
        // Fallback to default (empty) states map
        if(!z){

          z = this.__defaultStates;
        };
        // Compile the appearance
        var K;
        // If an include or base is defined, too, we need to merge the entries
        if(M.include || M.base){

          // Gather included data
          var D;
          if(M.include){

            D = this.styleFrom(M.include, z, A, B);
          };
          // This process tries to insert the original data first, and
          // append the new data later, to higher prioritize the local
          // data above the included/inherited data. This is especially needed
          // for property groups or properties which includes other
          // properties when modified.
          var H = M.style(z, D);
          // Create new map
          K = {
          };
          // Copy base data, but exclude overwritten local and included stuff
          if(M.base){

            var J = this.styleFrom(C, z, M.base, B);
            if(M.include){

              for(var L in J){

                if(!D.hasOwnProperty(L) && !H.hasOwnProperty(L)){

                  K[L] = J[L];
                };
              };
            } else {

              for(var L in J){

                if(!H.hasOwnProperty(L)){

                  K[L] = J[L];
                };
              };
            };
          };
          // Copy include data, but exclude overwritten local stuff
          if(M.include){

            for(var L in D){

              if(!H.hasOwnProperty(L)){

                K[L] = D[L];
              };
            };
          };
          // Append local data
          for(var L in H){

            K[L] = H[L];
          };
        } else {

          K = M.style(z);
        };
        // Cache new entry and return
        return F[N] = K || null;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__styleCache = this.__aliasMap = null;
    }
  });
})();
(function(){

  var m = 'Invalid include in theme "',k = 'The configuration key "',j = "Mixin theme is not a valid theme!",h = '" is not allowed!',g = "You can only define one theme category per file! Invalid theme: ",f = "other",e = "Found base flag in entry '",d = 'Invalid patch in theme "',c = "[Theme ",b = "' of theme '",U = '" is invalid: ',T = 'Invalid extend in theme "',S = 'Invalid type of key "',R = 'The key "',Q = '"!',P = "]",O = '"! The value needs to be a map!',N = '"! The type of the key must be "',M = 'The type of the key "',L = "qx.Theme",t = 'The content of a meta theme must reference to other themes. The value for "',u = '" inside the meta block is wrong.',r = '"! The value is undefined/null!',s = '" is not allowed inside a meta theme block.',p = "'. Base flags are not allowed for themes without a valid super theme!",q = "'!",n = "fonts",o = "appearances",v = "icons",w = "string",D = "decorations",B = "widgets",F = "borders",E = "' are not compatible '",H = "The mixins '",G = "colors",y = 'Invalid key "',K = "meta",J = '": ',I = "undefined",x = '" in theme "',z = "Theme",A = "qx.debug",C = "object";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Theme classes contain styling information for certain aspects of the
   * graphical user interface.
   *
   * Supported themes are: colors, decorations, fonts, icons, appearances.
   * The additional meta theme allows for grouping of the individual
   * themes.
   *
   * For more details, take a look at the
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/desktop/ui_theming.html' target='_blank'>
   * documentation of the theme system in the qooxdoo manual.</a>
   */
  qx.Bootstrap.define(L, {
    statics : {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Theme config
       *
       * Example:
       * <pre class='javascript'>
       * qx.Theme.define("name",
       * {
       *   aliases : {
       *     "aliasKey" : "resourceFolderOrUri"
       *   },
       *   extend : otherTheme,
       *   include : [MMixinTheme],
       *   patch : [MMixinTheme],
       *   colors : {},
       *   decorations : {},
       *   fonts : {},
       *   widgets : {},
       *   appearances : {},
       *   meta : {}
       * });
       * </pre>
       *
       * For more details, take a look at the
       * <a href='http://manual.qooxdoo.org/${qxversion}/pages/gui_toolkit/ui_theming.html' target='_blank'>
       * documentation of the theme system in the qooxdoo manual.</a>
       *
       * @param name {String} name of the mixin
       * @param config {Map} config structure
       * @return {void}
       */
      define : function(name, V){

        if(!V){

          var V = {
          };
        };
        V.include = this.__normalizeArray(V.include);
        V.patch = this.__normalizeArray(V.patch);
        // Validate incoming data
        if(qx.core.Environment.get(A)){

          this.__validateConfig(name, V);
        };
        // Create alias
        var W = {
          $$type : z,
          name : name,
          title : V.title,
          // Attach toString
          toString : this.genericToString
        };
        // Remember extend
        if(V.extend){

          W.supertheme = V.extend;
        };
        // Assign to namespace
        W.basename = qx.Bootstrap.createNamespace(name, W);
        // Convert theme entry from Object to Function (for prototype inheritance)
        this.__convert(W, V);
        this.__initializeAliases(W, V);
        // Store class reference in global class registry
        this.$$registry[name] = W;
        // Include mixin themes
        for(var i = 0,a = V.include,l = a.length;i < l;i++){

          this.include(W, a[i]);
        };
        for(var i = 0,a = V.patch,l = a.length;i < l;i++){

          this.patch(W, a[i]);
        };
      },
      /**
       * Normalize an object to an array
       *
       * @param objectOrArray {Object|Array} Either an object that is to be
       *   normalized to an array, or an array, which is just passed through
       *
       * @return {Array} Either an array that has the original object as its
       *   single item, or the original array itself
       */
      __normalizeArray : function(X){

        if(!X){

          return [];
        };
        if(qx.Bootstrap.isArray(X)){

          return X;
        } else {

          return [X];
        };
      },
      /**
       * Initialize alias inheritance
       *
       * @param theme {Map} The theme
       * @param config {Map} config structure
       */
      __initializeAliases : function(Y, ba){

        var bb = ba.aliases || {
        };
        if(ba.extend && ba.extend.aliases){

          qx.Bootstrap.objectMergeWith(bb, ba.extend.aliases, false);
        };
        Y.aliases = bb;
      },
      /**
       * Return a map of all known themes
       *
       * @return {Map} known themes
       */
      getAll : function(){

        return this.$$registry;
      },
      /**
       * Returns a theme by name
       *
       * @param name {String} theme name to check
       * @return {Object ? void} theme object
       */
      getByName : function(name){

        return this.$$registry[name];
      },
      /**
       * Determine if theme exists
       *
       * @param name {String} theme name to check
       * @return {Boolean} true if theme exists
       */
      isDefined : function(name){

        return this.getByName(name) !== undefined;
      },
      /**
       * Determine the number of themes which are defined
       *
       * @return {Number} the number of classes
       */
      getTotalNumber : function(){

        return qx.Bootstrap.objectGetLength(this.$$registry);
      },
      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */
      /**
       * This method will be attached to all themes to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The interface identifier
       */
      genericToString : function(){

        return c + this.name + P;
      },
      /**
       * Extract the inheritable key (could be only one)
       *
       * @param config {Map} The map from where to extract the key
       * @return {String} the key which was found
       */
      __extractType : function(bc){

        for(var i = 0,bd = this.__inheritableKeys,l = bd.length;i < l;i++){

          if(bc[bd[i]]){

            return bd[i];
          };
        };
      },
      /**
       * Convert existing entry to a prototype based inheritance function
       *
       * @param theme {Theme} newly created theme object
       * @param config {Map} incoming theme configuration
       */
      __convert : function(be, bf){

        var bi = this.__extractType(bf);
        // Use theme key from extended theme if own one is not available
        if(bf.extend && !bi){

          bi = bf.extend.type;
        };
        // Save theme type
        be.type = bi || f;
        // Create pseudo class
        var bk = function(){
        };
        // Process extend config
        if(bf.extend){

          bk.prototype = new bf.extend.$$clazz;
        };
        var bj = bk.prototype;
        var bh = bf[bi];
        // Copy entries to prototype
        for(var bg in bh){

          bj[bg] = bh[bg];
          // Appearance themes only:
          // Convert base flag to class reference (needed for mixin support)
          if(bj[bg].base){

            if(qx.core.Environment.get(A)){

              if(!bf.extend){

                throw new Error(e + bg + b + bf.name + p);
              };
            };
            bj[bg].base = bf.extend;
          };
        };
        // store pseudo class
        be.$$clazz = bk;
        // and create instance under the old key
        be[bi] = new bk;
      },
      /** {Map} Internal theme registry */
      $$registry : {
      },
      /** {Array} Keys which support inheritance */
      __inheritableKeys : [G, F, D, n, v, B, o, K],
      /** {Map} allowed keys in theme definition */
      __allowedKeys : qx.core.Environment.select(A, {
        "true" : {
          "title" : w,
          // String
          "aliases" : C,
          // Map
          "type" : w,
          // String
          "extend" : C,
          // Theme
          "colors" : C,
          // Map
          "borders" : C,
          // Map
          "decorations" : C,
          // Map
          "fonts" : C,
          // Map
          "icons" : C,
          // Map
          "widgets" : C,
          // Map
          "appearances" : C,
          // Map
          "meta" : C,
          // Map
          "include" : C,
          // Array
          "patch" : C
        },
        "default" : null
      }),
      /** {Map} allowed keys inside a meta theme block */
      __metaKeys : qx.core.Environment.select(A, {
        "true" : {
          "color" : C,
          "border" : C,
          "decoration" : C,
          "font" : C,
          "icon" : C,
          "appearance" : C,
          "widget" : C
        },
        "default" : null
      }),
      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       * @return {void}
       * @throws An error if the given config is not valid (e.g. wrong key or wrong key value)
       */
      __validateConfig : qx.core.Environment.select(A, {
        "true" : function(name, bl){

          var bq = this.__allowedKeys;
          for(var bp in bl){

            if(bq[bp] === undefined){

              throw new Error(k + bp + x + name + h);
            };
            if(bl[bp] == null){

              throw new Error(y + bp + x + name + r);
            };
            if(bq[bp] !== null && typeof bl[bp] !== bq[bp]){

              throw new Error(S + bp + x + name + N + bq[bp] + Q);
            };
          };
          // Validate maps
          var bo = [G, F, D, n, v, B, o, K];
          for(var i = 0,l = bo.length;i < l;i++){

            var bp = bo[i];
            if(bl[bp] !== undefined && (bl[bp] instanceof Array || bl[bp] instanceof RegExp || bl[bp] instanceof Date || bl[bp].classname !== undefined)){

              throw new Error(y + bp + x + name + O);
            };
          };
          // Check conflicts (detect number ...)
          var bm = 0;
          for(var i = 0,l = bo.length;i < l;i++){

            var bp = bo[i];
            if(bl[bp]){

              bm++;
            };
            if(bm > 1){

              throw new Error(g + name);
            };
          };
          // Validate meta
          if(bl.meta){

            var bn;
            for(var bp in bl.meta){

              bn = bl.meta[bp];
              if(this.__metaKeys[bp] === undefined){

                throw new Error(R + bp + s);
              };
              if(typeof bn !== this.__metaKeys[bp]){

                throw new Error(M + bp + u);
              };
              if(!(typeof bn === C && bn !== null && bn.$$type === z)){

                throw new Error(t + bp + x + name + U + bn);
              };
            };
          };
          // Validate extend
          if(bl.extend && bl.extend.$$type !== z){

            throw new Error(T + name + J + bl.extend);
          };
          // Validate include
          if(bl.include){

            for(var i = 0,l = bl.include.length;i < l;i++){

              if(typeof (bl.include[i]) == I || bl.include[i].$$type !== z){

                throw new Error(m + name + J + bl.include[i]);
              };
            };
          };
          // Validate patch
          if(bl.patch){

            for(var i = 0,l = bl.patch.length;i < l;i++){

              if(typeof (bl.patch[i]) == I || bl.patch[i].$$type !== z){

                throw new Error(d + name + J + bl.patch[i]);
              };
            };
          };
        },
        "default" : function(){
        }
      }),
      /**
       * Include all keys of the given mixin theme into the theme. The mixin may
       * include keys which are already defined in the target theme. Existing
       * features of equal name will be overwritten.
       *
       * @param theme {Theme} An existing theme which should be modified by including the mixin theme.
       * @param mixinTheme {Theme} The theme to be included.
       */
      patch : function(br, bs){

        this.__checkForInvalidTheme(bs);
        var bu = this.__extractType(bs);
        if(bu !== this.__extractType(br)){

          throw new Error(H + br.name + E + bs.name + q);
        };
        var bt = bs[bu];
        var bv = br.$$clazz.prototype;
        for(var bw in bt){

          bv[bw] = bt[bw];
        };
      },
      /**
       * Include all keys of the given mixin theme into the theme. If the
       * mixin includes any keys that are already available in the
       * class, they will be silently ignored. Use the {@link #patch} method
       * if you need to overwrite keys in the current class.
       *
       * @param theme {Theme} An existing theme which should be modified by including the mixin theme.
       * @param mixinTheme {Theme} The theme to be included.
       */
      include : function(bx, by){

        this.__checkForInvalidTheme(by);
        var bA = by.type;
        if(bA !== bx.type){

          throw new Error(H + bx.name + E + by.name + q);
        };
        var bz = by[bA];
        var bB = bx.$$clazz.prototype;
        for(var bC in bz){

          //Skip keys already present
          if(bB[bC] !== undefined){

            continue;
          };
          bB[bC] = bz[bC];
        };
      },
      /**
       * Helper method to check for an invalid theme
       *
       * @param mixinTheme {qx,Theme?null} theme to check
       * @throws an error if the theme is not valid
       */
      __checkForInvalidTheme : function(bD){

        if(typeof bD === I || bD == null){

          var bE = new Error(j);
          if(qx.core.Environment.get(A)){

            var bF = qx.dev.StackTrace.getStackTraceFromError(bE);
            qx.Bootstrap.error(this, bF);
          };
          throw bE;
        };
      }
    }
  });
})();
(function(){

  var q = "widget",p = "__hideTimer",o = "qx.ui.tooltip.ToolTip",n = "",m = "__showTimer",l = "_applyCurrent",k = "qx.ui.tooltip.Manager",j = "__sharedToolTip",i = "tooltip-error",h = "singleton",c = "Boolean",g = "interval",f = "mouseover",b = "mouseout",a = "mousemove",d = "focusout";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  /**
   * The tooltip manager globally manages the tooltips of all widgets. It will
   * display tooltips if the user hovers a widgets with a tooltip and hides all
   * other tooltips.
   */
  qx.Class.define(k, {
    type : h,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      // Register events
      qx.event.Registration.addListener(document.body, f, this.__onMouseOverRoot, this, true);
      // Instantiate timers
      this.__showTimer = new qx.event.Timer();
      this.__showTimer.addListener(g, this.__onShowInterval, this);
      this.__hideTimer = new qx.event.Timer();
      this.__hideTimer.addListener(g, this.__onHideInterval, this);
      // Init mouse position
      this.__mousePosition = {
        left : 0,
        top : 0
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Holds the current ToolTip instance */
      current : {
        check : o,
        nullable : true,
        apply : l
      },
      /** Show all invalid form fields tooltips . */
      showInvalidToolTips : {
        check : c,
        init : true
      },
      /** Show all tooltips. */
      showToolTips : {
        check : c,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __mousePosition : null,
      __hideTimer : null,
      __showTimer : null,
      __sharedToolTip : null,
      __sharedErrorToolTip : null,
      /**
       * Get the shared tooltip, which is used to display the
       * {@link qx.ui.core.Widget#toolTipText} and
       * {@link qx.ui.core.Widget#toolTipIcon} properties of widgets.
       * You can use this public shared instance to e.g. customize the
       * look and feel.
       *
       * @return {qx.ui.tooltip.ToolTip} The shared tooltip
       */
      getSharedTooltip : function(){

        if(!this.__sharedToolTip){

          this.__sharedToolTip = new qx.ui.tooltip.ToolTip().set({
            rich : true
          });
        };
        return this.__sharedToolTip;
      },
      /**
       * Get the shared tooltip, which is used to display the
       * {@link qx.ui.core.Widget#toolTipText} and
       * {@link qx.ui.core.Widget#toolTipIcon} properties of widgets.
       * You can use this public shared instance to e.g. customize the
       * look and feel of the validation tooltips like
       * <code>getSharedErrorTooltip().getChildControl("atom").getChildControl("label").set({rich: true, wrap: true, width: 80})</code>
       *
       * @return {qx.ui.tooltip.ToolTip} The shared tooltip
       */
      getSharedErrorTooltip : function(){

        if(!this.__sharedErrorToolTip){

          this.__sharedErrorToolTip = new qx.ui.tooltip.ToolTip().set({
            appearance : i,
            rich : true
          });
          this.__sharedErrorToolTip.setLabel(n);
          // trigger label widget creation
          this.__sharedErrorToolTip.syncAppearance();
        };
        return this.__sharedErrorToolTip;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyCurrent : function(r, s){

        // Return if the new tooltip is a child of the old one
        if(s && qx.ui.core.Widget.contains(s, r)){

          return;
        };
        // If old tooltip existing, hide it and clear widget binding
        if(s){

          if(!s.isDisposed()){

            s.exclude();
          };
          this.__showTimer.stop();
          this.__hideTimer.stop();
        };
        var u = qx.event.Registration;
        var t = document.body;
        // If new tooltip is not null, set it up and start the timer
        if(r){

          this.__showTimer.startWith(r.getShowTimeout());
          // Register hide handler
          u.addListener(t, b, this.__onMouseOutRoot, this, true);
          u.addListener(t, d, this.__onFocusOutRoot, this, true);
          u.addListener(t, a, this.__onMouseMoveRoot, this, true);
        } else {

          // Deregister hide handler
          u.removeListener(t, b, this.__onMouseOutRoot, this, true);
          u.removeListener(t, d, this.__onFocusOutRoot, this, true);
          u.removeListener(t, a, this.__onMouseMoveRoot, this, true);
        };
      },
      /*
      ---------------------------------------------------------------------------
        TIMER EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for the interval event of the show timer.
       *
       * @param e {qx.event.type.Event} Event object
       */
      __onShowInterval : function(e){

        var v = this.getCurrent();
        if(v && !v.isDisposed()){

          this.__hideTimer.startWith(v.getHideTimeout());
          if(v.getPlaceMethod() == q){

            v.placeToWidget(v.getOpener());
          } else {

            v.placeToPoint(this.__mousePosition);
          };
          v.show();
        };
        this.__showTimer.stop();
      },
      /**
       * Event listener for the interval event of the hide timer.
       *
       * @param e {qx.event.type.Event} Event object
       */
      __onHideInterval : function(e){

        var w = this.getCurrent();
        if(w && !w.isDisposed()){

          w.exclude();
        };
        this.__hideTimer.stop();
        this.resetCurrent();
      },
      /*
      ---------------------------------------------------------------------------
        MOUSE EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Global mouse move event handler
       *
       * @param e {qx.event.type.Mouse} The move mouse event
       */
      __onMouseMoveRoot : function(e){

        var x = this.__mousePosition;
        x.left = e.getDocumentLeft();
        x.top = e.getDocumentTop();
      },
      /**
       * Searches for the tooltip of the target widget. If any tooltip instance
       * is found this instance is bound to the target widget and the tooltip is
       * set as {@link #current}
       *
       * @param e {qx.event.type.Mouse} mouseOver event
       * @return {void}
       */
      __onMouseOverRoot : function(e){

        var y = qx.ui.core.Widget.getWidgetByElement(e.getTarget());
        this.showToolTip(y);
      },
      /**
       * Explicitly show tooltip for particular form item.
       *
       * @param target {Object || null} widget to show tooltip for
       */
      showToolTip : function(z){

        if(!z){

          return;
        };
        var C,D,B,A;
        // Search first parent which has a tooltip
        while(z != null){

          C = z.getToolTip();
          D = z.getToolTipText() || null;
          B = z.getToolTipIcon() || null;
          if(qx.Class.hasInterface(z.constructor, qx.ui.form.IForm) && !z.isValid()){

            A = z.getInvalidMessage();
          };
          if(C || D || B || A){

            break;
          };
          z = z.getLayoutParent();
        };
        //do nothing if
        if(//an invalid message is set and invalid tooltips are disabled
        //an invalid message isn't set and tooltips are disabled
        //tooltip is blocked
        //don't have a target
        // tooltip is disabled
        !z || !z.getEnabled() || z.isBlockToolTip() || (!A && !this.getShowToolTips()) || (A && !this.getShowInvalidToolTips())){

          return;
        };
        if(A){

          C = this.getSharedErrorTooltip().set({
            label : A
          });
        };
        if(!C){

          C = this.getSharedTooltip().set({
            label : D,
            icon : B
          });
        };
        this.setCurrent(C);
        C.setOpener(z);
      },
      /**
       * Resets the property {@link #current} if there was a
       * tooltip and no new one is created.
       *
       * @param e {qx.event.type.Mouse} mouseOut event
       * @return {void}
       */
      __onMouseOutRoot : function(e){

        var E = qx.ui.core.Widget.getWidgetByElement(e.getTarget());
        if(!E){

          return;
        };
        var F = qx.ui.core.Widget.getWidgetByElement(e.getRelatedTarget());
        if(!F){

          return;
        };
        var G = this.getCurrent();
        // If there was a tooltip and
        // - the destination target is the current tooltip
        //   or
        // - the current tooltip contains the destination target
        if(G && (F == G || qx.ui.core.Widget.contains(G, F))){

          return;
        };
        // If the destination target exists and the target contains it
        if(F && E && qx.ui.core.Widget.contains(E, F)){

          return;
        };
        // If there was a tooltip and there is no new one
        if(G && !F){

          this.setCurrent(null);
        } else {

          this.resetCurrent();
        };
      },
      /*
      ---------------------------------------------------------------------------
        FOCUS EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Reset the property {@link #current} if the
       * current tooltip is the tooltip of the target widget.
       *
       * @param e {qx.event.type.Focus} blur event
       * @return {void}
       */
      __onFocusOutRoot : function(e){

        var H = qx.ui.core.Widget.getWidgetByElement(e.getTarget());
        if(!H){

          return;
        };
        var I = this.getCurrent();
        // Only set to null if blured widget is the
        // one which has created the current tooltip
        if(I && I == H.getToolTip()){

          this.setCurrent(null);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      // Deregister events
      qx.event.Registration.removeListener(document.body, f, this.__onMouseOverRoot, this, true);
      // Dispose timers
      this._disposeObjects(m, p, j);
      this.__mousePosition = null;
    }
  });
})();
(function(){

  var a = "qx.ui.core.MLayoutHandling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin exposes all methods to manage the layout manager of a widget.
   * It can only be included into instances of {@link Widget}.
   *
   * To optimize the method calls the including widget should call the method
   * {@link #remap} in its defer function. This will map the protected
   * methods to the public ones and save one method call for each function.
   */
  qx.Mixin.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Set a layout manager for the widget. A a layout manager can only be connected
       * with one widget. Reset the connection with a previous widget first, if you
       * like to use it in another widget instead.
       *
       * @param layout {qx.ui.layout.Abstract} The new layout or
       *     <code>null</code> to reset the layout.
       * @return {void}
       */
      setLayout : function(b){

        return this._setLayout(b);
      },
      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      getLayout : function(){

        return this._getLayout();
      }
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Mapping of protected methods to public.
       * This omits an additional function call when using these methods. Call
       * this methods in the defer block of the including class.
       *
       * @param members {Map} The including classes members map
       */
      remap : function(c){

        c.getLayout = c._getLayout;
        c.setLayout = c._setLayout;
      }
    }
  });
})();
(function(){

  var j = "changeWidth",i = "Wrong 'width' argument. ",h = "allowShrinkY",g = "Something went wrong with the layout of ",f = "bottom",e = "Wrong 'left' argument. ",d = "baseline",c = "marginBottom",b = "qx.ui.core.LayoutItem",a = "center",G = "marginTop",F = "!",E = "allowGrowX",D = "middle",C = "marginLeft",B = "allowShrinkX",A = "top",z = "right",y = "marginRight",x = "abstract",q = "Wrong 'top' argument. ",r = "Wrong 'height' argument. ",o = "allowGrowY",p = "left",m = "changeHeight",n = "_applyAlign",k = "qx.debug",l = "shorthand",s = "Boolean",t = "_applyStretching",v = "_applyMargin",u = "_applyDimension",w = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The base class of all items, which should be laid out using a layout manager
   * {@link qx.ui.layout.Abstract}.
   */
  qx.Class.define(b, {
    type : x,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        DIMENSION
      ---------------------------------------------------------------------------
      */
      /**
       * The user provided minimal width.
       *
       * Also take a look at the related properties {@link #width} and {@link #maxWidth}.
       */
      minWidth : {
        check : w,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /**
       * The <code>LayoutItem</code>'s preferred width.
       *
       * The computed width may differ from the given width due to
       * stretching. Also take a look at the related properties
       * {@link #minWidth} and {@link #maxWidth}.
       */
      width : {
        check : w,
        event : j,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /**
       * The user provided maximal width.
       *
       * Also take a look at the related properties {@link #width} and {@link #minWidth}.
       */
      maxWidth : {
        check : w,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /**
       * The user provided minimal height.
       *
       * Also take a look at the related properties {@link #height} and {@link #maxHeight}.
       */
      minHeight : {
        check : w,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /**
       * The item's preferred height.
       *
       * The computed height may differ from the given height due to
       * stretching. Also take a look at the related properties
       * {@link #minHeight} and {@link #maxHeight}.
       */
      height : {
        check : w,
        event : m,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /**
       * The user provided maximum height.
       *
       * Also take a look at the related properties {@link #height} and {@link #minHeight}.
       */
      maxHeight : {
        check : w,
        nullable : true,
        apply : u,
        init : null,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        STRETCHING
      ---------------------------------------------------------------------------
      */
      /** Whether the item can grow horizontally. */
      allowGrowX : {
        check : s,
        apply : t,
        init : true,
        themeable : true
      },
      /** Whether the item can shrink horizontally. */
      allowShrinkX : {
        check : s,
        apply : t,
        init : true,
        themeable : true
      },
      /** Whether the item can grow vertically. */
      allowGrowY : {
        check : s,
        apply : t,
        init : true,
        themeable : true
      },
      /** Whether the item can shrink vertically. */
      allowShrinkY : {
        check : s,
        apply : t,
        init : true,
        themeable : true
      },
      /** Growing and shrinking in the horizontal direction */
      allowStretchX : {
        group : [E, B],
        mode : l,
        themeable : true
      },
      /** Growing and shrinking in the vertical direction */
      allowStretchY : {
        group : [o, h],
        mode : l,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        MARGIN
      ---------------------------------------------------------------------------
      */
      /** Margin of the widget (top) */
      marginTop : {
        check : w,
        init : 0,
        apply : v,
        themeable : true
      },
      /** Margin of the widget (right) */
      marginRight : {
        check : w,
        init : 0,
        apply : v,
        themeable : true
      },
      /** Margin of the widget (bottom) */
      marginBottom : {
        check : w,
        init : 0,
        apply : v,
        themeable : true
      },
      /** Margin of the widget (left) */
      marginLeft : {
        check : w,
        init : 0,
        apply : v,
        themeable : true
      },
      /**
       * The 'margin' property is a shorthand property for setting 'marginTop',
       * 'marginRight', 'marginBottom' and 'marginLeft' at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left respectively.
       * If there is only one value, it applies to all sides, if there are two or three,
       * the missing values are taken from the opposite side.
       */
      margin : {
        group : [G, y, c, C],
        mode : l,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        ALIGN
      ---------------------------------------------------------------------------
      */
      /**
       * Horizontal alignment of the item in the parent layout.
       *
       * Note: Item alignment is only supported by {@link LayoutItem} layouts where
       * it would have a visual effect. Except for {@link Spacer}, which provides
       * blank space for layouts, all classes that inherit {@link LayoutItem} support alignment.
       */
      alignX : {
        check : [p, a, z],
        nullable : true,
        apply : n,
        themeable : true
      },
      /**
       * Vertical alignment of the item in the parent layout.
       *
       * Note: Item alignment is only supported by {@link LayoutItem} layouts where
       * it would have a visual effect. Except for {@link Spacer}, which provides
       * blank space for layouts, all classes that inherit {@link LayoutItem} support alignment.
       */
      alignY : {
        check : [A, D, f, d],
        nullable : true,
        apply : n,
        themeable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        LAYOUT PROCESS
      ---------------------------------------------------------------------------
      */
      /** {Integer} The computed height */
      __computedHeightForWidth : null,
      /** {Map} The computed size of the layout item */
      __computedLayout : null,
      /** {Boolean} Whether the current layout is valid */
      __hasInvalidLayout : null,
      /** {Map} Cached size hint */
      __sizeHint : null,
      /** {Boolean} Whether the margins have changed and must be updated */
      __updateMargin : null,
      /** {Map} user provided bounds of the widget, which override the layout manager */
      __userBounds : null,
      /** {Map} The item's layout properties */
      __layoutProperties : null,
      /**
       * Get the computed location and dimension as computed by
       * the layout manager.
       *
       * @return {Map} The location and dimensions in pixel
       *    (if the layout is valid). Contains the keys
       *    <code>width</code>, <code>height</code>, <code>left</code> and
       *    <code>top</code>.
       */
      getBounds : function(){

        return this.__userBounds || this.__computedLayout || null;
      },
      /**
       * Reconfigure number of separators
       */
      clearSeparators : function(){
      },
      /**
       * Renders a separator between two children
       *
       * @param separator {Decorator} The separator to render
       * @param bounds {Map} Contains the left and top coordinate and the width and height
       *    of the separator to render.
       */
      renderSeparator : function(H, I){
      },
      /**
       * Used by the layout engine to apply coordinates and dimensions.
       *
       * @param left {Integer} Any integer value for the left position,
       *   always in pixels
       * @param top {Integer} Any integer value for the top position,
       *   always in pixels
       * @param width {Integer} Any positive integer value for the width,
       *   always in pixels
       * @param height {Integer} Any positive integer value for the height,
       *   always in pixels
       * @return {Map} A map of which layout sizes changed.
       */
      renderLayout : function(J, top, K, L){

        if(qx.core.Environment.get(k)){

          var M = g + this.toString() + F;
          this.assertInteger(J, e + M);
          this.assertInteger(top, q + M);
          this.assertInteger(K, i + M);
          this.assertInteger(L, r + M);
        };
        // Height for width support
        // Results into a relayout which means that width/height is applied in the next iteration.
        var N = null;
        if(this.getHeight() == null && this._hasHeightForWidth()){

          var N = this._getHeightForWidth(K);
        };
        if(N != null && N !== this.__computedHeightForWidth){

          // This variable is used in the next computation of the size hint
          this.__computedHeightForWidth = N;
          // Re-add to layout queue
          qx.ui.core.queue.Layout.add(this);
          return null;
        };
        // Detect size changes
        // Dynamically create data structure for computed layout
        var P = this.__computedLayout;
        if(!P){

          P = this.__computedLayout = {
          };
        };
        // Detect changes
        var O = {
        };
        if(J !== P.left || top !== P.top){

          O.position = true;
          P.left = J;
          P.top = top;
        };
        if(K !== P.width || L !== P.height){

          O.size = true;
          P.width = K;
          P.height = L;
        };
        // Clear invalidation marker
        if(this.__hasInvalidLayout){

          O.local = true;
          delete this.__hasInvalidLayout;
        };
        if(this.__updateMargin){

          O.margin = true;
          delete this.__updateMargin;
        };
        // Returns changes, especially for deriving classes
        return O;
      },
      /**
       * Whether the item should be excluded from the layout
       *
       * @return {Boolean} Should the item be excluded by the layout
       */
      isExcluded : function(){

        return false;
      },
      /**
       * Whether the layout of this item (to layout the children)
       * is valid.
       *
       * @return {Boolean} Returns <code>true</code>
       */
      hasValidLayout : function(){

        return !this.__hasInvalidLayout;
      },
      /**
       * Indicate that the item has layout changes and propagate this information
       * up the item hierarchy.
       *
       */
      scheduleLayoutUpdate : function(){

        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Called by the layout manager to mark this item's layout as invalid.
       * This function should clear all layout relevant caches.
       */
      invalidateLayoutCache : function(){

        // this.debug("Mark layout invalid!");
        this.__hasInvalidLayout = true;
        this.__sizeHint = null;
      },
      /**
       * A size hint computes the dimensions of a widget. It returns
       * the recommended dimensions as well as the min and max dimensions.
       * The min and max values already respect the stretching properties.
       *
       * <h3>Wording</h3>
       * <ul>
       * <li>User value: Value defined by the widget user, using the size properties</li>
       *
       * <li>Layout value: The value computed by {@link qx.ui.core.Widget#_getContentHint}</li>
       * </ul>
       *
       * <h3>Algorithm</h3>
       * <ul>
       * <li>minSize: If the user min size is not null, the user value is taken,
       *     otherwise the layout value is used.</li>
       *
       * <li>(preferred) size: If the user value is not null the user value is used,
       *     otherwise the layout value is used.</li>
       *
       * <li>max size: Same as the preferred size.</li>
       * </ul>
       *
       * @param compute {Boolean?true} Automatically compute size hint if currently not
       *   cached?
       * @return {Map} The map with the preferred width/height and the allowed
       *   minimum and maximum values in cases where shrinking or growing
       *   is required.
       */
      getSizeHint : function(Q){

        var R = this.__sizeHint;
        if(R){

          return R;
        };
        if(Q === false){

          return null;
        };
        // Compute as defined
        R = this.__sizeHint = this._computeSizeHint();
        // Respect height for width
        if(this._hasHeightForWidth() && this.__computedHeightForWidth && this.getHeight() == null){

          R.height = this.__computedHeightForWidth;
        };
        // normalize width
        if(R.minWidth > R.width){

          R.width = R.minWidth;
        };
        if(R.maxWidth < R.width){

          R.width = R.maxWidth;
        };
        if(!this.getAllowGrowX()){

          R.maxWidth = R.width;
        };
        if(!this.getAllowShrinkX()){

          R.minWidth = R.width;
        };
        // normalize height
        if(R.minHeight > R.height){

          R.height = R.minHeight;
        };
        if(R.maxHeight < R.height){

          R.height = R.maxHeight;
        };
        if(!this.getAllowGrowY()){

          R.maxHeight = R.height;
        };
        if(!this.getAllowShrinkY()){

          R.minHeight = R.height;
        };
        // Finally return
        return R;
      },
      /**
       * Computes the size hint of the layout item.
       *
       * @return The map with the preferred width/height and the allowed
       *   minimum and maximum values.
       */
      _computeSizeHint : function(){

        var W = this.getMinWidth() || 0;
        var T = this.getMinHeight() || 0;
        var X = this.getWidth() || W;
        var V = this.getHeight() || T;
        var S = this.getMaxWidth() || Infinity;
        var U = this.getMaxHeight() || Infinity;
        return {
          minWidth : W,
          width : X,
          maxWidth : S,
          minHeight : T,
          height : V,
          maxHeight : U
        };
      },
      /**
       * Whether the item supports height for width.
       *
       * @return {Boolean} Whether the item supports height for width
       */
      _hasHeightForWidth : function(){

        var Y = this._getLayout();
        if(Y){

          return Y.hasHeightForWidth();
        };
        return false;
      },
      /**
       * If an item wants to trade height for width it has to implement this
       * method and return the preferred height of the item if it is resized to
       * the given width. This function returns <code>null</code> if the item
       * do not support height for width.
       *
       * @param width {Integer} The computed width
       * @return {Integer} The desired height
       */
      _getHeightForWidth : function(ba){

        var bb = this._getLayout();
        if(bb && bb.hasHeightForWidth()){

          return bb.getHeightForWidth(ba);
        };
        return null;
      },
      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      _getLayout : function(){

        return null;
      },
      // property apply
      _applyMargin : function(){

        this.__updateMargin = true;
        var parent = this.$$parent;
        if(parent){

          parent.updateLayoutProperties();
        };
      },
      // property apply
      _applyAlign : function(){

        var parent = this.$$parent;
        if(parent){

          parent.updateLayoutProperties();
        };
      },
      // property apply
      _applyDimension : function(){

        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyStretching : function(){

        qx.ui.core.queue.Layout.add(this);
      },
      /*
      ---------------------------------------------------------------------------
        SUPPORT FOR USER BOUNDARIES
      ---------------------------------------------------------------------------
      */
      /**
       * Whether user bounds are set on this layout item
       *
       * @return {Boolean} Whether user bounds are set on this layout item
       */
      hasUserBounds : function(){

        return !!this.__userBounds;
      },
      /**
       * Set user bounds of the widget. Widgets with user bounds are sized and
       * positioned manually and are ignored by any layout manager.
       *
       * @param left {Integer} left position (relative to the parent)
       * @param top {Integer} top position (relative to the parent)
       * @param width {Integer} width of the layout item
       * @param height {Integer} height of the layout item
       * @return {void}
       */
      setUserBounds : function(bc, top, bd, be){

        this.__userBounds = {
          left : bc,
          top : top,
          width : bd,
          height : be
        };
        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Clear the user bounds. After this call the layout item is laid out by
       * the layout manager again.
       *
       * @return {void}
       */
      resetUserBounds : function(){

        delete this.__userBounds;
        qx.ui.core.queue.Layout.add(this);
      },
      /*
      ---------------------------------------------------------------------------
        LAYOUT PROPERTIES
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} Empty storage pool
       *
       * @lint ignoreReferenceField(__emptyProperties)
       */
      __emptyProperties : {
      },
      /**
       * Stores the given layout properties
       *
       * @param props {Map} Incoming layout property data
       * @return {void}
       */
      setLayoutProperties : function(bf){

        if(bf == null){

          return;
        };
        var bg = this.__layoutProperties;
        if(!bg){

          bg = this.__layoutProperties = {
          };
        };
        // Check values through parent
        var parent = this.getLayoutParent();
        if(parent){

          parent.updateLayoutProperties(bf);
        };
        // Copy over values
        for(var bh in bf){

          if(bf[bh] == null){

            delete bg[bh];
          } else {

            bg[bh] = bf[bh];
          };
        };
      },
      /**
       * Returns currently stored layout properties
       *
       * @return {Map} Returns a map of layout properties
       */
      getLayoutProperties : function(){

        return this.__layoutProperties || this.__emptyProperties;
      },
      /**
       * Removes all stored layout properties.
       *
       * @return {void}
       */
      clearLayoutProperties : function(){

        delete this.__layoutProperties;
      },
      /**
       * Should be executed on every change of layout properties.
       *
       * This also includes "virtual" layout properties like margin or align
       * when they have an effect on the parent and not on the widget itself.
       *
       * This method is always executed on the parent not on the
       * modified widget itself.
       *
       * @param props {Map?null} Optional map of known layout properties
       * @return {void}
       */
      updateLayoutProperties : function(bi){

        var bj = this._getLayout();
        if(bj){

          // Verify values through underlying layout
          if(qx.core.Environment.get(k)){

            if(bi){

              for(var bk in bi){

                if(bi[bk] !== null){

                  bj.verifyLayoutProperty(this, bk, bi[bk]);
                };
              };
            };
          };
          // Precomputed and cached children data need to be
          // rebuild on upcoming (re-)layout.
          bj.invalidateChildrenCache();
        };
        qx.ui.core.queue.Layout.add(this);
      },
      /*
      ---------------------------------------------------------------------------
        HIERARCHY SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the application root
       *
       * @return {qx.ui.root.Abstract} The currently used root
       */
      getApplicationRoot : function(){

        return qx.core.Init.getApplication().getRoot();
      },
      /**
       * Get the items parent. Even if the item has been added to a
       * layout, the parent is always a child of the containing item. The parent
       * item may be <code>null</code>.
       *
       * @return {qx.ui.core.Widget|null} The parent.
       */
      getLayoutParent : function(){

        return this.$$parent || null;
      },
      /**
       * Set the parent
       *
       * @param parent {qx.ui.core.Widget|null} The new parent.
       */
      setLayoutParent : function(parent){

        if(this.$$parent === parent){

          return;
        };
        this.$$parent = parent || null;
        qx.ui.core.queue.Visibility.add(this);
      },
      /**
       * Whether the item is a root item and directly connected to
       * the DOM.
       *
       * @return {Boolean} Whether the item a root item
       */
      isRootWidget : function(){

        return false;
      },
      /**
       * Returns the root item. The root item is the item which
       * is directly inserted into an existing DOM node at HTML level.
       * This is often the BODY element of a typical web page.
       *
       * @return {qx.ui.core.Widget} The root item (if available)
       */
      _getRoot : function(){

        var parent = this;
        while(parent){

          if(parent.isRootWidget()){

            return parent;
          };
          parent = parent.$$parent;
        };
        return null;
      },
      /*
      ---------------------------------------------------------------------------
        CLONE SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      clone : function(){

        var bl = qx.core.Object.prototype.clone.call(this);
        var bm = this.__layoutProperties;
        if(bm){

          bl.__layoutProperties = qx.lang.Object.clone(bm);
        };
        return bl;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.$$parent = this.$$subparent = this.__layoutProperties = this.__computedLayout = this.__userBounds = this.__sizeHint = null;
    }
  });
})();
(function(){

  var b = "qx.ui.core.queue.Layout",a = "layout";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The layout queue manages all widgets, which need a recalculation of their
   * layout. The {@link #flush} method computes the layout of all queued widgets
   * and their dependent widgets.
   */
  qx.Class.define(b, {
    statics : {
      /** {Map} This contains all the queued widgets for the next flush. */
      __queue : {
      },
      /**
       * Clears the widget from the internal queue. Normally only used
       * during interims disposes of one or a few widgets.
       *
       * @param widget {qx.ui.core.Widget} The widget to clear
       */
      remove : function(c){

        delete this.__queue[c.$$hash];
      },
      /**
       * Mark a widget's layout as invalid and add its layout root to
       * the queue.
       *
       * Should only be used by {@link qx.ui.core.Widget}.
       *
       * @param widget {qx.ui.core.Widget} Widget to add.
       * @return {void}
       */
      add : function(d){

        this.__queue[d.$$hash] = d;
        qx.ui.core.queue.Manager.scheduleFlush(a);
      },
      /**
      * Check whether the queue has scheduled changes for a widget.
      * Note that the layout parent can have changes scheduled that
      * affect the children widgets.
      *
      * @param widget {qx.ui.core.Widget} Widget to check.
      * @return {Boolean} Whether the widget given has layout changes queued.
      */
      isScheduled : function(e){

        return !!this.__queue[e.$$hash];
      },
      /**
       * Update the layout of all widgets, which layout is marked as invalid.
       *
       * This is used exclusively by the {@link qx.ui.core.queue.Manager}.
       *
       * @return {void}
       */
      flush : function(){

        // get sorted widgets to (re-)layout
        var f = this.__getSortedQueue();
        // iterate in reversed order to process widgets with the smallest nesting
        // level first because these may affect the inner lying children
        for(var i = f.length - 1;i >= 0;i--){

          var g = f[i];
          // continue if a relayout of one of the root's parents has made the
          // layout valid
          if(g.hasValidLayout()){

            continue;
          };
          // overflow areas or qx.ui.root.*
          if(g.isRootWidget() && !g.hasUserBounds()){

            // This is a real root widget. Set its size to its preferred size.
            var j = g.getSizeHint();
            g.renderLayout(0, 0, j.width, j.height);
          } else {

            // This is an inner item of layout changes. Do a relayout of its
            // children without changing its position and size.
            var h = g.getBounds();
            g.renderLayout(h.left, h.top, h.width, h.height);
          };
        };
      },
      /**
       * Get the widget's nesting level. Top level widgets have a nesting level
       * of <code>0</code>.
       *
       * @param widget {qx.ui.core.Widget} The widget to query.
       * @return {Integer} The nesting level
       */
      getNestingLevel : function(k){

        var l = this.__nesting;
        var n = 0;
        var parent = k;
        // Detecting level
        while(true){

          if(l[parent.$$hash] != null){

            n += l[parent.$$hash];
            break;
          };
          if(!parent.$$parent){

            break;
          };
          parent = parent.$$parent;
          n += 1;
        };
        // Update the processed hierarchy (runs from inner to outer)
        var m = n;
        while(k && k !== parent){

          l[k.$$hash] = m--;
          k = k.$$parent;
        };
        return n;
      },
      /**
       * Group widget by their nesting level.
       *
       * @return {Map[]} A sparse array. Each entry of the array contains a widget
       *     map with all widgets of the same level as the array index.
       */
      __getLevelGroupedWidgets : function(){

        var t = qx.ui.core.queue.Visibility;
        // clear cache
        this.__nesting = {
        };
        // sparse level array
        var s = [];
        var r = this.__queue;
        var o,q;
        for(var p in r){

          o = r[p];
          if(t.isVisible(o)){

            q = this.getNestingLevel(o);
            // create hierarchy
            if(!s[q]){

              s[q] = {
              };
            };
            // store widget in level map
            s[q][p] = o;
            // remove widget from layout queue
            delete r[p];
          };
        };
        return s;
      },
      /**
       * Compute all layout roots of the given widgets. Layout roots are either
       * root widgets or widgets, which preferred size has not changed by the
       * layout changes of its children.
       *
       * This function returns the roots ordered by their nesting factors. The
       * layout with the largest nesting level comes first.
       *
       * @return {qx.ui.core.Widget[]} Ordered list or layout roots.
       */
      __getSortedQueue : function(){

        var x = [];
        var z = this.__getLevelGroupedWidgets();
        for(var w = z.length - 1;w >= 0;w--){

          // Ignore empty levels (levels is an sparse array)
          if(!z[w]){

            continue;
          };
          for(var v in z[w]){

            var u = z[w][v];
            // This is a real layout root. Add it directly to the list
            if(w == 0 || u.isRootWidget() || u.hasUserBounds()){

              x.push(u);
              u.invalidateLayoutCache();
              continue;
            };
            // compare old size hint to new size hint
            var B = u.getSizeHint(false);
            if(B){

              u.invalidateLayoutCache();
              var y = u.getSizeHint();
              var A = (!u.getBounds() || B.minWidth !== y.minWidth || B.width !== y.width || B.maxWidth !== y.maxWidth || B.minHeight !== y.minHeight || B.height !== y.height || B.maxHeight !== y.maxHeight);
            } else {

              A = true;
            };
            if(A){

              // Since the level is > 0, the widget must
              // have a parent != null.
              var parent = u.getLayoutParent();
              if(!z[w - 1]){

                z[w - 1] = {
                };
              };
              z[w - 1][parent.$$hash] = parent;
            } else {

              // this is an internal layout root since its own preferred size
              // has not changed.
              x.push(u);
            };
          };
        };
        return x;
      }
    }
  });
})();
(function(){

  var b = "qx.util.DeferredCallManager",a = "singleton";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This class manages the timer used for deferred calls. All
   * {@link qx.util.DeferredCall} instances use the single timer from this class.
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    type : a,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      this.__calls = {
      };
      this.__timeoutWrapper = qx.lang.Function.bind(this.__timeout, this);
      this.__hasCalls = false;
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __timeoutId : null,
      __currentQueue : null,
      __calls : null,
      __hasCalls : null,
      __timeoutWrapper : null,
      /**
       * Schedule a deferred call
       *
       * @param deferredCall {qx.util.DeferredCall} The call to schedule
       */
      schedule : function(c){

        if(this.__timeoutId == null){

          this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);
        };
        var d = c.toHashCode();
        // the flush is currently running and the call is already
        // scheduled
        if(this.__currentQueue && this.__currentQueue[d]){

          return;
        };
        this.__calls[d] = c;
        this.__hasCalls = true;
      },
      /**
       * Cancel a scheduled deferred call
       *
       * @param deferredCall {qx.util.DeferredCall} The call to schedule
       */
      cancel : function(e){

        var f = e.toHashCode();
        // the flush is currently running and the call is already
        // scheduled -> remove it from the current queue
        if(this.__currentQueue && this.__currentQueue[f]){

          this.__currentQueue[f] = null;
          return;
        };
        delete this.__calls[f];
        // stop timer if no other calls are waiting
        if(qx.lang.Object.isEmpty(this.__calls) && this.__timeoutId != null){

          window.clearTimeout(this.__timeoutId);
          this.__timeoutId = null;
        };
      },
      /**
       * Helper function for the timer.
       *
       * @signature function()
       */
      __timeout : qx.event.GlobalError.observeMethod(function(){

        this.__timeoutId = null;
        // the queue may change while doing the flush so we work on a copy of
        // the queue and loop while the queue has any entries.
        while(this.__hasCalls){

          this.__currentQueue = qx.lang.Object.clone(this.__calls);
          this.__calls = {
          };
          this.__hasCalls = false;
          for(var h in this.__currentQueue){

            var g = this.__currentQueue[h];
            if(g){

              this.__currentQueue[h] = null;
              g.call();
            };
          };
        };
        this.__currentQueue = null;
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__timeoutId != null){

        window.clearTimeout(this.__timeoutId);
      };
      this.__timeoutWrapper = this.__calls = null;
    }
  });
})();
(function(){

  var e = "qx.util.DeferredCall",d = "The context object '",c = "qx.debug",b = "'is already disposed.",a = "' of the defered call '";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.util.DeferredCallManager)
  
  ************************************************************************ */
  /**
   * This class represents a wrapper for functions, which should be called after
   * the current thread of JavaScript has finished and the control is returned to
   * the browser. The wrapped function will at most be called once after the control
   * has been given back to the browser, independent of the number of {@link #call}
   * calls.
   */
  qx.Class.define(e, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param callback {Function} The callback
     * @param context {Object?window} the context in which the function will be called.
     */
    construct : function(f, g){

      qx.core.Object.call(this);
      this.__callback = f;
      this.__context = g || null;
      this.__manager = qx.util.DeferredCallManager.getInstance();
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __callback : null,
      __context : null,
      __manager : null,
      /**
       * Prevent the callback from being called.
       */
      cancel : function(){

        this.__manager.cancel(this);
      },
      /**
       * Issue a deferred call of the callback.
       */
      schedule : function(){

        this.__manager.schedule(this);
      },
      /**
       * Calls the callback directly.
       */
      call : function(){

        if(qx.core.Environment.get(c)){

          // warn if the context is disposed
          var h = this.__context;
          if(h && h.isDisposed && h.isDisposed()){

            this.warn(d + h + a + this + b);
          };
        };
        this.__context ? this.__callback.apply(this.__context) : this.__callback();
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.cancel();
      this.__context = this.__callback = this.__manager = null;
    }
  });
})();
(function(){

  var m = "Child is already in: ",k = "text",j = "|bubble|",h = "qx.html.Element",g = "|capture|",f = "focus",d = "Failed to add event listener for type '",c = "Flushing elements...",b = "blur",a = "Flush: ",bh = "deactivate",bg = "css.userselect",bf = "Synced DOM with ",be = " from the target '",bd = "capture",bc = "visible",bb = "Root elements could not be inserted into other ones.",ba = "Has no children!",Y = "off",X = "releaseCapture",t = "Could not move to same index!",u = "Flush invisible element",r = "Failed to remove event listener for type '",s = "qxSelectable",p = "tabIndex",q = "Has no child at this position!",n = "qx.html.Iframe",o = "activate",z = "Has no parent to remove from.",A = " to the target '",I = " operations",G = "Flush rendered element",P = "none",K = "css.userselect.none",T = "hidden",R = "__children",C = "on",W = "Switching visibility to: ",V = "id",U = "': ",B = "scroll",E = "Invalid capture flag.",F = "div",H = "'",J = "Invalid callback function",L = "Invalid context for callback.",Q = "",S = "Invalid event type.",v = "mshtml",w = "engine.name",D = "Has no child: ",O = "Could not overwrite existing element!",N = "qx.debug",M = "element";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * High-performance, high-level DOM element creation and management.
   *
   * Includes support for HTML and style attributes. Elements also have
   * got a powerful children and visibility management.
   *
   * Processes DOM insertion and modification with advanced logic
   * to reduce the real transactions.
   *
   * From the view of the parent you can use the following children management
   * methods:
   * {@link #getChildren}, {@link #indexOf}, {@link #hasChild}, {@link #add},
   * {@link #addAt}, {@link #remove}, {@link #removeAt}, {@link #removeAll}
   *
   * Each child itself also has got some powerful methods to control its
   * position:
   * {@link #getParent}, {@link #free},
   * {@link #insertInto}, {@link #insertBefore}, {@link #insertAfter},
   * {@link #moveTo}, {@link #moveBefore}, {@link #moveAfter},
   */
  qx.Class.define(h, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Creates a new Element
     *
     * @param tagName {String?"div"} Tag name of the element to create
     * @param styles {Map?null} optional map of CSS styles, where the key is the name
     *    of the style and the value is the value to use.
     * @param attributes {Map?null} optional map of element attributes, where the
     *    key is the name of the attribute and the value is the value to use.
     */
    construct : function(bi, bj, bk){

      qx.core.Object.call(this);
      // {String} Set tag name
      this.__nodeName = bi || F;
      this.__styleValues = bj || null;
      this.__attribValues = bk || null;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /*
      ---------------------------------------------------------------------------
        STATIC DATA
      ---------------------------------------------------------------------------
      */
      /** {Boolean} If debugging should be enabled */
      DEBUG : false,
      /** {Map} Contains the modified {@link qx.html.Element}s. The key is the hash code. */
      _modified : {
      },
      /** {Map} Contains the {@link qx.html.Element}s which should get hidden or visible at the next flush. The key is the hash code. */
      _visibility : {
      },
      /** {Map} Contains the {@link qx.html.Element}s which should scrolled at the next flush */
      _scroll : {
      },
      /** {Array} List of post actions for elements. The key is the action name. The value the {@link qx.html.Element}. */
      _actions : [],
      /**  {Map} List of all selections. */
      __selection : {
      },
      /*
      ---------------------------------------------------------------------------
        PUBLIC ELEMENT FLUSH
      ---------------------------------------------------------------------------
      */
      /**
       * Schedule a deferred element queue flush. If the widget subsystem is used
       * this method gets overwritten by {@link qx.ui.core.queue.Manager}.
       *
       * @param job {String} The job descriptor. Should always be <code>"element"</code>.
       */
      _scheduleFlush : function(bl){

        qx.html.Element.__deferredCall.schedule();
      },
      /**
       * Flush the global modified list
       */
      flush : function(){

        var bw;
        if(qx.core.Environment.get(N)){

          if(this.DEBUG){

            qx.log.Logger.debug(this, c);
          };
        };
        // blur elements, which will be removed
        var bo = this.__getFocusHandler();
        var bn = bo.getFocus();
        if(bn && this.__willBecomeInvisible(bn)){

          bo.blur(bn);
        };
        // decativate elements, which will be removed
        var bD = bo.getActive();
        if(bD && this.__willBecomeInvisible(bD)){

          qx.bom.Element.deactivate(bD);
        };
        // release capture for elements, which will be removed
        var br = this.__getCaptureElement();
        if(br && this.__willBecomeInvisible(br)){

          qx.bom.Element.releaseCapture(br);
        };
        var bx = [];
        var by = this._modified;
        for(var bv in by){

          bw = by[bv];
          // Ignore all hidden elements except iframes
          // but keep them until they get visible (again)
          if(bw.__willBeSeeable() || bw.classname == n){

            // Separately queue rendered elements
            if(bw.__element && qx.dom.Hierarchy.isRendered(bw.__element)){

              bx.push(bw);
            } else {

              if(qx.core.Environment.get(N)){

                if(this.DEBUG){

                  bw.debug(u);
                };
              };
              bw.__flush();
            };
            // Cleanup modification list
            delete by[bv];
          };
        };
        for(var i = 0,l = bx.length;i < l;i++){

          bw = bx[i];
          if(qx.core.Environment.get(N)){

            if(this.DEBUG){

              bw.debug(G);
            };
          };
          bw.__flush();
        };
        // Process visibility list
        var bt = this._visibility;
        for(var bv in bt){

          bw = bt[bv];
          var bz = bw.__element;
          if(!bz){

            delete bt[bv];
            continue;
          };
          if(qx.core.Environment.get(N)){

            if(this.DEBUG){

              qx.log.Logger.debug(this, W + bw.__visible);
            };
          };
          // hiding or showind an object and deleting it right after that may
          // cause an disposed object in the visibility queue [BUG #3607]
          if(!bw.$$disposed){

            bz.style.display = bw.__visible ? Q : P;
            // also hide the element (fixed some rendering problem in IE<8 & IE8 quirks)
            if((qx.core.Environment.get(w) == v)){

              if(!(document.documentMode >= 8)){

                bz.style.visibility = bw.__visible ? bc : T;
              };
            };
          };
          delete bt[bv];
        };
        // Process scroll list
        var scroll = this._scroll;
        for(var bv in scroll){

          bw = scroll[bv];
          var bE = bw.__element;
          if(bE && bE.offsetWidth){

            var bq = true;
            // ScrollToX
            if(bw.__lazyScrollX != null){

              bw.__element.scrollLeft = bw.__lazyScrollX;
              delete bw.__lazyScrollX;
            };
            // ScrollToY
            if(bw.__lazyScrollY != null){

              bw.__element.scrollTop = bw.__lazyScrollY;
              delete bw.__lazyScrollY;
            };
            // ScrollIntoViewX
            var bA = bw.__lazyScrollIntoViewX;
            if(bA != null){

              var bu = bA.element.getDomElement();
              if(bu && bu.offsetWidth){

                qx.bom.element.Scroll.intoViewX(bu, bE, bA.align);
                delete bw.__lazyScrollIntoViewX;
              } else {

                bq = false;
              };
            };
            // ScrollIntoViewY
            var bB = bw.__lazyScrollIntoViewY;
            if(bB != null){

              var bu = bB.element.getDomElement();
              if(bu && bu.offsetWidth){

                qx.bom.element.Scroll.intoViewY(bu, bE, bB.align);
                delete bw.__lazyScrollIntoViewY;
              } else {

                bq = false;
              };
            };
            // Clear flag if all things are done
            // Otherwise wait for the next flush
            if(bq){

              delete scroll[bv];
            };
          };
        };
        var bp = {
          "releaseCapture" : 1,
          "blur" : 1,
          "deactivate" : 1
        };
        // Process action list
        for(var i = 0;i < this._actions.length;i++){

          var bC = this._actions[i];
          var bz = bC.element.__element;
          if(!bz || !bp[bC.type] && !bC.element.__willBeSeeable()){

            continue;
          };
          var bs = bC.args;
          bs.unshift(bz);
          qx.bom.Element[bC.type].apply(qx.bom.Element, bs);
        };
        this._actions = [];
        // Process selection
        for(var bv in this.__selection){

          var bm = this.__selection[bv];
          var bE = bm.element.__element;
          if(bE){

            qx.bom.Selection.set(bE, bm.start, bm.end);
            delete this.__selection[bv];
          };
        };
        // Fire appear/disappear events
        qx.event.handler.Appear.refresh();
      },
      /**
       * Get the focus handler
       *
       * @return {qx.event.handler.Focus} The focus handler
       */
      __getFocusHandler : function(){

        if(!this.__focusHandler){

          var bF = qx.event.Registration.getManager(window);
          this.__focusHandler = bF.getHandler(qx.event.handler.Focus);
        };
        return this.__focusHandler;
      },
      /**
       * Get the mouse capture element
       *
       * @return {Element} The mouse capture DOM element
       */
      __getCaptureElement : function(){

        if(!this.__mouseCapture){

          var bG = qx.event.Registration.getManager(window);
          this.__mouseCapture = bG.getDispatcher(qx.event.dispatch.MouseCapture);
        };
        return this.__mouseCapture.getCaptureElement();
      },
      /**
       * Whether the given DOM element will become invisible after the flush
       *
       * @param domElement {Element} The DOM element to check
       * @return {Boolean} Whether the element will become invisible
       */
      __willBecomeInvisible : function(bH){

        var bI = qx.core.ObjectRegistry.fromHashCode(bH.$$element);
        return bI && !bI.__willBeSeeable();
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        PROTECTED HELPERS/DATA
      ---------------------------------------------------------------------------
      */
      __nodeName : null,
      /** {Element} DOM element of this object */
      __element : null,
      /** {Boolean} Marker for always visible root nodes (often the body node) */
      __root : false,
      /** {Boolean} Whether the element should be included in the render result */
      __included : true,
      /** {Boolean} Whether the element should be visible in the render result */
      __visible : true,
      __lazyScrollIntoViewX : null,
      __lazyScrollIntoViewY : null,
      __lazyScrollX : null,
      __lazyScrollY : null,
      __styleJobs : null,
      __attribJobs : null,
      __propertyJobs : null,
      __styleValues : null,
      __attribValues : null,
      __propertyValues : null,
      __eventValues : null,
      __children : null,
      __modifiedChildren : null,
      __parent : null,
      /**
       * Add the element to the global modification list.
       *
       * @return {void}
       */
      _scheduleChildrenUpdate : function(){

        if(this.__modifiedChildren){

          return;
        };
        this.__modifiedChildren = true;
        qx.html.Element._modified[this.$$hash] = this;
        qx.html.Element._scheduleFlush(M);
      },
      /**
       * Internal helper to generate the DOM element
       *
       */
      _createDomElement : function(){

        return qx.dom.Element.create(this.__nodeName);
      },
      /*
      ---------------------------------------------------------------------------
        FLUSH OBJECT
      ---------------------------------------------------------------------------
      */
      /**
       * Syncs data of an HtmlElement object to the DOM.
       *
       * @return {void}
       */
      __flush : function(){

        if(qx.core.Environment.get(N)){

          if(this.DEBUG){

            this.debug(a + this.getAttribute(V));
          };
        };
        var length;
        var bJ = this.__children;
        if(bJ){

          length = bJ.length;
          var bK;
          for(var i = 0;i < length;i++){

            bK = bJ[i];
            if(bK.__visible && bK.__included && !bK.__element){

              bK.__flush();
            };
          };
        };
        if(!this.__element){

          this.__element = this._createDomElement();
          this.__element.$$element = this.$$hash;
          this._copyData(false);
          if(bJ && length > 0){

            this._insertChildren();
          };
        } else {

          this._syncData();
          if(this.__modifiedChildren){

            this._syncChildren();
          };
        };
        delete this.__modifiedChildren;
      },
      /*
      ---------------------------------------------------------------------------
        SUPPORT FOR CHILDREN FLUSH
      ---------------------------------------------------------------------------
      */
      /**
       * Append all child nodes to the DOM
       * element. This function is used when the element is initially
       * created. After this initial apply {@link #_syncChildren} is used
       * instead.
       *
       * @return {void}
       */
      _insertChildren : function(){

        var bL = this.__children;
        var length = bL.length;
        var bN;
        if(length > 2){

          var bM = document.createDocumentFragment();
          for(var i = 0;i < length;i++){

            bN = bL[i];
            if(bN.__element && bN.__included){

              bM.appendChild(bN.__element);
            };
          };
          this.__element.appendChild(bM);
        } else {

          var bM = this.__element;
          for(var i = 0;i < length;i++){

            bN = bL[i];
            if(bN.__element && bN.__included){

              bM.appendChild(bN.__element);
            };
          };
        };
      },
      /**
       * Syncronize internal children hierarchy to the DOM. This is used
       * for further runtime updates after the element has been created
       * initially.
       *
       * @return {void}
       */
      _syncChildren : function(){

        var bX = qx.core.ObjectRegistry;
        var bO = this.__children;
        var bV = bO.length;
        var bP;
        var bT;
        var bR = this.__element;
        var bU = bR.childNodes;
        var bQ = 0;
        var bS;
        if(qx.core.Environment.get(N)){

          var bW = 0;
        };
        // Remove children from DOM which are excluded or remove first
        for(var i = bU.length - 1;i >= 0;i--){

          bS = bU[i];
          bT = bX.fromHashCode(bS.$$element);
          if(!bT || !bT.__included || bT.__parent !== this){

            bR.removeChild(bS);
            if(qx.core.Environment.get(N)){

              bW++;
            };
          };
        };
        // Start from beginning and bring DOM in sync
        // with the data structure
        for(var i = 0;i < bV;i++){

          bP = bO[i];
          // Only process visible childs
          if(bP.__included){

            bT = bP.__element;
            bS = bU[bQ];
            if(!bT){

              continue;
            };
            // Only do something when out of sync
            // If the data element is not there it may mean that it is still
            // marked as visible=false
            if(bT != bS){

              if(bS){

                bR.insertBefore(bT, bS);
              } else {

                bR.appendChild(bT);
              };
              if(qx.core.Environment.get(N)){

                bW++;
              };
            };
            // Increase counter
            bQ++;
          };
        };
        // User feedback
        if(qx.core.Environment.get(N)){

          if(qx.html.Element.DEBUG){

            this.debug(bf + bW + I);
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        SUPPORT FOR ATTRIBUTE/STYLE/EVENT FLUSH
      ---------------------------------------------------------------------------
      */
      /**
       * Copies data between the internal representation and the DOM. This
       * simply copies all the data and only works well directly after
       * element creation. After this the data must be synced using {@link #_syncData}
       *
       * @param fromMarkup {Boolean} Whether the copy should respect styles
       *   given from markup
       * @return {void}
       */
      _copyData : function(bY){

        var cd = this.__element;
        // Copy attributes
        var cc = this.__attribValues;
        if(cc){

          var ca = qx.bom.element.Attribute;
          for(var ce in cc){

            ca.set(cd, ce, cc[ce]);
          };
        };
        // Copy styles
        var cc = this.__styleValues;
        if(cc){

          var cb = qx.bom.element.Style;
          if(bY){

            cb.setStyles(cd, cc);
          } else {

            // Set styles at once which is a lot faster in most browsers
            // compared to separate modifications of many single style properties.
            cb.setCss(cd, cb.compile(cc));
          };
        };
        // Copy properties
        var cc = this.__propertyValues;
        if(cc){

          for(var ce in cc){

            this._applyProperty(ce, cc[ce]);
          };
        };
        // Attach events
        var cc = this.__eventValues;
        if(cc){

          // Import listeners
          qx.event.Registration.getManager(cd).importListeners(cd, cc);
          // Cleanup event map
          // Events are directly attached through event manager
          // after initial creation. This differs from the
          // handling of styles and attributes where queuing happens
          // through the complete runtime of the application.
          delete this.__eventValues;
        };
      },
      /**
       * Syncronizes data between the internal representation and the DOM. This
       * is the counterpart of {@link #_copyData} and is used for further updates
       * after the element has been created.
       *
       * @return {void}
       */
      _syncData : function(){

        var cj = this.__element;
        var ci = qx.bom.element.Attribute;
        var cg = qx.bom.element.Style;
        // Sync attributes
        var ch = this.__attribJobs;
        if(ch){

          var cm = this.__attribValues;
          if(cm){

            var ck;
            for(var cl in ch){

              ck = cm[cl];
              if(ck !== undefined){

                ci.set(cj, cl, ck);
              } else {

                ci.reset(cj, cl);
              };
            };
          };
          this.__attribJobs = null;
        };
        // Sync styles
        var ch = this.__styleJobs;
        if(ch){

          var cm = this.__styleValues;
          if(cm){

            var cf = {
            };
            for(var cl in ch){

              cf[cl] = cm[cl];
            };
            cg.setStyles(cj, cf);
          };
          this.__styleJobs = null;
        };
        // Sync misc
        var ch = this.__propertyJobs;
        if(ch){

          var cm = this.__propertyValues;
          if(cm){

            var ck;
            for(var cl in ch){

              this._applyProperty(cl, cm[cl]);
            };
          };
          this.__propertyJobs = null;
        };
      },
      /*
      ---------------------------------------------------------------------------
        PRIVATE HELPERS/DATA
      ---------------------------------------------------------------------------
      */
      /**
       * Walk up the internal children hierarchy and
       * look if one of the children is marked as root.
       *
       * This method is quite performance hungry as it
       * really walks up recursively.
       */
      __willBeSeeable : function(){

        var cn = this;
        // Any chance to cache this information in the parents?
        while(cn){

          if(cn.__root){

            return true;
          };
          if(!cn.__included || !cn.__visible){

            return false;
          };
          cn = cn.__parent;
        };
        return false;
      },
      /**
       * Internal helper for all children addition needs
       *
       * @param child {var} the element to add
       * @throws an exception if the given element is already a child
       *     of this element
       */
      __addChildHelper : function(co){

        if(co.__parent === this){

          throw new Error(m + co);
        };
        if(co.__root){

          throw new Error(bb);
        };
        // Remove from previous parent
        if(co.__parent){

          co.__parent.remove(co);
        };
        // Convert to child of this object
        co.__parent = this;
        // Prepare array
        if(!this.__children){

          this.__children = [];
        };
        // Schedule children update
        if(this.__element){

          this._scheduleChildrenUpdate();
        };
      },
      /**
       * Internal helper for all children removal needs
       *
       * @param child {qx.html.Element} the removed element
       * @throws an exception if the given element is not a child
       *     of this element
       */
      __removeChildHelper : function(cp){

        if(cp.__parent !== this){

          throw new Error(D + cp);
        };
        // Schedule children update
        if(this.__element){

          this._scheduleChildrenUpdate();
        };
        // Remove reference to old parent
        delete cp.__parent;
      },
      /**
       * Internal helper for all children move needs
       *
       * @param child {qx.html.Element} the moved element
       * @throws an exception if the given element is not a child
       *     of this element
       */
      __moveChildHelper : function(cq){

        if(cq.__parent !== this){

          throw new Error(D + cq);
        };
        // Schedule children update
        if(this.__element){

          this._scheduleChildrenUpdate();
        };
      },
      /*
      ---------------------------------------------------------------------------
        CHILDREN MANAGEMENT (EXECUTED ON THE PARENT)
      ---------------------------------------------------------------------------
      */
      /**
       * Returns a copy of the internal children structure.
       *
       * Please do not modify the array in place. If you need
       * to work with the data in such a way make yourself
       * a copy of the data first.
       *
       * @return {Array} the children list
       */
      getChildren : function(){

        return this.__children || null;
      },
      /**
       * Get a child element at the given index
       *
       * @param index {Integer} child index
       * @return {qx.html.Element|null} The child element or <code>null</code> if
       *     no child is found at that index.
       */
      getChild : function(cr){

        var cs = this.__children;
        return cs && cs[cr] || null;
      },
      /**
       * Returns whether the element has any child nodes
       *
       * @return {Boolean} Whether the element has any child nodes
       */
      hasChildren : function(){

        var ct = this.__children;
        return ct && ct[0] !== undefined;
      },
      /**
       * Find the position of the given child
       *
       * @param child {qx.html.Element} the child
       * @return {Integer} returns the position. If the element
       *     is not a child <code>-1</code> will be returned.
       */
      indexOf : function(cu){

        var cv = this.__children;
        return cv ? cv.indexOf(cu) : -1;
      },
      /**
       * Whether the given element is a child of this element.
       *
       * @param child {qx.html.Element} the child
       * @return {Boolean} Returns <code>true</code> when the given
       *    element is a child of this element.
       */
      hasChild : function(cw){

        var cx = this.__children;
        return cx && cx.indexOf(cw) !== -1;
      },
      /**
       * Append all given children at the end of this element.
       *
       * @param varargs {qx.html.Element...} elements to insert
       * @return {qx.html.Element} this object (for chaining support)
       */
      add : function(cy){

        if(arguments[1]){

          for(var i = 0,l = arguments.length;i < l;i++){

            this.__addChildHelper(arguments[i]);
          };
          this.__children.push.apply(this.__children, arguments);
        } else {

          this.__addChildHelper(cy);
          this.__children.push(cy);
        };
        // Chaining support
        return this;
      },
      /**
       * Inserts a new element into this element at the given position.
       *
       * @param child {qx.html.Element} the element to insert
       * @param index {Integer} the index (starts at 0 for the
       *     first child) to insert (the index of the following
       *     children will be increased by one)
       * @return {qx.html.Element} this object (for chaining support)
       */
      addAt : function(cz, cA){

        this.__addChildHelper(cz);
        qx.lang.Array.insertAt(this.__children, cz, cA);
        // Chaining support
        return this;
      },
      /**
       * Removes all given children
       *
       * @param childs {qx.html.Element...} children to remove
       * @return {qx.html.Element} this object (for chaining support)
       */
      remove : function(cB){

        var cC = this.__children;
        if(!cC){

          return;
        };
        if(arguments[1]){

          var cD;
          for(var i = 0,l = arguments.length;i < l;i++){

            cD = arguments[i];
            this.__removeChildHelper(cD);
            qx.lang.Array.remove(cC, cD);
          };
        } else {

          this.__removeChildHelper(cB);
          qx.lang.Array.remove(cC, cB);
        };
        // Chaining support
        return this;
      },
      /**
       * Removes the child at the given index
       *
       * @param index {Integer} the position of the
       *     child (starts at 0 for the first child)
       * @return {qx.html.Element} this object (for chaining support)
       */
      removeAt : function(cE){

        var cF = this.__children;
        if(!cF){

          throw new Error(ba);
        };
        var cG = cF[cE];
        if(!cG){

          throw new Error(q);
        };
        this.__removeChildHelper(cG);
        qx.lang.Array.removeAt(this.__children, cE);
        // Chaining support
        return this;
      },
      /**
       * Remove all children from this element.
       *
       * @return {qx.html.Element} A reference to this.
       */
      removeAll : function(){

        var cH = this.__children;
        if(cH){

          for(var i = 0,l = cH.length;i < l;i++){

            this.__removeChildHelper(cH[i]);
          };
          // Clear array
          cH.length = 0;
        };
        // Chaining support
        return this;
      },
      /*
      ---------------------------------------------------------------------------
        CHILDREN MANAGEMENT (EXECUTED ON THE CHILD)
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the parent of this element.
       *
       * @return {qx.html.Element|null} The parent of this element
       */
      getParent : function(){

        return this.__parent || null;
      },
      /**
       * Insert self into the given parent. Normally appends self to the end,
       * but optionally a position can be defined. With index <code>0</code> it
       * will be inserted at the begin.
       *
       * @param parent {qx.html.Element} The new parent of this element
       * @param index {Integer?null} Optional position
       * @return {qx.html.Element} this object (for chaining support)
       */
      insertInto : function(parent, cI){

        parent.__addChildHelper(this);
        if(cI == null){

          parent.__children.push(this);
        } else {

          qx.lang.Array.insertAt(this.__children, this, cI);
        };
        return this;
      },
      /**
       * Insert self before the given (related) element
       *
       * @param rel {qx.html.Element} the related element
       * @return {qx.html.Element} this object (for chaining support)
       */
      insertBefore : function(cJ){

        var parent = cJ.__parent;
        parent.__addChildHelper(this);
        qx.lang.Array.insertBefore(parent.__children, this, cJ);
        return this;
      },
      /**
       * Insert self after the given (related) element
       *
       * @param rel {qx.html.Element} the related element
       * @return {qx.html.Element} this object (for chaining support)
       */
      insertAfter : function(cK){

        var parent = cK.__parent;
        parent.__addChildHelper(this);
        qx.lang.Array.insertAfter(parent.__children, this, cK);
        return this;
      },
      /**
       * Move self to the given index in the current parent.
       *
       * @param index {Integer} the index (starts at 0 for the first child)
       * @return {qx.html.Element} this object (for chaining support)
       * @throws an exception when the given element is not child
       *      of this element.
       */
      moveTo : function(cL){

        var parent = this.__parent;
        parent.__moveChildHelper(this);
        var cM = parent.__children.indexOf(this);
        if(cM === cL){

          throw new Error(t);
        } else if(cM < cL){

          cL--;
        };
        qx.lang.Array.removeAt(parent.__children, cM);
        qx.lang.Array.insertAt(parent.__children, this, cL);
        return this;
      },
      /**
       * Move self before the given (related) child.
       *
       * @param rel {qx.html.Element} the related child
       * @return {qx.html.Element} this object (for chaining support)
       */
      moveBefore : function(cN){

        var parent = this.__parent;
        return this.moveTo(parent.__children.indexOf(cN));
      },
      /**
       * Move self after the given (related) child.
       *
       * @param rel {qx.html.Element} the related child
       * @return {qx.html.Element} this object (for chaining support)
       */
      moveAfter : function(cO){

        var parent = this.__parent;
        return this.moveTo(parent.__children.indexOf(cO) + 1);
      },
      /**
       * Remove self from the current parent.
       *
       * @return {qx.html.Element} this object (for chaining support)
       */
      free : function(){

        var parent = this.__parent;
        if(!parent){

          throw new Error(z);
        };
        if(!parent.__children){

          return;
        };
        parent.__removeChildHelper(this);
        qx.lang.Array.remove(parent.__children, this);
        return this;
      },
      /*
      ---------------------------------------------------------------------------
        DOM ELEMENT ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the DOM element (if created). Please use this with caution.
       * It is better to make all changes to the object itself using the public
       * API rather than to the underlying DOM element.
       *
       * @return {Element|null} The DOM element node, if available.
       */
      getDomElement : function(){

        return this.__element || null;
      },
      /**
       * Returns the nodeName of the DOM element.
       *
       * @return {String} The node name
       */
      getNodeName : function(){

        return this.__nodeName;
      },
      /**
       * Sets the nodeName of the DOM element.
       *
       * @param name {String} The node name
       */
      setNodeName : function(name){

        this.__nodeName = name;
      },
      /**
       * Sets the element's root flag, which indicates
       * whether the element should be a root element or not.
       * @param root {Boolean} The root flag.
       */
      setRoot : function(cP){

        this.__root = cP;
      },
      /**
       * Uses existing markup for this element. This is mainly used
       * to insert pre-built markup blocks into the element hierarchy.
       *
       * @param html {String} HTML markup with one root element
       *   which is used as the main element for this instance.
       * @return {Element} The created DOM element
       */
      useMarkup : function(cQ){

        if(this.__element){

          throw new Error(O);
        };
        // Prepare extraction
        // We have a IE specific issue with "Unknown error" messages
        // when we try to use the same DOM node again. I am not sure
        // why this happens. Would be a good performance improvement,
        // but does not seem to work.
        if((qx.core.Environment.get(w) == v)){

          var cR = document.createElement(F);
        } else {

          var cR = qx.dom.Element.getHelperElement();
        };
        // Extract first element
        cR.innerHTML = cQ;
        this.useElement(cR.firstChild);
        return this.__element;
      },
      /**
       * Uses an existing element instead of creating one. This may be interesting
       * when the DOM element is directly needed to add content etc.
       *
       * @param elem {Element} Element to reuse
       */
      useElement : function(cS){

        if(this.__element){

          throw new Error(O);
        };
        // Use incoming element
        this.__element = cS;
        this.__element.$$element = this.$$hash;
        // Copy currently existing data over to element
        this._copyData(true);
      },
      /**
       * Whether the element is focusable (or will be when created)
       *
       * @return {Boolean} <code>true</code> when the element is focusable.
       */
      isFocusable : function(){

        var cU = this.getAttribute(p);
        if(cU >= 1){

          return true;
        };
        var cT = qx.event.handler.Focus.FOCUSABLE_ELEMENTS;
        if(cU >= 0 && cT[this.__nodeName]){

          return true;
        };
        return false;
      },
      /**
       * Set whether the element is selectable. It uses the qooxdoo attribute
       * qxSelectable with the values 'on' or 'off'.
       * In webkit, a special css property will be used (-webkit-user-select).
       *
       * @param value {Boolean} True, if the element should be selectable.
       */
      setSelectable : function(cV){

        this.setAttribute(s, cV ? C : Y);
        var cW = qx.core.Environment.get(bg);
        if(cW){

          this.setStyle(cW, cV ? k : qx.core.Environment.get(K));
        };
      },
      /**
       * Whether the element is natively focusable (or will be when created)
       *
       * This ignores the configured tabIndex.
       *
       * @return {Boolean} <code>true</code> when the element is focusable.
       */
      isNativelyFocusable : function(){

        return !!qx.event.handler.Focus.FOCUSABLE_ELEMENTS[this.__nodeName];
      },
      /*
      ---------------------------------------------------------------------------
        EXCLUDE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Marks the element as included which means it will be moved into
       * the DOM again and synced with the internal data representation.
       *
       * @return {qx.html.Element} this object (for chaining support)
       */
      include : function(){

        if(this.__included){

          return;
        };
        delete this.__included;
        if(this.__parent){

          this.__parent._scheduleChildrenUpdate();
        };
        return this;
      },
      /**
       * Marks the element as excluded which means it will be removed
       * from the DOM and ignored for updates until it gets included again.
       *
       * @return {qx.html.Element} this object (for chaining support)
       */
      exclude : function(){

        if(!this.__included){

          return;
        };
        this.__included = false;
        if(this.__parent){

          this.__parent._scheduleChildrenUpdate();
        };
        return this;
      },
      /**
       * Whether the element is part of the DOM
       *
       * @return {Boolean} Whether the element is part of the DOM.
       */
      isIncluded : function(){

        return this.__included === true;
      },
      /*
      ---------------------------------------------------------------------------
        VISIBILITY SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Marks the element as visible which means that a previously applied
       * CSS style of display=none gets removed and the element will inserted
       * into the DOM, when this had not already happened before.
       *
       * @return {qx.html.Element} this object (for chaining support)
       */
      show : function(){

        if(this.__visible){

          return;
        };
        if(this.__element){

          qx.html.Element._visibility[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        // Must be sure that the element gets included into the DOM.
        if(this.__parent){

          this.__parent._scheduleChildrenUpdate();
        };
        delete this.__visible;
      },
      /**
       * Marks the element as hidden which means it will kept in DOM (if it
       * is already there, but configured hidden using a CSS style of display=none).
       *
       * @return {qx.html.Element} this object (for chaining support)
       */
      hide : function(){

        if(!this.__visible){

          return;
        };
        if(this.__element){

          qx.html.Element._visibility[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        this.__visible = false;
      },
      /**
       * Whether the element is visible.
       *
       * Please note: This does not control the visibility or parent inclusion recursively.
       *
       * @return {Boolean} Returns <code>true</code> when the element is configured
       *   to be visible.
       */
      isVisible : function(){

        return this.__visible === true;
      },
      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Scrolls the given child element into view. Only scrolls children.
       * Do not influence elements on top of this element.
       *
       * If the element is currently invisible it gets scrolled automatically
       * at the next time it is visible again (queued).
       *
       * @param elem {qx.html.Element} The element to scroll into the viewport.
       * @param align {String?null} Alignment of the element. Allowed values:
       *   <code>left</code> or <code>right</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param direct {Boolean?true} Whether the execution should be made
       *   directly when possible
       */
      scrollChildIntoViewX : function(cX, cY, da){

        var dc = this.__element;
        var dd = cX.getDomElement();
        if(da !== false && dc && dc.offsetWidth && dd && dd.offsetWidth){

          qx.bom.element.Scroll.intoViewX(dd, dc, cY);
        } else {

          this.__lazyScrollIntoViewX = {
            element : cX,
            align : cY
          };
          qx.html.Element._scroll[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        delete this.__lazyScrollX;
      },
      /**
       * Scrolls the given child element into view. Only scrolls children.
       * Do not influence elements on top of this element.
       *
       * If the element is currently invisible it gets scrolled automatically
       * at the next time it is visible again (queued).
       *
       * @param elem {qx.html.Element} The element to scroll into the viewport.
       * @param align {String?null} Alignment of the element. Allowed values:
       *   <code>top</code> or <code>bottom</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param direct {Boolean?true} Whether the execution should be made
       *   directly when possible
       */
      scrollChildIntoViewY : function(de, df, dg){

        var dh = this.__element;
        var di = de.getDomElement();
        if(dg !== false && dh && dh.offsetWidth && di && di.offsetWidth){

          qx.bom.element.Scroll.intoViewY(di, dh, df);
        } else {

          this.__lazyScrollIntoViewY = {
            element : de,
            align : df
          };
          qx.html.Element._scroll[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        delete this.__lazyScrollY;
      },
      /**
       * Scrolls the element to the given left position.
       *
       * @param x {Integer} Horizontal scroll position
       * @param lazy {Boolean?false} Whether the scrolling should be performed
       *    during element flush.
       * @return {void}
       */
      scrollToX : function(x, dj){

        var dk = this.__element;
        if(dj !== true && dk && dk.offsetWidth){

          dk.scrollLeft = x;
          delete this.__lazyScrollX;
        } else {

          this.__lazyScrollX = x;
          qx.html.Element._scroll[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        delete this.__lazyScrollIntoViewX;
      },
      /**
       * Get the horizontal scroll position.
       *
       * @return {Integer} Horizontal scroll position
       */
      getScrollX : function(){

        var dl = this.__element;
        if(dl){

          return dl.scrollLeft;
        };
        return this.__lazyScrollX || 0;
      },
      /**
       * Scrolls the element to the given top position.
       *
       * @param y {Integer} Vertical scroll position
       * @param lazy {Boolean?false} Whether the scrolling should be performed
       *    during element flush.
       * @return {void}
       */
      scrollToY : function(y, dm){

        var dn = this.__element;
        if(dm !== true && dn && dn.offsetWidth){

          dn.scrollTop = y;
          delete this.__lazyScrollY;
        } else {

          this.__lazyScrollY = y;
          qx.html.Element._scroll[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        delete this.__lazyScrollIntoViewY;
      },
      /**
       * Get the vertical scroll position.
       *
       * @return {Integer} Vertical scroll position
       */
      getScrollY : function(){

        var dp = this.__element;
        if(dp){

          return dp.scrollTop;
        };
        return this.__lazyScrollY || 0;
      },
      /**
       * Disables browser-native scrolling
       */
      disableScrolling : function(){

        this.enableScrolling();
        this.scrollToX(0);
        this.scrollToY(0);
        this.addListener(B, this.__onScroll, this);
      },
      /**
       * Re-enables browser-native scrolling
       */
      enableScrolling : function(){

        this.removeListener(B, this.__onScroll, this);
      },
      __inScroll : null,
      /**
       * Handler for the scroll-event
       *
       * @param e {qx.event.type.Native} scroll-event
       */
      __onScroll : function(e){

        if(!this.__inScroll){

          this.__inScroll = true;
          this.__element.scrollTop = 0;
          this.__element.scrollLeft = 0;
          delete this.__inScroll;
        };
      },
      /*
      ---------------------------------------------------------------------------
        TEXT SELECTION SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Get the selection of the element.
       *
       * If the underlaying DOM element is not yet created, this methods returns
       * a null value.
       *
       * @return {String|null}
       */
      getTextSelection : function(){

        var dq = this.__element;
        if(dq){

          return qx.bom.Selection.get(dq);
        };
        return null;
      },
      /**
       * Get the length of selection of the element.
       *
       * If the underlaying DOM element is not yet created, this methods returns
       * a null value.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength : function(){

        var dr = this.__element;
        if(dr){

          return qx.bom.Selection.getLength(dr);
        };
        return null;
      },
      /**
       * Get the start of the selection of the element.
       *
       * If the underlaying DOM element is not yet created, this methods returns
       * a null value.
       *
       * @return {Integer|null}
       */
      getTextSelectionStart : function(){

        var ds = this.__element;
        if(ds){

          return qx.bom.Selection.getStart(ds);
        };
        return null;
      },
      /**
       * Get the end of the selection of the element.
       *
       * If the underlaying DOM element is not yet created, this methods returns
       * a null value.
       *
       * @return {Integer|null}
       */
      getTextSelectionEnd : function(){

        var dt = this.__element;
        if(dt){

          return qx.bom.Selection.getEnd(dt);
        };
        return null;
      },
      /**
       * Set the selection of the element with the given start and end value.
       * If no end value is passed the selection will extend to the end.
       *
       * This method only works if the underlying DOM element is already created.
       *
       * @param start {Integer} start of the selection (zero based)
       * @param end {Integer} end of the selection
       * @return {void}
       */
      setTextSelection : function(du, dv){

        var dw = this.__element;
        if(dw){

          qx.bom.Selection.set(dw, du, dv);
          return;
        };
        // if element not created, save the selection for flushing
        qx.html.Element.__selection[this.toHashCode()] = {
          element : this,
          start : du,
          end : dv
        };
        qx.html.Element._scheduleFlush(M);
      },
      /**
       * Clears the selection of the element.
       *
       * This method only works if the underlying DOM element is already created.
       *
       * @return {void}
       */
      clearTextSelection : function(){

        var dx = this.__element;
        if(dx){

          qx.bom.Selection.clear(dx);
        };
        delete qx.html.Element.__selection[this.toHashCode()];
      },
      /*
      ---------------------------------------------------------------------------
        FOCUS/ACTIVATE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Takes the action to process as argument and queues this action if the
       * underlying DOM element is not yet created.
       *
       * @param action {String} action to queue
       * @param args {Array} optional list of arguments for the action
       * @return {void}
       */
      __performAction : function(dy, dz){

        var dA = qx.html.Element._actions;
        dA.push({
          type : dy,
          element : this,
          args : dz || []
        });
        qx.html.Element._scheduleFlush(M);
      },
      /**
       * Focus this element.
       *
       * If the underlaying DOM element is not yet created, the
       * focus is queued for processing after the element creation.
       *
       * @return {void}
       */
      focus : function(){

        this.__performAction(f);
      },
      /**
       * Mark this element to get blurred on the next flush of the queue
       *
       * @return {void}
       */
      blur : function(){

        this.__performAction(b);
      },
      /**
       * Mark this element to get activated on the next flush of the queue
       *
       * @return {void}
       */
      activate : function(){

        this.__performAction(o);
      },
      /**
       * Mark this element to get deactivated on the next flush of the queue
       *
       * @return {void}
       */
      deactivate : function(){

        this.__performAction(bh);
      },
      /**
       * Captures all mouse events to this element
       *
       * @param containerCapture {Boolean?true} If true all events originating in
       *   the container are captured. If false events originating in the container
       *   are not captured.
       */
      capture : function(dB){

        this.__performAction(bd, [dB !== false]);
      },
      /**
       * Releases this element from a previous {@link #capture} call
       */
      releaseCapture : function(){

        this.__performAction(X);
      },
      /*
      ---------------------------------------------------------------------------
        STYLE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Set up the given style attribute
       *
       * @param key {String} the name of the style attribute
       * @param value {var} the value
       * @param direct {Boolean?false} Whether the value should be applied
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      setStyle : function(dC, dD, dE){

        if(!this.__styleValues){

          this.__styleValues = {
          };
        };
        if(this.__styleValues[dC] == dD){

          return;
        };
        if(dD == null){

          delete this.__styleValues[dC];
        } else {

          this.__styleValues[dC] = dD;
        };
        // Uncreated elements simply copy all data
        // on creation. We don't need to remember any
        // jobs. It is a simple full list copy.
        if(this.__element){

          // Omit queuing in direct mode
          if(dE){

            qx.bom.element.Style.set(this.__element, dC, dD);
            return this;
          };
          // Dynamically create if needed
          if(!this.__styleJobs){

            this.__styleJobs = {
            };
          };
          // Store job info
          this.__styleJobs[dC] = true;
          // Register modification
          qx.html.Element._modified[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        return this;
      },
      /**
       * Convenience method to modify a set of styles at once.
       *
       * @param map {Map} a map where the key is the name of the property
       *    and the value is the value to use.
       * @param direct {Boolean?false} Whether the values should be applied
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      setStyles : function(dF, dG){

        // inline calls to "set" because this method is very
        // performance critical!
        var dH = qx.bom.element.Style;
        if(!this.__styleValues){

          this.__styleValues = {
          };
        };
        if(this.__element){

          // Dynamically create if needed
          if(!this.__styleJobs){

            this.__styleJobs = {
            };
          };
          for(var dJ in dF){

            var dI = dF[dJ];
            if(this.__styleValues[dJ] == dI){

              continue;
            };
            if(dI == null){

              delete this.__styleValues[dJ];
            } else {

              this.__styleValues[dJ] = dI;
            };
            // Omit queuing in direct mode
            if(dG){

              dH.set(this.__element, dJ, dI);
              continue;
            };
            // Store job info
            this.__styleJobs[dJ] = true;
          };
          // Register modification
          qx.html.Element._modified[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        } else {

          for(var dJ in dF){

            var dI = dF[dJ];
            if(this.__styleValues[dJ] == dI){

              continue;
            };
            if(dI == null){

              delete this.__styleValues[dJ];
            } else {

              this.__styleValues[dJ] = dI;
            };
          };
        };
        return this;
      },
      /**
       * Removes the given style attribute
       *
       * @param key {String} the name of the style attribute
       * @param direct {Boolean?false} Whether the value should be removed
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      removeStyle : function(dK, dL){

        this.setStyle(dK, null, dL);
      },
      /**
       * Get the value of the given style attribute.
       *
       * @param key {String} name of the style attribute
       * @return {var} the value of the style attribute
       */
      getStyle : function(dM){

        return this.__styleValues ? this.__styleValues[dM] : null;
      },
      /**
       * Returns a map of all styles. Do not modify the result map!
       *
       * @return {Map} All styles or <code>null</code> when none are configured.
       */
      getAllStyles : function(){

        return this.__styleValues || null;
      },
      /*
      ---------------------------------------------------------------------------
        ATTRIBUTE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Set up the given attribute
       *
       * @param key {String} the name of the attribute
       * @param value {var} the value
       * @param direct {Boolean?false} Whether the value should be applied
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      setAttribute : function(dN, dO, dP){

        if(!this.__attribValues){

          this.__attribValues = {
          };
        };
        if(this.__attribValues[dN] == dO){

          return;
        };
        if(dO == null){

          delete this.__attribValues[dN];
        } else {

          this.__attribValues[dN] = dO;
        };
        // Uncreated elements simply copy all data
        // on creation. We don't need to remember any
        // jobs. It is a simple full list copy.
        if(this.__element){

          // Omit queuing in direct mode
          if(dP){

            qx.bom.element.Attribute.set(this.__element, dN, dO);
            return this;
          };
          // Dynamically create if needed
          if(!this.__attribJobs){

            this.__attribJobs = {
            };
          };
          // Store job info
          this.__attribJobs[dN] = true;
          // Register modification
          qx.html.Element._modified[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        return this;
      },
      /**
       * Convenience method to modify a set of attributes at once.
       *
       * @param map {Map} a map where the key is the name of the property
       *    and the value is the value to use.
       * @param direct {Boolean?false} Whether the values should be applied
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      setAttributes : function(dQ, dR){

        for(var dS in dQ){

          this.setAttribute(dS, dQ[dS], dR);
        };
        return this;
      },
      /**
       * Removes the given attribute
       *
       * @param key {String} the name of the attribute
       * @param direct {Boolean?false} Whether the value should be removed
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      removeAttribute : function(dT, dU){

        this.setAttribute(dT, null, dU);
      },
      /**
       * Get the value of the given attribute.
       *
       * @param key {String} name of the attribute
       * @return {var} the value of the attribute
       */
      getAttribute : function(dV){

        return this.__attribValues ? this.__attribValues[dV] : null;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Applies a special property with the given value.
       *
       * This property apply routine can be easily overwritten and
       * extended by sub classes to add new low level features which
       * are not easily possible using styles and attributes.
       *
       * @param name {String} Unique property identifier
       * @param value {var} Any valid value (depends on the property)
       * @return {qx.html.Element} this object (for chaining support)
       */
      _applyProperty : function(name, dW){
      },
      /**
       * Set up the given property.
       *
       * @param key {String} the name of the property
       * @param value {var} the value
       * @param direct {Boolean?false} Whether the value should be applied
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      _setProperty : function(dX, dY, ea){

        if(!this.__propertyValues){

          this.__propertyValues = {
          };
        };
        if(this.__propertyValues[dX] == dY){

          return;
        };
        if(dY == null){

          delete this.__propertyValues[dX];
        } else {

          this.__propertyValues[dX] = dY;
        };
        // Uncreated elements simply copy all data
        // on creation. We don't need to remember any
        // jobs. It is a simple full list copy.
        if(this.__element){

          // Omit queuing in direct mode
          if(ea){

            this._applyProperty(dX, dY);
            return this;
          };
          // Dynamically create if needed
          if(!this.__propertyJobs){

            this.__propertyJobs = {
            };
          };
          // Store job info
          this.__propertyJobs[dX] = true;
          // Register modification
          qx.html.Element._modified[this.$$hash] = this;
          qx.html.Element._scheduleFlush(M);
        };
        return this;
      },
      /**
       * Removes the given misc
       *
       * @param key {String} the name of the misc
       * @param direct {Boolean?false} Whether the value should be removed
       *    directly (without queuing)
       * @return {qx.html.Element} this object (for chaining support)
       */
      _removeProperty : function(eb, ec){

        this._setProperty(eb, null, ec);
      },
      /**
       * Get the value of the given misc.
       *
       * @param key {String} name of the misc
       * @return {var} the value of the misc
       */
      _getProperty : function(ed){

        var ee = this.__propertyValues;
        if(!ee){

          return null;
        };
        var ef = ee[ed];
        return ef == null ? null : ef;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Adds an event listener to the element.
       *
       * @param type {String} Name of the event
       * @param listener {Function} Function to execute on event
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean ? false} Whether capturing should be enabled
       * @return {var} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListener : function(eg, eh, self, ei){

        if(this.$$disposed){

          return null;
        };
        if(qx.core.Environment.get(N)){

          var ej = d + eg + H + A + this + U;
          this.assertString(eg, ej + S);
          this.assertFunction(eh, ej + J);
          if(self !== undefined){

            this.assertObject(self, L);
          };
          if(ei !== undefined){

            this.assertBoolean(ei, E);
          };
        };
        if(this.__element){

          return qx.event.Registration.addListener(this.__element, eg, eh, self, ei);
        };
        if(!this.__eventValues){

          this.__eventValues = {
          };
        };
        if(ei == null){

          ei = false;
        };
        var ek = qx.event.Manager.getNextUniqueId();
        var em = eg + (ei ? g : j) + ek;
        this.__eventValues[em] = {
          type : eg,
          listener : eh,
          self : self,
          capture : ei,
          unique : ek
        };
        return em;
      },
      /**
       * Removes an event listener from the element.
       *
       * @param type {String} Name of the event
       * @param listener {Function} Function to execute on event
       * @param self {Object} Execution context of given function
       * @param capture {Boolean ? false} Whether capturing should be enabled
       * @return {qx.html.Element} this object (for chaining support)
       */
      removeListener : function(en, eo, self, ep){

        if(this.$$disposed){

          return null;
        };
        if(qx.core.Environment.get(N)){

          var eq = r + en + H + be + this + U;
          this.assertString(en, eq + S);
          this.assertFunction(eo, eq + J);
          if(self !== undefined){

            this.assertObject(self, L);
          };
          if(ep !== undefined){

            this.assertBoolean(ep, E);
          };
        };
        if(this.__element){

          qx.event.Registration.removeListener(this.__element, en, eo, self, ep);
        } else {

          var es = this.__eventValues;
          var er;
          if(ep == null){

            ep = false;
          };
          for(var et in es){

            er = es[et];
            // Optimized for performance: Testing references first
            if(er.listener === eo && er.self === self && er.capture === ep && er.type === en){

              delete es[et];
              break;
            };
          };
        };
        return this;
      },
      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param id {var} The id returned by {@link #addListener}
       * @return {qx.html.Element} this object (for chaining support)
       */
      removeListenerById : function(eu){

        if(this.$$disposed){

          return null;
        };
        if(this.__element){

          qx.event.Registration.removeListenerById(this.__element, eu);
        } else {

          delete this.__eventValues[eu];
        };
        return this;
      },
      /**
       * Check if there are one or more listeners for an event type.
       *
       * @param type {String} name of the event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the object has a listener of the given type.
       */
      hasListener : function(ev, ew){

        if(this.$$disposed){

          return false;
        };
        if(this.__element){

          return qx.event.Registration.hasListener(this.__element, ev, ew);
        };
        var ey = this.__eventValues;
        var ex;
        if(ew == null){

          ew = false;
        };
        for(var ez in ey){

          ex = ey[ez];
          // Optimized for performance: Testing fast types first
          if(ex.capture === ew && ex.type === ev){

            return true;
          };
        };
        return false;
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(eA){

      eA.__deferredCall = new qx.util.DeferredCall(eA.flush, eA);
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      var eB = this.__element;
      if(eB){

        qx.event.Registration.getManager(eB).removeAllListeners(eB);
        eB.$$element = Q;
      };
      if(!qx.core.ObjectRegistry.inShutDown){

        var parent = this.__parent;
        if(parent && !parent.$$disposed){

          parent.remove(this);
        };
      };
      this._disposeArray(R);
      this.__attribValues = this.__styleValues = this.__eventValues = this.__propertyValues = this.__attribJobs = this.__styleJobs = this.__propertyJobs = this.__element = this.__parent = this.__lazyScrollIntoViewX = this.__lazyScrollIntoViewY = null;
    }
  });
})();
(function(){

  var c = "qx.event.handler.Appear",b = "disappear",a = "appear";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This class supports <code>appear</code> and <code>disappear</code> events
   * on DOM level.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(d){

      qx.core.Object.call(this);
      this.__manager = d;
      this.__targets = {
      };
      // Register
      qx.event.handler.Appear.__instances[this.$$hash] = this;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        appear : true,
        disappear : true
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true,
      /** {Map} Stores all appear manager instances */
      __instances : {
      },
      /**
       * Refreshes all appear handlers. Useful after massive DOM manipulations e.g.
       * through qx.html.Element.
       *
       * @return {void}
       */
      refresh : function(){

        var e = this.__instances;
        for(var f in e){

          e[f].refresh();
        };
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      __targets : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(g, h){
      },
      // interface implementation
      registerEvent : function(i, j, k){

        var l = qx.core.ObjectRegistry.toHashCode(i) + j;
        var m = this.__targets;
        if(m && !m[l]){

          m[l] = i;
          i.$$displayed = i.offsetWidth > 0;
        };
      },
      // interface implementation
      unregisterEvent : function(n, o, p){

        var q = qx.core.ObjectRegistry.toHashCode(n) + o;
        var r = this.__targets;
        if(!r){

          return;
        };
        if(r[q]){

          delete r[q];
        };
      },
      /*
      ---------------------------------------------------------------------------
        USER ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * This method should be called by all DOM tree modifying routines
       * to check the registered nodes for changes.
       *
       * @return {void}
       */
      refresh : function(){

        var v = this.__targets;
        var w;
        for(var u in v){

          w = v[u];
          var s = w.offsetWidth > 0;
          if((!!w.$$displayed) !== s){

            w.$$displayed = s;
            var t = qx.event.Registration.createEvent(s ? a : b);
            this.__manager.dispatchEvent(w, t);
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__manager = this.__targets = null;
      // Deregister
      delete qx.event.handler.Appear.__instances[this.$$hash];
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(x){

      qx.event.Registration.addHandler(x);
    }
  });
})();
(function(){

  var h = "abstract",g = "qx.event.dispatch.AbstractBubbling",f = "Missing implementation",e = "The context object '",d = "qx.debug",c = "' for the event '",b = "' of '",a = "'is already disposed.";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Event dispatcher for all bubbling events.
   */
  qx.Class.define(g, {
    extend : qx.core.Object,
    implement : qx.event.IEventDispatcher,
    type : h,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(k){

      this._manager = k;
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the parent of the given target
       *
       * @abstract
       * @param target {var} The target which parent should be found
       * @return {var} The parent of the given target
       */
      _getParent : function(l){

        throw new Error(f);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canDispatchEvent : function(m, event, n){

        return event.getBubbles();
      },
      // interface implementation
      dispatchEvent : function(o, event, p){

        var parent = o;
        var y = this._manager;
        var v,C;
        var t;
        var x,A;
        var z;
        // Cache list for AT_TARGET
        var B = [];
        v = y.getListeners(o, p, true);
        C = y.getListeners(o, p, false);
        if(v){

          B.push(v);
        };
        if(C){

          B.push(C);
        };
        // Cache list for CAPTURING_PHASE and BUBBLING_PHASE
        var parent = this._getParent(o);
        var r = [];
        var q = [];
        var s = [];
        var w = [];
        // Walk up the tree and look for event listeners
        while(parent != null){

          // Attention:
          // We do not follow the DOM2 events specifications here
          // http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-flow-capture
          // Opera is the only browser which conforms to the spec.
          // Safari and Mozilla do it the same way like qooxdoo does
          // and add the capture events of the target to the execution list.
          v = y.getListeners(parent, p, true);
          if(v){

            s.push(v);
            w.push(parent);
          };
          C = y.getListeners(parent, p, false);
          if(C){

            r.push(C);
            q.push(parent);
          };
          parent = this._getParent(parent);
        };
        // capturing phase
        // loop through the hierarchy in reverted order (from root)
        event.setEventPhase(qx.event.type.Event.CAPTURING_PHASE);
        for(var i = s.length - 1;i >= 0;i--){

          z = w[i];
          event.setCurrentTarget(z);
          t = s[i];
          for(var j = 0,u = t.length;j < u;j++){

            x = t[j];
            A = x.context || z;
            if(qx.core.Environment.get(d)){

              // warn if the context is disposed
              if(A && A.isDisposed && A.isDisposed()){

                this.warn(e + A + c + p + b + z + a);
              };
            };
            x.handler.call(A, event);
          };
          if(event.getPropagationStopped()){

            return;
          };
        };
        // at target
        event.setEventPhase(qx.event.type.Event.AT_TARGET);
        event.setCurrentTarget(o);
        for(var i = 0,D = B.length;i < D;i++){

          t = B[i];
          for(var j = 0,u = t.length;j < u;j++){

            x = t[j];
            A = x.context || o;
            if(qx.core.Environment.get(d)){

              // warn if the context is disposed
              if(A && A.isDisposed && A.isDisposed()){

                this.warn(e + A + c + p + b + o + a);
              };
            };
            x.handler.call(A, event);
          };
          if(event.getPropagationStopped()){

            return;
          };
        };
        // bubbling phase
        // loop through the hierarchy in normal order (to root)
        event.setEventPhase(qx.event.type.Event.BUBBLING_PHASE);
        for(var i = 0,D = r.length;i < D;i++){

          z = q[i];
          event.setCurrentTarget(z);
          t = r[i];
          for(var j = 0,u = t.length;j < u;j++){

            x = t[j];
            A = x.context || z;
            if(qx.core.Environment.get(d)){

              // warn if the context is disposed
              if(A && A.isDisposed && A.isDisposed()){

                this.warn(e + A + c + p + b + z + a);
              };
            };
            x.handler.call(A, event);
          };
          if(event.getPropagationStopped()){

            return;
          };
        };
      }
    }
  });
})();
(function(){

  var a = "qx.event.dispatch.DomBubbling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Event dispatcher for all bubbling events on DOM elements.
   */
  qx.Class.define(a, {
    extend : qx.event.dispatch.AbstractBubbling,
    statics : {
      /** {Integer} Priority of this dispatcher */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL
    },
    members : {
      // overridden
      _getParent : function(b){

        return b.parentNode;
      },
      // interface implementation
      canDispatchEvent : function(c, event, d){

        return c.nodeType !== undefined && event.getBubbles();
      }
    },
    defer : function(e){

      qx.event.Registration.addDispatcher(e);
    }
  });
})();
(function(){

  var d = "qx.event.handler.Element",c = "load",b = "iframe",a = "-";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This class supports typical DOM element inline events like scroll,
   * change, select, ...
   */
  qx.Class.define(d, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(e){

      qx.core.Object.call(this);
      this._manager = e;
      this._registeredEvents = {
      };
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        abort : true,
        // Image elements
        load : true,
        // Image elements
        scroll : true,
        select : true,
        reset : true,
        // Form Elements
        submit : true
      },
      /** {MAP} Whether the event is cancelable */
      CANCELABLE : {
        selectstart : true
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(f, g){

        // Don't handle "load" event of Iframe. Unfortunately, both Element and
        // Iframe handler support "load" event. Should be handled by
        // qx.event.handler.Iframe only. Fixes [#BUG 4587].
        if(g === c){

          return f.tagName.toLowerCase() !== b;
        } else {

          return true;
        };
      },
      // interface implementation
      registerEvent : function(h, i, j){

        var m = qx.core.ObjectRegistry.toHashCode(h);
        var k = m + a + i;
        var l = qx.lang.Function.listener(this._onNative, this, k);
        qx.bom.Event.addNativeListener(h, i, l);
        this._registeredEvents[k] = {
          element : h,
          type : i,
          listener : l
        };
      },
      // interface implementation
      unregisterEvent : function(n, o, p){

        var s = this._registeredEvents;
        if(!s){

          return;
        };
        var t = qx.core.ObjectRegistry.toHashCode(n);
        var q = t + a + o;
        var r = this._registeredEvents[q];
        if(r){

          qx.bom.Event.removeNativeListener(n, o, r.listener);
        };
        delete this._registeredEvents[q];
      },
      /*
      ---------------------------------------------------------------------------
        EVENT-HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Default event handler.
       *
       * @signature function(nativeEvent, eventId)
       * @param nativeEvent {Event} Native event
       * @param eventId {Integer} ID of the event (as stored internally)
       */
      _onNative : qx.event.GlobalError.observeMethod(function(u, v){

        var x = this._registeredEvents;
        if(!x){

          return;
        };
        var w = x[v];
        var y = this.constructor.CANCELABLE[w.type];
        qx.event.Registration.fireNonBubblingEvent(w.element, w.type, qx.event.type.Native, [u, undefined, undefined, undefined, y]);
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      var z;
      var A = this._registeredEvents;
      for(var B in A){

        z = A[B];
        qx.bom.Event.removeNativeListener(z.element, z.type, z.listener);
      };
      this._manager = this._registeredEvents = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(C){

      qx.event.Registration.addHandler(C);
    }
  });
})();
(function(){

  var a = "qx.event.handler.UserAction";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This handler accepts the useraction event fired by the keyboard and
   * and mouse handlers after an user triggered action has occurred.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(b){

      qx.core.Object.call(this);
      // Define shorthands
      this.__manager = b;
      this.__window = b.getWindow();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        useraction : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      __window : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(c, d){
      },
      // interface implementation
      registerEvent : function(e, f, g){
      },
      // interface implementation
      unregisterEvent : function(h, i, j){
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__manager = this.__window = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(k){

      qx.event.Registration.addHandler(k);
    }
  });
})();
(function(){

  var t = "engine.version",s = "useraction",r = "webkit",q = "gecko",p = "DOMMouseScroll",o = "qx.event.handler.Mouse",n = "os.name",m = "mouseover",l = "mouseout",k = "ios",d = "mousemove",j = "on",g = "dblclick",c = "mousedown",b = "contextmenu",f = "mousewheel",e = "mouseup",h = "engine.name",a = "click";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.UserAction)
  #ignore(qx.event.handler.DragDrop)
  
  ************************************************************************ */
  /**
   * This class provides an unified mouse event handler for Internet Explorer,
   * Firefox, Opera and Safari
   */
  qx.Class.define(o, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(u){

      qx.core.Object.call(this);
      // Define shorthands
      this.__manager = u;
      this.__window = u.getWindow();
      this.__root = this.__window.document;
      // Initialize observers
      this._initButtonObserver();
      this._initMoveObserver();
      this._initWheelObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        mousemove : 1,
        mouseover : 1,
        mouseout : 1,
        mousedown : 1,
        mouseup : 1,
        click : 1,
        dblclick : 1,
        contextmenu : 1,
        mousewheel : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT + qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __onButtonEventWrapper : null,
      __onMoveEventWrapper : null,
      __onWheelEventWrapper : null,
      __lastEventType : null,
      __lastMouseDownTarget : null,
      __manager : null,
      __window : null,
      __root : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(v, w){
      },
      // interface implementation
      // The iPhone requires for attaching mouse events natively to every element which
      // should react on mouse events. As of version 3.0 it also requires to keep the
      // listeners as long as the event should work. In 2.0 it was enough to attach the
      // listener once.
      registerEvent : qx.core.Environment.get(n) === k ? function(x, y, z){

        x[j + y] = qx.lang.Function.returnNull;
      } : qx.lang.Function.returnNull,
      // interface implementation
      unregisterEvent : qx.core.Environment.get(n) === k ? function(A, B, C){

        A[j + B] = undefined;
      } : qx.lang.Function.returnNull,
      /*
      ---------------------------------------------------------------------------
        HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Fire a mouse event with the given parameters
       *
       * @param domEvent {Event} DOM event
       * @param type {String} type of the event
       * @param target {Element} event target
       */
      __fireEvent : function(D, E, F){

        if(!F){

          F = qx.bom.Event.getTarget(D);
        };
        // we need a true node for the fireEvent
        // e.g. when hovering over text of disabled textfields IE is returning
        // an empty object as "srcElement"
        if(F && F.nodeType){

          qx.event.Registration.fireEvent(F, E || D.type, E == f ? qx.event.type.MouseWheel : qx.event.type.Mouse, [D, F, null, true, true]);
        };
        // Fire user action event
        qx.event.Registration.fireEvent(this.__window, s, qx.event.type.Data, [E || D.type]);
      },
      /**
       * Internal target for checking the target and mouse type for mouse
       * scrolling on a feature detection base.
       *
       * @return {Map} A map containing two keys, target and type.
       */
      __getMouseWheelTarget : function(){

        // Fix for bug #3234
        var H = [this.__window, this.__root, this.__root.body];
        var I = this.__window;
        var G = p;
        for(var i = 0;i < H.length;i++){

          if(qx.bom.Event.supportsEvent(H[i], f)){

            G = f;
            I = H[i];
            break;
          };
        };
        return {
          type : G,
          target : I
        };
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native mouse button event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _initButtonObserver : function(){

        this.__onButtonEventWrapper = qx.lang.Function.listener(this._onButtonEvent, this);
        var Event = qx.bom.Event;
        Event.addNativeListener(this.__root, c, this.__onButtonEventWrapper);
        Event.addNativeListener(this.__root, e, this.__onButtonEventWrapper);
        Event.addNativeListener(this.__root, a, this.__onButtonEventWrapper);
        Event.addNativeListener(this.__root, g, this.__onButtonEventWrapper);
        Event.addNativeListener(this.__root, b, this.__onButtonEventWrapper);
      },
      /**
       * Initializes the native mouse move event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _initMoveObserver : function(){

        this.__onMoveEventWrapper = qx.lang.Function.listener(this._onMoveEvent, this);
        var Event = qx.bom.Event;
        Event.addNativeListener(this.__root, d, this.__onMoveEventWrapper);
        Event.addNativeListener(this.__root, m, this.__onMoveEventWrapper);
        Event.addNativeListener(this.__root, l, this.__onMoveEventWrapper);
      },
      /**
       * Initializes the native mouse wheel event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _initWheelObserver : function(){

        this.__onWheelEventWrapper = qx.lang.Function.listener(this._onWheelEvent, this);
        var J = this.__getMouseWheelTarget();
        qx.bom.Event.addNativeListener(J.target, J.type, this.__onWheelEventWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Disconnects the native mouse button event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _stopButtonObserver : function(){

        var Event = qx.bom.Event;
        Event.removeNativeListener(this.__root, c, this.__onButtonEventWrapper);
        Event.removeNativeListener(this.__root, e, this.__onButtonEventWrapper);
        Event.removeNativeListener(this.__root, a, this.__onButtonEventWrapper);
        Event.removeNativeListener(this.__root, g, this.__onButtonEventWrapper);
        Event.removeNativeListener(this.__root, b, this.__onButtonEventWrapper);
      },
      /**
       * Disconnects the native mouse move event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _stopMoveObserver : function(){

        var Event = qx.bom.Event;
        Event.removeNativeListener(this.__root, d, this.__onMoveEventWrapper);
        Event.removeNativeListener(this.__root, m, this.__onMoveEventWrapper);
        Event.removeNativeListener(this.__root, l, this.__onMoveEventWrapper);
      },
      /**
       * Disconnects the native mouse wheel event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _stopWheelObserver : function(){

        var K = this.__getMouseWheelTarget();
        qx.bom.Event.removeNativeListener(K.target, K.type, this.__onWheelEventWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT OBSERVERS
      ---------------------------------------------------------------------------
      */
      /**
       * Global handler for all mouse move related events like "mousemove",
       * "mouseout" and "mouseover".
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       */
      _onMoveEvent : qx.event.GlobalError.observeMethod(function(L){

        this.__fireEvent(L);
      }),
      /**
       * Global handler for all mouse button related events like "mouseup",
       * "mousedown", "click", "dblclick" and "contextmenu".
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       */
      _onButtonEvent : qx.event.GlobalError.observeMethod(function(M){

        var O = M.type;
        var P = qx.bom.Event.getTarget(M);
        // Safari (and maybe gecko) takes text nodes as targets for events
        // See: http://www.quirksmode.org/js/events_properties.html
        if(qx.core.Environment.get(h) == q || qx.core.Environment.get(h) == r){

          if(P && P.nodeType == 3){

            P = P.parentNode;
          };
        };
        // prevent click events on drop during Drag&Drop [BUG #6846]
        var N = qx.event.handler.DragDrop && this.__manager.getHandler(qx.event.handler.DragDrop).isSessionActive();
        if(N && O == a){

          return;
        };
        if(this.__rightClickFixPre){

          this.__rightClickFixPre(M, O, P);
        };
        if(this.__doubleClickFixPre){

          this.__doubleClickFixPre(M, O, P);
        };
        this.__fireEvent(M, O, P);
        if(this.__rightClickFixPost){

          this.__rightClickFixPost(M, O, P);
        };
        if(this.__differentTargetClickFixPost && !N){

          this.__differentTargetClickFixPost(M, O, P);
        };
        this.__lastEventType = O;
      }),
      /**
       * Global handler for the mouse wheel event.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       */
      _onWheelEvent : qx.event.GlobalError.observeMethod(function(Q){

        this.__fireEvent(Q, f);
      }),
      /*
      ---------------------------------------------------------------------------
        CROSS BROWSER SUPPORT FIXES
      ---------------------------------------------------------------------------
      */
      /**
       * Normalizes the click sequence of right click events in Webkit and Opera.
       * The normalized sequence is:
       *
       *  1. mousedown  <- not fired by Webkit
       *  2. mouseup  <- not fired by Webkit
       *  3. contextmenu <- not fired by Opera
       *
       * @param domEvent {Event} original DOM event
       * @param type {String} event type
       * @param target {Element} event target of the DOM event.
       *
       * @signature function(domEvent, type, target)
       */
      __rightClickFixPre : qx.core.Environment.select(h, {
        "webkit" : function(R, S, T){

          // The webkit bug has been fixed in Safari 4
          if(parseFloat(qx.core.Environment.get(t)) < 530){

            if(S == b){

              this.__fireEvent(R, e, T);
            };
          };
        },
        "default" : null
      }),
      /**
       * Normalizes the click sequence of right click events in Webkit and Opera.
       * The normalized sequence is:
       *
       *  1. mousedown  <- not fired by Webkit
       *  2. mouseup  <- not fired by Webkit
       *  3. contextmenu <- not fired by Opera
       *
       * TODO: Just curious. Where is the webkit version? is the
       * documentation up-to-date?
       *
       * @param domEvent {Event} original DOM event
       * @param type {String} event type
       * @param target {Element} event target of the DOM event.
       *
       * @signature function(domEvent, type, target)
       */
      __rightClickFixPost : qx.core.Environment.select(h, {
        "opera" : function(U, V, W){

          if(V == e && U.button == 2){

            this.__fireEvent(U, b, W);
          };
        },
        "default" : null
      }),
      /**
       * Normalizes the click sequence of double click event in the Internet
       * Explorer. The normalized sequence is:
       *
       *  1. mousedown
       *  2. mouseup
       *  3. click
       *  4. mousedown  <- not fired by IE
       *  5. mouseup
       *  6. click  <- not fired by IE
       *  7. dblclick
       *
       *  Note: This fix is only applied, when the IE event model is used, otherwise
       *  the fix is ignored.
       *
       * @param domEvent {Event} original DOM event
       * @param type {String} event type
       * @param target {Element} event target of the DOM event.
       *
       * @signature function(domEvent, type, target)
       */
      __doubleClickFixPre : qx.core.Environment.select(h, {
        "mshtml" : function(X, Y, ba){

          // Do only apply the fix when the event is from the IE event model,
          // otherwise do not apply the fix.
          if(X.target !== undefined){

            return;
          };
          if(Y == e && this.__lastEventType == a){

            this.__fireEvent(X, c, ba);
          } else if(Y == g){

            this.__fireEvent(X, a, ba);
          };
        },
        "default" : null
      }),
      /**
       * If the mouseup event happens on a different target than the corresponding
       * mousedown event the internet explorer dispatches a click event on the
       * first common ancestor of both targets. The presence of this click event
       * is essential for the qooxdoo widget system. All other browsers don't fire
       * the click event so it must be emulated.
       *
       * @param domEvent {Event} original DOM event
       * @param type {String} event type
       * @param target {Element} event target of the DOM event.
       *
       * @signature function(domEvent, type, target)
       */
      __differentTargetClickFixPost : qx.core.Environment.select(h, {
        "mshtml" : null,
        "default" : function(bb, bc, bd){

          switch(bc){case c:
          this.__lastMouseDownTarget = bd;
          break;case e:
          if(bd !== this.__lastMouseDownTarget){

            var be = qx.dom.Hierarchy.getCommonParent(bd, this.__lastMouseDownTarget);
            if(be){

              this.__fireEvent(bb, a, be);
            };
          };};
        }
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopButtonObserver();
      this._stopMoveObserver();
      this._stopWheelObserver();
      this.__manager = this.__window = this.__root = this.__lastMouseDownTarget = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(bf){

      qx.event.Registration.addHandler(bf);
    }
  });
})();
(function(){

  var e = "os.name",d = "opera",c = "engine.name",b = "qx.event.type.Dom",a = "osx";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Common base class for all DOM events.
   */
  qx.Class.define(b, {
    extend : qx.event.type.Native,
    statics : {
      /** {Integer} The modifier mask for the shift key. */
      SHIFT_MASK : 1,
      /** {Integer} The modifier mask for the control key. */
      CTRL_MASK : 2,
      /** {Integer} The modifier mask for the alt key. */
      ALT_MASK : 4,
      /** {Integer} The modifier mask for the meta key (e.g. apple key on Macs). */
      META_MASK : 8
    },
    members : {
      // overridden
      _cloneNativeEvent : function(f, g){

        var g = qx.event.type.Native.prototype._cloneNativeEvent.call(this, f, g);
        g.shiftKey = f.shiftKey;
        g.ctrlKey = f.ctrlKey;
        g.altKey = f.altKey;
        g.metaKey = f.metaKey;
        return g;
      },
      /**
       * Return in a bit map, which modifier keys are pressed. The constants
       * {@link #SHIFT_MASK}, {@link #CTRL_MASK}, {@link #ALT_MASK} and
       * {@link #META_MASK} define the bit positions of the corresponding keys.
       *
       * @return {Integer} A bit map with the pressed modifier keys.
       */
      getModifiers : function(){

        var i = 0;
        var h = this._native;
        if(h.shiftKey){

          i |= qx.event.type.Dom.SHIFT_MASK;
        };
        if(h.ctrlKey){

          i |= qx.event.type.Dom.CTRL_MASK;
        };
        if(h.altKey){

          i |= qx.event.type.Dom.ALT_MASK;
        };
        if(h.metaKey){

          i |= qx.event.type.Dom.META_MASK;
        };
        return i;
      },
      /**
       * Returns whether the ctrl key is pressed.
       *
       * @return {Boolean} whether the ctrl key is pressed.
       */
      isCtrlPressed : function(){

        return this._native.ctrlKey;
      },
      /**
       * Returns whether the shift key is pressed.
       *
       * @return {Boolean} whether the shift key is pressed.
       */
      isShiftPressed : function(){

        return this._native.shiftKey;
      },
      /**
       * Returns whether the alt key is pressed.
       *
       * @return {Boolean} whether the alt key is pressed.
       */
      isAltPressed : function(){

        return this._native.altKey;
      },
      /**
       * Returns whether the meta key is pressed.
       *
       * @return {Boolean} whether the meta key is pressed.
       */
      isMetaPressed : function(){

        return this._native.metaKey;
      },
      /**
       * Returns whether the ctrl key or (on the Mac) the command key is pressed.
       *
       * @return {Boolean} <code>true</code> if the command key is pressed on the Mac
       *           or the ctrl key is pressed on another system.
       */
      isCtrlOrCommandPressed : function(){

        // Opera seems to use ctrlKey for the cmd key so don't fix that for opera
        // on mac [BUG #5884]
        if(qx.core.Environment.get(e) == a && qx.core.Environment.get(c) != d){

          return this._native.metaKey;
        } else {

          return this._native.ctrlKey;
        };
      }
    }
  });
})();
(function(){

  var j = "click",i = "contextmenu",h = "qx.event.type.Mouse",g = "browser.documentmode",f = "browser.name",e = "ie",d = "none",c = "middle",b = "left",a = "right";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * Mouse event object.
   *
   * the interface of this class is based on the DOM Level 2 mouse event
   * interface: http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-mouseevents
   */
  qx.Class.define(h, {
    extend : qx.event.type.Dom,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _cloneNativeEvent : function(k, l){

        var l = qx.event.type.Dom.prototype._cloneNativeEvent.call(this, k, l);
        l.button = k.button;
        l.clientX = k.clientX;
        l.clientY = k.clientY;
        l.pageX = k.pageX;
        l.pageY = k.pageY;
        l.screenX = k.screenX;
        l.screenY = k.screenY;
        l.wheelDelta = k.wheelDelta;
        l.wheelDeltaX = k.wheelDeltaX;
        l.wheelDeltaY = k.wheelDeltaY;
        l.detail = k.detail;
        l.axis = k.axis;
        l.wheelX = k.wheelX;
        l.wheelY = k.wheelY;
        l.HORIZONTAL_AXIS = k.HORIZONTAL_AXIS;
        l.srcElement = k.srcElement;
        l.target = k.target;
        return l;
      },
      /**
       * {Map} Contains the button ID to identifier data.
       *
       * @lint ignoreReferenceField(__buttonsDom2EventModel)
       */
      __buttonsDom2EventModel : {
        '0' : b,
        '2' : a,
        '1' : c
      },
      /**
       * {Map} Contains the button ID to identifier data.
       *
       * @lint ignoreReferenceField(__buttonsMshtmlEventModel)
       */
      __buttonsMshtmlEventModel : {
        '1' : b,
        '2' : a,
        '4' : c
      },
      // overridden
      stop : function(){

        this.stopPropagation();
      },
      /**
       * During mouse events caused by the depression or release of a mouse button,
       * this method can be used to check which mouse button changed state.
       *
       * Only internet explorer can compute the button during mouse move events. For
       * all other browsers the button only contains sensible data during
       * "click" events like "click", "dblclick", "mousedown", "mouseup" or "contextmenu".
       *
       * But still, browsers act different on click:
       * <pre>
       * <- = left mouse button
       * -> = right mouse button
       * ^  = middle mouse button
       *
       * Browser | click, dblclick | contextmenu
       * ---------------------------------------
       * Firefox | <- ^ ->         | ->
       * Chrome  | <- ^            | ->
       * Safari  | <- ^            | ->
       * IE      | <- (^ is <-)    | ->
       * Opera   | <-              | -> (twice)
       * </pre>
       *
       * @return {String} One of "left", "right", "middle" or "none"
       */
      getButton : function(){

        switch(this._type){case i:
        return a;case j:
        // IE does not support buttons on click --> assume left button
        if(qx.core.Environment.get(f) === e && qx.core.Environment.get(g) < 9){

          return b;
        };default:
        if(this._native.target !== undefined){

          return this.__buttonsDom2EventModel[this._native.button] || d;
        } else {

          return this.__buttonsMshtmlEventModel[this._native.button] || d;
        };};
      },
      /**
       * Whether the left button is pressed
       *
       * @return {Boolean} true when the left button is pressed
       */
      isLeftPressed : function(){

        return this.getButton() === b;
      },
      /**
       * Whether the middle button is pressed
       *
       * @return {Boolean} true when the middle button is pressed
       */
      isMiddlePressed : function(){

        return this.getButton() === c;
      },
      /**
       * Whether the right button is pressed
       *
       * @return {Boolean} true when the right button is pressed
       */
      isRightPressed : function(){

        return this.getButton() === a;
      },
      /**
       * Get a secondary event target related to an UI event. This attribute is
       * used with the mouseover event to indicate the event target which the
       * pointing device exited and with the mouseout event to indicate the
       * event target which the pointing device entered.
       *
       * @return {Element} The secondary event target.
       * @signature function()
       */
      getRelatedTarget : function(){

        return this._relatedTarget;
      },
      /**
       * Get the he horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Integer} The horizontal mouse position
       */
      getViewportLeft : function(){

        return this._native.clientX;
      },
      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @return {Integer} The vertical mouse position
       * @signature function()
       */
      getViewportTop : function(){

        return this._native.clientY;
      },
      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Integer} The horizontal mouse position in the document.
       */
      getDocumentLeft : function(){

        if(this._native.pageX !== undefined){

          return this._native.pageX;
        } else {

          var m = qx.dom.Node.getWindow(this._native.srcElement);
          return this._native.clientX + qx.bom.Viewport.getScrollLeft(m);
        };
      },
      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Integer} The vertical mouse position in the document.
       */
      getDocumentTop : function(){

        if(this._native.pageY !== undefined){

          return this._native.pageY;
        } else {

          var n = qx.dom.Node.getWindow(this._native.srcElement);
          return this._native.clientY + qx.bom.Viewport.getScrollTop(n);
        };
      },
      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Integer} The horizontal mouse position on the screen.
       */
      getScreenLeft : function(){

        return this._native.screenX;
      },
      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * Note: This value is usually not very useful unless you want to
       * position a native popup window at this coordinate.
       *
       * @return {Integer} The vertical mouse position on the screen.
       */
      getScreenTop : function(){

        return this._native.screenY;
      }
    }
  });
})();
(function(){

  var l = "engine.name",k = "x",j = "osx",i = "win",h = "qx.dynamicmousewheel",g = "chrome",f = "qx.event.type.MouseWheel",d = "browser.name",c = "y",b = "os.name",a = "engine.version";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mouse wheel event object.
   */
  qx.Class.define(f, {
    extend : qx.event.type.Mouse,
    statics : {
      /**
       * The maximal mesured scroll wheel delta.
       * @internal
       */
      MAXSCROLL : null,
      /**
       * The minimal mesured scroll wheel delta.
       * @internal
       */
      MINSCROLL : null,
      /**
       * The normalization factor for the speed calculation.
       * @internal
       */
      FACTOR : 1
    },
    members : {
      // overridden
      stop : function(){

        this.stopPropagation();
        this.preventDefault();
      },
      /**
       * Normalizer for the mouse wheel data.
       *
       * @param delta {Number} The mouse delta.
       */
      __normalize : function(m){

        var n = Math.abs(m);
        // store the min value
        if(qx.event.type.MouseWheel.MINSCROLL == null || qx.event.type.MouseWheel.MINSCROLL > n){

          qx.event.type.MouseWheel.MINSCROLL = n;
          this.__recalculateMultiplicator();
        };
        // store the max value
        if(qx.event.type.MouseWheel.MAXSCROLL == null || qx.event.type.MouseWheel.MAXSCROLL < n){

          qx.event.type.MouseWheel.MAXSCROLL = n;
          this.__recalculateMultiplicator();
        };
        // special case for systems not speeding up
        if(qx.event.type.MouseWheel.MAXSCROLL === n && qx.event.type.MouseWheel.MINSCROLL === n){

          return 2 * (m / n);
        };
        var o = qx.event.type.MouseWheel.MAXSCROLL - qx.event.type.MouseWheel.MINSCROLL;
        var p = (m / o) * Math.log(o) * qx.event.type.MouseWheel.FACTOR;
        // return at least 1 or -1
        return p < 0 ? Math.min(p, -1) : Math.max(p, 1);
      },
      /**
       * Recalculates the factor with which the calculated delta is normalized.
       */
      __recalculateMultiplicator : function(){

        var q = qx.event.type.MouseWheel.MAXSCROLL || 0;
        var t = qx.event.type.MouseWheel.MINSCROLL || q;
        if(q <= t){

          return;
        };
        var r = q - t;
        var s = (q / r) * Math.log(r);
        if(s == 0){

          s = 1;
        };
        qx.event.type.MouseWheel.FACTOR = 6 / s;
      },
      /**
       * Get the amount the wheel has been scrolled
       *
       * @param axis {String?} Optional parameter which definex the scroll axis.
       *   The value can either be <code>"x"</code> or <code>"y"</code>.
       * @return {Integer} Scroll wheel movement for the given axis. If no axis
       *   is given, the y axis is used.
       */
      getWheelDelta : function(u){

        var e = this._native;
        // default case
        if(u === undefined){

          if(v === undefined){

            // default case
            var v = -e.wheelDelta;
            if(e.wheelDelta === undefined){

              v = e.detail;
            };
          };
          return this.__convertWheelDelta(v);
        };
        // get the x scroll delta
        if(u === k){

          var x = 0;
          if(e.wheelDelta !== undefined){

            if(e.wheelDeltaX !== undefined){

              x = e.wheelDeltaX ? this.__convertWheelDelta(-e.wheelDeltaX) : 0;
            };
          } else {

            if(e.axis && e.axis == e.HORIZONTAL_AXIS){

              x = this.__convertWheelDelta(e.detail);
            };
          };
          return x;
        };
        // get the y scroll delta
        if(u === c){

          var y = 0;
          if(e.wheelDelta !== undefined){

            if(e.wheelDeltaY !== undefined){

              y = e.wheelDeltaY ? this.__convertWheelDelta(-e.wheelDeltaY) : 0;
            } else {

              y = this.__convertWheelDelta(-e.wheelDelta);
            };
          } else {

            if(!(e.axis && e.axis == e.HORIZONTAL_AXIS)){

              y = this.__convertWheelDelta(e.detail);
            };
          };
          return y;
        };
        // default case, return 0
        return 0;
      },
      /**
       * Get the amount the wheel has been scrolled
       *
       * @param delta {Integer} The delta which is given by the mouse event.
       * @return {Integer} Scroll wheel movement
       */
      __convertWheelDelta : function(w){

        // new feature detectiong behavior
        if(qx.core.Environment.get(h)){

          return this.__normalize(w);
        } else {

          var z = qx.core.Environment.select(l, {
            "default" : function(){

              return w / 40;
            },
            "gecko" : function(){

              return w;
            },
            "webkit" : function(){

              if(qx.core.Environment.get(d) == g){

                // mac has a much higher sppedup during scrolling
                if(qx.core.Environment.get(b) == j){

                  return w / 60;
                } else {

                  return w / 120;
                };
              } else {

                // windows safaris behave different than on OSX
                if(qx.core.Environment.get(b) == i){

                  var A = 120;
                  // safari 5.0 and not 5.0.1
                  if(parseFloat(qx.core.Environment.get(a)) == 533.16){

                    A = 1200;
                  };
                } else {

                  A = 40;
                  // Safari 5.0 or 5.0.1
                  if(parseFloat(qx.core.Environment.get(a)) == 533.16 || parseFloat(qx.core.Environment.get(a)) == 533.17 || parseFloat(qx.core.Environment.get(a)) == 533.18){

                    A = 1200;
                  };
                };
                return w / A;
              };
            }
          });
          return z.call(this);
        };
      }
    }
  });
})();
(function(){

  var g = "qx.dom.Hierarchy",f = "previousSibling",e = "nextSibling",d = "parentNode",c = "*",b = "html.element.compareDocumentPosition",a = "html.element.contains";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Prototype JS
       http://www.prototypejs.org/
       Version 1.5
  
       Copyright:
         (c) 2006-2007, Prototype Core Team
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Prototype Core Team
  
     ----------------------------------------------------------------------
  
       Copyright (c) 2005-2008 Sam Stephenson
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */
  /**
   * Methods to operate on nodes and elements on a DOM tree. This contains
   * special getters to query for child nodes, siblings, etc. This class also
   * supports to operate on one element and reorganize the content with
   * the insertion of new HTML or nodes.
   */
  qx.Bootstrap.define(g, {
    statics : {
      /**
       * Returns the DOM index of the given node
       *
       * @param node {Node} Node to look for
       * @return {Integer} The DOM index
       */
      getNodeIndex : function(h){

        var i = 0;
        while(h && (h = h.previousSibling)){

          i++;
        };
        return i;
      },
      /**
       * Returns the DOM index of the given element (ignoring non-elements)
       *
       * @param element {Element} Element to look for
       * @return {Integer} The DOM index
       */
      getElementIndex : function(j){

        var k = 0;
        var l = qx.dom.Node.ELEMENT;
        while(j && (j = j.previousSibling)){

          if(j.nodeType == l){

            k++;
          };
        };
        return k;
      },
      /**
       * Return the next element to the supplied element
       *
       * "nextSibling" is not good enough as it might return a text or comment element
       *
       * @param element {Element} Starting element node
       * @return {Element | null} Next element node
       */
      getNextElementSibling : function(m){

        while(m && (m = m.nextSibling) && !qx.dom.Node.isElement(m)){

          continue;
        };
        return m || null;
      },
      /**
       * Return the previous element to the supplied element
       *
       * "previousSibling" is not good enough as it might return a text or comment element
       *
       * @param element {Element} Starting element node
       * @return {Element | null} Previous element node
       */
      getPreviousElementSibling : function(n){

        while(n && (n = n.previousSibling) && !qx.dom.Node.isElement(n)){

          continue;
        };
        return n || null;
      },
      /**
       * Whether the first element contains the second one
       *
       * Uses native non-standard contains() in Internet Explorer,
       * Opera and Webkit (supported since Safari 3.0 beta)
       *
       * @param element {Element} Parent element
       * @param target {Node} Child node
       * @return {Boolean}
       */
      contains : function(o, p){

        if(qx.core.Environment.get(a)){

          if(qx.dom.Node.isDocument(o)){

            var q = qx.dom.Node.getDocument(p);
            return o && q == o;
          } else if(qx.dom.Node.isDocument(p)){

            return false;
          } else {

            return o.contains(p);
          };
        } else if(qx.core.Environment.get(b)){

          // http://developer.mozilla.org/en/docs/DOM:Node.compareDocumentPosition
          return !!(o.compareDocumentPosition(p) & 16);
        } else {

          while(p){

            if(o == p){

              return true;
            };
            p = p.parentNode;
          };
          return false;
        };
      },
      /**
       * Whether the element is inserted into the document
       * for which it was created.
       *
       * @param element {Element} DOM element to check
       * @return {Boolean} <code>true</code> when the element is inserted
       *    into the document.
       */
      isRendered : function(r){

        var s = r.ownerDocument || r.document;
        if(qx.core.Environment.get(a)){

          // Fast check for all elements which are not in the DOM
          if(!r.parentNode || !r.offsetParent){

            return false;
          };
          return s.body.contains(r);
        } else if(qx.core.Environment.get(b)){

          // Gecko way, DOM3 method
          return !!(s.compareDocumentPosition(r) & 16);
        } else {

          while(r){

            if(r == s.body){

              return true;
            };
            r = r.parentNode;
          };
          return false;
        };
      },
      /**
       * Checks if <code>element</code> is a descendant of <code>ancestor</code>.
       *
       * @param element {Element} first element
       * @param ancestor {Element} second element
       * @return {Boolean} Element is a descendant of ancestor
       */
      isDescendantOf : function(t, u){

        return this.contains(u, t);
      },
      /**
       * Get the common parent element of two given elements. Returns
       * <code>null</code> when no common element has been found.
       *
       * Uses native non-standard contains() in Opera and Internet Explorer
       *
       * @param element1 {Element} First element
       * @param element2 {Element} Second element
       * @return {Element} the found parent, if none was found <code>null</code>
       */
      getCommonParent : function(v, w){

        if(v === w){

          return v;
        };
        if(qx.core.Environment.get(a)){

          while(v && qx.dom.Node.isElement(v)){

            if(v.contains(w)){

              return v;
            };
            v = v.parentNode;
          };
          return null;
        } else {

          var x = [];
          while(v || w){

            if(v){

              if(qx.lang.Array.contains(x, v)){

                return v;
              };
              x.push(v);
              v = v.parentNode;
            };
            if(w){

              if(qx.lang.Array.contains(x, w)){

                return w;
              };
              x.push(w);
              w = w.parentNode;
            };
          };
          return null;
        };
      },
      /**
       * Collects all of element's ancestors and returns them as an array of
       * elements.
       *
       * @param element {Element} DOM element to query for ancestors
       * @return {Array} list of all parents
       */
      getAncestors : function(y){

        return this._recursivelyCollect(y, d);
      },
      /**
       * Returns element's children.
       *
       * @param element {Element} DOM element to query for child elements
       * @return {Array} list of all child elements
       */
      getChildElements : function(z){

        z = z.firstChild;
        if(!z){

          return [];
        };
        var A = this.getNextSiblings(z);
        if(z.nodeType === 1){

          A.unshift(z);
        };
        return A;
      },
      /**
       * Collects all of element's descendants (deep) and returns them as an array
       * of elements.
       *
       * @param element {Element} DOM element to query for child elements
       * @return {Array} list of all found elements
       */
      getDescendants : function(B){

        return qx.lang.Array.fromCollection(B.getElementsByTagName(c));
      },
      /**
       * Returns the first child that is an element. This is opposed to firstChild DOM
       * property which will return any node (whitespace in most usual cases).
       *
       * @param element {Element} DOM element to query for first descendant
       * @return {Element} the first descendant
       */
      getFirstDescendant : function(C){

        C = C.firstChild;
        while(C && C.nodeType != 1){

          C = C.nextSibling;
        };
        return C;
      },
      /**
       * Returns the last child that is an element. This is opposed to lastChild DOM
       * property which will return any node (whitespace in most usual cases).
       *
       * @param element {Element} DOM element to query for last descendant
       * @return {Element} the last descendant
       */
      getLastDescendant : function(D){

        D = D.lastChild;
        while(D && D.nodeType != 1){

          D = D.previousSibling;
        };
        return D;
      },
      /**
       * Collects all of element's previous siblings and returns them as an array of elements.
       *
       * @param element {Element} DOM element to query for previous siblings
       * @return {Array} list of found DOM elements
       */
      getPreviousSiblings : function(E){

        return this._recursivelyCollect(E, f);
      },
      /**
       * Collects all of element's next siblings and returns them as an array of
       * elements.
       *
       * @param element {Element} DOM element to query for next siblings
       * @return {Array} list of found DOM elements
       */
      getNextSiblings : function(F){

        return this._recursivelyCollect(F, e);
      },
      /**
       * Recursively collects elements whose relationship is specified by
       * property.  <code>property</code> has to be a property (a method won't
       * do!) of element that points to a single DOM node. Returns an array of
       * elements.
       *
       * @param element {Element} DOM element to start with
       * @param property {String} property to look for
       * @return {Array} result list
       */
      _recursivelyCollect : function(G, H){

        var I = [];
        while(G = G[H]){

          if(G.nodeType == 1){

            I.push(G);
          };
        };
        return I;
      },
      /**
       * Collects all of element's siblings and returns them as an array of elements.
       *
       * @param element {var} DOM element to start with
       * @return {Array} list of all found siblings
       */
      getSiblings : function(J){

        return this.getPreviousSiblings(J).reverse().concat(this.getNextSiblings(J));
      },
      /**
       * Whether the given element is empty.
       * Inspired by Base2 (Dean Edwards)
       *
       * @param element {Element} The element to check
       * @return {Boolean} true when the element is empty
       */
      isEmpty : function(K){

        K = K.firstChild;
        while(K){

          if(K.nodeType === qx.dom.Node.ELEMENT || K.nodeType === qx.dom.Node.TEXT){

            return false;
          };
          K = K.nextSibling;
        };
        return true;
      },
      /**
       * Removes all of element's text nodes which contain only whitespace
       *
       * @param element {Element} Element to cleanup
       * @return {void}
       */
      cleanWhitespace : function(L){

        var M = L.firstChild;
        while(M){

          var N = M.nextSibling;
          if(M.nodeType == 3 && !/\S/.test(M.nodeValue)){

            L.removeChild(M);
          };
          M = N;
        };
      }
    }
  });
})();
(function(){

  var k = "PageUp",j = "Escape",i = "Enter",h = "PrintScreen",g = "7",f = "Left",e = "5",d = "F5",c = "Down",b = "Up",bi = "3",bh = "Meta",bg = "F11",bf = "F6",be = "PageDown",bd = "CapsLock",bc = "Insert",bb = "F8",ba = "Scroll",Y = "Control",r = "Tab",s = "Shift",p = "End",q = "Pause",n = "Unidentified",o = "8",l = "F1",m = "F4",v = "Home",w = "qx.event.util.Keyboard",E = "F2",C = "6",M = "F7",H = "Apps",U = "4",R = "F12",y = "Alt",X = "2",W = "NumLock",V = "Delete",x = "1",A = "Backspace",B = "F9",D = "F10",F = "Right",I = "F3",O = ",",T = "-",t = "+",u = "os.name",z = "A",L = "Space",K = "osx",J = "/",Q = "Z",P = "*",G = "cmd",N = "Win",a = "0",S = "9";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Utilities for working with character codes and key identifiers
   */
  qx.Bootstrap.define(w, {
    statics : {
      /*
      ---------------------------------------------------------------------------
        KEY MAPS
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} maps the charcodes of special printable keys to key identifiers
       *
       * @lint ignoreReferenceField(specialCharCodeMap)
       */
      specialCharCodeMap : {
        '8' : A,
        // The Backspace (Back) key.
        '9' : r,
        // The Horizontal Tabulation (Tab) key.
        //   Note: This key identifier is also used for the
        //   Return (Macintosh numpad) key.
        '13' : i,
        // The Enter key.
        '27' : j,
        // The Escape (Esc) key.
        '32' : L
      },
      /**
       * {Map} maps the keycodes of the numpad keys to the right charcodes
       *
       * @lint ignoreReferenceField(numpadToCharCode)
       */
      numpadToCharCode : {
        '96' : a.charCodeAt(0),
        '97' : x.charCodeAt(0),
        '98' : X.charCodeAt(0),
        '99' : bi.charCodeAt(0),
        '100' : U.charCodeAt(0),
        '101' : e.charCodeAt(0),
        '102' : C.charCodeAt(0),
        '103' : g.charCodeAt(0),
        '104' : o.charCodeAt(0),
        '105' : S.charCodeAt(0),
        '106' : P.charCodeAt(0),
        '107' : t.charCodeAt(0),
        '109' : T.charCodeAt(0),
        '110' : O.charCodeAt(0),
        '111' : J.charCodeAt(0)
      },
      /**
       * {Map} maps the keycodes of non printable keys to key identifiers
       *
       * @lint ignoreReferenceField(keyCodeToIdentifierMap)
       */
      keyCodeToIdentifierMap : {
        '16' : s,
        // The Shift key.
        '17' : Y,
        // The Control (Ctrl) key.
        '18' : y,
        // The Alt (Menu) key.
        '20' : bd,
        // The CapsLock key
        '224' : bh,
        // The Meta key. (Apple Meta and Windows key)
        '37' : f,
        // The Left Arrow key.
        '38' : b,
        // The Up Arrow key.
        '39' : F,
        // The Right Arrow key.
        '40' : c,
        // The Down Arrow key.
        '33' : k,
        // The Page Up key.
        '34' : be,
        // The Page Down (Next) key.
        '35' : p,
        // The End key.
        '36' : v,
        // The Home key.
        '45' : bc,
        // The Insert (Ins) key. (Does not fire in Opera/Win)
        '46' : V,
        // The Delete (Del) Key.
        '112' : l,
        // The F1 key.
        '113' : E,
        // The F2 key.
        '114' : I,
        // The F3 key.
        '115' : m,
        // The F4 key.
        '116' : d,
        // The F5 key.
        '117' : bf,
        // The F6 key.
        '118' : M,
        // The F7 key.
        '119' : bb,
        // The F8 key.
        '120' : B,
        // The F9 key.
        '121' : D,
        // The F10 key.
        '122' : bg,
        // The F11 key.
        '123' : R,
        // The F12 key.
        '144' : W,
        // The Num Lock key.
        '44' : h,
        // The Print Screen (PrintScrn, SnapShot) key.
        '145' : ba,
        // The scroll lock key
        '19' : q,
        // The pause/break key
        // The left Windows Logo key or left cmd key
        '91' : qx.core.Environment.get(u) == K ? G : N,
        '92' : N,
        // The right Windows Logo key or left cmd key
        // The Application key (Windows Context Menu) or right cmd key
        '93' : qx.core.Environment.get(u) == K ? G : H
      },
      /** char code for capital A */
      charCodeA : z.charCodeAt(0),
      /** char code for capital Z */
      charCodeZ : Q.charCodeAt(0),
      /** char code for 0 */
      charCode0 : a.charCodeAt(0),
      /** char code for 9 */
      charCode9 : S.charCodeAt(0),
      /**
       * converts a keyboard code to the corresponding identifier
       *
       * @param keyCode {Integer} key code
       * @return {String} key identifier
       */
      keyCodeToIdentifier : function(bj){

        if(this.isIdentifiableKeyCode(bj)){

          var bk = this.numpadToCharCode[bj];
          if(bk){

            return String.fromCharCode(bk);
          };
          return (this.keyCodeToIdentifierMap[bj] || this.specialCharCodeMap[bj] || String.fromCharCode(bj));
        } else {

          return n;
        };
      },
      /**
       * converts a character code to the corresponding identifier
       *
       * @param charCode {String} character code
       * @return {String} key identifier
       */
      charCodeToIdentifier : function(bl){

        return this.specialCharCodeMap[bl] || String.fromCharCode(bl).toUpperCase();
      },
      /**
       * Check whether the keycode can be reliably detected in keyup/keydown events
       *
       * @param keyCode {String} key code to check.
       * @return {Boolean} Whether the keycode can be reliably detected in keyup/keydown events.
       */
      isIdentifiableKeyCode : function(bm){

        // A-Z (TODO: is this lower or uppercase?)
        if(bm >= this.charCodeA && bm <= this.charCodeZ){

          return true;
        };
        // 0-9
        if(bm >= this.charCode0 && bm <= this.charCode9){

          return true;
        };
        // Enter, Space, Tab, Backspace
        if(this.specialCharCodeMap[bm]){

          return true;
        };
        // Numpad
        if(this.numpadToCharCode[bm]){

          return true;
        };
        // non printable keys
        if(this.isNonPrintableKeyCode(bm)){

          return true;
        };
        return false;
      },
      /**
       * Checks whether the keyCode represents a non printable key
       *
       * @param keyCode {String} key code to check.
       * @return {Boolean} Whether the keyCode represents a non printable key.
       */
      isNonPrintableKeyCode : function(bn){

        return this.keyCodeToIdentifierMap[bn] ? true : false;
      },
      /**
       * Checks whether a given string is a valid keyIdentifier
       *
       * @param keyIdentifier {String} The key identifier.
       * @return {Boolean} whether the given string is a valid keyIdentifier
       */
      isValidKeyIdentifier : function(bo){

        if(this.identifierToKeyCodeMap[bo]){

          return true;
        };
        if(bo.length != 1){

          return false;
        };
        if(bo >= a && bo <= S){

          return true;
        };
        if(bo >= z && bo <= Q){

          return true;
        };
        switch(bo){case t:case T:case P:case J:
        return true;default:
        return false;};
      },
      /**
       * Checks whether a given string is a printable keyIdentifier.
       *
       * @param keyIdentifier {String} The key identifier.
       * @return {Boolean} whether the given string is a printable keyIdentifier.
       */
      isPrintableKeyIdentifier : function(bp){

        if(bp === L){

          return true;
        } else {

          return this.identifierToKeyCodeMap[bp] ? false : true;
        };
      }
    },
    defer : function(bq, br){

      // construct inverse of keyCodeToIdentifierMap
      if(!bq.identifierToKeyCodeMap){

        bq.identifierToKeyCodeMap = {
        };
        for(var bs in bq.keyCodeToIdentifierMap){

          bq.identifierToKeyCodeMap[bq.keyCodeToIdentifierMap[bs]] = parseInt(bs, 10);
        };
        for(var bs in bq.specialCharCodeMap){

          bq.identifierToKeyCodeMap[bq.specialCharCodeMap[bs]] = parseInt(bs, 10);
        };
      };
    }
  });
})();
(function(){

  var j = "text",i = "os.name",h = "F11",g = "PrintScreen",f = "PageUp",e = "gecko",d = "F1",c = "Left",b = "F5",a = "Down",V = "Up",U = "F3",T = "Use qx.event.util.Keyboard.isValidKeyIdentifier instead.",S = "Use qx.event.util.Keyboard.keyCodeToIdentifier instead.",R = "F6",Q = "Insert",P = "F8",O = "input",N = "End",M = "Delete",q = "qx.event.handler.Keyboard",r = "win",o = "Use qx.event.util.Keyboard.isNonPrintableKeyCode instead.",p = "Home",m = "F2",n = "Use qx.event.util.Keyboard.charCodeToIdentifier instead.",k = "Use qx.event.util.Keyboard.isPrintableKeyIdentifier instead.",l = "Right",s = "F12",t = "F4",A = "PageDown",y = "F7",E = "Use qx.event.util.Keyboard.isIdentifiableKeyCode instead.",C = "F9",I = "F10",G = "off",v = "autoComplete",L = "Enter",K = "NumLock",J = "useraction",u = "keyinput",w = "mshtml",x = "webkit",z = "engine.version",B = "keyup",D = "keypress",F = "engine.name",H = "keydown";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.UserAction)
  
  ************************************************************************ */
  /**
   * This class provides unified key event handler for Internet Explorer,
   * Firefox, Opera and Safari.
   */
  qx.Class.define(q, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(W){

      qx.core.Object.call(this);
      // Define shorthands
      this.__manager = W;
      this.__window = W.getWindow();
      // Gecko ignores key events when not explicitly clicked in the document.
      if((qx.core.Environment.get(F) == e)){

        this.__root = this.__window;
      } else {

        this.__root = this.__window.document.documentElement;
      };
      // Internal sequence cache
      this.__lastUpDownType = {
      };
      // Initialize observer
      this._initKeyObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        keyup : 1,
        keydown : 1,
        keypress : 1,
        keyinput : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true,
      /**
       * Checks whether a given string is a valid keyIdentifier
       *
       * @param keyIdentifier {String} The key identifier.
       * @return {Boolean} whether the given string is a valid keyIdentifier
       * @deprecated since 2.0
       */
      isValidKeyIdentifier : function(X){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, T);
        return qx.event.util.Keyboard.isValidKeyIdentifier(X);
      },
      /**
       * Checks whether a given string is a printable keyIdentifier.
       *
       * @param keyIdentifier {String} The key identifier.
       * @return {Boolean} whether the given string is a printable keyIdentifier.
       * @deprecated since 2.0
       */
      isPrintableKeyIdentifier : function(Y){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, k);
        return qx.event.util.Keyboard.isPrintableKeyIdentifier(Y);
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __onKeyUpDownWrapper : null,
      __manager : null,
      __window : null,
      __root : null,
      __lastUpDownType : null,
      __lastKeyCode : null,
      __inputListeners : null,
      __onKeyPressWrapper : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(ba, bb){
      },
      // interface implementation
      registerEvent : function(bc, bd, be){
      },
      // interface implementation
      unregisterEvent : function(bf, bg, bh){
      },
      /*
      ---------------------------------------------------------------------------
        HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Fire a key input event with the given parameters
       *
       * @param domEvent {Event} DOM event
       * @param charCode {Integer} character code
       */
      _fireInputEvent : function(bi, bj){

        var bk = this.__getEventTarget();
        // Only fire when target is defined and visible
        if(bk && bk.offsetWidth != 0){

          var event = qx.event.Registration.createEvent(u, qx.event.type.KeyInput, [bi, bk, bj]);
          this.__manager.dispatchEvent(bk, event);
        };
        // Fire user action event
        // Needs to check if still alive first
        if(this.__window){

          qx.event.Registration.fireEvent(this.__window, J, qx.event.type.Data, [u]);
        };
      },
      /**
       * Fire a key up/down/press event with the given parameters
       *
       * @param domEvent {Event} DOM event
       * @param type {String} type og the event
       * @param keyIdentifier {String} key identifier
       */
      _fireSequenceEvent : function(bl, bm, bn){

        var bo = this.__getEventTarget();
        var bp = bl.keyCode;
        // Fire key event
        var event = qx.event.Registration.createEvent(bm, qx.event.type.KeySequence, [bl, bo, bn]);
        this.__manager.dispatchEvent(bo, event);
        // IE and Safari suppress a "keypress" event if the "keydown" event's
        // default action was prevented. In this case we emulate the "keypress"
        if(qx.core.Environment.get(F) == w || qx.core.Environment.get(F) == x){

          if(bm == H && event.getDefaultPrevented()){

            // some key press events are already emulated. Ignore these events.
            if(!qx.event.util.Keyboard.isNonPrintableKeyCode(bp) && !this._emulateKeyPress[bp]){

              this._fireSequenceEvent(bl, D, bn);
            };
          };
        };
        // Fire user action event
        // Needs to check if still alive first
        if(this.__window){

          qx.event.Registration.fireEvent(this.__window, J, qx.event.type.Data, [bm]);
        };
      },
      /**
       * Get the target element for mouse events
       *
       * @return {Element} the event target element
       */
      __getEventTarget : function(){

        var bq = this.__manager.getHandler(qx.event.handler.Focus);
        var br = bq.getActive();
        // Fallback to focused element when active is null or invisible
        if(!br || br.offsetWidth == 0){

          br = bq.getFocus();
        };
        // Fallback to body when focused is null or invisible
        if(!br || br.offsetWidth == 0){

          br = this.__manager.getWindow().document.body;
        };
        return br;
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT/STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native key event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _initKeyObserver : function(){

        this.__onKeyUpDownWrapper = qx.lang.Function.listener(this.__onKeyUpDown, this);
        this.__onKeyPressWrapper = qx.lang.Function.listener(this.__onKeyPress, this);
        var Event = qx.bom.Event;
        Event.addNativeListener(this.__root, B, this.__onKeyUpDownWrapper);
        Event.addNativeListener(this.__root, H, this.__onKeyUpDownWrapper);
        Event.addNativeListener(this.__root, D, this.__onKeyPressWrapper);
      },
      /**
       * Stops the native key event listeners.
       *
       * @signature function()
       * @return {void}
       */
      _stopKeyObserver : function(){

        var Event = qx.bom.Event;
        Event.removeNativeListener(this.__root, B, this.__onKeyUpDownWrapper);
        Event.removeNativeListener(this.__root, H, this.__onKeyUpDownWrapper);
        Event.removeNativeListener(this.__root, D, this.__onKeyPressWrapper);
        for(var bt in (this.__inputListeners || {
        })){

          var bs = this.__inputListeners[bt];
          Event.removeNativeListener(bs.target, D, bs.callback);
        };
        delete (this.__inputListeners);
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT OBSERVERS
      ---------------------------------------------------------------------------
      */
      /**
       * Low level handler for "keyup" and "keydown" events
       *
       * @internal
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event object
       */
      __onKeyUpDown : qx.event.GlobalError.observeMethod(qx.core.Environment.select(F, {
        "mshtml" : function(bu){

          bu = window.event || bu;
          var bx = bu.keyCode;
          var bv = 0;
          var bw = bu.type;
          // Ignore the down in such sequences dp dp dp
          if(!(this.__lastUpDownType[bx] == H && bw == H)){

            this._idealKeyHandler(bx, bv, bw, bu);
          };
          // On non print-able character be sure to add a keypress event
          if(bw == H){

            // non-printable, backspace or tab
            if(qx.event.util.Keyboard.isNonPrintableKeyCode(bx) || this._emulateKeyPress[bx]){

              this._idealKeyHandler(bx, bv, D, bu);
            };
          };
          // Store last type
          this.__lastUpDownType[bx] = bw;
        },
        "gecko" : function(by){

          var bA = 0;
          var bC = by.keyCode;
          var bB = by.type;
          var bz = qx.event.util.Keyboard;
          // FF repeats under windows keydown events like IE
          if(qx.core.Environment.get(i) == r){

            var bD = bC ? bz.keyCodeToIdentifier(bC) : bz.charCodeToIdentifier(bA);
            if(!(this.__lastUpDownType[bD] == H && bB == H)){

              this._idealKeyHandler(bC, bA, bB, by);
            };
            // Store last type
            this.__lastUpDownType[bD] = bB;
          } else {

            this._idealKeyHandler(bC, bA, bB, by);
          };
          this.__firefoxInputFix(by.target, bB, bC);
        },
        "webkit" : function(bE){

          var bH = 0;
          var bF = 0;
          var bG = bE.type;
          // starting with Safari 3.1 (version 525.13) Apple switched the key
          // handling to match the IE behaviour.
          if(parseFloat(qx.core.Environment.get(z)) < 525.13){

            if(bG == B || bG == H){

              bH = this._charCode2KeyCode[bE.charCode] || bE.keyCode;
            } else {

              if(this._charCode2KeyCode[bE.charCode]){

                bH = this._charCode2KeyCode[bE.charCode];
              } else {

                bF = bE.charCode;
              };
            };
            this._idealKeyHandler(bH, bF, bG, bE);
          } else {

            bH = bE.keyCode;
            this._idealKeyHandler(bH, bF, bG, bE);
            // On non print-able character be sure to add a keypress event
            if(bG == H){

              // non-printable, backspace or tab
              if(qx.event.util.Keyboard.isNonPrintableKeyCode(bH) || this._emulateKeyPress[bH]){

                this._idealKeyHandler(bH, bF, D, bE);
              };
            };
            // Store last type
            this.__lastUpDownType[bH] = bG;
          };
        },
        "opera" : function(bI){

          this.__lastKeyCode = bI.keyCode;
          this._idealKeyHandler(bI.keyCode, 0, bI.type, bI);
        }
      })),
      /**
       * some keys like "up", "down", "pageup", "pagedown" do not bubble a
       * "keypress" event in Firefox. To work around this bug we attach keypress
       * listeners directly to the input events.
       *
       * https://bugzilla.mozilla.org/show_bug.cgi?id=467513
       *
       * @signature function(target, type, keyCode)
       * @param target {Element} The event target
       * @param type {String} The event type
       * @param keyCode {Integer} the key code
       */
      __firefoxInputFix : qx.core.Environment.select(F, {
        "gecko" : function(bJ, bK, bL){

          if(bK === H && (bL == 33 || bL == 34 || bL == 38 || bL == 40) && bJ.type == j && bJ.tagName.toLowerCase() === O && bJ.getAttribute(v) !== G){

            if(!this.__inputListeners){

              this.__inputListeners = {
              };
            };
            var bN = qx.core.ObjectRegistry.toHashCode(bJ);
            if(this.__inputListeners[bN]){

              return;
            };
            var self = this;
            this.__inputListeners[bN] = {
              target : bJ,
              callback : function(bO){

                qx.bom.Event.stopPropagation(bO);
                self.__onKeyPress(bO);
              }
            };
            var bM = qx.event.GlobalError.observeMethod(this.__inputListeners[bN].callback);
            qx.bom.Event.addNativeListener(bJ, D, bM);
          };
        },
        "default" : null
      }),
      /**
       * Low level key press handler
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event object
       */
      __onKeyPress : qx.event.GlobalError.observeMethod(qx.core.Environment.select(F, {
        "mshtml" : function(bP){

          bP = window.event || bP;
          if(this._charCode2KeyCode[bP.keyCode]){

            this._idealKeyHandler(this._charCode2KeyCode[bP.keyCode], 0, bP.type, bP);
          } else {

            this._idealKeyHandler(0, bP.keyCode, bP.type, bP);
          };
        },
        "gecko" : function(bQ){

          var bR = bQ.charCode;
          var bS = bQ.type;
          this._idealKeyHandler(bQ.keyCode, bR, bS, bQ);
        },
        "webkit" : function(bT){

          // starting with Safari 3.1 (version 525.13) Apple switched the key
          // handling to match the IE behaviour.
          if(parseFloat(qx.core.Environment.get(z)) < 525.13){

            var bW = 0;
            var bU = 0;
            var bV = bT.type;
            if(bV == B || bV == H){

              bW = this._charCode2KeyCode[bT.charCode] || bT.keyCode;
            } else {

              if(this._charCode2KeyCode[bT.charCode]){

                bW = this._charCode2KeyCode[bT.charCode];
              } else {

                bU = bT.charCode;
              };
            };
            this._idealKeyHandler(bW, bU, bV, bT);
          } else {

            if(this._charCode2KeyCode[bT.keyCode]){

              this._idealKeyHandler(this._charCode2KeyCode[bT.keyCode], 0, bT.type, bT);
            } else {

              this._idealKeyHandler(0, bT.keyCode, bT.type, bT);
            };
          };
        },
        "opera" : function(bX){

          var ca = bX.keyCode;
          var bY = bX.type;
          // Some keys are identified differently for key up/down and keypress
          // (e.g. "v" gets identified as "F7").
          // So we store the last key up/down keycode and compare it to the
          // current keycode.
          // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=603
          if(ca != this.__lastKeyCode){

            this._idealKeyHandler(0, this.__lastKeyCode, bY, bX);
          } else {

            if(qx.event.util.Keyboard.keyCodeToIdentifierMap[bX.keyCode]){

              this._idealKeyHandler(bX.keyCode, 0, bX.type, bX);
            } else {

              this._idealKeyHandler(0, bX.keyCode, bX.type, bX);
            };
          };
        }
      })),
      /*
      ---------------------------------------------------------------------------
        IDEAL KEY HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Key handler for an idealized browser.
       * Runs after the browser specific key handlers have normalized the key events.
       *
       * @param keyCode {String} keyboard code
       * @param charCode {String} character code
       * @param eventType {String} type of the event (keydown, keypress, keyup)
       * @param domEvent {Element} DomEvent
       * @return {void}
       */
      _idealKeyHandler : function(cb, cc, cd, ce){

        var cf;
        // Use: keyCode
        if(cb || (!cb && !cc)){

          cf = qx.event.util.Keyboard.keyCodeToIdentifier(cb);
          this._fireSequenceEvent(ce, cd, cf);
        } else {

          cf = qx.event.util.Keyboard.charCodeToIdentifier(cc);
          this._fireSequenceEvent(ce, D, cf);
          this._fireInputEvent(ce, cc);
        };
      },
      /*
      ---------------------------------------------------------------------------
        KEY MAPS
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} maps the charcodes of special keys for key press emulation
       *
       * @lint ignoreReferenceField(_emulateKeyPress)
       */
      _emulateKeyPress : qx.core.Environment.select(F, {
        "mshtml" : {
          '8' : true,
          '9' : true
        },
        "webkit" : {
          '8' : true,
          '9' : true,
          '27' : true
        },
        "default" : {
        }
      }),
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Checks whether the keyCode represents a non printable key
       *
       * @param keyCode {String} key code to check.
       * @return {Boolean} Whether the keyCode represents a non printable key.
       * @deprecated since 2.0
       */
      _isNonPrintableKeyCode : function(cg){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, o);
        return qx.event.util.Keyboard.isNonPrintableKeyCode(cg);
      },
      /**
       * Check whether the keycode can be reliably detected in keyup/keydown events
       *
       * @param keyCode {String} key code to check.
       * @return {Boolean} Whether the keycode can be reliably detected in keyup/keydown events.
       * @deprecated since 2.0
       */
      _isIdentifiableKeyCode : function(ch){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, E);
        return qx.event.util.Keyboard.isIdentifiableKeyCode(ch);
      },
      /**
       * converts a keyboard code to the corresponding identifier
       *
       * @param keyCode {Integer} key code
       * @return {String} key identifier
       * @deprecated since 2.0
       */
      _keyCodeToIdentifier : function(ci){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, S);
        return qx.event.util.Keyboard.keyCodeToIdentifier(ci);
      },
      /**
       * converts a character code to the corresponding identifier
       *
       * @param charCode {String} character code
       * @return {String} key identifier
       * @deprecated since 2.0
       */
      _charCodeToIdentifier : function(cj){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, n);
        return qx.event.util.Keyboard.charCodeToIdentifier(cj);
      },
      /**
       * converts a key identifier back to a keycode
       *
       * @param keyIdentifier {String} The key identifier to convert
       * @return {Integer} keyboard code
       */
      _identifierToKeyCode : function(ck){

        return qx.event.util.Keyboard.identifierToKeyCodeMap[ck] || ck.charCodeAt(0);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopKeyObserver();
      this.__lastKeyCode = this.__manager = this.__window = this.__root = this.__lastUpDownType = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(cl, cm){

      // register at the event handler
      qx.event.Registration.addHandler(cl);
      if((qx.core.Environment.get(F) == w)){

        cm._charCode2KeyCode = {
          '13' : 13,
          '27' : 27
        };
      } else if((qx.core.Environment.get(F) == x)){

        // starting with Safari 3.1 (version 525.13) Apple switched the key
        // handling to match the IE behaviour.
        if(parseFloat(qx.core.Environment.get(z)) < 525.13){

          cm._charCode2KeyCode = {
            // Safari/Webkit Mappings
            '63289' : cm._identifierToKeyCode(K),
            '63276' : cm._identifierToKeyCode(f),
            '63277' : cm._identifierToKeyCode(A),
            '63275' : cm._identifierToKeyCode(N),
            '63273' : cm._identifierToKeyCode(p),
            '63234' : cm._identifierToKeyCode(c),
            '63232' : cm._identifierToKeyCode(V),
            '63235' : cm._identifierToKeyCode(l),
            '63233' : cm._identifierToKeyCode(a),
            '63272' : cm._identifierToKeyCode(M),
            '63302' : cm._identifierToKeyCode(Q),
            '63236' : cm._identifierToKeyCode(d),
            '63237' : cm._identifierToKeyCode(m),
            '63238' : cm._identifierToKeyCode(U),
            '63239' : cm._identifierToKeyCode(t),
            '63240' : cm._identifierToKeyCode(b),
            '63241' : cm._identifierToKeyCode(R),
            '63242' : cm._identifierToKeyCode(y),
            '63243' : cm._identifierToKeyCode(P),
            '63244' : cm._identifierToKeyCode(C),
            '63245' : cm._identifierToKeyCode(I),
            '63246' : cm._identifierToKeyCode(h),
            '63247' : cm._identifierToKeyCode(s),
            '63248' : cm._identifierToKeyCode(g),
            '3' : cm._identifierToKeyCode(L),
            '12' : cm._identifierToKeyCode(K),
            '13' : cm._identifierToKeyCode(L)
          };
        } else {

          cm._charCode2KeyCode = {
            '13' : 13,
            '27' : 27
          };
        };
      };
    }
  });
})();
(function(){

  var a = "qx.event.type.KeyInput";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Keyboard input event object.
   *
   * the interface of this class is based on the DOM Level 3 keyboard event
   * interface: http://www.w3.org/TR/DOM-Level-3-Events/#events-keyboardevents
   */
  qx.Class.define(a, {
    extend : qx.event.type.Dom,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Initialize the fields of the event.
       *
       * @param domEvent {Event} DOM event
       * @param target {Object} The event target
       * @param charCode {Integer} the character code
       * @return {qx.event.type.KeyInput} The initialized key event instance
       */
      init : function(b, c, d){

        qx.event.type.Dom.prototype.init.call(this, b, c, null, true, true);
        this._charCode = d;
        return this;
      },
      // overridden
      clone : function(e){

        var f = qx.event.type.Dom.prototype.clone.call(this, e);
        f._charCode = this._charCode;
        return f;
      },
      /**
       * Unicode number of the pressed character.
       *
       * @return {Integer} Unicode number of the pressed character
       */
      getCharCode : function(){

        return this._charCode;
      },
      /**
       * Returns the pressed character
       *
       * @return {String} The character
       */
      getChar : function(){

        return String.fromCharCode(this._charCode);
      }
    }
  });
})();
(function(){

  var a = "qx.event.type.KeySequence";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Keyboard event object.
   *
   * the interface of this class is based on the DOM Level 3 keyboard event
   * interface: http://www.w3.org/TR/DOM-Level-3-Events/#events-keyboardevents
   */
  qx.Class.define(a, {
    extend : qx.event.type.Dom,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Initialize the fields of the event.
       *
       * @param domEvent {Event} DOM event
       * @param target {Object} The event target
       * @param identifier {String} Key identifier
       * @return {qx.event.type.KeySequence} The initialized key event instance
       */
      init : function(b, c, d){

        qx.event.type.Dom.prototype.init.call(this, b, c, null, true, true);
        this._keyCode = b.keyCode;
        this._identifier = d;
        return this;
      },
      // overridden
      clone : function(e){

        var f = qx.event.type.Dom.prototype.clone.call(this, e);
        f._keyCode = this._keyCode;
        f._identifier = this._identifier;
        return f;
      },
      /**
       * Identifier of the pressed key. This property is modeled after the <em>KeyboardEvent.keyIdentifier</em> property
       * of the W3C DOM 3 event specification
       * (http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-KeyboardEvent-keyIdentifier).
       *
       * Printable keys are represented by an unicode string, non-printable keys
       * have one of the following values:
       *
       * <table>
       * <tr><th>Backspace</th><td>The Backspace (Back) key.</td></tr>
       * <tr><th>Tab</th><td>The Horizontal Tabulation (Tab) key.</td></tr>
       * <tr><th>Space</th><td>The Space (Spacebar) key.</td></tr>
       * <tr><th>Enter</th><td>The Enter key. Note: This key identifier is also used for the Return (Macintosh numpad) key.</td></tr>
       * <tr><th>Shift</th><td>The Shift key.</td></tr>
       * <tr><th>Control</th><td>The Control (Ctrl) key.</td></tr>
       * <tr><th>Alt</th><td>The Alt (Menu) key.</td></tr>
       * <tr><th>CapsLock</th><td>The CapsLock key</td></tr>
       * <tr><th>Meta</th><td>The Meta key. (Apple Meta and Windows key)</td></tr>
       * <tr><th>Escape</th><td>The Escape (Esc) key.</td></tr>
       * <tr><th>Left</th><td>The Left Arrow key.</td></tr>
       * <tr><th>Up</th><td>The Up Arrow key.</td></tr>
       * <tr><th>Right</th><td>The Right Arrow key.</td></tr>
       * <tr><th>Down</th><td>The Down Arrow key.</td></tr>
       * <tr><th>PageUp</th><td>The Page Up key.</td></tr>
       * <tr><th>PageDown</th><td>The Page Down (Next) key.</td></tr>
       * <tr><th>End</th><td>The End key.</td></tr>
       * <tr><th>Home</th><td>The Home key.</td></tr>
       * <tr><th>Insert</th><td>The Insert (Ins) key. (Does not fire in Opera/Win)</td></tr>
       * <tr><th>Delete</th><td>The Delete (Del) Key.</td></tr>
       * <tr><th>F1</th><td>The F1 key.</td></tr>
       * <tr><th>F2</th><td>The F2 key.</td></tr>
       * <tr><th>F3</th><td>The F3 key.</td></tr>
       * <tr><th>F4</th><td>The F4 key.</td></tr>
       * <tr><th>F5</th><td>The F5 key.</td></tr>
       * <tr><th>F6</th><td>The F6 key.</td></tr>
       * <tr><th>F7</th><td>The F7 key.</td></tr>
       * <tr><th>F8</th><td>The F8 key.</td></tr>
       * <tr><th>F9</th><td>The F9 key.</td></tr>
       * <tr><th>F10</th><td>The F10 key.</td></tr>
       * <tr><th>F11</th><td>The F11 key.</td></tr>
       * <tr><th>F12</th><td>The F12 key.</td></tr>
       * <tr><th>NumLock</th><td>The Num Lock key.</td></tr>
       * <tr><th>PrintScreen</th><td>The Print Screen (PrintScrn, SnapShot) key.</td></tr>
       * <tr><th>Scroll</th><td>The scroll lock key</td></tr>
       * <tr><th>Pause</th><td>The pause/break key</td></tr>
       * <tr><th>Win</th><td>The Windows Logo key</td></tr>
       * <tr><th>Apps</th><td>The Application key (Windows Context Menu)</td></tr>
       * </table>
       *
       * @return {String} The key identifier
       */
      getKeyIdentifier : function(){

        return this._identifier;
      },
      /**
       * Returns the native keyCode and is best used on keydown/keyup events to
       * check which physical key was pressed.
       * Don't use this on keypress events because it's erroneous and
       * inconsistent across browsers. But it can be used to detect which key is
       * exactly pressed (e.g. for num pad keys).
       * In any regular case, you should use {@link #getKeyIdentifier} which
       * takes care of all cross browser stuff.
       *
       * The key codes are not character codes, they are just ASCII codes to
       * identify the keyboard (or other input devices) keys.
       *
       * @return {Number} The key code.
       */
      getKeyCode : function(){

        return this._keyCode;
      },
      /**
       * Checks whether the pressed key is printable.
       *
       * @return {Boolean} Whether the pressed key is printable.
       */
      isPrintable : function(){

        return qx.event.util.Keyboard.isPrintableKeyIdentifier(this._identifier);
      }
    }
  });
})();
(function(){

  var j = "qx.event.handler.Focus",i = "_applyFocus",h = "deactivate",g = "textarea",f = "_applyActive",e = 'character',d = "input",c = "qxSelectable",b = "tabIndex",a = "off",z = "activate",y = "mshtml",x = "qxKeepFocus",w = "qxKeepActive",v = "DOMFocusIn",u = "draggesture",t = "focusin",s = "focusout",r = "selectstart",q = "DOMFocusOut",o = "on",p = "blur",m = "focus",n = "mousedown",k = "mouseup",l = "engine.name";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.event.dispatch.DomBubbling)
  
  ************************************************************************ */
  /**
   * This handler is used to normalize all focus/activation requirements
   * and normalize all cross browser quirks in this area.
   *
   * Notes:
   *
   * * Webkit and Opera (before 9.5) do not support tabIndex for all elements
   * (See also: http://bugs.webkit.org/show_bug.cgi?id=7138)
   *
   * * TabIndex is normally 0, which means all naturally focusable elements are focusable.
   * * TabIndex > 0 means that the element is focusable and tabable
   * * TabIndex < 0 means that the element, even if naturally possible, is not focusable.
   */
  qx.Class.define(j, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(A){

      qx.core.Object.call(this);
      // Define shorthands
      this._manager = A;
      this._window = A.getWindow();
      this._document = this._window.document;
      this._root = this._document.documentElement;
      this._body = this._document.body;
      // Initialize
      this._initObserver();
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The active DOM element */
      active : {
        apply : f,
        nullable : true
      },
      /** The focussed DOM element */
      focus : {
        apply : i,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        focus : 1,
        blur : 1,
        focusin : 1,
        focusout : 1,
        activate : 1,
        deactivate : 1
      },
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true,
      /**
       * {Map} See: http://msdn.microsoft.com/en-us/library/ms534654(VS.85).aspx
       */
      FOCUSABLE_ELEMENTS : qx.core.Environment.select("engine.name", {
        "mshtml|gecko" : {
          a : 1,
          body : 1,
          button : 1,
          frame : 1,
          iframe : 1,
          img : 1,
          input : 1,
          object : 1,
          select : 1,
          textarea : 1
        },
        "opera|webkit" : {
          button : 1,
          input : 1,
          select : 1,
          textarea : 1
        }
      })
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __onNativeMouseDownWrapper : null,
      __onNativeMouseUpWrapper : null,
      __onNativeFocusWrapper : null,
      __onNativeBlurWrapper : null,
      __onNativeDragGestureWrapper : null,
      __onNativeSelectStartWrapper : null,
      __onNativeFocusInWrapper : null,
      __onNativeFocusOutWrapper : null,
      __previousFocus : null,
      __previousActive : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(B, C){
      },
      // interface implementation
      registerEvent : function(D, E, F){
      },
      // interface implementation
      unregisterEvent : function(G, H, I){
      },
      /*
      ---------------------------------------------------------------------------
        FOCUS/BLUR USER INTERFACE
      ---------------------------------------------------------------------------
      */
      /**
       * Focuses the given DOM element
       *
       * @param element {Element} DOM element to focus
       */
      focus : function(J){

        // Fixed timing issue with IE, see [BUG #3267]
        if((qx.core.Environment.get(l) == y)){

          window.setTimeout(function(){

            try{

              // focus element before set cursor position
              J.focus();
              // Fixed cursor position issue with IE, only when nothing is selected.
              // See [BUG #3519] for details.
              var K = qx.bom.Selection.get(J);
              if(K.length == 0){

                var L = J.createTextRange();
                L.moveStart(e, J.value.length);
                L.collapse();
                L.select();
              };
            } catch(M) {
            };
          }, 0);
        } else {

          try{

            J.focus();
          } catch(N) {
          };
        };
        this.setFocus(J);
        this.setActive(J);
      },
      /**
       * Activates the given DOM element
       *
       * @param element {Element} DOM element to activate
       */
      activate : function(O){

        this.setActive(O);
      },
      /**
       * Blurs the given DOM element
       *
       * @param element {Element} DOM element to focus
       */
      blur : function(P){

        try{

          P.blur();
        } catch(Q) {
        };
        if(this.getActive() === P){

          this.resetActive();
        };
        if(this.getFocus() === P){

          this.resetFocus();
        };
      },
      /**
       * Deactivates the given DOM element
       *
       * @param element {Element} DOM element to activate
       */
      deactivate : function(R){

        if(this.getActive() === R){

          this.resetActive();
        };
      },
      /**
       * Tries to activate the given element. This checks whether
       * the activation is allowed first.
       *
       * @param element {Element} DOM element to activate
       */
      tryActivate : function(S){

        var T = this.__findActivatableElement(S);
        if(T){

          this.setActive(T);
        };
      },
      /*
      ---------------------------------------------------------------------------
        HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Shorthand to fire events from within this class.
       *
       * @param target {Element} DOM element which is the target
       * @param related {Element} DOM element which is the related target
       * @param type {String} Name of the event to fire
       * @param bubbles {Boolean} Whether the event should bubble
       */
      __fireEvent : function(U, V, W, X){

        var ba = qx.event.Registration;
        var Y = ba.createEvent(W, qx.event.type.Focus, [U, V, X]);
        ba.dispatchEvent(U, Y);
      },
      /*
      ---------------------------------------------------------------------------
        WINDOW FOCUS/BLUR SUPPORT
      ---------------------------------------------------------------------------
      */
      /** {Boolean} Whether the window is focused currently */
      _windowFocused : true,
      /**
       * Helper for native event listeners to react on window blur
       */
      __doWindowBlur : function(){

        // Omit doubled blur events
        // which is a common behavior at least for gecko based clients
        if(this._windowFocused){

          this._windowFocused = false;
          this.__fireEvent(this._window, null, p, false);
        };
      },
      /**
       * Helper for native event listeners to react on window focus
       */
      __doWindowFocus : function(){

        // Omit doubled focus events
        // which is a common behavior at least for gecko based clients
        if(!this._windowFocused){

          this._windowFocused = true;
          this.__fireEvent(this._window, null, m, false);
        };
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE OBSERVER
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes event listeners.
       *
       * @signature function()
       */
      _initObserver : qx.core.Environment.select(l, {
        "gecko" : function(){

          // Bind methods
          this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
          this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
          this.__onNativeFocusWrapper = qx.lang.Function.listener(this.__onNativeFocus, this);
          this.__onNativeBlurWrapper = qx.lang.Function.listener(this.__onNativeBlur, this);
          this.__onNativeDragGestureWrapper = qx.lang.Function.listener(this.__onNativeDragGesture, this);
          // Register events
          qx.bom.Event.addNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.addNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          // Capturing is needed for gecko to correctly
          // handle focus of input and textarea fields
          qx.bom.Event.addNativeListener(this._window, m, this.__onNativeFocusWrapper, true);
          qx.bom.Event.addNativeListener(this._window, p, this.__onNativeBlurWrapper, true);
          // Capture drag events
          qx.bom.Event.addNativeListener(this._window, u, this.__onNativeDragGestureWrapper, true);
        },
        "mshtml" : function(){

          // Bind methods
          this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
          this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
          this.__onNativeFocusInWrapper = qx.lang.Function.listener(this.__onNativeFocusIn, this);
          this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
          this.__onNativeSelectStartWrapper = qx.lang.Function.listener(this.__onNativeSelectStart, this);
          // Register events
          qx.bom.Event.addNativeListener(this._document, n, this.__onNativeMouseDownWrapper);
          qx.bom.Event.addNativeListener(this._document, k, this.__onNativeMouseUpWrapper);
          // MSHTML supports their own focusin and focusout events
          // To detect which elements get focus the target is useful
          // The window blur can detected using focusout and look
          // for the toTarget property which is empty in this case.
          qx.bom.Event.addNativeListener(this._document, t, this.__onNativeFocusInWrapper);
          qx.bom.Event.addNativeListener(this._document, s, this.__onNativeFocusOutWrapper);
          // Add selectstart to prevent selection
          qx.bom.Event.addNativeListener(this._document, r, this.__onNativeSelectStartWrapper);
        },
        "webkit" : function(){

          // Bind methods
          this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
          this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
          this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
          this.__onNativeFocusWrapper = qx.lang.Function.listener(this.__onNativeFocus, this);
          this.__onNativeBlurWrapper = qx.lang.Function.listener(this.__onNativeBlur, this);
          this.__onNativeSelectStartWrapper = qx.lang.Function.listener(this.__onNativeSelectStart, this);
          // Register events
          qx.bom.Event.addNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.addNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          qx.bom.Event.addNativeListener(this._document, r, this.__onNativeSelectStartWrapper, false);
          qx.bom.Event.addNativeListener(this._window, q, this.__onNativeFocusOutWrapper, true);
          qx.bom.Event.addNativeListener(this._window, m, this.__onNativeFocusWrapper, true);
          qx.bom.Event.addNativeListener(this._window, p, this.__onNativeBlurWrapper, true);
        },
        "opera" : function(){

          // Bind methods
          this.__onNativeMouseDownWrapper = qx.lang.Function.listener(this.__onNativeMouseDown, this);
          this.__onNativeMouseUpWrapper = qx.lang.Function.listener(this.__onNativeMouseUp, this);
          this.__onNativeFocusInWrapper = qx.lang.Function.listener(this.__onNativeFocusIn, this);
          this.__onNativeFocusOutWrapper = qx.lang.Function.listener(this.__onNativeFocusOut, this);
          // Register events
          qx.bom.Event.addNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.addNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          qx.bom.Event.addNativeListener(this._window, v, this.__onNativeFocusInWrapper, true);
          qx.bom.Event.addNativeListener(this._window, q, this.__onNativeFocusOutWrapper, true);
        }
      }),
      /**
       * Disconnects event listeners.
       *
       * @signature function()
       */
      _stopObserver : qx.core.Environment.select(l, {
        "gecko" : function(){

          qx.bom.Event.removeNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.removeNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, m, this.__onNativeFocusWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, p, this.__onNativeBlurWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, u, this.__onNativeDragGestureWrapper, true);
        },
        "mshtml" : function(){

          qx.bom.Event.removeNativeListener(this._document, n, this.__onNativeMouseDownWrapper);
          qx.bom.Event.removeNativeListener(this._document, k, this.__onNativeMouseUpWrapper);
          qx.bom.Event.removeNativeListener(this._document, t, this.__onNativeFocusInWrapper);
          qx.bom.Event.removeNativeListener(this._document, s, this.__onNativeFocusOutWrapper);
          qx.bom.Event.removeNativeListener(this._document, r, this.__onNativeSelectStartWrapper);
        },
        "webkit" : function(){

          qx.bom.Event.removeNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.removeNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          qx.bom.Event.removeNativeListener(this._document, r, this.__onNativeSelectStartWrapper, false);
          qx.bom.Event.removeNativeListener(this._window, q, this.__onNativeFocusOutWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, m, this.__onNativeFocusWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, p, this.__onNativeBlurWrapper, true);
        },
        "opera" : function(){

          qx.bom.Event.removeNativeListener(this._document, n, this.__onNativeMouseDownWrapper, true);
          qx.bom.Event.removeNativeListener(this._document, k, this.__onNativeMouseUpWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, v, this.__onNativeFocusInWrapper, true);
          qx.bom.Event.removeNativeListener(this._window, q, this.__onNativeFocusOutWrapper, true);
        }
      }),
      /*
      ---------------------------------------------------------------------------
        NATIVE LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Native event listener for <code>draggesture</code> event
       * supported by gecko. Used to stop native drag and drop when
       * selection is disabled.
       *
       * @see http://developer.mozilla.org/en/docs/Drag_and_Drop
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeDragGesture : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "gecko" : function(bb){

          var bc = qx.bom.Event.getTarget(bb);
          if(!this.__isSelectable(bc)){

            qx.bom.Event.preventDefault(bb);
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>DOMFocusIn</code> or <code>focusin</code>
       * depending on the client's engine.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeFocusIn : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml" : function(bd){

          // Force window focus to be the first
          this.__doWindowFocus();
          // Update internal data
          var bf = qx.bom.Event.getTarget(bd);
          // IE focusin is also fired on elements which are not focusable at all
          // We need to look up for the next focusable element.
          var be = this.__findFocusableElement(bf);
          if(be){

            this.setFocus(be);
          };
          // Make target active
          this.tryActivate(bf);
        },
        "opera" : function(bg){

          var bh = qx.bom.Event.getTarget(bg);
          if(bh == this._document || bh == this._window){

            this.__doWindowFocus();
            if(this.__previousFocus){

              this.setFocus(this.__previousFocus);
              delete this.__previousFocus;
            };
            if(this.__previousActive){

              this.setActive(this.__previousActive);
              delete this.__previousActive;
            };
          } else {

            this.setFocus(bh);
            this.tryActivate(bh);
            // Clear selection
            if(!this.__isSelectable(bh)){

              bh.selectionStart = 0;
              bh.selectionEnd = 0;
            };
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>DOMFocusOut</code> or <code>focusout</code>
       * depending on the client's engine.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeFocusOut : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml" : function(bi){

          var bj = qx.bom.Event.getRelatedTarget(bi);
          // If the focus goes to nowhere (the document is blurred)
          if(bj == null){

            // Update internal representation
            this.__doWindowBlur();
            // Reset active and focus
            this.resetFocus();
            this.resetActive();
          };
        },
        "webkit" : function(bk){

          var bl = qx.bom.Event.getTarget(bk);
          if(bl === this.getFocus()){

            this.resetFocus();
          };
          if(bl === this.getActive()){

            this.resetActive();
          };
        },
        "opera" : function(bm){

          var bn = qx.bom.Event.getTarget(bm);
          if(bn == this._document){

            this.__doWindowBlur();
            // Store old focus/active elements
            // Opera do not fire focus events for them
            // when refocussing the window (in my opinion an error)
            this.__previousFocus = this.getFocus();
            this.__previousActive = this.getActive();
            this.resetFocus();
            this.resetActive();
          } else {

            if(bn === this.getFocus()){

              this.resetFocus();
            };
            if(bn === this.getActive()){

              this.resetActive();
            };
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>blur</code>.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeBlur : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "gecko" : function(bo){

          var bp = qx.bom.Event.getTarget(bo);
          if(bp === this._window || bp === this._document){

            this.__doWindowBlur();
            this.resetActive();
            this.resetFocus();
          };
        },
        "webkit" : function(bq){

          var br = qx.bom.Event.getTarget(bq);
          if(br === this._window || br === this._document){

            this.__doWindowBlur();
            // Store old focus/active elements
            // Opera do not fire focus events for them
            // when refocussing the window (in my opinion an error)
            this.__previousFocus = this.getFocus();
            this.__previousActive = this.getActive();
            this.resetActive();
            this.resetFocus();
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>focus</code>.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeFocus : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "gecko" : function(bs){

          var bt = qx.bom.Event.getTarget(bs);
          if(bt === this._window || bt === this._document){

            this.__doWindowFocus();
            // Always speak of the body, not the window or document
            bt = this._body;
          };
          this.setFocus(bt);
          this.tryActivate(bt);
        },
        "webkit" : function(bu){

          var bv = qx.bom.Event.getTarget(bu);
          if(bv === this._window || bv === this._document){

            this.__doWindowFocus();
            if(this.__previousFocus){

              this.setFocus(this.__previousFocus);
              delete this.__previousFocus;
            };
            if(this.__previousActive){

              this.setActive(this.__previousActive);
              delete this.__previousActive;
            };
          } else {

            this.setFocus(bv);
            this.tryActivate(bv);
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>mousedown</code>.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeMouseDown : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml" : function(bw){

          var by = qx.bom.Event.getTarget(bw);
          // Stop events when no focus element available (or blocked)
          var bx = this.__findFocusableElement(by);
          if(bx){

            // Add unselectable to keep selection
            if(!this.__isSelectable(by)){

              // The element is not selectable. Block selection.
              by.unselectable = o;
              // Unselectable may keep the current selection which
              // is not what we like when changing the focus element.
              // So we clear it
              try{

                document.selection.empty();
              } catch(bz) {
              };
              // The unselectable attribute stops focussing as well.
              // Do this manually.
              try{

                bx.focus();
              } catch(bA) {
              };
            };
          } else {

            // Stop event for blocking support
            qx.bom.Event.preventDefault(bw);
            // Add unselectable to keep selection
            if(!this.__isSelectable(by)){

              by.unselectable = o;
            };
          };
        },
        "webkit|gecko" : function(bB){

          var bD = qx.bom.Event.getTarget(bB);
          var bC = this.__findFocusableElement(bD);
          if(bC){

            this.setFocus(bC);
          } else {

            qx.bom.Event.preventDefault(bB);
          };
        },
        "opera" : function(bE){

          var bH = qx.bom.Event.getTarget(bE);
          var bF = this.__findFocusableElement(bH);
          if(!this.__isSelectable(bH)){

            // Prevent the default action for all non-selectable
            // targets. This prevents text selection and context menu.
            qx.bom.Event.preventDefault(bE);
            // The stopped event keeps the selection
            // of the previously focused element.
            // We need to clear the old selection.
            if(bF){

              var bG = this.getFocus();
              if(bG && bG.selectionEnd){

                bG.selectionStart = 0;
                bG.selectionEnd = 0;
                bG.blur();
              };
              // The prevented event also stop the focus, do
              // it manually if needed.
              if(bF){

                this.setFocus(bF);
              };
            };
          } else if(bF){

            this.setFocus(bF);
          };
        },
        "default" : null
      })),
      /**
       * Native event listener for <code>mouseup</code>.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeMouseUp : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml" : function(bI){

          var bJ = qx.bom.Event.getTarget(bI);
          if(bJ.unselectable){

            bJ.unselectable = a;
          };
          this.tryActivate(this.__fixFocus(bJ));
        },
        "gecko" : function(bK){

          // As of Firefox 3.0:
          // Gecko fires mouseup on XUL elements
          // We only want to deal with real HTML elements
          var bL = qx.bom.Event.getTarget(bK);
          while(bL && bL.offsetWidth === undefined){

            bL = bL.parentNode;
          };
          if(bL){

            this.tryActivate(bL);
          };
        },
        "webkit|opera" : function(bM){

          var bN = qx.bom.Event.getTarget(bM);
          this.tryActivate(this.__fixFocus(bN));
        },
        "default" : null
      })),
      /**
       * Fix for bug #2602.
       *
       * @signature function(target)
       * @param target {Element} target element from mouse up event
       * @return {Element} Element to activate;
       */
      __fixFocus : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml|webkit" : function(bO){

          var bP = this.getFocus();
          if(bP && bO != bP && (bP.nodeName.toLowerCase() === d || bP.nodeName.toLowerCase() === g)){

            bO = bP;
          };
          return bO;
        },
        "default" : function(bQ){

          return bQ;
        }
      })),
      /**
       * Native event listener for <code>selectstart</code>.
       *
       *@signature function(domEvent)
       * @param domEvent {Event} Native event
       */
      __onNativeSelectStart : qx.event.GlobalError.observeMethod(qx.core.Environment.select(l, {
        "mshtml|webkit" : function(bR){

          var bS = qx.bom.Event.getTarget(bR);
          if(!this.__isSelectable(bS)){

            qx.bom.Event.preventDefault(bR);
          };
        },
        "default" : null
      })),
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Whether the given element is focusable. This is perfectly modeled to the
       * browsers behavior and this way may differ in the various clients.
       *
       * @param el {Element} DOM Element to query
       * @return {Boolean} Whether the element is focusable
       */
      __isFocusable : function(bT){

        var bU = qx.bom.element.Attribute.get(bT, b);
        if(bU >= 1){

          return true;
        };
        var bV = qx.event.handler.Focus.FOCUSABLE_ELEMENTS;
        if(bU >= 0 && bV[bT.tagName]){

          return true;
        };
        return false;
      },
      /**
       * Returns the next focusable parent element of an activated DOM element.
       *
       * @param el {Element} Element to start lookup with.
       * @return {Element|null} The next focusable element.
       */
      __findFocusableElement : function(bW){

        while(bW && bW.nodeType === 1){

          if(bW.getAttribute(x) == o){

            return null;
          };
          if(this.__isFocusable(bW)){

            return bW;
          };
          bW = bW.parentNode;
        };
        // This should be identical to the one which is selected when
        // clicking into an empty page area. In mshtml this must be
        // the body of the document.
        return this._body;
      },
      /**
       * Returns the next activatable element. May be the element itself.
       * Works a bit different than the method {@link #__findFocusableElement}
       * as it looks up for a parent which is has a keep focus flag. When
       * there is such a parent it returns null otherwise the original
       * incoming element.
       *
       * @param el {Element} Element to start lookup with.
       * @return {Element} The next activatable element.
       */
      __findActivatableElement : function(bX){

        var bY = bX;
        while(bX && bX.nodeType === 1){

          if(bX.getAttribute(w) == o){

            return null;
          };
          bX = bX.parentNode;
        };
        return bY;
      },
      /**
       * Whether the given el (or its content) should be selectable
       * by the user.
       *
       * @param node {Element} Node to start lookup with
       * @return {Boolean} Whether the content is selectable.
       */
      __isSelectable : function(ca){

        while(ca && ca.nodeType === 1){

          var cb = ca.getAttribute(c);
          if(cb != null){

            return cb === o;
          };
          ca = ca.parentNode;
        };
        return true;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // apply routine
      _applyActive : function(cc, cd){

        /*
        var id = "null";
        if (value) {
          id = (value.tagName||value) + "[" + (value.$$hash || "none") + "]";
        }
        this.debug("Property Active: " + id);
        
        id = "null";
        if (old) {
          id = (old.tagName||old) + "[" + (old.$$hash || "none") + "]";
        }
        this.debug("Property Deactivate: " + id);
        */
        // Fire events
        if(cd){

          this.__fireEvent(cd, cc, h, true);
        };
        if(cc){

          this.__fireEvent(cc, cd, z, true);
        };
      },
      // apply routine
      _applyFocus : function(ce, cf){

        /*
        var id = "null";
        if (value) {
          id = (value.tagName||value) + "[" + (value.$$hash || "none") + "]";
        }
        this.debug("Property Focus: " + id);
        
        id = "null";
        if (old) {
          id = (old.tagName||old) + "[" + (old.$$hash || "none") + "]";
        }
        this.debug("Property Blur: " + id);
        */
        // Fire bubbling events
        if(cf){

          this.__fireEvent(cf, ce, s, true);
        };
        if(ce){

          this.__fireEvent(ce, cf, t, true);
        };
        // Fire after events
        if(cf){

          this.__fireEvent(cf, ce, p, false);
        };
        if(ce){

          this.__fireEvent(ce, cf, m, false);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopObserver();
      this._manager = this._window = this._document = this._root = this._body = this.__mouseActive = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(cg){

      qx.event.Registration.addHandler(cg);
      // For faster lookups generate uppercase tag names dynamically
      var ch = cg.FOCUSABLE_ELEMENTS;
      for(var ci in ch){

        ch[ci.toUpperCase()] = 1;
      };
    }
  });
})();
(function(){

  var k = "qx.bom.Selection",j = "button",i = "#text",h = "body",g = 'character',f = "input",e = "StartToStart",d = "textarea",c = "EndToEnd",b = "character",a = "engine.name";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  /**
   * Low-level selection API to select elements like input and textarea elements
   * as well as text nodes or elements which their child nodes.
   */
  qx.Class.define(k, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the native selection object.
       *
       * @signature documentNode {document} Document node to retrieve the connected selection
       * @param documentNode {Object} The document node
       * @return {Selection} native selection object
       */
      getSelectionObject : qx.core.Environment.select(a, {
        "mshtml" : function(l){

          return l.selection;
        },
        // suitable for gecko, opera and webkit
        "default" : function(m){

          return qx.dom.Node.getWindow(m).getSelection();
        }
      }),
      /**
       * Returns the current selected text.
       *
       * @signature function(node)
       * @param node {Node} node to retrieve the selection for
       * @return {String?null) selected text as string
       */
      get : qx.core.Environment.select(a, {
        "mshtml" : function(n){

          // to get the selected text in IE you have to work with the TextRange
          // of the selection object. So always pass the document node to the
          // Range class to get this TextRange object.
          var o = qx.bom.Range.get(qx.dom.Node.getDocument(n));
          return o.text;
        },
        // suitable for gecko, opera and webkit
        "default" : function(p){

          if(this.__isInputOrTextarea(p)){

            return p.value.substring(p.selectionStart, p.selectionEnd);
          } else {

            return this.getSelectionObject(qx.dom.Node.getDocument(p)).toString();
          };
        }
      }),
      /**
       * Returns the length of the selection
       *
       * @signature function(node)
       * @param node {node} Form node or document/window to check.
       * @return {Integer|null} length of the selection or null
       */
      getLength : qx.core.Environment.select(a, {
        "mshtml" : function(q){

          var s = this.get(q);
          // get the selected part and split it by linebreaks
          var r = qx.util.StringSplit.split(s, /\r\n/);
          // return the length substracted by the count of linebreaks
          // IE counts linebreaks as two chars
          // -> harmonize this to one char per linebreak
          return s.length - (r.length - 1);
        },
        "opera" : function(t){

          var y,w,u;
          if(this.__isInputOrTextarea(t)){

            var x = t.selectionStart;
            var v = t.selectionEnd;
            y = t.value.substring(x, v);
            w = v - x;
          } else {

            y = qx.bom.Selection.get(t);
            w = y.length;
          };
          // get the selected part and split it by linebreaks
          u = qx.util.StringSplit.split(y, /\r\n/);
          // substract the count of linebreaks
          // Opera counts each linebreak as two chars
          // -> harmonize this to one char per linebreak
          return w - (u.length - 1);
        },
        // suitable for gecko and webkit
        "default" : function(z){

          if(this.__isInputOrTextarea(z)){

            return z.selectionEnd - z.selectionStart;
          } else {

            return this.get(z).length;
          };
        }
      }),
      /**
       * Returns the start of the selection
       *
       * @signature function(node)
       * @param node {Node} node to check for
       * @return {Integer} start of current selection or "-1" if the current
       *                   selection is not within the given node
       */
      getStart : qx.core.Environment.select(a, {
        "mshtml" : function(A){

          if(this.__isInputOrTextarea(A)){

            var F = qx.bom.Range.get();
            // Check if the document.selection is the text range inside the input element
            if(!A.contains(F.parentElement())){

              return -1;
            };
            var G = qx.bom.Range.get(A);
            var E = A.value.length;
            // Synchronize range start and end points
            G.moveToBookmark(F.getBookmark());
            G.moveEnd(g, E);
            return E - G.text.length;
          } else {

            var G = qx.bom.Range.get(A);
            var C = G.parentElement();
            // get a range which holds the text of the parent element
            var H = qx.bom.Range.get();
            try{

              // IE throws an invalid argument error when the document has no selection
              H.moveToElementText(C);
            } catch(J) {

              return 0;
            };
            // Move end points of full range so it starts at the user selection
            // and ends at the end of the element text.
            var B = qx.bom.Range.get(qx.dom.Node.getBodyElement(A));
            B.setEndPoint(e, G);
            B.setEndPoint(c, H);
            // selection is at beginning
            if(H.compareEndPoints(e, B) == 0){

              return 0;
            };
            var D;
            var I = 0;
            while(true){

              D = B.moveStart(b, -1);
              // Starting points of both ranges are equal
              if(H.compareEndPoints(e, B) == 0){

                break;
              };
              // Moving had no effect -> range is at begin of body
              if(D == 0){

                break;
              } else {

                I++;
              };
            };
            return ++I;
          };
        },
        "gecko|webkit" : function(K){

          if(this.__isInputOrTextarea(K)){

            return K.selectionStart;
          } else {

            var M = qx.dom.Node.getDocument(K);
            var L = this.getSelectionObject(M);
            // gecko and webkit do differ how the user selected the text
            // "left-to-right" or "right-to-left"
            if(L.anchorOffset < L.focusOffset){

              return L.anchorOffset;
            } else {

              return L.focusOffset;
            };
          };
        },
        "default" : function(N){

          if(this.__isInputOrTextarea(N)){

            return N.selectionStart;
          } else {

            return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(N)).anchorOffset;
          };
        }
      }),
      /**
       * Returns the end of the selection
       *
       * @signature function(node)
       * @param node {Node} node to check
       * @return {Integer} end of current selection
       */
      getEnd : qx.core.Environment.select(a, {
        "mshtml" : function(O){

          if(this.__isInputOrTextarea(O)){

            var T = qx.bom.Range.get();
            // Check if the document.selection is the text range inside the input element
            if(!O.contains(T.parentElement())){

              return -1;
            };
            var U = qx.bom.Range.get(O);
            var S = O.value.length;
            // Synchronize range start and end points
            U.moveToBookmark(T.getBookmark());
            U.moveStart(g, -S);
            return U.text.length;
          } else {

            var U = qx.bom.Range.get(O);
            var Q = U.parentElement();
            // get a range which holds the text of the parent element
            var V = qx.bom.Range.get();
            try{

              // IE throws an invalid argument error when the document has no selection
              V.moveToElementText(Q);
            } catch(X) {

              return 0;
            };
            var S = V.text.length;
            // Move end points of full range so it ends at the user selection
            // and starts at the start of the element text.
            var P = qx.bom.Range.get(qx.dom.Node.getBodyElement(O));
            P.setEndPoint(c, U);
            P.setEndPoint(e, V);
            // selection is at beginning
            if(V.compareEndPoints(c, P) == 0){

              return S - 1;
            };
            var R;
            var W = 0;
            while(true){

              R = P.moveEnd(b, 1);
              // Ending points of both ranges are equal
              if(V.compareEndPoints(c, P) == 0){

                break;
              };
              // Moving had no effect -> range is at begin of body
              if(R == 0){

                break;
              } else {

                W++;
              };
            };
            return S - (++W);
          };
        },
        "gecko|webkit" : function(Y){

          if(this.__isInputOrTextarea(Y)){

            return Y.selectionEnd;
          } else {

            var bb = qx.dom.Node.getDocument(Y);
            var ba = this.getSelectionObject(bb);
            // gecko and webkit do differ how the user selected the text
            // "left-to-right" or "right-to-left"
            if(ba.focusOffset > ba.anchorOffset){

              return ba.focusOffset;
            } else {

              return ba.anchorOffset;
            };
          };
        },
        "default" : function(bc){

          if(this.__isInputOrTextarea(bc)){

            return bc.selectionEnd;
          } else {

            return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(bc)).focusOffset;
          };
        }
      }),
      /**
       * Utility method to check for an input or textarea element
       *
       * @param node {node} node to check
       * @return {Boolean} Whether the given nodt is an input or textarea element
       */
      __isInputOrTextarea : function(bd){

        return qx.dom.Node.isElement(bd) && (bd.nodeName.toLowerCase() == f || bd.nodeName.toLowerCase() == d);
      },
      /**
       * Sets a selection at the given node with the given start and end.
       * For text nodes, input and textarea elements the start and end parameters
       * set the boundaries at the text.
       * For element nodes the start and end parameters are used to select the
       * childNodes of the given element.
       *
       * @signature function(node, start, end)
       * @param node {Node} node to set the selection at
       * @param start {Integer} start of the selection
       * @param end {Integer} end of the selection
       * @return {Boolean} whether a selection is drawn
       */
      set : qx.core.Environment.select(a, {
        "mshtml" : function(be, bf, bg){

          var bh;
          // if the node is the document itself then work on with the body element
          if(qx.dom.Node.isDocument(be)){

            be = be.body;
          };
          if(qx.dom.Node.isElement(be) || qx.dom.Node.isText(be)){

            switch(be.nodeName.toLowerCase()){case f:case d:case j:
            if(bg === undefined){

              bg = be.value.length;
            };
            if(bf >= 0 && bf <= be.value.length && bg >= 0 && bg <= be.value.length){

              bh = qx.bom.Range.get(be);
              bh.collapse(true);
              bh.moveStart(b, bf);
              bh.moveEnd(b, bg - bf);
              bh.select();
              return true;
            };
            break;case i:
            if(bg === undefined){

              bg = be.nodeValue.length;
            };
            if(bf >= 0 && bf <= be.nodeValue.length && bg >= 0 && bg <= be.nodeValue.length){

              // get a range of the body element
              bh = qx.bom.Range.get(qx.dom.Node.getBodyElement(be));
              // use the parent node -> "moveToElementText" expects an element
              bh.moveToElementText(be.parentNode);
              bh.collapse(true);
              bh.moveStart(b, bf);
              bh.moveEnd(b, bg - bf);
              bh.select();
              return true;
            };
            break;default:
            if(bg === undefined){

              bg = be.childNodes.length - 1;
            };
            // check start and end -> childNodes
            if(be.childNodes[bf] && be.childNodes[bg]){

              // get the TextRange of the body element
              // IMPORTANT: only with a range of the body the method "moveElementToText" is available
              bh = qx.bom.Range.get(qx.dom.Node.getBodyElement(be));
              // position it at the given node
              bh.moveToElementText(be.childNodes[bf]);
              bh.collapse(true);
              // create helper range
              var bi = qx.bom.Range.get(qx.dom.Node.getBodyElement(be));
              bi.moveToElementText(be.childNodes[bg]);
              // set the end of the range to the end of the helper range
              bh.setEndPoint(c, bi);
              bh.select();
              return true;
            };};
          };
          return false;
        },
        // suitable for gecko, opera and webkit
        "default" : function(bj, bk, bl){

          // special handling for input and textarea elements
          var bp = bj.nodeName.toLowerCase();
          if(qx.dom.Node.isElement(bj) && (bp == f || bp == d)){

            // if "end" is not given set it to the end
            if(bl === undefined){

              bl = bj.value.length;
            };
            // check boundaries
            if(bk >= 0 && bk <= bj.value.length && bl >= 0 && bl <= bj.value.length){

              bj.focus();
              bj.select();
              bj.setSelectionRange(bk, bl);
              return true;
            };
          } else {

            var bn = false;
            var bo = qx.dom.Node.getWindow(bj).getSelection();
            var bm = qx.bom.Range.get(bj);
            // element or text node?
            // for elements nodes the offsets are applied to childNodes
            // for text nodes the offsets are applied to the text content
            if(qx.dom.Node.isText(bj)){

              if(bl === undefined){

                bl = bj.length;
              };
              if(bk >= 0 && bk < bj.length && bl >= 0 && bl <= bj.length){

                bn = true;
              };
            } else if(qx.dom.Node.isElement(bj)){

              if(bl === undefined){

                bl = bj.childNodes.length - 1;
              };
              if(bk >= 0 && bj.childNodes[bk] && bl >= 0 && bj.childNodes[bl]){

                bn = true;
              };
            } else if(qx.dom.Node.isDocument(bj)){

              // work on with the body element
              bj = bj.body;
              if(bl === undefined){

                bl = bj.childNodes.length - 1;
              };
              if(bk >= 0 && bj.childNodes[bk] && bl >= 0 && bj.childNodes[bl]){

                bn = true;
              };
            };;
            if(bn){

              // collapse the selection if needed
              if(!bo.isCollapsed){

                bo.collapseToStart();
              };
              // set start and end of the range
              bm.setStart(bj, bk);
              // for element nodes set the end after the childNode
              if(qx.dom.Node.isText(bj)){

                bm.setEnd(bj, bl);
              } else {

                bm.setEndAfter(bj.childNodes[bl]);
              };
              // remove all existing ranges and add the new one
              if(bo.rangeCount > 0){

                bo.removeAllRanges();
              };
              bo.addRange(bm);
              return true;
            };
          };
          return false;
        }
      }),
      /**
       * Selects all content/childNodes of the given node
       *
       * @param node {Node} text, element or document node
       * @return {Boolean} whether a selection is drawn
       */
      setAll : function(bq){

        return qx.bom.Selection.set(bq, 0);
      },
      /**
       * Clears the selection on the given node.
       *
       * @param node {Node} node to clear the selection for
       * @return {void}
       */
      clear : qx.core.Environment.select(a, {
        "mshtml" : function(br){

          var bs = qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(br));
          var bt = qx.bom.Range.get(br);
          var parent = bt.parentElement();
          var bu = qx.bom.Range.get(qx.dom.Node.getDocument(br));
          // only collapse if the selection is really on the given node
          // -> compare the two parent elements of the ranges with each other and
          // the given node
          if(parent == bu.parentElement() && parent == br){

            bs.empty();
          };
        },
        "default" : function(bv){

          var bx = qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(bv));
          var bz = bv.nodeName.toLowerCase();
          // if the node is an input or textarea element use the specialized methods
          if(qx.dom.Node.isElement(bv) && (bz == f || bz == d)){

            // TODO: this leads Webkit to also focus the input/textarea element
            // which is NOT desired.
            // Additionally there is a bug in webkit with input/textarea elements
            // concerning the native selection and range object.
            // -> getting e.g. the startContainer/endContainer of the range returns
            // the text element (as expected) but webkit does embed this text node
            // into a lonely DIV element, so there us no chance to check if the
            // selection is currently at the input/textarea element to only perform
            // the "setSelectionRange" in the case the given node is REALLY selected.
            // Webkit bugzilla: https://bugs.webkit.org/show_bug.cgi?id=15903
            // qooxdoo bugzilla: http://bugzilla.qooxdoo.org/show_bug.cgi?id=1087
            bv.setSelectionRange(0, 0);
            qx.bom.Element.blur(bv);
          } else if(qx.dom.Node.isDocument(bv) || bz == h){

            bx.collapse(bv.body ? bv.body : bv, 0);
          } else {

            var by = qx.bom.Range.get(bv);
            if(!by.collapsed){

              var bA;
              var bw = by.commonAncestorContainer;
              // compare the parentNode of the textNode with the given node
              // (if this node is an element) to decide whether the selection
              // is cleared or not.
              if(qx.dom.Node.isElement(bv) && qx.dom.Node.isText(bw)){

                bA = bw.parentNode;
              } else {

                bA = bw;
              };
              if(bA == bv){

                bx.collapse(bv, 0);
              };
            };
          };
        }
      })
    }
  });
})();
(function(){

  var l = "qx.bom.Range",k = "text",j = "engine.name",i = "password",h = "file",g = "submit",f = "reset",e = "textarea",d = "input",c = "hidden",a = "body",b = "button";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  /**
   * Low-level Range API which is used together with the low-level Selection API.
   * This is especially useful whenever a developer want to work on text level,
   * e.g. for an editor.
   */
  qx.Class.define(l, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns the range object of the given node.
       *
       * @signature function(node)
       * @param node {Node} node to get the range of
       * @return {Range} valid range of given selection
       */
      get : qx.core.Environment.select(j, {
        "mshtml" : function(m){

          // check for the type of the given node
          // for IE the nodes input, textarea, button and body
          // have access to own TextRange objects. Everything else is
          // gathered via the selection object.
          if(qx.dom.Node.isElement(m)){

            switch(m.nodeName.toLowerCase()){case d:
            switch(m.type){case k:case i:case c:case b:case f:case h:case g:
            return m.createTextRange();
            break;default:
            return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(m)).createRange();};
            break;case e:case a:case b:
            return m.createTextRange();
            break;default:
            return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(m)).createRange();};
          } else {

            if(m == null){

              m = window;
            };
            // need to pass the document node to work with multi-documents
            return qx.bom.Selection.getSelectionObject(qx.dom.Node.getDocument(m)).createRange();
          };
        },
        // suitable for gecko, opera and webkit
        "default" : function(n){

          var o = qx.dom.Node.getDocument(n);
          // get the selection object of the corresponding document
          var p = qx.bom.Selection.getSelectionObject(o);
          if(p.rangeCount > 0){

            return p.getRangeAt(0);
          } else {

            return o.createRange();
          };
        }
      })
    }
  });
})();
(function(){

  var j = "m",h = "g",g = "^",f = "qx.util.StringSplit",e = "i",d = "$(?!\\s)",c = "[object RegExp]",b = "y",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Adrian Olaru (adrianolaru)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Cross-Browser Split
       http://blog.stevenlevithan.com/archives/cross-browser-split
       Version 1.0.1
  
       Copyright:
         (c) 2006-2007, Steven Levithan <http://stevenlevithan.com>
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Steven Levithan
  
  ************************************************************************ */
  /**
   * Implements an ECMA-compliant, uniform cross-browser split method
   */
  qx.Class.define(f, {
    statics : {
      /**
       * ECMA-compliant, uniform cross-browser split method
       *
       * @param str {String} Incoming string to split
       * @param separator {RegExp} Specifies the character to use for separating the string.
       *   The separator is treated as a string or a  regular expression. If separator is
       *   omitted, the array returned contains one element consisting of the entire string.
       * @param limit {Integer?} Integer specifying a limit on the number of splits to be found.
       * @return {String[]} split string
       */
      split : function(k, l, m){

        // if `separator` is not a regex, use the native `split`
        if(Object.prototype.toString.call(l) !== c){

          return String.prototype.split.call(k, l, m);
        };
        var t = [],n = 0,r = (l.ignoreCase ? e : a) + (l.multiline ? j : a) + (l.sticky ? b : a),l = RegExp(l.source, r + h),// make `global` and avoid `lastIndex` issues by working with a copy
        q,u,o,p,s = /()??/.exec(a)[1] === undefined;
        // NPCG: nonparticipating capturing group
        k = k + a;
        // type conversion
        if(!s){

          q = RegExp(g + l.source + d, r);
        };
        /* behavior for `limit`: if it's...
        - `undefined`: no limit.
        - `NaN` or zero: return an empty array.
        - a positive number: use `Math.floor(limit)`.
        - a negative number: no limit.
        - other: type-convert, then use the above rules. */
        if(m === undefined || +m < 0){

          m = Infinity;
        } else {

          m = Math.floor(+m);
          if(!m){

            return [];
          };
        };
        while(u = l.exec(k)){

          o = u.index + u[0].length;
          // `separator.lastIndex` is not reliable cross-browser
          if(o > n){

            t.push(k.slice(n, u.index));
            // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
            if(!s && u.length > 1){

              u[0].replace(q, function(){

                for(var i = 1;i < arguments.length - 2;i++){

                  if(arguments[i] === undefined){

                    u[i] = undefined;
                  };
                };
              });
            };
            if(u.length > 1 && u.index < k.length){

              Array.prototype.push.apply(t, u.slice(1));
            };
            p = u[0].length;
            n = o;
            if(t.length >= m){

              break;
            };
          };
          if(l.lastIndex === u.index){

            l.lastIndex++;
          };
        };
        if(n === k.length){

          if(p || !l.test(a)){

            t.push(a);
          };
        } else {

          t.push(k.slice(n));
        };
        return t.length > m ? t.slice(0, m) : t;
      }
    }
  });
})();
(function(){

  var k = "engine.name",j = "swipe",i = "webkit",h = "tap",g = "x",f = "y",e = "qx.event.handler.TouchCore",d = "touchcancel",c = "touchmove",b = "touchend",a = "touchstart";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tino Butz (tbtz)
       * Christian Hagendorn (chris_schmidt)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */
  /* ************************************************************************
  #ignore(qx.event.type.Tap)
  #ignore(qx.event.type.Swipe)
  #ignore(qx.event.type)
  #ignore(qx.event)
  ************************************************************************ */
  /**
   * Listens for native touch events and fires composite events like "tap" and
   * "swipe"
   */
  qx.Bootstrap.define(e, {
    extend : Object,
    statics : {
      /** {Integer} The maximum distance of a tap. Only if the x or y distance of
       *      the performed tap is less or equal the value of this constant, a tap
       *      event is fired.
       */
      TAP_MAX_DISTANCE : qx.core.Environment.get("os.name") != "android" ? 10 : 40,
      /** {Map} The direction of a swipe relative to the axis */
      SWIPE_DIRECTION : {
        x : ["left", "right"],
        y : ["up", "down"]
      },
      /** {Integer} The minimum distance of a swipe. Only if the x or y distance
       *      of the performed swipe is greater as or equal the value of this
       *      constant, a swipe event is fired.
       */
      SWIPE_MIN_DISTANCE : qx.core.Environment.get("os.name") != "android" ? 11 : 41,
      /** {Integer} The minimum velocity of a swipe. Only if the velocity of the
       *      performed swipe is greater as or equal the value of this constant, a
       *      swipe event is fired.
       */
      SWIPE_MIN_VELOCITY : 0
    },
    /**
     * Create a new instance
     *
     * @param target {Element} element on which to listen for native touch events
     * @param emitter {qx.event.Emitter} Event emitter object
     */
    construct : function(l, m){

      this.__target = l;
      this.__emitter = m;
      this._initTouchObserver();
    },
    members : {
      __target : null,
      __emitter : null,
      __onTouchEventWrapper : null,
      __originalTarget : null,
      __startPageX : null,
      __startPageY : null,
      __startTime : null,
      __isSingleTouchGesture : null,
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native touch event listeners.
       */
      _initTouchObserver : function(){

        this.__onTouchEventWrapper = qx.lang.Function.listener(this._onTouchEvent, this);
        var Event = qx.bom.Event;
        Event.addNativeListener(this.__target, a, this.__onTouchEventWrapper);
        Event.addNativeListener(this.__target, c, this.__onTouchEventWrapper);
        Event.addNativeListener(this.__target, b, this.__onTouchEventWrapper);
        Event.addNativeListener(this.__target, d, this.__onTouchEventWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Disconnects the native touch event listeners.
       */
      _stopTouchObserver : function(){

        var Event = qx.bom.Event;
        Event.removeNativeListener(this.__target, a, this.__onTouchEventWrapper);
        Event.removeNativeListener(this.__target, c, this.__onTouchEventWrapper);
        Event.removeNativeListener(this.__target, b, this.__onTouchEventWrapper);
        Event.removeNativeListener(this.__target, d, this.__onTouchEventWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT OBSERVERS
      ---------------------------------------------------------------------------
      */
      /**
       * Handler for native touch events.
       *
       * @param domEvent {Event} The touch event from the browser.
       */
      _onTouchEvent : function(n){

        this._commonTouchEventHandler(n);
      },
      /**
       * Called by an event handler.
       *
       * @param domEvent {Event} DOM event
       * @param type {String ? null} type of the event
       */
      _commonTouchEventHandler : function(o, p){

        var p = p || o.type;
        if(p == a){

          this.__originalTarget = this._getTarget(o);
        };
        this._fireEvent(o, p);
        this.__checkAndFireGesture(o, p);
      },
      /*
      ---------------------------------------------------------------------------
        HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Return the target of the event.
       *
       * @param domEvent {Event} DOM event
       * @return {Element} Event target
       */
      _getTarget : function(q){

        var r = qx.bom.Event.getTarget(q);
        // Text node. Fix Safari Bug, see http://www.quirksmode.org/js/events_properties.html
        if((qx.core.Environment.get(k) == i)){

          if(r && r.nodeType == 3){

            r = r.parentNode;
          };
        };
        return r;
      },
      /**
       * Fire a touch event with the given parameters
       *
       * @param domEvent {Event} DOM event
       * @param type {String ? null} type of the event
       * @param target {Element ? null} event target
       */
      _fireEvent : function(s, t, u){

        if(!u){

          u = this._getTarget(s);
        };
        var t = t || s.type;
        if(u && u.nodeType && this.__emitter){

          this.__emitter.emit(t, s);
        };
      },
      /**
       * Checks if a gesture was made and fires the gesture event.
       *
       * @param domEvent {Event} DOM event
       * @param type {String ? null} type of the event
       * @param target {Element ? null} event target
       */
      __checkAndFireGesture : function(v, w, x){

        if(!x){

          x = this._getTarget(v);
        };
        var w = w || v.type;
        if(w == a){

          this.__gestureStart(v, x);
        } else if(w == c){

          this.__gestureChange(v, x);
        } else if(w == b){

          this.__gestureEnd(v, x);
        };;
      },
      /**
       * Helper method for gesture start.
       *
       * @param domEvent {Event} DOM event
       * @param target {Element} event target
       */
      __gestureStart : function(y, z){

        var A = y.changedTouches[0];
        this.__startPageX = A.screenX;
        this.__startPageY = A.screenY;
        this.__startTime = new Date().getTime();
        this.__isSingleTouchGesture = y.changedTouches.length === 1;
      },
      /**
       * Helper method for gesture change.
       *
       * @param domEvent {Event} DOM event
       * @param target {Element} event target
       */
      __gestureChange : function(B, C){

        // Abort a single touch gesture when another touch occurs.
        if(this.__isSingleTouchGesture && B.changedTouches.length > 1){

          this.__isSingleTouchGesture = false;
        };
      },
      /**
       * Helper method for gesture end.
       *
       * @param domEvent {Event} DOM event
       * @param target {Element} event target
       */
      __gestureEnd : function(D, E){

        if(this.__isSingleTouchGesture){

          var F = D.changedTouches[0];
          var I = {
            x : F.screenX - this.__startPageX,
            y : F.screenY - this.__startPageY
          };
          var J = qx.event.handler.TouchCore;
          var G;
          if(this.__originalTarget == E && Math.abs(I.x) <= J.TAP_MAX_DISTANCE && Math.abs(I.y) <= J.TAP_MAX_DISTANCE){

            if(qx.event && qx.event.type && qx.event.type.Tap){

              G = qx.event.type.Tap;
            };
            this._fireEvent(D, h, E, G);
          } else {

            var H = this.__getSwipeGesture(D, E, I);
            if(H){

              if(qx.event && qx.event.type && qx.event.type.Swipe){

                G = qx.event.type.Swipe;
              };
              D.swipe = H;
              this._fireEvent(D, j, E, G);
            };
          };
        };
      },
      /**
       * Returns the swipe gesture when the user performed a swipe.
       *
       * @param domEvent {Event} DOM event
       * @param target {Element} event target
       * @param deltaCoordinates {Map} delta x/y coordinates since the gesture started.
       * @return {Map} returns the swipe data when the user performed a swipe, null if the gesture was no swipe.
       */
      __getSwipeGesture : function(K, L, M){

        var Q = qx.event.handler.TouchCore;
        var R = new Date().getTime() - this.__startTime;
        var T = (Math.abs(M.x) >= Math.abs(M.y)) ? g : f;
        var N = M[T];
        var O = Q.SWIPE_DIRECTION[T][N < 0 ? 0 : 1];
        var S = (R !== 0) ? N / R : 0;
        var P = null;
        if(Math.abs(S) >= Q.SWIPE_MIN_VELOCITY && Math.abs(N) >= Q.SWIPE_MIN_DISTANCE){

          P = {
            startTime : this.__startTime,
            duration : R,
            axis : T,
            direction : O,
            distance : N,
            velocity : S
          };
        };
        return P;
      },
      /**
       * Dispose this object
       */
      dispose : function(){

        this._stopTouchObserver();
        this.__originalTarget = this.__target = this.__emitter = null;
      }
    }
  });
})();
(function(){

  var c = "touchcancel",b = "qx.event.type.Touch",a = "touchend";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * Touch event object.
   *
   * For more information see:
   *     http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html
   */
  qx.Class.define(b, {
    extend : qx.event.type.Dom,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _cloneNativeEvent : function(d, e){

        var e = qx.event.type.Dom.prototype._cloneNativeEvent.call(this, d, e);
        e.pageX = d.pageX;
        e.pageY = d.pageY;
        e.offsetX = d.offsetX;
        e.offsetY = d.offsetY;
        // Workaround for BUG #6491
        e.layerX = (d.offsetX || d.layerX);
        e.layerY = (d.offsetY || d.layerY);
        e.scale = d.scale;
        e.rotation = d.rotation;
        e.srcElement = d.srcElement;
        e.targetTouches = [];
        for(var i = 0;i < d.targetTouches.length;i++){

          e.targetTouches[i] = d.targetTouches[i];
        };
        e.changedTouches = [];
        for(i = 0;i < d.changedTouches.length;i++){

          e.changedTouches[i] = d.changedTouches[i];
        };
        e.touches = [];
        for(i = 0;i < d.touches.length;i++){

          e.touches[i] = d.touches[i];
        };
        return e;
      },
      // overridden
      stop : function(){

        this.stopPropagation();
      },
      /**
       * Returns an array of native Touch objects representing all current
       * touches on the document.
       * Returns an empty array for the "touchend" event.
       *
       * @return {Object[]} Array of touch objects. For more information see:
       *     http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchClassReference/Touch/Touch.html
       */
      getAllTouches : function(){

        return this._native.touches;
      },
      /**
       * Returns an array of native Touch objects representing all touches
       * associated with the event target element.
       * Returns an empty array for the "touchend" event.
       *
       * @return {Object[]} Array of touch objects. For more information see:
       *     http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchClassReference/Touch/Touch.html
       */
      getTargetTouches : function(){

        return this._native.targetTouches;
      },
      /**
       * Returns an array of native Touch objects representing all touches of
       * the target element that changed in this event.
       *
       * On the "touchstart" event the array contains all touches that were
       * added to the target element.
       * On the "touchmove" event the array contains all touches that were
       * moved on the target element.
       * On the "touchend" event the array contains all touches that used
       * to be on the target element.
       *
       * @return {Object[]} Array of touch objects. For more information see:
       *     http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchClassReference/Touch/Touch.html
       */
      getChangedTargetTouches : function(){

        return this._native.changedTouches;
      },
      /**
       * Checks whether more than one touch is associated with the event target
       * element.
       *
       * @return {Boolean} Is multi-touch
       */
      isMultiTouch : function(){

        return this.__getEventSpecificTouches().length > 1;
      },
      /**
       * iOS only: Returns the distance between two fingers since the start of the event.
       * The distance is a multiplier of the initial distance.
       * Initial value: 1.0.
       * Gestures:
       * < 1.0, pinch close / zoom out.
       * > 1.0, pinch open / to zoom in.
       *
       * @return The scale distance between two fingers
       */
      getScale : function(){

        return this._native.scale;
      },
      /**
       * iOS only: Returns the delta of the rotation since the start of the event, in degrees.
       * Initial value is 0.0
       * Clockwise > 0
       * Counter-clockwise < 0.
       *
       * @return {Float} The rotation delta
       */
      getRotation : function(){

        return this._native.rotation;
      },
      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The horizontal position of the touch in the document.
       */
      getDocumentLeft : function(f){

        return this.__getEventSpecificTouch(f).pageX;
      },
      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The vertical position of the touch in the document.
       */
      getDocumentTop : function(g){

        return this.__getEventSpecificTouch(g).pageY;
      },
      /**
       * Get the horizontal coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The horizontal position of the touch
       */
      getScreenLeft : function(h){

        return this.__getEventSpecificTouch(h).screenX;
      },
      /**
       * Get the vertical coordinate at which the event occurred relative to
       * the origin of the screen coordinate system.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The vertical position of the touch
       */
      getScreenTop : function(j){

        return this.__getEventSpecificTouch(j).screenY;
      },
      /**
       * Get the the horizontal coordinate at which the event occurred relative
       * to the viewport.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The horizontal position of the touch
       */
      getViewportLeft : function(k){

        return this.__getEventSpecificTouch(k).clientX;
      },
      /**
       * Get the vertical coordinate at which the event occurred relative
       * to the viewport.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} The vertical position of the touch
       */
      getViewportTop : function(l){

        return this.__getEventSpecificTouch(l).clientY;
      },
      /**
       * Returns the unique identifier for a certain touch object.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object
       * @return {Integer} Unique identifier of the touch object
       */
      getIdentifier : function(m){

        return this.__getEventSpecificTouch(m).identifier;
      },
      /**
       * Returns an event specific touch on the target element. This function is
       * used as the "touchend" event only offers Touch objects in the
       * changedTouches array.
       *
       * @param touchIndex {Integer ? 0) The index of the Touch object to
       *     retrieve
       * @return {Object} A native Touch object
       */
      __getEventSpecificTouch : function(n){

        n = n == null ? 0 : n;
        return this.__getEventSpecificTouches()[n];
      },
      /**
       * Returns the event specific touches on the target element. This function
       * is used as the "touchend" event only offers Touch objects in the
       * changedTouches array.
       *
       * @return {Object[]} Array of native Touch objects
       */
      __getEventSpecificTouches : function(){

        var o = (this._isTouchEnd() ? this.getChangedTargetTouches() : this.getTargetTouches());
        return o;
      },
      /**
       * Indicates if the event occurs during the "touchend" phase. Needed to
       * determine the event specific touches. Override this method if you derive
       * from this class and want to indicate that the specific event occurred
       * during the "touchend" phase.
       *
       * @return {Boolean} Whether the event occurred during the "touchend" phase
       */
      _isTouchEnd : function(){

        return (this.getType() == a || this.getType() == c);
      }
    }
  });
})();
(function(){

  var a = "qx.event.type.Tap";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * Tap event object.
   */
  qx.Class.define(a, {
    extend : qx.event.type.Touch,
    members : {
      // overridden
      _isTouchEnd : function(){

        return true;
      }
    }
  });
})();
(function(){

  var a = "qx.event.type.Swipe";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * Swipe event object.
   */
  qx.Class.define(a, {
    extend : qx.event.type.Touch,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _cloneNativeEvent : function(b, c){

        var c = qx.event.type.Touch.prototype._cloneNativeEvent.call(this, b, c);
        c.swipe = b.swipe;
        return c;
      },
      // overridden
      _isTouchEnd : function(){

        return true;
      },
      /**
       * Returns the start time of the performed swipe.
       *
       * @return {Integer} the start time
       */
      getStartTime : function(){

        return this._native.swipe.startTime;
      },
      /**
       * Returns the duration the performed swipe took.
       *
       * @return {Integer} the duration
       */
      getDuration : function(){

        return this._native.swipe.duration;
      },
      /**
       * Returns whether the performed swipe was on the x or y axis.
       *
       * @return {String} "x"/"y" axis
       */
      getAxis : function(){

        return this._native.swipe.axis;
      },
      /**
       * Returns the direction of the performed swipe in reference to the axis.
       * y = up / down
       * x = left / right
       *
       * @return {String} the direction
       */
      getDirection : function(){

        return this._native.swipe.direction;
      },
      /**
       * Returns the velocity of the performed swipe.
       *
       * @return {Number} the velocity
       */
      getVelocity : function(){

        return this._native.swipe.velocity;
      },
      /**
       * Returns the distance of the performed swipe.
       *
       * @return {Integer} the distance
       */
      getDistance : function(){

        return this._native.swipe.distance;
      }
    }
  });
})();
(function(){

  var l = "event.pointer",k = "onhashchange",j = "event.help",i = "event.touch",h = "opera",g = "event.hashchange",f = "onhelp",e = "pointerEvents",d = "documentMode",c = "qx.bom.client.Event",a = "ontouchstart",b = "mshtml";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Internal class which contains the checks used by {@link qx.core.Environment}.
   * All checks in here are marked as internal which means you should never use
   * them directly.
   *
   * This class should contain all checks about events.
   *
   * @internal
   */
  qx.Bootstrap.define(c, {
    statics : {
      /**
       * Checks if touch events are supported.
       *
       * @internal
       * @return {Boolean} <code>true</code> if touch events are supported.
       */
      getTouch : function(){

        return (a in window);
      },
      /**
       * Checks if pointer events are available.
       *
       * @internal
       * @return {Boolean} <code>true</code> if pointer events are supported.
       */
      getPointer : function(){

        // Check if browser reports that pointerEvents is a known style property
        if(e in document.documentElement.style){

          // Opera 10.63 incorrectly advertises support for CSS pointer events (#4229).
          // Do not rely on pointer events in Opera until this browser issue is fixed.
          // IE9 only supports pointer events only for SVG.
          // See http://msdn.microsoft.com/en-us/library/ff972269%28v=VS.85%29.aspx
          var m = qx.bom.client.Engine.getName();
          return m != h && m != b;
        };
        return false;
      },
      /**
       * Checks if the proprietary <code>help</code> event is available.
       *
       * @internal
       * @return {Boolean} <code>true</code> if the "help" event is supported.
       */
      getHelp : function(){

        return (f in document);
      },
      /**
       * Checks if the <code>hashchange</code> event is available
       *
       * @internal
       * @return {Boolean} <code>true</code> if the "hashchange" event is supported.
       */
      getHashChange : function(){

        // avoid false positive in IE7
        var n = qx.bom.client.Engine.getName();
        var o = k in window;
        return (n !== b && o) || (n === b && d in document && document.documentMode >= 8 && o);
      }
    },
    defer : function(p){

      qx.core.Environment.add(i, p.getTouch);
      qx.core.Environment.add(l, p.getPointer);
      qx.core.Environment.add(j, p.getHelp);
      qx.core.Environment.add(g, p.getHashChange);
    }
  });
})();
(function(){

  var e = "resize",d = "landscape",c = "portrait",b = "qx.event.handler.Orientation",a = "orientationchange";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * This class provides a handler for the orientation event.
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(f){

      qx.core.Object.call(this);
      // Define shorthands
      this.__manager = f;
      this.__window = f.getWindow();
      this._initObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        orientationchange : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      __window : null,
      __nativeEventType : null,
      _currentOrientation : null,
      __onNativeWrapper : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(g, h){
      },
      // interface implementation
      registerEvent : function(i, j, k){
      },
      // interface implementation
      unregisterEvent : function(l, m, n){
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native orientation change event listeners.
       */
      _initObserver : function(){

        this.__onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
        // Handle orientation change event for Android devices by the resize event.
        // See http://stackoverflow.com/questions/1649086/detect-rotation-of-android-phone-in-the-browser-with-javascript
        // for more information.
        this.__nativeEventType = qx.bom.Event.supportsEvent(this.__window, a) ? a : e;
        var Event = qx.bom.Event;
        Event.addNativeListener(this.__window, this.__nativeEventType, this.__onNativeWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        OBSERVER STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Disconnects the native orientation change event listeners.
       */
      _stopObserver : function(){

        var Event = qx.bom.Event;
        Event.removeNativeListener(this.__window, this.__nativeEventType, this.__onNativeWrapper);
      },
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT OBSERVERS
      ---------------------------------------------------------------------------
      */
      /**
       * Handler for the native orientation change event.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} The touch event from the browser.
       */
      _onNative : qx.event.GlobalError.observeMethod(function(o){

        var q = qx.bom.Viewport;
        var p = q.getOrientation(o.target);
        if(this._currentOrientation != p){

          this._currentOrientation = p;
          var r = q.isLandscape(o.target) ? d : c;
          qx.event.Registration.fireEvent(this.__window, a, qx.event.type.Orientation, [p, r]);
        };
      })
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopObserver();
      this.__manager = this.__window = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(s){

      qx.event.Registration.addHandler(s);
    }
  });
})();
(function(){

  var c = "landscape",b = "qx.event.type.Orientation",a = "portrait";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * Orientation event object.
   */
  qx.Class.define(b, {
    extend : qx.event.type.Event,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __orientation : null,
      __mode : null,
      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param orientation {String} One of <code>0</code>, <code>90</code> or <code>-90</code>
       * @param mode {String} <code>landscape</code> or <code>portrait</code>
       * @return {qx.event.type.Orientation} The initialized event instance
       */
      init : function(d, e){

        qx.event.type.Event.prototype.init.call(this, false, false);
        this.__orientation = d;
        this.__mode = e;
        return this;
      },
      /**
       * Get a copy of this object
       *
       * @param embryo {qx.event.type.Orientation?null} Optional event class, which will
       *     be configured using the data of this event instance. The event must be
       *     an instance of this event class. If the data is <code>null</code>,
       *     a new pooled instance is created.
       *
       * @return {qx.event.type.Orientation} a copy of this object
       */
      clone : function(f){

        var g = qx.event.type.Event.prototype.clone.call(this, f);
        g.__orientation = this.__orientation;
        g.__mode = this.__mode;
        return g;
      },
      /**
       * Returns the current orientation of the viewport in degree.
       *
       * All possible values and their meaning:
       *
       * * <code>0</code>: "Portrait"
       * * <code>-90</code>: "Landscape (right, screen turned clockwise)"
       * * <code>90</code>: "Landscape (left, screen turned counterclockwise)"
       * * <code>180</code>: "Portrait (upside-down portrait)"
       *
       * @return {Integer} The current orientation in degree
       */
      getOrientation : function(){

        return this.__orientation;
      },
      /**
       * Whether the viewport orientation is currently in landscape mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in landscape mode.
       */
      isLandscape : function(){

        return this.__mode == c;
      },
      /**
       * Whether the viewport orientation is currently in portrait mode.
       *
       * @return {Boolean} <code>true</code> when the viewport orientation
       *     is currently in portrait mode.
       */
      isPortrait : function(){

        return this.__mode == a;
      }
    }
  });
})();
(function(){

  var o = "mshtml",n = "engine.name",m = "qx.event.handler.Touch",l = "useraction",k = "touchmove",j = "qx.mobile.nativescroll",i = "dispose",h = "touchstart",g = "mouseup",f = "touchend",b = "mousedown",d = "mousemove",c = "event.touch",a = "qx.mobile.emulatetouch";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Tino Butz (tbtz)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.UserAction)
  #require(qx.event.handler.Orientation)
  #require(qx.event.type.Tap)
  #require(qx.event.type.Swipe)
  
  ************************************************************************ */
  /**
   * EXPERIMENTAL - NOT READY FOR PRODUCTION
   *
   * This class provides a unified touch event handler.
   */
  qx.Class.define(m, {
    extend : qx.event.handler.TouchCore,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(p){

      // Define shorthands
      this.__manager = p;
      this.__window = p.getWindow();
      this.__root = this.__window.document;
      qx.event.handler.TouchCore.apply(this, [this.__root]);
      this._initMouseObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        touchstart : 1,
        touchmove : 1,
        touchend : 1,
        touchcancel : 1,
        // Appears when the touch is interrupted, e.g. by an alert box
        tap : 1,
        swipe : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE + qx.event.IEventHandler.TARGET_DOCUMENT,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true,
      /** {Map} Mapping of mouse events to touch events */
      MOUSE_TO_TOUCH_MAPPING : {
        "mousedown" : "touchstart",
        "mousemove" : "touchmove",
        "mouseup" : "touchend"
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __onMouseEventWrapper : null,
      __manager : null,
      __window : null,
      __root : null,
      // Checks if the mouse movement is happening while simulating a touch event
      __isInTouch : false,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(q, r){
      },
      // interface implementation
      registerEvent : function(s, t, u){
      },
      // interface implementation
      unregisterEvent : function(v, w, x){
      },
      /*
      ---------------------------------------------------------------------------
        HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Fire a touch event with the given parameters
       *
       * @param domEvent {Event} DOM event
       * @param type {String ? null} type of the event
       * @param target {Element ? null} event target
       * @param eventTypeClass {Class ? qx.event.type.Touch} the event type class
       */
      _fireEvent : function(y, z, A, B){

        if(!A){

          A = this._getTarget(y);
        };
        var z = z || y.type;
        if(A && A.nodeType){

          qx.event.Registration.fireEvent(A, z, B || qx.event.type.Touch, [y, A, null, true, true]);
        };
        // Fire user action event
        qx.event.Registration.fireEvent(this.__window, l, qx.event.type.Data, [z]);
      },
      /**
       * Normalizes a mouse event to a touch event.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       */
      __normalizeMouseEvent : qx.core.Environment.select(a, {
        "true" : function(C){

          var D = C.type;
          var F = qx.event.handler.Touch.MOUSE_TO_TOUCH_MAPPING;
          if(F[D]){

            D = F[D];
            // Remember if we are in a touch event
            if(D == h && this.__isLeftMouseButtonPressed(C)){

              this.__isInTouch = true;
            } else if(D == f){

              this.__isInTouch = false;
            };
            var G = this.__createTouchObject(C);
            var E = (D == f ? [] : [G]);
            // add the touches to the native mouse event
            C.touches = E;
            C.targetTouches = E;
            C.changedTouches = [G];
          };
          return D;
        },
        "default" : qx.lang.Function.empty
      }),
      /**
       * Checks if the left mouse button is pressed.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       * @return {Boolean} Whether the left mouse button is pressed
       */
      __isLeftMouseButtonPressed : qx.core.Environment.select(a, {
        "true" : function(H){

          if((qx.core.Environment.get(n) == o)){

            var I = 1;
          } else {

            var I = 0;
          };
          return H.button == I;
        },
        "default" : qx.lang.Function.empty
      }),
      /**
       * Creates and returns a Touch mock object.
       * Fore more information see:
       * http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchClassReference/Touch/Touch.html
       *
       * @signature function(domEvent)
       * @param domEvent {Event} DOM event
       * @return {Object} The Touch mock object
       */
      __createTouchObject : qx.core.Environment.select(a, {
        "true" : function(J){

          var K = this._getTarget(J);
          return {
            clientX : J.clientX,
            clientY : J.clientY,
            screenX : J.screenX,
            screenY : J.screenY,
            pageX : J.pageX,
            pageY : J.pageY,
            identifier : 1,
            target : K
          };
        },
        "default" : qx.lang.Function.empty
      }),
      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the native mouse event listeners.
       */
      _initMouseObserver : qx.core.Environment.select(a, {
        "true" : function(){

          if(!qx.core.Environment.get(c)){

            this.__onMouseEventWrapper = qx.lang.Function.listener(this._onMouseEvent, this);
            var Event = qx.bom.Event;
            Event.addNativeListener(this.__root, b, this.__onMouseEventWrapper);
            Event.addNativeListener(this.__root, d, this.__onMouseEventWrapper);
            Event.addNativeListener(this.__root, g, this.__onMouseEventWrapper);
          };
        },
        "default" : qx.lang.Function.empty
      }),
      /*
      ---------------------------------------------------------------------------
        OBSERVER STOP
      ---------------------------------------------------------------------------
      */
      /**
       * Disconnects the native mouse event listeners.
       */
      _stopMouseObserver : qx.core.Environment.select(a, {
        "true" : function(){

          if(!qx.core.Environment.get(c)){

            var Event = qx.bom.Event;
            Event.removeNativeListener(this.__root, b, this.__onMouseEventWrapper);
            Event.removeNativeListener(this.__root, d, this.__onMouseEventWrapper);
            Event.removeNativeListener(this.__root, g, this.__onMouseEventWrapper);
          };
        },
        "default" : qx.lang.Function.empty
      }),
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT OBSERVERS
      ---------------------------------------------------------------------------
      */
      /**
       * Handler for the native touch events.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} The touch event from the browser.
       */
      _onTouchEvent : qx.event.GlobalError.observeMethod(function(L){

        this._commonTouchEventHandler(L);
      }),
      /**
       * Handler for the native mouse events.
       *
       * @signature function(domEvent)
       * @param domEvent {Event} The mouse event from the browser.
       */
      _onMouseEvent : qx.core.Environment.select(a, {
        "true" : qx.event.GlobalError.observeMethod(function(M){

          if(!qx.core.Environment.get(c)){

            if(M.type == d && !this.__isInTouch){

              return;
            };
            var N = this.__normalizeMouseEvent(M);
            this._commonTouchEventHandler(M, N);
          };
        }),
        "default" : qx.lang.Function.empty
      }),
      /**
       * Dispose this object
       */
      dispose : function(){

        this.__callBase(i);
        this._stopMouseObserver();
        this.__manager = this.__window = this.__root = null;
      },
      /**
       * Call overriden method.
       *
       * @param method {String} Name of the overriden method.
       * @param args {Array} Arguments.
       */
      __callBase : function(O, P){

        qx.event.handler.TouchCore.prototype[O].apply(this, P || []);
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(Q){

      qx.event.Registration.addHandler(Q);
      // Prevent scrolling on the document to avoid scrolling at all
      if(qx.core.Environment.get(c)){

        if(qx.core.Environment.get(j) == false){

          document.addEventListener(k, function(e){

            e.preventDefault();
          });
        };
        // get the handler to asure that the instance is created
        qx.event.Registration.getManager(document).getHandler(Q);
      };
    }
  });
})();
(function(){

  var m = "select-multiple",k = "value",j = "select",h = "qx.event.handler.Input",g = "checked",f = "blur",d = "keydown",c = "propertychange",b = "browser.version",a = "browser.documentmode",A = "opera",z = "keyup",y = "mshtml",x = "keypress",w = "engine.version",v = "radio",u = "checkbox",t = "text",s = "textarea",r = "password",p = "change",q = "engine.name",n = "input";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  // Original behavior:
  // ================================================================
  // Normally a "change" event should occour on blur of the element
  // (http://www.w3.org/TR/DOM-Level-2-Events/events.html)
  // However this is not true for "file" upload fields
  // And this is also not true for checkboxes and radiofields (all non mshtml)
  // And this is also not true for select boxes where the selections
  // happens in the opened popup (Gecko + Webkit)
  // Normalized behavior:
  // ================================================================
  // Change on blur for textfields, textareas and file
  // Instant change event on checkboxes, radiobuttons
  // Select field fires on select (when using popup or size>1)
  // but differs when using keyboard:
  // mshtml+opera=keypress; mozilla+safari=blur
  // Input event for textareas does not work in Safari 3 beta (WIN)
  // Safari 3 beta (WIN) repeats change event for select box on blur when selected using popup
  // Opera fires "change" on radio buttons two times for each change
  /**
   * This handler provides an "change" event for all form fields and an
   * "input" event for form fields of type "text" and "textarea".
   *
   * To let these events work it is needed to create the elements using
   * {@link qx.bom.Input}
   */
  qx.Class.define(h, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this._onChangeCheckedWrapper = qx.lang.Function.listener(this._onChangeChecked, this);
      this._onChangeValueWrapper = qx.lang.Function.listener(this._onChangeValue, this);
      this._onInputWrapper = qx.lang.Function.listener(this._onInput, this);
      this._onPropertyWrapper = qx.lang.Function.listener(this._onProperty, this);
      // special event handler for opera
      if((qx.core.Environment.get(q) == A)){

        this._onKeyDownWrapper = qx.lang.Function.listener(this._onKeyDown, this);
        this._onKeyUpWrapper = qx.lang.Function.listener(this._onKeyUp, this);
        this._onBlurWrapper = qx.lang.Function.listener(this._onBlur, this);
      };
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        input : 1,
        change : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // special handling for opera
      __enter : false,
      __onInputTimeoutId : null,
      // stores the former set value for opera and IE
      __oldValue : null,
      // stores the former set value for IE
      __oldInputValue : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(B, C){

        var D = B.tagName.toLowerCase();
        if(C === n && (D === n || D === s)){

          return true;
        };
        if(C === p && (D === n || D === s || D === j)){

          return true;
        };
        return false;
      },
      // interface implementation
      registerEvent : function(E, F, G){

        if(qx.core.Environment.get(q) == y && (qx.core.Environment.get(w) < 9 || (qx.core.Environment.get(w) >= 9 && qx.core.Environment.get(a) < 9))){

          if(!E.__inputHandlerAttached){

            var H = E.tagName.toLowerCase();
            var I = E.type;
            if(I === t || I === r || H === s || I === u || I === v){

              qx.bom.Event.addNativeListener(E, c, this._onPropertyWrapper);
            };
            if(I !== u && I !== v){

              qx.bom.Event.addNativeListener(E, p, this._onChangeValueWrapper);
            };
            if(I === t || I === r){

              this._onKeyPressWrapped = qx.lang.Function.listener(this._onKeyPress, this, E);
              qx.bom.Event.addNativeListener(E, x, this._onKeyPressWrapped);
            };
            E.__inputHandlerAttached = true;
          };
        } else {

          if(F === n){

            this.__registerInputListener(E);
          } else if(F === p){

            if(E.type === v || E.type === u){

              qx.bom.Event.addNativeListener(E, p, this._onChangeCheckedWrapper);
            } else {

              qx.bom.Event.addNativeListener(E, p, this._onChangeValueWrapper);
            };
            // special enter bugfix for opera
            if((qx.core.Environment.get(q) == A) || (qx.core.Environment.get(q) == y)){

              if(E.type === t || E.type === r){

                this._onKeyPressWrapped = qx.lang.Function.listener(this._onKeyPress, this, E);
                qx.bom.Event.addNativeListener(E, x, this._onKeyPressWrapped);
              };
            };
          };
        };
      },
      __registerInputListener : qx.core.Environment.select(q, {
        "mshtml" : function(J){

          if(qx.core.Environment.get(w) >= 9 && qx.core.Environment.get(a) >= 9){

            qx.bom.Event.addNativeListener(J, n, this._onInputWrapper);
            if(J.type === t || J.type === r || J.type === s){

              // Fixed input for delete and backspace key
              this._inputFixWrapper = qx.lang.Function.listener(this._inputFix, this, J);
              qx.bom.Event.addNativeListener(J, z, this._inputFixWrapper);
            };
          };
        },
        "webkit" : function(K){

          // TODO: remove listener
          var L = K.tagName.toLowerCase();
          // the change event is not fired while typing
          // this has been fixed in the latest nightlies
          if(parseFloat(qx.core.Environment.get(w)) < 532 && L == s){

            qx.bom.Event.addNativeListener(K, x, this._onInputWrapper);
          };
          qx.bom.Event.addNativeListener(K, n, this._onInputWrapper);
        },
        "opera" : function(M){

          // register key events for filtering "enter" on input events
          qx.bom.Event.addNativeListener(M, z, this._onKeyUpWrapper);
          qx.bom.Event.addNativeListener(M, d, this._onKeyDownWrapper);
          // register an blur event for preventing the input event on blur
          qx.bom.Event.addNativeListener(M, f, this._onBlurWrapper);
          qx.bom.Event.addNativeListener(M, n, this._onInputWrapper);
        },
        "default" : function(N){

          qx.bom.Event.addNativeListener(N, n, this._onInputWrapper);
        }
      }),
      // interface implementation
      unregisterEvent : function(O, P){

        if(qx.core.Environment.get(q) == y && qx.core.Environment.get(w) < 9 && qx.core.Environment.get(a) < 9){

          if(O.__inputHandlerAttached){

            var Q = O.tagName.toLowerCase();
            var R = O.type;
            if(R === t || R === r || Q === s || R === u || R === v){

              qx.bom.Event.removeNativeListener(O, c, this._onPropertyWrapper);
            };
            if(R !== u && R !== v){

              qx.bom.Event.removeNativeListener(O, p, this._onChangeValueWrapper);
            };
            if(R === t || R === r){

              qx.bom.Event.removeNativeListener(O, x, this._onKeyPressWrapped);
            };
            try{

              delete O.__inputHandlerAttached;
            } catch(S) {

              O.__inputHandlerAttached = null;
            };
          };
        } else {

          if(P === n){

            this.__unregisterInputListener(O);
          } else if(P === p){

            if(O.type === v || O.type === u){

              qx.bom.Event.removeNativeListener(O, p, this._onChangeCheckedWrapper);
            } else {

              qx.bom.Event.removeNativeListener(O, p, this._onChangeValueWrapper);
            };
          };
          if((qx.core.Environment.get(q) == A) || (qx.core.Environment.get(q) == y)){

            if(O.type === t || O.type === r){

              qx.bom.Event.removeNativeListener(O, x, this._onKeyPressWrapped);
            };
          };
        };
      },
      __unregisterInputListener : qx.core.Environment.select(q, {
        "mshtml" : function(T){

          if(qx.core.Environment.get(w) >= 9 && qx.core.Environment.get(a) >= 9){

            qx.bom.Event.removeNativeListener(T, n, this._onInputWrapper);
            if(T.type === t || T.type === r || T.type === s){

              // Fixed input for delete and backspace key
              qx.bom.Event.removeNativeListener(T, z, this._inputFixWrapper);
            };
          };
        },
        "webkit" : function(U){

          // TODO: remove listener
          var V = U.tagName.toLowerCase();
          // the change event is not fired while typing
          // this has been fixed in the latest nightlies
          if(parseFloat(qx.core.Environment.get(w)) < 532 && V == s){

            qx.bom.Event.removeNativeListener(U, x, this._onInputWrapper);
          };
          qx.bom.Event.removeNativeListener(U, n, this._onInputWrapper);
        },
        "opera" : function(W){

          // unregister key events for filtering "enter" on input events
          qx.bom.Event.removeNativeListener(W, z, this._onKeyUpWrapper);
          qx.bom.Event.removeNativeListener(W, d, this._onKeyDownWrapper);
          // unregister the blur event (needed for preventing input event on blur)
          qx.bom.Event.removeNativeListener(W, f, this._onBlurWrapper);
          qx.bom.Event.removeNativeListener(W, n, this._onInputWrapper);
        },
        "default" : function(X){

          qx.bom.Event.removeNativeListener(X, n, this._onInputWrapper);
        }
      }),
      /*
      ---------------------------------------------------------------------------
        FOR OPERA AND IE (KEYPRESS TO SIMULATE CHANGE EVENT)
      ---------------------------------------------------------------------------
      */
      /**
       * Handler for fixing the different behavior when pressing the enter key.
       *
       * FF and Safari fire a "change" event if the user presses the enter key.
       * IE and Opera fire the event only if the focus is changed.
       *
       * @signature function(e, target)
       * @param e {Event} DOM event object
       * @param target {Element} The event target
       */
      _onKeyPress : qx.core.Environment.select(q, {
        "mshtml|opera" : function(e, Y){

          if(e.keyCode === 13){

            if(Y.value !== this.__oldValue){

              this.__oldValue = Y.value;
              qx.event.Registration.fireEvent(Y, p, qx.event.type.Data, [Y.value]);
            };
          };
        },
        "default" : null
      }),
      /*
      ---------------------------------------------------------------------------
        FOR IE (KEYUP TO SIMULATE INPUT EVENT)
      ---------------------------------------------------------------------------
      */
      /**
       * Handler for fixing the different behavior when pressing the backspace or
       * delete key.
       *
       * The other browsers fire a "input" event if the user presses the backspace
       * or delete key.
       * IE fire the event only for other keys.
       *
       * @signature function(e, target)
       * @param e {Event} DOM event object
       * @param target {Element} The event target
       */
      _inputFix : qx.core.Environment.select(q, {
        "mshtml" : function(e, ba){

          if(e.keyCode === 46 || e.keyCode === 8){

            if(ba.value !== this.__oldInputValue){

              this.__oldInputValue = ba.value;
              qx.event.Registration.fireEvent(ba, n, qx.event.type.Data, [ba.value]);
            };
          };
        },
        "default" : null
      }),
      /*
      ---------------------------------------------------------------------------
        FOR OPERA ONLY LISTENER (KEY AND BLUR)
      ---------------------------------------------------------------------------
      */
      /**
       * Key event listener for opera which recognizes if the enter key has been
       * pressed.
       *
       * @signature function(e)
       * @param e {Event} DOM event object
       */
      _onKeyDown : qx.core.Environment.select(q, {
        "opera" : function(e){

          // enter is pressed
          if(e.keyCode === 13){

            this.__enter = true;
          };
        },
        "default" : null
      }),
      /**
       * Key event listener for opera which recognizes if the enter key has been
       * pressed.
       *
       * @signature function(e)
       * @param e {Event} DOM event object
       */
      _onKeyUp : qx.core.Environment.select(q, {
        "opera" : function(e){

          // enter is pressed
          if(e.keyCode === 13){

            this.__enter = false;
          };
        },
        "default" : null
      }),
      /**
       * Blur event listener for opera cancels the timeout of the input event.
       *
       * @signature function(e)
       * @param e {Event} DOM event object
       */
      _onBlur : qx.core.Environment.select(q, {
        "opera" : function(e){

          if(this.__onInputTimeoutId && qx.core.Environment.get(b) < 10.6){

            window.clearTimeout(this.__onInputTimeoutId);
          };
        },
        "default" : null
      }),
      /*
      ---------------------------------------------------------------------------
        NATIVE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Internal function called by input elements created using {@link qx.bom.Input}.
       *
       * @signature function(e)
       * @param e {Event} Native DOM event
       */
      _onInput : qx.event.GlobalError.observeMethod(function(e){

        var bc = qx.bom.Event.getTarget(e);
        var bb = bc.tagName.toLowerCase();
        // ignore native input event when triggered by return in input element
        if(!this.__enter || bb !== n){

          // opera lower 10.6 needs a special treatment for input events because
          // they are also fired on blur
          if((qx.core.Environment.get(q) == A) && qx.core.Environment.get(b) < 10.6){

            this.__onInputTimeoutId = window.setTimeout(function(){

              qx.event.Registration.fireEvent(bc, n, qx.event.type.Data, [bc.value]);
            }, 0);
          } else {

            qx.event.Registration.fireEvent(bc, n, qx.event.type.Data, [bc.value]);
          };
        };
      }),
      /**
       * Internal function called by input elements created using {@link qx.bom.Input}.
       *
       * @signature function(e)
       * @param e {Event} Native DOM event
       */
      _onChangeValue : qx.event.GlobalError.observeMethod(function(e){

        var be = qx.bom.Event.getTarget(e);
        var bd = be.value;
        if(be.type === m){

          var bd = [];
          for(var i = 0,o = be.options,l = o.length;i < l;i++){

            if(o[i].selected){

              bd.push(o[i].value);
            };
          };
        };
        qx.event.Registration.fireEvent(be, p, qx.event.type.Data, [bd]);
      }),
      /**
       * Internal function called by input elements created using {@link qx.bom.Input}.
       *
       * @signature function(e)
       * @param e {Event} Native DOM event
       */
      _onChangeChecked : qx.event.GlobalError.observeMethod(function(e){

        var bf = qx.bom.Event.getTarget(e);
        if(bf.type === v){

          if(bf.checked){

            qx.event.Registration.fireEvent(bf, p, qx.event.type.Data, [bf.value]);
          };
        } else {

          qx.event.Registration.fireEvent(bf, p, qx.event.type.Data, [bf.checked]);
        };
      }),
      /**
       * Internal function called by input elements created using {@link qx.bom.Input}.
       *
       * @signature function(e)
       * @param e {Event} Native DOM event
       */
      _onProperty : qx.core.Environment.select(q, {
        "mshtml" : qx.event.GlobalError.observeMethod(function(e){

          var bg = qx.bom.Event.getTarget(e);
          var bh = e.propertyName;
          if(bh === k && (bg.type === t || bg.type === r || bg.tagName.toLowerCase() === s)){

            if(!bg.$$inValueSet){

              qx.event.Registration.fireEvent(bg, n, qx.event.type.Data, [bg.value]);
            };
          } else if(bh === g){

            if(bg.type === u){

              qx.event.Registration.fireEvent(bg, p, qx.event.type.Data, [bg.checked]);
            } else if(bg.checked){

              qx.event.Registration.fireEvent(bg, p, qx.event.type.Data, [bg.value]);
            };
          };
        }),
        "default" : function(){
        }
      })
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(bi){

      qx.event.Registration.addHandler(bi);
    }
  });
})();
(function(){

  var a = "qx.event.handler.Capture";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This class provides capture event support at DOM level.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        capture : true,
        losecapture : true
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(b, c){
      },
      // interface implementation
      registerEvent : function(d, e, f){
      },
      // interface implementation
      unregisterEvent : function(g, h, i){
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(j){

      qx.event.Registration.addHandler(j);
    }
  });
})();
(function(){

  var k = "mousedown",j = "qxDraggable",i = "Escape",h = "drag",g = "Unsupported data type: ",f = "drop",d = "qxDroppable",c = "qx.event.handler.DragDrop",b = "This method must not be used outside the drop event listener!",a = "!",H = "droprequest",G = "dragstart",F = "dragchange",E = "dragleave",D = "dragover",C = "left",B = "Please use a droprequest listener to the drag source to fill the manager with data!",A = "blur",z = "mouseout",y = "keydown",r = "Control",s = "Shift",p = "mousemove",q = "move",n = "mouseover",o = "Alt",l = "keyup",m = "mouseup",t = "keypress",u = "dragend",w = "on",v = "copy",x = "alias";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.Mouse)
  #require(qx.event.handler.Keyboard)
  #require(qx.event.handler.Capture)
  
  ************************************************************************ */
  /**
   * Event handler, which supports drag events on DOM elements.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(I){

      qx.core.Object.call(this);
      // Define shorthands
      this.__manager = I;
      this.__root = I.getWindow().document.documentElement;
      // Initialize mousedown listener
      this.__manager.addListener(this.__root, k, this._onMouseDown, this);
      // Initialize data structures
      this.__rebuildStructures();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        dragstart : 1,
        dragend : 1,
        dragover : 1,
        dragleave : 1,
        drop : 1,
        drag : 1,
        dragchange : 1,
        droprequest : 1
      },
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      __root : null,
      __dropTarget : null,
      __dragTarget : null,
      __types : null,
      __actions : null,
      __keys : null,
      __cache : null,
      __currentType : null,
      __currentAction : null,
      __sessionActive : false,
      __startLeft : 0,
      __startTop : 0,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(J, K){
      },
      // interface implementation
      registerEvent : function(L, M, N){
      },
      // interface implementation
      unregisterEvent : function(O, P, Q){
      },
      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Registers a supported type
       *
       * @param type {String} The type to add
       */
      addType : function(R){

        this.__types[R] = true;
      },
      /**
       * Registers a supported action. One of <code>move</code>,
       * <code>copy</code> or <code>alias</code>.
       *
       * @param action {String} The action to add
       */
      addAction : function(S){

        this.__actions[S] = true;
      },
      /**
       * Whether the current drag target supports the given type
       *
       * @param type {String} Any type
       * @return {Boolean} Whether the type is supported
       */
      supportsType : function(T){

        return !!this.__types[T];
      },
      /**
       * Whether the current drag target supports the given action
       *
       * @param type {String} Any type
       * @return {Boolean} Whether the action is supported
       */
      supportsAction : function(U){

        return !!this.__actions[U];
      },
      /**
       * Returns the data of the given type during the <code>drop</code> event
       * on the drop target. This method fires a <code>droprequest</code> at
       * the drag target which should be answered by calls to {@link #addData}.
       *
       * @param type {String} Any supported type
       * @return {var} The result data
       */
      getData : function(V){

        if(!this.__validDrop || !this.__dropTarget){

          throw new Error(b);
        };
        if(!this.__types[V]){

          throw new Error(g + V + a);
        };
        if(!this.__cache[V]){

          this.__currentType = V;
          this.__fireEvent(H, this.__dragTarget, this.__dropTarget, false);
        };
        if(!this.__cache[V]){

          throw new Error(B);
        };
        return this.__cache[V] || null;
      },
      /**
       * Returns the currently selected action (by user keyboard modifiers)
       *
       * @return {String} One of <code>move</code>, <code>copy</code> or
       *    <code>alias</code>
       */
      getCurrentAction : function(){

        return this.__currentAction;
      },
      /**
       * Adds data of the given type to the internal storage. The data
       * is available until the <code>dragend</code> event is fired.
       *
       * @param type {String} Any valid type
       * @param data {var} Any data to store
       */
      addData : function(W, X){

        this.__cache[W] = X;
      },
      /**
       * Returns the type which was requested last.
       *
       * @return {String} The last requested data type
       */
      getCurrentType : function(){

        return this.__currentType;
      },
      /**
       * Returns if a drag session is currently active
       *
       * @return {Boolean} active drag session
       */
      isSessionActive : function(){

        return this.__sessionActive;
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL UTILS
      ---------------------------------------------------------------------------
      */
      /**
       * Rebuilds the internal data storage used during a drag&drop session
       */
      __rebuildStructures : function(){

        this.__types = {
        };
        this.__actions = {
        };
        this.__keys = {
        };
        this.__cache = {
        };
      },
      /**
       * Detects the current action and stores it under the private
       * field <code>__currentAction</code>. Also fires the event
       * <code>dragchange</code> on every modification.
       */
      __detectAction : function(){

        if(this.__dragTarget == null){

          return;
        };
        var bb = this.__actions;
        var Y = this.__keys;
        var ba = null;
        if(this.__validDrop){

          if(Y.Shift && Y.Control && bb.alias){

            ba = x;
          } else if(Y.Shift && Y.Alt && bb.copy){

            ba = v;
          } else if(Y.Shift && bb.move){

            ba = q;
          } else if(Y.Alt && bb.alias){

            ba = x;
          } else if(Y.Control && bb.copy){

            ba = v;
          } else if(bb.move){

            ba = q;
          } else if(bb.copy){

            ba = v;
          } else if(bb.alias){

            ba = x;
          };;;;;;;
        };
        if(ba != this.__currentAction){

          this.__currentAction = ba;
          this.__fireEvent(F, this.__dragTarget, this.__dropTarget, false);
        };
      },
      /**
       * Wrapper for {@link qx.event.Registration#fireEvent} for drag&drop events
       * needed in this class.
       *
       * @param type {String} Event type
       * @param target {Object} Target to fire on
       * @param relatedTarget {Object} Related target, i.e. drag or drop target
       *    depending on the drag event
       * @param cancelable {Boolean} Whether the event is cancelable
       * @param original {qx.event.type.Mouse} Original mouse event
       */
      __fireEvent : function(bc, bd, be, bf, bg){

        var bi = qx.event.Registration;
        var bh = bi.createEvent(bc, qx.event.type.Drag, [bf, bg]);
        if(bd !== be){

          bh.setRelatedTarget(be);
        };
        return bi.dispatchEvent(bd, bh);
      },
      /**
       * Finds next draggable parent of the given element. Maybe the element itself as well.
       *
       * Looks for the attribute <code>qxDraggable</code> with the value <code>on</code>.
       *
       * @param elem {Element} The element to query
       * @return {Element} The next parent element which is draggable. May also be <code>null</code>
       */
      __findDraggable : function(bj){

        while(bj && bj.nodeType == 1){

          if(bj.getAttribute(j) == w){

            return bj;
          };
          bj = bj.parentNode;
        };
        return null;
      },
      /**
       * Finds next droppable parent of the given element. Maybe the element itself as well.
       *
       * Looks for the attribute <code>qxDroppable</code> with the value <code>on</code>.
       *
       * @param elem {Element} The element to query
       * @return {Element} The next parent element which is droppable. May also be <code>null</code>
       */
      __findDroppable : function(bk){

        while(bk && bk.nodeType == 1){

          if(bk.getAttribute(d) == w){

            return bk;
          };
          bk = bk.parentNode;
        };
        return null;
      },
      /**
       * Clean up event listener and structures when a drag was ended without ever starting into session mode
       * (e.g. not reaching the required offset before)
       */
      __clearInit : function(){

        // Clear drag target
        this.__dragTarget = null;
        // Deregister from root events
        this.__manager.removeListener(this.__root, p, this._onMouseMove, this, true);
        this.__manager.removeListener(this.__root, m, this._onMouseUp, this, true);
        // Deregister from window's blur
        qx.event.Registration.removeListener(window, A, this._onWindowBlur, this);
        // Clear structures
        this.__rebuildStructures();
      },
      /**
       * Cleans up a drag&drop session when <code>dragstart</code> was fired before.
       */
      __clearSession : function(){

        if(this.__sessionActive){

          // Deregister from root events
          this.__manager.removeListener(this.__root, n, this._onMouseOver, this, true);
          this.__manager.removeListener(this.__root, z, this._onMouseOut, this, true);
          this.__manager.removeListener(this.__root, y, this._onKeyDown, this, true);
          this.__manager.removeListener(this.__root, l, this._onKeyUp, this, true);
          this.__manager.removeListener(this.__root, t, this._onKeyPress, this, true);
          // Fire dragend event
          this.__fireEvent(u, this.__dragTarget, this.__dropTarget, false);
          // Clear flag
          this.__sessionActive = false;
        };
        // Cleanup
        this.__validDrop = false;
        this.__dropTarget = null;
        // Clear init
        this.__clearInit();
      },
      /** {Boolean} Whether a valid drop object exists */
      __validDrop : false,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for window's <code>blur</code> event
       *
       * @param e {qx.event.type.Event} Event object
       */
      _onWindowBlur : function(e){

        this.__clearSession();
      },
      /**
       * Event listener for root's <code>keydown</code> event
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyDown : function(e){

        var bl = e.getKeyIdentifier();
        switch(bl){case o:case r:case s:
        if(!this.__keys[bl]){

          this.__keys[bl] = true;
          this.__detectAction();
        };};
      },
      /**
       * Event listener for root's <code>keyup</code> event
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyUp : function(e){

        var bm = e.getKeyIdentifier();
        switch(bm){case o:case r:case s:
        if(this.__keys[bm]){

          this.__keys[bm] = false;
          this.__detectAction();
        };};
      },
      /**
       * Event listener for root's <code>keypress</code> event
       *
       * @param e {qx.event.type.KeySequence} Event object
       */
      _onKeyPress : function(e){

        var bn = e.getKeyIdentifier();
        switch(bn){case i:
        this.__clearSession();};
      },
      /**
       * Event listener for root's <code>mousedown</code> event
       *
       * @param e {qx.event.type.Mouse} Event object
       */
      _onMouseDown : function(e){

        if(this.__sessionActive || e.getButton() !== C){

          return;
        };
        var bo = this.__findDraggable(e.getTarget());
        if(bo){

          // Cache coordinates for offset calculation
          this.__startLeft = e.getDocumentLeft();
          this.__startTop = e.getDocumentTop();
          // This is the source target
          this.__dragTarget = bo;
          // Register move event to manager
          this.__manager.addListener(this.__root, p, this._onMouseMove, this, true);
          this.__manager.addListener(this.__root, m, this._onMouseUp, this, true);
          // Register window blur listener
          qx.event.Registration.addListener(window, A, this._onWindowBlur, this);
        };
      },
      /**
       * Event listener for root's <code>mouseup</code> event
       *
       * @param e {qx.event.type.Mouse} Event object
       */
      _onMouseUp : function(e){

        // Fire drop event in success case
        if(this.__validDrop){

          this.__fireEvent(f, this.__dropTarget, this.__dragTarget, false, e);
        };
        // Stop event
        if(this.__sessionActive){

          e.stopPropagation();
        };
        // Clean up
        this.__clearSession();
      },
      /**
       * Event listener for root's <code>mousemove</code> event
       *
       * @param e {qx.event.type.Mouse} Event object
       */
      _onMouseMove : function(e){

        // Whether the session is already active
        if(this.__sessionActive){

          // Fire specialized move event
          if(!this.__fireEvent(h, this.__dragTarget, this.__dropTarget, true, e)){

            this.__clearSession();
          };
        } else {

          if(Math.abs(e.getDocumentLeft() - this.__startLeft) > 3 || Math.abs(e.getDocumentTop() - this.__startTop) > 3){

            if(this.__fireEvent(G, this.__dragTarget, this.__dropTarget, true, e)){

              // Flag session as active
              this.__sessionActive = true;
              // Register to root events
              this.__manager.addListener(this.__root, n, this._onMouseOver, this, true);
              this.__manager.addListener(this.__root, z, this._onMouseOut, this, true);
              this.__manager.addListener(this.__root, y, this._onKeyDown, this, true);
              this.__manager.addListener(this.__root, l, this._onKeyUp, this, true);
              this.__manager.addListener(this.__root, t, this._onKeyPress, this, true);
              // Reevaluate current action
              var bp = this.__keys;
              bp.Control = e.isCtrlPressed();
              bp.Shift = e.isShiftPressed();
              bp.Alt = e.isAltPressed();
              this.__detectAction();
            } else {

              // Fire dragend event
              this.__fireEvent(u, this.__dragTarget, this.__dropTarget, false);
              // Clean up
              this.__clearInit();
            };
          };
        };
      },
      /**
       * Event listener for root's <code>mouseover</code> event
       *
       * @param e {qx.event.type.Mouse} Event object
       */
      _onMouseOver : function(e){

        var bq = e.getTarget();
        var br = this.__findDroppable(bq);
        if(br && br != this.__dropTarget){

          this.__validDrop = this.__fireEvent(D, br, this.__dragTarget, true, e);
          this.__dropTarget = br;
          this.__detectAction();
        };
      },
      /**
       * Event listener for root's <code>mouseout</code> event
       *
       * @param e {qx.event.type.Mouse} Event object
       */
      _onMouseOut : function(e){

        var bt = this.__findDroppable(e.getTarget());
        var bs = this.__findDroppable(e.getRelatedTarget());
        if(bt && bt !== bs && bt == this.__dropTarget){

          this.__fireEvent(E, this.__dropTarget, bs, false, e);
          this.__dropTarget = null;
          this.__validDrop = false;
          qx.event.Timer.once(this.__detectAction, this, 0);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      // Clear fields
      this.__dragTarget = this.__dropTarget = this.__manager = this.__root = this.__types = this.__actions = this.__keys = this.__cache = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(bu){

      qx.event.Registration.addHandler(bu);
    }
  });
})();
(function(){

  var a = "qx.event.type.Drag";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * Event object class for drag events
   */
  qx.Class.define(a, {
    extend : qx.event.type.Event,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @param originalEvent {qx.event.type.Mouse} The original (mouse) event to use
       * @return {qx.event.type.Event} The initialized event instance
       */
      init : function(b, c){

        qx.event.type.Event.prototype.init.call(this, true, b);
        if(c){

          this._native = c.getNativeEvent() || null;
          this._originalTarget = c.getTarget() || null;
        } else {

          this._native = null;
          this._originalTarget = null;
        };
        return this;
      },
      // overridden
      clone : function(d){

        var e = qx.event.type.Event.prototype.clone.call(this, d);
        e._native = this._native;
        return e;
      },
      /**
       * Get the horizontal position at which the event occurred relative to the
       * left of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Integer} The horizontal mouse position in the document.
       */
      getDocumentLeft : function(){

        if(this._native == null){

          return 0;
        };
        if(this._native.pageX !== undefined){

          return this._native.pageX;
        } else {

          var f = qx.dom.Node.getWindow(this._native.srcElement);
          return this._native.clientX + qx.bom.Viewport.getScrollLeft(f);
        };
      },
      /**
       * Get the vertical position at which the event occurred relative to the
       * top of the document. This property takes into account any scrolling of
       * the page.
       *
       * @return {Integer} The vertical mouse position in the document.
       */
      getDocumentTop : function(){

        if(this._native == null){

          return 0;
        };
        if(this._native.pageY !== undefined){

          return this._native.pageY;
        } else {

          var g = qx.dom.Node.getWindow(this._native.srcElement);
          return this._native.clientY + qx.bom.Viewport.getScrollTop(g);
        };
      },
      /**
       * Returns the drag&drop event handler responsible for the target
       *
       * @return {qx.event.handler.DragDrop} The drag&drop handler
       */
      getManager : function(){

        return qx.event.Registration.getManager(this.getTarget()).getHandler(qx.event.handler.DragDrop);
      },
      /**
       * Used during <code>dragstart</code> listener to
       * inform the manager about supported data types.
       *
       * @param type {String} Data type to add to list of supported types
       */
      addType : function(h){

        this.getManager().addType(h);
      },
      /**
       * Used during <code>dragstart</code> listener to
       * inform the manager about supported drop actions.
       *
       * @param action {String} Action to add to the list of supported actions
       */
      addAction : function(i){

        this.getManager().addAction(i);
      },
      /**
       * Whether the given type is supported by the drag
       * target (source target).
       *
       * This is used in the event listeners for <code>dragover</code>
       * or <code>dragdrop</code>.
       *
       * @param type {String} The type to look for
       * @return {Boolean} Whether the given type is supported
       */
      supportsType : function(j){

        return this.getManager().supportsType(j);
      },
      /**
       * Whether the given action is supported by the drag
       * target (source target).
       *
       * This is used in the event listeners for <code>dragover</code>
       * or <code>dragdrop</code>.
       *
       * @param action {String} The action to look for
       * @return {Boolean} Whether the given action is supported
       */
      supportsAction : function(k){

        return this.getManager().supportsAction(k);
      },
      /**
       * Adds data of the given type to the internal storage. The data
       * is available until the <code>dragend</code> event is fired.
       *
       * @param type {String} Any valid type
       * @param data {var} Any data to store
       */
      addData : function(l, m){

        this.getManager().addData(l, m);
      },
      /**
       * Returns the data of the given type. Used in the <code>drop</code> listener.
       *
       * @param type {String} Any of the supported types.
       */
      getData : function(n){

        return this.getManager().getData(n);
      },
      /**
       * Returns the type which was requested last, to be used
       * in the <code>droprequest</code> listener.
       *
       * @return {String} The last requested data type
       */
      getCurrentType : function(){

        return this.getManager().getCurrentType();
      },
      /**
       * Returns the currently selected action. Depends on the
       * supported actions of the source target and the modification
       * keys pressed by the user.
       *
       * Used in the <code>droprequest</code> listener.
       *
       * @return {String} The action. May be one of <code>move</code>,
       *    <code>copy</code> or <code>alias</code>.
       */
      getCurrentAction : function(){

        return this.getManager().getCurrentAction();
      }
    }
  });
})();
(function(){

  var c = "qx.event.handler.Offline",b = "offline",a = "online";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class provides a handler for the online event.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(d){

      qx.core.Object.call(this);
      this.__manager = d;
      this.__window = d.getWindow();
      this._initObserver();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        online : true,
        offline : true
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_WINDOW,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : true
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      __window : null,
      __onNativeWrapper : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(e, f){
      },
      // interface implementation
      registerEvent : function(g, h, i){
      },
      // interface implementation
      unregisterEvent : function(j, k, l){
      },
      /**
       * Connects the native online and offline event listeners.
       */
      _initObserver : function(){

        this.__onNativeWrapper = qx.lang.Function.listener(this._onNative, this);
        qx.bom.Event.addNativeListener(this.__window, b, this.__onNativeWrapper);
        qx.bom.Event.addNativeListener(this.__window, a, this.__onNativeWrapper);
      },
      /**
       * Disconnects the native online and offline event listeners.
       */
      _stopObserver : function(){

        qx.bom.Event.removeNativeListener(this.__window, b, this.__onNativeWrapper);
        qx.bom.Event.removeNativeListener(this.__window, a, this.__onNativeWrapper);
      },
      /**
       * Native handler function which fires a qooxdoo event.
       * @signature function(domEvent)
       * @param domEvent {Event} Native DOM event
       */
      _onNative : qx.event.GlobalError.observeMethod(function(m){

        qx.event.Registration.fireEvent(this.__window, m.type, qx.event.type.Event, []);
      }),
      /*
      ---------------------------------------------------------------------------
        USER ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns whether the current window thinks its online or not.
       * @return {Boolean} <code>true</code> if its online
       */
      isOnline : function(){

        return !!this.__window.navigator.onLine;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__manager = null;
      this._stopObserver();
      // Deregister
      delete qx.event.handler.Appear.__instances[this.$$hash];
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(n){

      qx.event.Registration.addHandler(n);
    }
  });
})();
(function(){

  var f = "Use qx.dom.Element.create instead",e = "Use qx.dom.Element.getHelperElement instead",d = "qx.bom.Element",c = "Use qx.dom.Element.empty instead",b = "mshtml",a = "engine.name";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.dispatch.Direct)
  #require(qx.event.dispatch.DomBubbling)
  #require(qx.event.handler.Keyboard)
  #require(qx.event.handler.Mouse)
  #require(qx.event.handler.DragDrop)
  #require(qx.event.handler.Element)
  #require(qx.event.handler.Appear)
  #require(qx.event.handler.Touch)
  #require(qx.event.handler.Offline)
  #require(qx.event.handler.Input)
  
  ************************************************************************ */
  /**
   * This class is mainly a convenience wrapper for DOM elements to
   * qooxdoo's event system.
   */
  qx.Class.define(d, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /*
      ---------------------------------------------------------------------------
        CREATION
      ---------------------------------------------------------------------------
      */
      /**
       * Detects if the DOM support a <code>document.createElement</code> call with a
       * <code>String</code> as markup like:
       *
       * <pre class="javascript">
       * document.createElement("<INPUT TYPE='RADIO' NAME='RADIOTEST' VALUE='Second Choice'>");
       * </pre>
       *
       * Element creation with markup is not standard compatible with Document Object Model (Core) Level 1, but
       * Internet Explorer supports it. With an exception that IE9 in IE9 standard mode is standard compatible and
       * doesn't support element creation with markup.
       *
       * @param win {Window?} Window to check for
       * @return {Boolean} <code>true</code> if the DOM supports it, <code>false</code> otherwise.
       * @deprecated since 2.0
       */
      allowCreationWithMarkup : function(g){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee);
        return qx.dom.Element._allowCreationWithMarkup(g);
      },
      /**
       * Creates and returns a DOM helper element.
       *
       * @param win {Window?} Window to create the element for
       * @return {Element} The created element node
       * @deprecated since 2.0
       */
      getHelperElement : function(h){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, e);
        return qx.dom.Element.getHelperElement(h);
      },
      /**
       * Creates an DOM element.
       *
       * Attributes may be given directly with this call. This is critical
       * for some attributes e.g. name, type, ... in many clients.
       *
       * Depending on the kind of attributes passed, <code>innerHTML</code> may be
       * used internally to assemble the element. Please make sure you understand
       * the security implications. See {@link qx.bom.Html#clean}.
       *
       * @param name {String} Tag name of the element
       * @param attributes {Map?} Map of attributes to apply
       * @param win {Window?} Window to create the element for
       * @return {Element} The created element node
       * @deprecated since 2.0
       */
      create : function(name, k, m){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, f);
        return qx.dom.Element.create(name, k, m);
      },
      /*
      ---------------------------------------------------------------------------
        MODIFICATION
      ---------------------------------------------------------------------------
      */
      /**
       * Removes all content from the given element
       *
       * @param element {Element} element to clean
       * @return {String} empty string (new HTML content)
       * @deprecated since 2.0
       */
      empty : function(n){

        qx.log.Logger.deprecatedMethodWarning(arguments.callee, c);
        return qx.dom.Element.empty(n);
      },
      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */
      /**
       * Add an event listener to a DOM element. The event listener is passed an
       * instance of {@link Event} containing all relevant information
       * about the event as parameter.
       *
       * @param element {Element} DOM element to attach the event on.
       * @param type {String} Name of the event e.g. "click", "keydown", ...
       * @param listener {Function} Event listener function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean} Whether to attach the event to the
       *       capturing phase or the bubbling phase of the event. The default is
       *       to attach the event handler to the bubbling phase.
       * @return {String} An opaque id, which can be used to remove the event listener
       *       using the {@link #removeListenerById} method.
       */
      addListener : function(o, p, q, self, r){

        return qx.event.Registration.addListener(o, p, q, self, r);
      },
      /**
       * Remove an event listener from a from DOM node.
       *
       * Note: All registered event listeners will automatically be removed from
       *   the DOM at page unload so it is not necessary to detach events yourself.
       *
       * @param element {Element} DOM Element
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the event listener
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener.
       * @param capture {Boolean} Whether to remove the event listener of
       *       the bubbling or of the capturing phase.
       */
      removeListener : function(s, t, u, self, v){

        return qx.event.Registration.removeListener(s, t, u, self, v);
      },
      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param target {Object} The event target
       * @param id {String} The id returned by {@link #addListener}
       */
      removeListenerById : function(w, x){

        return qx.event.Registration.removeListenerById(w, x);
      },
      /**
       * Check whether there are one or more listeners for an event type
       * registered at the element.
       *
       * @param element {Element} DOM element
       * @param type {String} The event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *       the bubbling or of the capturing phase.
       * @return {Boolean} Whether the element has event listeners of the given type.
       */
      hasListener : function(y, z, A){

        return qx.event.Registration.hasListener(y, z, A);
      },
      /**
       * Focuses the given element. The element needs to have a positive <code>tabIndex</code> value.
       *
       * @param element {Element} DOM element to focus
       * @return {void}
       */
      focus : function(B){

        qx.event.Registration.getManager(B).getHandler(qx.event.handler.Focus).focus(B);
      },
      /**
       * Blurs the given element
       *
       * @param element {Element} DOM element to blur
       * @return {void}
       */
      blur : function(C){

        qx.event.Registration.getManager(C).getHandler(qx.event.handler.Focus).blur(C);
      },
      /**
       * Activates the given element. The active element receives all key board events.
       *
       * @param element {Element} DOM element to focus
       * @return {void}
       */
      activate : function(D){

        qx.event.Registration.getManager(D).getHandler(qx.event.handler.Focus).activate(D);
      },
      /**
       * Deactivates the given element. The active element receives all key board events.
       *
       * @param element {Element} DOM element to focus
       * @return {void}
       */
      deactivate : function(E){

        qx.event.Registration.getManager(E).getHandler(qx.event.handler.Focus).deactivate(E);
      },
      /**
       * Captures the given element
       *
       * @param element {Element} DOM element to capture
       * @param containerCapture {Boolean?true} If true all events originating in
       *   the container are captured. If false events originating in the container
       *   are not captured.
       */
      capture : function(F, G){

        qx.event.Registration.getManager(F).getDispatcher(qx.event.dispatch.MouseCapture).activateCapture(F, G);
      },
      /**
       * Releases the given element (from a previous {@link #capture} call)
       *
       * @param element {Element} DOM element to release
       * @return {void}
       */
      releaseCapture : function(H){

        qx.event.Registration.getManager(H).getDispatcher(qx.event.dispatch.MouseCapture).releaseCapture(H);
      },
      /**
       * Tests if the element matches the selector
       *
       * @param element {Element} DOM element to test against
       * @param selector {String} Valid selector (CSS3 + extensions)
       * @return {Boolean} whether the element can be selected by the selector or not
       * @deprecated since 2.0
       */
      matchesSelector : function(I, J){

        if(J){

          return qx.bom.Selector.query(J, I.parentNode).length > 0;
        } else {

          return false;
        };
      },
      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */
      /**
       * Clone given DOM element. May optionally clone all attached
       * events (recursively) as well.
       *
       * @param element {Element} Element to clone
       * @param events {Boolean?false} Whether events should be copied as well
       * @return {Element} The copied element
       */
      clone : function(K, L){

        var O;
        if(L || ((qx.core.Environment.get(a) == b) && !qx.xml.Document.isXmlDocument(K))){

          var S = qx.event.Registration.getManager(K);
          var M = qx.dom.Hierarchy.getDescendants(K);
          M.push(K);
        };
        // IE copies events bound via attachEvent() when
        // using cloneNode(). Calling detachEvent() on the
        // clone will also remove the events from the orignal.
        //
        // In order to get around this, we detach all locally
        // attached events first, do the cloning and recover
        // them afterwards again.
        if((qx.core.Environment.get(a) == b)){

          for(var i = 0,l = M.length;i < l;i++){

            S.toggleAttachedEvents(M[i], false);
          };
        };
        // Do the native cloning
        var O = K.cloneNode(true);
        // Recover events on original elements
        if((qx.core.Environment.get(a) == b)){

          for(var i = 0,l = M.length;i < l;i++){

            S.toggleAttachedEvents(M[i], true);
          };
        };
        // Attach events from original element
        if(L === true){

          // Produce recursive list of elements in the clone
          var V = qx.dom.Hierarchy.getDescendants(O);
          V.push(O);
          // Process all elements and copy over listeners
          var N,Q,U,P;
          for(var i = 0,T = M.length;i < T;i++){

            U = M[i];
            N = S.serializeListeners(U);
            if(N.length > 0){

              Q = V[i];
              for(var j = 0,R = N.length;j < R;j++){

                P = N[j];
                S.addListener(Q, P.type, P.handler, P.self, P.capture);
              };
            };
          };
        };
        // Finally return the clone
        return O;
      }
    }
  });
})();
(function(){

  var i = "mshtml",h = "blur",g = "focus",f = "click",e = "qx.event.dispatch.MouseCapture",d = "capture",c = "scroll",b = "engine.name",a = "losecapture";
  /* ************************************************************************
  
    qooxdoo - the new era of web development
  
    http://qooxdoo.org
  
    Copyright:
      2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
    License:
      LGPL: http://www.gnu.org/licenses/lgpl.html
      EPL: http://www.eclipse.org/org/documents/epl-v10.php
      See the LICENSE file in the project's top-level directory for details.
  
    Authors:
      * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.event.handler.Focus)
  #use(qx.event.handler.Window)
  #use(qx.event.handler.Capture)
  
  ************************************************************************ */
  /**
   * Implementation of the Internet Explorer specific event capturing mode for
   * mouse events http://msdn2.microsoft.com/en-us/library/ms536742.aspx.
   *
   * This class is used internally by {@link qx.event.Manager} to do mouse event
   * capturing.
   */
  qx.Class.define(e, {
    extend : qx.event.dispatch.AbstractBubbling,
    /**
     * @param manager {qx.event.Manager} Event manager for the window to use
     * @param registration {qx.event.Registration} The event registration to use
     */
    construct : function(j, k){

      qx.event.dispatch.AbstractBubbling.call(this, j);
      this.__window = j.getWindow();
      this.__registration = k;
      j.addListener(this.__window, h, this.releaseCapture, this);
      j.addListener(this.__window, g, this.releaseCapture, this);
      j.addListener(this.__window, c, this.releaseCapture, this);
    },
    statics : {
      /** {Integer} Priority of this dispatcher */
      PRIORITY : qx.event.Registration.PRIORITY_FIRST
    },
    members : {
      __registration : null,
      __captureElement : null,
      __containerCapture : true,
      __window : null,
      // overridden
      _getParent : function(l){

        return l.parentNode;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      canDispatchEvent : function(m, event, n){

        return !!(this.__captureElement && this.__captureEvents[n]);
      },
      // overridden
      dispatchEvent : function(o, event, p){

        // Conforming to the MS implementation a mouse click will stop mouse
        // capturing. The event is "eaten" by the capturing handler.
        if(p == f){

          event.stopPropagation();
          this.releaseCapture();
          return;
        };
        if(this.__containerCapture || !qx.dom.Hierarchy.contains(this.__captureElement, o)){

          o = this.__captureElement;
        };
        qx.event.dispatch.AbstractBubbling.prototype.dispatchEvent.call(this, o, event, p);
      },
      /*
      ---------------------------------------------------------------------------
        HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * @lint ignoreReferenceField(__captureEvents)
       */
      __captureEvents : {
        "mouseup" : 1,
        "mousedown" : 1,
        "click" : 1,
        "dblclick" : 1,
        "mousemove" : 1,
        "mouseout" : 1,
        "mouseover" : 1
      },
      /*
      ---------------------------------------------------------------------------
        USER ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Set the given element as target for event
       *
       * @param element {Element} The element which should capture the mouse events.
       * @param containerCapture {Boolean?true} If true all events originating in
       *   the container are captured. IF false events originating in the container
       *   are not captured.
       */
      activateCapture : function(q, r){

        var r = r !== false;
        if(this.__captureElement === q && this.__containerCapture == r){

          return;
        };
        if(this.__captureElement){

          this.releaseCapture();
        };
        // turn on native mouse capturing if the browser supports it
        this.nativeSetCapture(q, r);
        if(this.hasNativeCapture){

          var self = this;
          qx.bom.Event.addNativeListener(q, a, function(){

            qx.bom.Event.removeNativeListener(q, a, arguments.callee);
            self.releaseCapture();
          });
        };
        this.__containerCapture = r;
        this.__captureElement = q;
        this.__registration.fireEvent(q, d, qx.event.type.Event, [true, false]);
      },
      /**
       * Get the element currently capturing events.
       *
       * @return {Element|null} The current capture element. This value may be
       *    null.
       */
      getCaptureElement : function(){

        return this.__captureElement;
      },
      /**
       * Stop capturing of mouse events.
       */
      releaseCapture : function(){

        var s = this.__captureElement;
        if(!s){

          return;
        };
        this.__captureElement = null;
        this.__registration.fireEvent(s, a, qx.event.type.Event, [true, false]);
        // turn off native mouse capturing if the browser supports it
        this.nativeReleaseCapture(s);
      },
      /** Whether the browser has native mouse capture support */
      hasNativeCapture : qx.core.Environment.get(b) == i,
      /**
       * If the browser supports native mouse capturing, sets the mouse capture to
       * the object that belongs to the current document.
       *
       * @param element {Element} The capture DOM element
       * @param containerCapture {Boolean?true} If true all events originating in
       *   the container are captured. If false events originating in the container
       *   are not captured.
       * @signature function(element, containerCapture)
       */
      nativeSetCapture : qx.core.Environment.select(b, {
        "mshtml" : function(t, u){

          t.setCapture(u !== false);
        },
        "default" : qx.lang.Function.empty
      }),
      /**
       * If the browser supports native mouse capturing, removes mouse capture
       * from the object in the current document.
       *
       * @param element {Element} The DOM element to release the capture for
       * @signature function(element)
       */
      nativeReleaseCapture : qx.core.Environment.select(b, {
        "mshtml" : function(v){

          v.releaseCapture();
        },
        "default" : qx.lang.Function.empty
      })
    },
    destruct : function(){

      this.__captureElement = this.__window = this.__registration = null;
    },
    defer : function(w){

      qx.event.Registration.addDispatcher(w);
    }
  });
})();
(function(){

  var q = "text",p = "file",o = "+",n = "'/>",k = "CLASS",h = "HTML",g = "radio",f = "script",d = "className",c = "TAG",bh = "[test!='']:sizzle",bg = "password",bf = "htmlFor",be = "submit",bd = "<a href='#'></a>",bc = "<a name='",bb = "#",ba = "qx.bom.Selector",Y = "type",X = "'] ",x = "\\$&",y = "parentNode",v = "previousSibling",w = "NAME",t = "number",u = "='$1']",r = "reset",s = 'type',B = "image",C = ".TEST",K = "<div class='test e'></div><div class='test'></div>",I = "Syntax error, unrecognized expression: ",P = "~",M = "checkbox",T = "[id='",R = "hidden",E = "__sizzle__",W = "<p class='TEST'></p>",V = "ID",U = "body",D = "object",G = "button",H = "[object Array]",J = "href",L = "e",N = "\\",Q = "div",S = "*",z = "id",A = "string",F = "undefined",O = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008-2010 Sebastian Werner, http://sebastian-werner.net
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Sizzle CSS Selector Engine - v1.5.1
  
       Homepage:
         http://sizzlejs.com/
  
       Documentation:
         http://wiki.github.com/jeresig/sizzle
  
       Discussion:
         http://groups.google.com/group/sizzlejs
  
       Code:
         http://github.com/jeresig/sizzle/tree
  
       Copyright:
         (c) 2009, The Dojo Foundation
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
     ----------------------------------------------------------------------
  
       Copyright (c) 2009 John Resig
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation files
       (the "Software"), to deal in the Software without restriction,
       including without limitation the rights to use, copy, modify, merge,
       publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
       subject to the following conditions:
  
       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       DEALINGS IN THE SOFTWARE.
  
     ----------------------------------------------------------------------
  
       Version:
         Snapshot taken on 2011-03-15, latest Sizzle commit on 2011-02-18:
         commit  ef19279f54ba49242c6461d47577c703f4f4e80e
  
  ************************************************************************ */
  /**
   * The selector engine supports virtually all CSS 3 Selectors  – this even
   * includes some parts that are infrequently implemented such as escaped
   * selectors (<code>.foo\\+bar</code>), Unicode selectors, and results returned
   * in document order. There are a few notable exceptions to the CSS 3 selector
   * support:
   *
   * * <code>:root</code>
   * * <code>:target</code>
   * * <code>:nth-last-child</code>
   * * <code>:nth-of-type</code>
   * * <code>:nth-last-of-type</code>
   * * <code>:first-of-type</code>
   * * <code>:last-of-type</code>
   * * <code>:only-of-type</code>
   * * <code>:lang()</code>
   *
   * In addition to the CSS 3 Selectors the engine supports the following
   * additional selectors or conventions.
   *
   * *Changes*
   *
   * * <code>:not(a.b)</code>: Supports non-simple selectors in <code>:not()</code> (most browsers only support <code>:not(a)</code>, for example).
   * * <code>:not(div > p)</code>: Supports full selectors in <code>:not()</code>.
   * * <code>:not(div, p)</code>: Supports multiple selectors in <code>:not()</code>.
   * * <code>[NAME=VALUE]</code>: Doesn't require quotes around the specified value in an attribute selector.
   *
   * *Additions*
   *
   * * <code>[NAME!=VALUE]</code>: Finds all elements whose <code>NAME</code> attribute doesn't match the specified value. Is equivalent to doing <code>:not([NAME=VALUE])</code>.
   * * <code>:contains(TEXT)</code>: Finds all elements whose textual context contains the word <code>TEXT</code> (case sensitive).
   * * <code>:header</code>: Finds all elements that are a header element (h1, h2, h3, h4, h5, h6).
   * * <code>:parent</code>: Finds all elements that contains another element.
   *
   * *Positional Selector Additions*
   *
   * * <code>:first</code>/</code>:last</code>: Finds the first or last matching element on the page. (e.g. <code>div:first</code> would find the first div on the page, in document order)
   * * <code>:even</code>/<code>:odd</code>: Finds every other element on the page (counting begins at 0, so <code>:even</code> would match the first element).
   * * <code>:eq</code>/<code>:nth</code>: Finds the Nth element on the page (e.g. <code>:eq(5)</code> finds the 6th element on the page).
   * * <code>:lt</code>/<code>:gt</code>: Finds all elements at positions less than or greater than the specified positions.
   *
   * *Form Selector Additions*
   *
   * * <code>:input</code>: Finds all input elements (includes textareas, selects, and buttons).
   * * <code>:text</code>, <code>:checkbox</code>, <code>:file</code>, <code>:password</code>, <code>:submit</code>, <code>:image</code>, <code>:reset</code>, <code>:button</code>: Finds the input element with the specified input type (<code>:button</code> also finds button elements).
   *
   * Based on Sizzle by John Resig, see:
   *
   * * http://sizzlejs.com/
   *
   * For further usage details also have a look at the wiki page at:
   *
   * * https://github.com/jquery/sizzle/wiki/Sizzle-Home
   */
  qx.Bootstrap.define(ba, {
    statics : {
      /**
       * Queries the document for the given selector. Supports all CSS3 selectors
       * plus some extensions as mentioned in the class description.
       *
       * @signature function(selector, context)
       * @param selector {String} Valid selector (CSS3 + extensions)
       * @param context {Element} Context element (result elements must be children of this element)
       * @return {Array} Matching elements
       */
      query : null,
      /**
       * Returns an reduced array which only contains the elements from the given
       * array which matches the given selector
       *
       * @signature function(selector, set)
       * @param selector {String} Selector to filter given set
       * @param set {Array} List to filter according to given selector
       * @return {Array} New array containing matching elements
       */
      matches : null
    }
  });
  (function(){

    var bq = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,bx = 0,bz = Object.prototype.toString,br = false,bB = true,bv = /\\/g,bk = /\W/;
    [0, 0].sort(function(){

      bB = false;
      return 0;
    });
    var bu = function(bD, bE, bF, bG){

      bF = bF || [];
      bE = bE || document;
      var bP = bE;
      if(bE.nodeType !== 1 && bE.nodeType !== 9){

        return [];
      };
      if(!bD || typeof bD !== A){

        return bF;
      };
      var m,bJ,bH,bL,bN,bK,bQ,i,bR = true,bI = bu.isXML(bE),bM = [],bO = bD;
      // Reset the position of the chunker regexp (start from head)
      do {

        bq.exec(O);
        m = bq.exec(bO);
        if(m){

          bO = m[3];
          bM.push(m[1]);
          if(m[2]){

            bL = m[3];
            break;
          };
        };
      }while(m);
      if(bM.length > 1 && bs.exec(bD)){

        if(bM.length === 2 && bn.relative[bM[0]]){

          bJ = bm(bM[0] + bM[1], bE);
        } else {

          bJ = bn.relative[bM[0]] ? [bE] : bu(bM.shift(), bE);
          while(bM.length){

            bD = bM.shift();
            if(bn.relative[bD]){

              bD += bM.shift();
            };
            bJ = bm(bD, bJ);
          };
        };
      } else {

        // Take a shortcut and set the context if the root selector is an ID
        // (but not if it'll be faster if the inner selector is an ID)
        if(!bG && bM.length > 1 && bE.nodeType === 9 && !bI && bn.match.ID.test(bM[0]) && !bn.match.ID.test(bM[bM.length - 1])){

          bN = bu.find(bM.shift(), bE, bI);
          bE = bN.expr ? bu.filter(bN.expr, bN.set)[0] : bN.set[0];
        };
        if(bE){

          bN = bG ? {
            expr : bM.pop(),
            set : bj(bG)
          } : bu.find(bM.pop(), bM.length === 1 && (bM[0] === P || bM[0] === o) && bE.parentNode ? bE.parentNode : bE, bI);
          bJ = bN.expr ? bu.filter(bN.expr, bN.set) : bN.set;
          if(bM.length > 0){

            bH = bj(bJ);
          } else {

            bR = false;
          };
          while(bM.length){

            bK = bM.pop();
            bQ = bK;
            if(!bn.relative[bK]){

              bK = O;
            } else {

              bQ = bM.pop();
            };
            if(bQ == null){

              bQ = bE;
            };
            bn.relative[bK](bH, bQ, bI);
          };
        } else {

          bH = bM = [];
        };
      };
      if(!bH){

        bH = bJ;
      };
      if(!bH){

        bu.error(bK || bD);
      };
      if(bz.call(bH) === H){

        if(!bR){

          bF.push.apply(bF, bH);
        } else if(bE && bE.nodeType === 1){

          for(i = 0;bH[i] != null;i++){

            if(bH[i] && (bH[i] === true || bH[i].nodeType === 1 && bu.contains(bE, bH[i]))){

              bF.push(bJ[i]);
            };
          };
        } else {

          for(i = 0;bH[i] != null;i++){

            if(bH[i] && bH[i].nodeType === 1){

              bF.push(bJ[i]);
            };
          };
        };
      } else {

        bj(bH, bF);
      };
      if(bL){

        bu(bL, bP, bF, bG);
        bu.uniqueSort(bF);
      };
      return bF;
    };
    bu.uniqueSort = function(bS){

      if(bw){

        br = bB;
        bS.sort(bw);
        if(br){

          for(var i = 1;i < bS.length;i++){

            if(bS[i] === bS[i - 1]){

              bS.splice(i--, 1);
            };
          };
        };
      };
      return bS;
    };
    bu.matches = function(bT, bU){

      return bu(bT, null, null, bU);
    };
    bu.matchesSelector = function(bV, bW){

      return bu(bW, null, null, [bV]).length > 0;
    };
    bu.find = function(bX, bY, ca){

      var cb;
      if(!bX){

        return [];
      };
      for(var i = 0,l = bn.order.length;i < l;i++){

        var cd,cc = bn.order[i];
        if((cd = bn.leftMatch[cc].exec(bX))){

          var ce = cd[1];
          cd.splice(1, 1);
          if(ce.substr(ce.length - 1) !== N){

            cd[1] = (cd[1] || O).replace(bv, O);
            cb = bn.find[cc](cd, bY, ca);
            if(cb != null){

              bX = bX.replace(bn.match[cc], O);
              break;
            };
          };
        };
      };
      if(!cb){

        cb = typeof bY.getElementsByTagName !== F ? bY.getElementsByTagName(S) : [];
      };
      return {
        set : cb,
        expr : bX
      };
    };
    bu.filter = function(cf, cg, ch, ci){

      var ct,cs,cj = cf,co = [],ck = cg,cl = cg && cg[0] && bu.isXML(cg[0]);
      while(cf && cg.length){

        for(var cr in bn.filter){

          if((ct = bn.leftMatch[cr].exec(cf)) != null && ct[2]){

            var cq,cn,cm = bn.filter[cr],cu = ct[1];
            cs = false;
            ct.splice(1, 1);
            if(cu.substr(cu.length - 1) === N){

              continue;
            };
            if(ck === co){

              co = [];
            };
            if(bn.preFilter[cr]){

              ct = bn.preFilter[cr](ct, ck, ch, co, ci, cl);
              if(!ct){

                cs = cq = true;
              } else if(ct === true){

                continue;
              };
            };
            if(ct){

              for(var i = 0;(cn = ck[i]) != null;i++){

                if(cn){

                  cq = cm(cn, ct, i, ck);
                  var cp = ci ^ !!cq;
                  if(ch && cq != null){

                    if(cp){

                      cs = true;
                    } else {

                      ck[i] = false;
                    };
                  } else if(cp){

                    co.push(cn);
                    cs = true;
                  };
                };
              };
            };
            if(cq !== undefined){

              if(!ch){

                ck = co;
              };
              cf = cf.replace(bn.match[cr], O);
              if(!cs){

                return [];
              };
              break;
            };
          };
        };
        // Improper expression
        if(cf === cj){

          if(cs == null){

            bu.error(cf);
          } else {

            break;
          };
        };
        cj = cf;
      };
      return ck;
    };
    bu.error = function(cv){

      throw I + cv;
    };
    var bn = bu.selectors = {
      order : [V, w, c],
      match : {
        ID : /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
        CLASS : /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
        NAME : /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
        ATTR : /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
        TAG : /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
        CHILD : /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
        POS : /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
        PSEUDO : /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
      },
      leftMatch : {
      },
      attrMap : {
        "class" : d,
        "for" : bf
      },
      attrHandle : {
        href : function(cw){

          return cw.getAttribute(J);
        },
        type : function(cx){

          return cx.getAttribute(Y);
        }
      },
      relative : {
        "+" : function(cy, cz){

          var cA = typeof cz === A,cC = cA && !bk.test(cz),cD = cA && !cC;
          if(cC){

            cz = cz.toLowerCase();
          };
          for(var i = 0,l = cy.length,cB;i < l;i++){

            if((cB = cy[i])){

              while((cB = cB.previousSibling) && cB.nodeType !== 1){
              };
              cy[i] = cD || cB && cB.nodeName.toLowerCase() === cz ? cB || false : cB === cz;
            };
          };
          if(cD){

            bu.filter(cz, cy, true);
          };
        },
        ">" : function(cE, cF){

          var cH,cG = typeof cF === A,i = 0,l = cE.length;
          if(cG && !bk.test(cF)){

            cF = cF.toLowerCase();
            for(;i < l;i++){

              cH = cE[i];
              if(cH){

                var parent = cH.parentNode;
                cE[i] = parent.nodeName.toLowerCase() === cF ? parent : false;
              };
            };
          } else {

            for(;i < l;i++){

              cH = cE[i];
              if(cH){

                cE[i] = cG ? cH.parentNode : cH.parentNode === cF;
              };
            };
            if(cG){

              bu.filter(cF, cE, true);
            };
          };
        },
        "" : function(cI, cJ, cK){

          var cN,cL = bx++,cM = bA;
          if(typeof cJ === A && !bk.test(cJ)){

            cJ = cJ.toLowerCase();
            cN = cJ;
            cM = bC;
          };
          cM(y, cJ, cL, cI, cN, cK);
        },
        "~" : function(cO, cP, cQ){

          var cT,cR = bx++,cS = bA;
          if(typeof cP === A && !bk.test(cP)){

            cP = cP.toLowerCase();
            cT = cP;
            cS = bC;
          };
          cS(v, cP, cR, cO, cT, cQ);
        }
      },
      find : {
        ID : function(cU, cV, cW){

          if(typeof cV.getElementById !== "undefined" && !cW){

            var m = cV.getElementById(cU[1]);
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            return m && m.parentNode ? [m] : [];
          };
        },
        NAME : function(cX, cY){

          if(typeof cY.getElementsByName !== "undefined"){

            var db = [],da = cY.getElementsByName(cX[1]);
            for(var i = 0,l = da.length;i < l;i++){

              if(da[i].getAttribute("name") === cX[1]){

                db.push(da[i]);
              };
            };
            return db.length === 0 ? null : db;
          };
        },
        TAG : function(dc, dd){

          if(typeof dd.getElementsByTagName !== "undefined"){

            return dd.getElementsByTagName(dc[1]);
          };
        }
      },
      preFilter : {
        CLASS : function(de, df, dg, dh, di, dj){

          de = " " + de[1].replace(bv, "") + " ";
          if(dj){

            return de;
          };
          for(var i = 0,dk;(dk = df[i]) != null;i++){

            if(dk){

              if(di ^ (dk.className && (" " + dk.className + " ").replace(/[\t\n\r]/g, " ").indexOf(de) >= 0)){

                if(!dg){

                  dh.push(dk);
                };
              } else if(dg){

                df[i] = false;
              };
            };
          };
          return false;
        },
        ID : function(dl){

          return dl[1].replace(bv, "");
        },
        TAG : function(dm, dn){

          return dm[1].replace(bv, "").toLowerCase();
        },
        CHILD : function(dp){

          if(dp[1] === "nth"){

            if(!dp[2]){

              bu.error(dp[0]);
            };
            dp[2] = dp[2].replace(/^\+|\s*/g, '');
            // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
            var dq = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(dp[2] === "even" && "2n" || dp[2] === "odd" && "2n+1" || !/\D/.test(dp[2]) && "0n+" + dp[2] || dp[2]);
            // calculate the numbers (first)n+(last) including if they are negative
            dp[2] = (dq[1] + (dq[2] || 1)) - 0;
            dp[3] = dq[3] - 0;
          } else if(dp[2]){

            bu.error(dp[0]);
          };
          // TODO: Move to normal caching system
          dp[0] = bx++;
          return dp;
        },
        ATTR : function(dr, ds, dt, du, dv, dw){

          var name = dr[1] = dr[1].replace(bv, "");
          if(!dw && bn.attrMap[name]){

            dr[1] = bn.attrMap[name];
          };
          // Handle if an un-quoted value was used
          dr[4] = (dr[4] || dr[5] || "").replace(bv, "");
          if(dr[2] === "~="){

            dr[4] = " " + dr[4] + " ";
          };
          return dr;
        },
        PSEUDO : function(dx, dy, dz, dA, dB){

          if(dx[1] === "not"){

            // If we're dealing with a complex expression, or a simple one
            if((bq.exec(dx[3]) || "").length > 1 || /^\w/.test(dx[3])){

              dx[3] = bu(dx[3], null, null, dy);
            } else {

              var dC = bu.filter(dx[3], dy, dz, true ^ dB);
              if(!dz){

                dA.push.apply(dA, dC);
              };
              return false;
            };
          } else if(bn.match.POS.test(dx[0]) || bn.match.CHILD.test(dx[0])){

            return true;
          };
          return dx;
        },
        POS : function(dD){

          dD.unshift(true);
          return dD;
        }
      },
      filters : {
        enabled : function(dE){

          return dE.disabled === false && dE.type !== R;
        },
        disabled : function(dF){

          return dF.disabled === true;
        },
        checked : function(dG){

          return dG.checked === true;
        },
        selected : function(dH){

          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if(dH.parentNode){

            dH.parentNode.selectedIndex;
          };
          return dH.selected === true;
        },
        parent : function(dI){

          return !!dI.firstChild;
        },
        empty : function(dJ){

          return !dJ.firstChild;
        },
        has : function(dK, i, dL){

          return !!bu(dL[3], dK).length;
        },
        header : function(dM){

          return (/h\d/i).test(dM.nodeName);
        },
        text : function(dN){

          // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
          // use getAttribute instead to test this case
          return q === dN.getAttribute(s);
        },
        radio : function(dO){

          return g === dO.type;
        },
        checkbox : function(dP){

          return M === dP.type;
        },
        file : function(dQ){

          return p === dQ.type;
        },
        password : function(dR){

          return bg === dR.type;
        },
        submit : function(dS){

          return be === dS.type;
        },
        image : function(dT){

          return B === dT.type;
        },
        reset : function(dU){

          return r === dU.type;
        },
        button : function(dV){

          return G === dV.type || dV.nodeName.toLowerCase() === G;
        },
        input : function(dW){

          return (/input|select|textarea|button/i).test(dW.nodeName);
        }
      },
      setFilters : {
        first : function(dX, i){

          return i === 0;
        },
        last : function(dY, i, ea, eb){

          return i === eb.length - 1;
        },
        even : function(ec, i){

          return i % 2 === 0;
        },
        odd : function(ed, i){

          return i % 2 === 1;
        },
        lt : function(ee, i, ef){

          return i < ef[3] - 0;
        },
        gt : function(eg, i, eh){

          return i > eh[3] - 0;
        },
        nth : function(ei, i, ej){

          return ej[3] - 0 === i;
        },
        eq : function(ek, i, el){

          return el[3] - 0 === i;
        }
      },
      filter : {
        PSEUDO : function(em, en, i, eo){

          var name = en[1],ep = bn.filters[name];
          if(ep){

            return ep(em, i, en, eo);
          } else if(name === "contains"){

            return (em.textContent || em.innerText || bu.getText([em]) || "").indexOf(en[3]) >= 0;
          } else if(name === "not"){

            var eq = en[3];
            for(var j = 0,l = eq.length;j < l;j++){

              if(eq[j] === em){

                return false;
              };
            };
            return true;
          } else {

            bu.error(name);
          };;
        },
        CHILD : function(er, es){

          var ey = es[1],et = er;
          switch(ey){case "only":case "first":
          while((et = et.previousSibling)){

            if(et.nodeType === 1){

              return false;
            };
          };
          if(ey === "first"){

            return true;
          };
          et = er;case "last":
          while((et = et.nextSibling)){

            if(et.nodeType === 1){

              return false;
            };
          };
          return true;case "nth":
          var ez = es[2],ev = es[3];
          if(ez === 1 && ev === 0){

            return true;
          };
          var ex = es[0],parent = er.parentNode;
          if(parent && (parent.sizcache !== ex || !er.nodeIndex)){

            var eu = 0;
            for(et = parent.firstChild;et;et = et.nextSibling){

              if(et.nodeType === 1){

                et.nodeIndex = ++eu;
              };
            };
            parent.sizcache = ex;
          };
          var ew = er.nodeIndex - ev;
          if(ez === 0){

            return ew === 0;
          } else {

            return (ew % ez === 0 && ew / ez >= 0);
          };};
        },
        ID : function(eA, eB){

          return eA.nodeType === 1 && eA.getAttribute("id") === eB;
        },
        TAG : function(eC, eD){

          return (eD === "*" && eC.nodeType === 1) || eC.nodeName.toLowerCase() === eD;
        },
        CLASS : function(eE, eF){

          return (" " + (eE.className || eE.getAttribute("class")) + " ").indexOf(eF) > -1;
        },
        ATTR : function(eG, eH){

          var name = eH[1],eL = bn.attrHandle[name] ? bn.attrHandle[name](eG) : eG[name] != null ? eG[name] : eG.getAttribute(name),eK = eL + "",eJ = eH[2],eI = eH[4];
          return eL == null ? eJ === "!=" : eJ === "=" ? eK === eI : eJ === "*=" ? eK.indexOf(eI) >= 0 : eJ === "~=" ? (" " + eK + " ").indexOf(eI) >= 0 : !eI ? eK && eL !== false : eJ === "!=" ? eK !== eI : eJ === "^=" ? eK.indexOf(eI) === 0 : eJ === "$=" ? eK.substr(eK.length - eI.length) === eI : eJ === "|=" ? eK === eI || eK.substr(0, eI.length + 1) === eI + "-" : false;
        },
        POS : function(eM, eN, i, eO){

          var name = eN[2],eP = bn.setFilters[name];
          if(eP){

            return eP(eM, i, eN, eO);
          };
        }
      }
    };
    var bs = bn.match.POS,bi = function(eQ, eR){

      return N + (eR - 0 + 1);
    };
    for(var by in bn.match){

      bn.match[by] = new RegExp(bn.match[by].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
      bn.leftMatch[by] = new RegExp(/(^(?:.|\r|\n)*?)/.source + bn.match[by].source.replace(/\\(\d+)/g, bi));
    };
    var bj = function(eS, eT){

      eS = Array.prototype.slice.call(eS, 0);
      if(eT){

        eT.push.apply(eT, eS);
        return eT;
      };
      return eS;
    };
    // Perform a simple check to determine if the browser is capable of
    // converting a NodeList to an array using builtin methods.
    // Also verifies that the returned array holds DOM nodes
    // (which is not the case in the Blackberry browser)
    try{

      Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;
    } catch(e) {

      bj = function(eU, eV){

        var i = 0,eW = eV || [];
        if(bz.call(eU) === H){

          Array.prototype.push.apply(eW, eU);
        } else {

          if(typeof eU.length === t){

            for(var l = eU.length;i < l;i++){

              eW.push(eU[i]);
            };
          } else {

            for(;eU[i];i++){

              eW.push(eU[i]);
            };
          };
        };
        return eW;
      };
    };
    var bw,bo;
    if(document.documentElement.compareDocumentPosition){

      bw = function(a, b){

        if(a === b){

          br = true;
          return 0;
        };
        if(!a.compareDocumentPosition || !b.compareDocumentPosition){

          return a.compareDocumentPosition ? -1 : 1;
        };
        return a.compareDocumentPosition(b) & 4 ? -1 : 1;
      };
    } else {

      bw = function(a, b){

        var fc,fa,fd = [],fe = [],eY = a.parentNode,fb = b.parentNode,eX = eY;
        // The nodes are identical, we can exit early
        if(a === b){

          br = true;
          return 0;
        } else if(eY === fb){

          return bo(a, b);
        } else if(!eY){

          return -1;
        } else if(!fb){

          return 1;
        };;;
        // Otherwise they're somewhere else in the tree so we need
        // to build up a full list of the parentNodes for comparison
        while(eX){

          fd.unshift(eX);
          eX = eX.parentNode;
        };
        eX = fb;
        while(eX){

          fe.unshift(eX);
          eX = eX.parentNode;
        };
        fc = fd.length;
        fa = fe.length;
        // Start walking down the tree looking for a discrepancy
        for(var i = 0;i < fc && i < fa;i++){

          if(fd[i] !== fe[i]){

            return bo(fd[i], fe[i]);
          };
        };
        // We ended someplace up the tree so do a sibling check
        return i === fc ? bo(a, fe[i], -1) : bo(fd[i], b, 1);
      };
      bo = function(a, b, ff){

        if(a === b){

          return ff;
        };
        var fg = a.nextSibling;
        while(fg){

          if(fg === b){

            return -1;
          };
          fg = fg.nextSibling;
        };
        return 1;
      };
    };
    // Utility function for retreiving the text value of an array of DOM nodes
    bu.getText = function(fh){

      var fj = O,fi;
      for(var i = 0;fh[i];i++){

        fi = fh[i];
        // Get the text from text nodes and CDATA nodes
        if(fi.nodeType === 3 || fi.nodeType === 4){

          fj += fi.nodeValue;
        } else if(fi.nodeType !== 8){

          fj += bu.getText(fi.childNodes);
        };
      };
      return fj;
    };
    (function(){

      // We're going to inject a fake input element with a specified name
      var fm = document.createElement(Q),fl = f + (new Date()).getTime(),fk = document.documentElement;
      fm.innerHTML = bc + fl + n;
      // Inject it into the root element, check its status, and remove it quickly
      fk.insertBefore(fm, fk.firstChild);
      // The workaround has to do additional checks after a getElementById
      // Which slows things down for other browsers (hence the branching)
      if(document.getElementById(fl)){

        bn.find.ID = function(fn, fo, fp){

          if(typeof fo.getElementById !== F && !fp){

            var m = fo.getElementById(fn[1]);
            return m ? m.id === fn[1] || typeof m.getAttributeNode !== F && m.getAttributeNode(z).nodeValue === fn[1] ? [m] : undefined : [];
          };
        };
        bn.filter.ID = function(fq, fr){

          var fs = typeof fq.getAttributeNode !== F && fq.getAttributeNode(z);
          return fq.nodeType === 1 && fs && fs.nodeValue === fr;
        };
      };
      fk.removeChild(fm);
      // release memory in IE
      fk = fm = null;
    })();
    (function(){

      // Check to see if the browser returns only elements
      // when doing getElementsByTagName("*")
      // Create a fake element
      var ft = document.createElement(Q);
      ft.appendChild(document.createComment(O));
      // Make sure no comments are found
      if(ft.getElementsByTagName(S).length > 0){

        bn.find.TAG = function(fu, fv){

          var fx = fv.getElementsByTagName(fu[1]);
          // Filter out possible comments
          if(fu[1] === S){

            var fw = [];
            for(var i = 0;fx[i];i++){

              if(fx[i].nodeType === 1){

                fw.push(fx[i]);
              };
            };
            fx = fw;
          };
          return fx;
        };
      };
      // Check to see if an attribute returns normalized href attributes
      ft.innerHTML = bd;
      if(ft.firstChild && typeof ft.firstChild.getAttribute !== F && ft.firstChild.getAttribute(J) !== bb){

        bn.attrHandle.href = function(fy){

          return fy.getAttribute(J, 2);
        };
      };
      // release memory in IE
      ft = null;
    })();
    if(document.querySelectorAll){

      (function(){

        var fA = bu,fz = document.createElement(Q),fB = E;
        fz.innerHTML = W;
        // Safari can't handle uppercase or unicode characters when
        // in quirks mode.
        if(fz.querySelectorAll && fz.querySelectorAll(C).length === 0){

          return;
        };
        bu = function(fD, fE, fF, fG){

          fE = fE || document;
          // Only use querySelectorAll on non-XML documents
          // (ID selectors don't work in non-HTML documents)
          if(!fG && !bu.isXML(fE)){

            // See if we find a selector to speed up
            var fL = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(fD);
            if(fL && (fE.nodeType === 1 || fE.nodeType === 9)){

              // Speed-up: Sizzle("TAG")
              if(fL[1]){

                return bj(fE.getElementsByTagName(fD), fF);
              } else if(fL[2] && bn.find.CLASS && fE.getElementsByClassName){

                return bj(fE.getElementsByClassName(fL[2]), fF);
              };
            };
            if(fE.nodeType === 9){

              // Speed-up: Sizzle("body")
              // The body element only exists once, optimize finding it
              if(fD === U && fE.body){

                return bj([fE.body], fF);
              } else if(fL && fL[3]){

                var fJ = fE.getElementById(fL[3]);
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                if(fJ && fJ.parentNode){

                  // Handle the case where IE and Opera return items
                  // by name instead of ID
                  if(fJ.id === fL[3]){

                    return bj([fJ], fF);
                  };
                } else {

                  return bj([], fF);
                };
              };
              try{

                return bj(fE.querySelectorAll(fD), fF);
              } catch(fO) {
              };
            } else if(fE.nodeType === 1 && fE.nodeName.toLowerCase() !== D){

              var fN = fE,fI = fE.getAttribute(z),fK = fI || fB,fH = fE.parentNode,fM = /^\s*[+~]/.test(fD);
              if(!fI){

                fE.setAttribute(z, fK);
              } else {

                fK = fK.replace(/'/g, x);
              };
              if(fM && fH){

                fE = fE.parentNode;
              };
              try{

                if(!fM || fH){

                  return bj(fE.querySelectorAll(T + fK + X + fD), fF);
                };
              } catch(fP) {
              }finally{

                if(!fI){

                  fN.removeAttribute(z);
                };
              };
            };
          };
          return fA(fD, fE, fF, fG);
        };
        for(var fC in fA){

          bu[fC] = fA[fC];
        };
        // release memory in IE
        fz = null;
      })();
    };
    (function(){

      var fS = document.documentElement,fQ = fS.matchesSelector || fS.mozMatchesSelector || fS.webkitMatchesSelector || fS.msMatchesSelector,fR = false;
      try{

        // This should fail with an exception
        // Gecko does not error, returns false instead
        fQ.call(document.documentElement, bh);
      } catch(fT) {

        fR = true;
      };
      if(fQ){

        bu.matchesSelector = function(fU, fV){

          // Make sure that attribute selectors are quoted
          fV = fV.replace(/\=\s*([^'"\]]*)\s*\]/g, u);
          if(!bu.isXML(fU)){

            try{

              if(fR || !bn.match.PSEUDO.test(fV) && !/!=/.test(fV)){

                return fQ.call(fU, fV);
              };
            } catch(e) {
            };
          };
          return bu(fV, null, null, [fU]).length > 0;
        };
      };
    })();
    (function(){

      var fW = document.createElement(Q);
      fW.innerHTML = K;
      // Opera can't find a second classname (in 9.6)
      // Also, make sure that getElementsByClassName actually exists
      if(!fW.getElementsByClassName || fW.getElementsByClassName(L).length === 0){

        return;
      };
      // Safari caches class attributes, doesn't catch changes (in 3.2)
      fW.lastChild.className = L;
      if(fW.getElementsByClassName(L).length === 1){

        return;
      };
      bn.order.splice(1, 0, k);
      bn.find.CLASS = function(fX, fY, ga){

        if(typeof fY.getElementsByClassName !== F && !ga){

          return fY.getElementsByClassName(fX[1]);
        };
      };
      // release memory in IE
      fW = null;
    })();
    function bC(gb, gc, gd, ge, gf, gg){

      for(var i = 0,l = ge.length;i < l;i++){

        var gi = ge[i];
        if(gi){

          var gh = false;
          gi = gi[gb];
          while(gi){

            if(gi.sizcache === gd){

              gh = ge[gi.sizset];
              break;
            };
            if(gi.nodeType === 1 && !gg){

              gi.sizcache = gd;
              gi.sizset = i;
            };
            if(gi.nodeName.toLowerCase() === gc){

              gh = gi;
              break;
            };
            gi = gi[gb];
          };
          ge[i] = gh;
        };
      };
    };
    function bA(gj, gk, gl, gm, gn, go){

      for(var i = 0,l = gm.length;i < l;i++){

        var gq = gm[i];
        if(gq){

          var gp = false;
          gq = gq[gj];
          while(gq){

            if(gq.sizcache === gl){

              gp = gm[gq.sizset];
              break;
            };
            if(gq.nodeType === 1){

              if(!go){

                gq.sizcache = gl;
                gq.sizset = i;
              };
              if(typeof gk !== A){

                if(gq === gk){

                  gp = true;
                  break;
                };
              } else if(bu.filter(gk, [gq]).length > 0){

                gp = gq;
                break;
              };
            };
            gq = gq[gj];
          };
          gm[i] = gp;
        };
      };
    };
    if(document.documentElement.contains){

      bu.contains = function(a, b){

        return a !== b && (a.contains ? a.contains(b) : true);
      };
    } else if(document.documentElement.compareDocumentPosition){

      bu.contains = function(a, b){

        return !!(a.compareDocumentPosition(b) & 16);
      };
    } else {

      bu.contains = function(){

        return false;
      };
    };
    bu.isXML = function(gr){

      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var gs = (gr ? gr.ownerDocument || gr : 0).documentElement;
      return gs ? gs.nodeName !== h : false;
    };
    var bm = function(gt, gu){

      var gy,gw = [],gv = O,gx = gu.nodeType ? [gu] : gu;
      // Position selectors must be done after the filter
      // And so must :not(positional) so we move all PSEUDOs to the end
      while((gy = bn.match.PSEUDO.exec(gt))){

        gv += gy[0];
        gt = gt.replace(bn.match.PSEUDO, O);
      };
      gt = bn.relative[gt] ? gt + S : gt;
      for(var i = 0,l = gx.length;i < l;i++){

        bu(gt, gx[i], gw);
      };
      return bu.filter(gv, gw);
    };
    /**
     * Above is the original Sizzle code.
     */
    // EXPOSE qooxdoo variant
    var bt = qx.bom.Selector;
    bt.query = function(gz, gA){

      return bu(gz, gA);
    };
    bt.matches = function(gB, gC){

      return bu(gB, null, null, gC);
    };
  })();
})();
(function(){

  var l = "Silverlight",k = "plugin.silverlight.version",h = "function",g = "QuickTimeCheckObject.QuickTimeCheck.1",f = "Adobe Acrobat",e = "plugin.windowsmedia",d = "QuickTime",c = "plugin.silverlight",b = "qx.bom.client.Plugin",a = "plugin.divx",H = "Chrome PDF Viewer",G = "Windows Media",F = "plugin.gears",E = "plugin.quicktime",D = "plugin.windowsmedia.version",C = "DivX Web Player",B = "AgControl.AgControl",A = "plugin.pdf",z = "plugin.pdf.version",y = "plugin.divx.version",s = "WMPlayer.OCX.7",t = "AcroPDF.PDF",q = "plugin.activex",r = "plugin.quicktime.version",o = "npdivx.DivXBrowserPlugin.1",p = "pdf",m = "wmv",n = "divx",u = "quicktime",v = "mshtml",x = "silverlight",w = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Contains detection for QuickTime, Windows Media, DivX, Silverlight adn gears.
   * If no version could be detected the version is set to an empty string as
   * default.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(b, {
    statics : {
      /**
       * Checkes for the availability of google gears plugin.
       *
       * @internal
       * @return {Boolean} <code>true</code> if gears is available
       */
      getGears : function(){

        return !!(window.google && window.google.gears);
      },
      /**
       * Checks for ActiveX availability.
       *
       * @internal
       * @return {Boolean} <code>true</code> if ActiveX is available
       */
      getActiveX : function(){

        return (typeof window.ActiveXObject === h);
      },
      /**
       * Database of supported features.
       * Filled with additional data at initialization
       */
      __db : {
        quicktime : {
          plugin : [d],
          control : g
        },
        wmv : {
          plugin : [G],
          control : s
        },
        divx : {
          plugin : [C],
          control : o
        },
        silverlight : {
          plugin : [l],
          control : B
        },
        pdf : {
          plugin : [H, f],
          control : t
        }
      },
      /**
       * Fetches the version of the quicktime plugin.
       * @return {String} The version of the plugin, if available,
       *   an empty string otherwise
       * @internal
       */
      getQuicktimeVersion : function(){

        var I = qx.bom.client.Plugin.__db[u];
        return qx.bom.client.Plugin.__getVersion(I.control, I.plugin);
      },
      /**
       * Fetches the version of the windows media plugin.
       * @return {String} The version of the plugin, if available,
       *   an empty string otherwise
       * @internal
       */
      getWindowsMediaVersion : function(){

        var J = qx.bom.client.Plugin.__db[m];
        return qx.bom.client.Plugin.__getVersion(J.control, J.plugin);
      },
      /**
       * Fetches the version of the divx plugin.
       * @return {String} The version of the plugin, if available,
       *   an empty string otherwise
       * @internal
       */
      getDivXVersion : function(){

        var K = qx.bom.client.Plugin.__db[n];
        return qx.bom.client.Plugin.__getVersion(K.control, K.plugin);
      },
      /**
       * Fetches the version of the silverlight plugin.
       * @return {String} The version of the plugin, if available,
       *   an empty string otherwise
       * @internal
       */
      getSilverlightVersion : function(){

        var L = qx.bom.client.Plugin.__db[x];
        return qx.bom.client.Plugin.__getVersion(L.control, L.plugin);
      },
      /**
       * Fetches the version of the pdf plugin.
       * @return {String} The version of the plugin, if available,
       *  an empty string otherwise
       * @internal
       */
      getPdfVersion : function(){

        var M = qx.bom.client.Plugin.__db[p];
        return qx.bom.client.Plugin.__getVersion(M.control, M.plugin);
      },
      /**
       * Checks if the quicktime plugin is available.
       * @return {Boolean} <code>true</code> if the plugin is available
       * @internal
       */
      getQuicktime : function(){

        var N = qx.bom.client.Plugin.__db[u];
        return qx.bom.client.Plugin.__isAvailable(N.control, N.plugin);
      },
      /**
       * Checks if the windows media plugin is available.
       * @return {Boolean} <code>true</code> if the plugin is available
       * @internal
       */
      getWindowsMedia : function(){

        var O = qx.bom.client.Plugin.__db[m];
        return qx.bom.client.Plugin.__isAvailable(O.control, O.plugin);
      },
      /**
       * Checks if the divx plugin is available.
       * @return {Boolean} <code>true</code> if the plugin is available
       * @internal
       */
      getDivX : function(){

        var P = qx.bom.client.Plugin.__db[n];
        return qx.bom.client.Plugin.__isAvailable(P.control, P.plugin);
      },
      /**
       * Checks if the silverlight plugin is available.
       * @return {Boolean} <code>true</code> if the plugin is available
       * @internal
       */
      getSilverlight : function(){

        var Q = qx.bom.client.Plugin.__db[x];
        return qx.bom.client.Plugin.__isAvailable(Q.control, Q.plugin);
      },
      /**
       * Checks if the pdf plugin is available.
       * @return {Boolean} <code>true</code> if the plugin is available
       * @internal
       */
      getPdf : function(){

        var R = qx.bom.client.Plugin.__db[p];
        return qx.bom.client.Plugin.__isAvailable(R.control, R.plugin);
      },
      /**
       * Internal helper for getting the version of a given plugin.
       *
       * @param activeXName {String} The name which should be used to generate
       *   the test ActiveX Object.
       * @param pluginNames {Array} The names with which the plugins are listed in
       *   the navigator.plugins list.
       * @return {String} The version of the plugin as string.
       */
      __getVersion : function(S, T){

        var U = qx.bom.client.Plugin.__isAvailable(S, T);
        // don't check if the plugin is not available
        if(!U){

          return w;
        };
        // IE checks
        if(qx.bom.client.Engine.getName() == v){

          var V = new ActiveXObject(S);
          try{

            var Y = V.versionInfo;
            if(Y != undefined){

              return Y;
            };
            Y = V.version;
            if(Y != undefined){

              return Y;
            };
            Y = V.settings.version;
            if(Y != undefined){

              return Y;
            };
          } catch(bb) {

            return w;
          };
          return w;
        } else {

          var ba = navigator.plugins;
          var X = /([0-9]\.[0-9])/g;
          for(var i = 0;i < ba.length;i++){

            var W = ba[i];
            for(var j = 0;j < T.length;j++){

              if(W.name.indexOf(T[j]) !== -1){

                if(X.test(W.name) || X.test(W.description)){

                  return RegExp.$1;
                };
              };
            };
          };
          return w;
        };
      },
      /**
       * Internal helper for getting the availability of a given plugin.
       *
       * @param activeXName {String} The name which should be used to generate
       *   the test ActiveX Object.
       * @param pluginNames {Array} The names with which the plugins are listed in
       *   the navigator.plugins list.
       * @return {Boolean} <code>true</code>, if the plugin available
       */
      __isAvailable : function(bc, bd){

        // IE checks
        if(qx.bom.client.Engine.getName() == v){

          var be = window.ActiveXObject;
          if(!be){

            return false;
          };
          try{

            new ActiveXObject(bc);
          } catch(bg) {

            return false;
          };
          return true;
        } else {

          var bf = navigator.plugins;
          if(!bf){

            return false;
          };
          var name;
          for(var i = 0;i < bf.length;i++){

            name = bf[i].name;
            for(var j = 0;j < bd.length;j++){

              if(name.indexOf(bd[j]) !== -1){

                return true;
              };
            };
          };
          return false;
        };
      }
    },
    defer : function(bh){

      qx.core.Environment.add(F, bh.getGears);
      qx.core.Environment.add(E, bh.getQuicktime);
      qx.core.Environment.add(r, bh.getQuicktimeVersion);
      qx.core.Environment.add(e, bh.getWindowsMedia);
      qx.core.Environment.add(D, bh.getWindowsMediaVersion);
      qx.core.Environment.add(a, bh.getDivX);
      qx.core.Environment.add(y, bh.getDivXVersion);
      qx.core.Environment.add(c, bh.getSilverlight);
      qx.core.Environment.add(k, bh.getSilverlightVersion);
      qx.core.Environment.add(A, bh.getPdf);
      qx.core.Environment.add(z, bh.getPdfVersion);
      qx.core.Environment.add(q, bh.getActiveX);
    }
  });
})();
(function(){

  var t = '<\?xml version="1.0" encoding="utf-8"?>\n<',s = "qx.xml.Document",r = " />",q = "xml.domparser",p = "SelectionLanguage",o = "'",n = "MSXML2.XMLHTTP.3.0",m = "MSXML2.XMLHTTP.6.0",k = "xml.implementation",j = " xmlns='",c = "text/xml",h = "XPath",f = "MSXML2.DOMDocument.6.0",b = "HTML",a = "MSXML2.DOMDocument.3.0",e = "",d = "No XML implementation available!",g = "plugin.activex";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Cross browser XML document creation API
   *
   * The main purpose of this class is to allow you to create XML document objects in a
   * cross-browser fashion. Use <code>create</code> to create an empty document,
   * <code>fromString</code> to create one from an existing XML text. Both methods
   * return a *native DOM object*. That means you use standard DOM methods on such
   * an object (e.g. <code>createElement</code>).
   *
   * The following links provide further information on XML documents:
   *
   * * <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#i-Document">W3C Interface Specification</a>
   * * <a href="http://msdn2.microsoft.com/en-us/library/ms535918.aspx">MS xml Object</a>
   * * <a href="http://msdn2.microsoft.com/en-us/library/ms764622.aspx">MSXML GUIDs and ProgIDs</a>
   * * <a href="http://developer.mozilla.org/en/docs/Parsing_and_serializing_XML">MDN Parsing and Serializing XML</a>
   */
  qx.Class.define(s, {
    statics : {
      /** {String} ActiveX class name of DOMDocument (IE specific) */
      DOMDOC : null,
      /** {String} ActiveX class name of XMLHttpRequest (IE specific) */
      XMLHTTP : null,
      /**
       * Whether the given element is a XML document or element
       * which is part of a XML document.
       *
       * @param elem {Document|Element} Any DOM Document or Element
       * @return {Boolean} Whether the document is a XML document
       */
      isXmlDocument : function(u){

        if(u.nodeType === 9){

          return u.documentElement.nodeName !== b;
        } else if(u.ownerDocument){

          return this.isXmlDocument(u.ownerDocument);
        } else {

          return false;
        };
      },
      /**
       * Create an XML document.
       *
       * Returns a native DOM document object, set up for XML.
       *
       * @param namespaceUri {String ? null} The namespace URI of the document element to create or null.
       * @param qualifiedName {String ? null} The qualified name of the document element to be created or null.
       * @return {Document} empty XML object
       */
      create : function(v, w){

        // ActiveX - This is the preferred way for IE9 as well since it has no XPath
        // support when using the native implementation.createDocument
        if(qx.core.Environment.get(g)){

          var x = new ActiveXObject(this.DOMDOC);
          //The SelectionLanguage property is no longer needed in MSXML 6; trying
          // to set it causes an exception in IE9.
          if(this.DOMDOC == a){

            x.setProperty(p, h);
          };
          if(w){

            var y = t;
            y += w;
            if(v){

              y += j + v + o;
            };
            y += r;
            x.loadXML(y);
          };
          return x;
        };
        if(qx.core.Environment.get(k)){

          return document.implementation.createDocument(v || e, w || e, null);
        };
        throw new Error(d);
      },
      /**
       * The string passed in is parsed into a DOM document.
       *
       * @param str {String} the string to be parsed
       * @return {Document} XML document with given content
       * @signature function(str)
       */
      fromString : function(z){

        // Legacy IE/ActiveX
        if(qx.core.Environment.get(g)){

          var B = qx.xml.Document.create();
          B.loadXML(z);
          return B;
        };
        if(qx.core.Environment.get(q)){

          var A = new DOMParser();
          return A.parseFromString(z, c);
        };
        throw new Error(d);
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(C){

      // Detecting available ActiveX implementations.
      if(qx.core.Environment.get(g)){

        // According to information on the Microsoft XML Team's WebLog
        // it is recommended to check for availability of MSXML versions 6.0 and 3.0.
        // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
        var D = [f, a];
        var E = [m, n];
        for(var i = 0,l = D.length;i < l;i++){

          try{

            // Keep both objects in sync with the same version.
            // This is important as there were compatibility issues detected.
            new ActiveXObject(D[i]);
            new ActiveXObject(E[i]);
          } catch(F) {

            continue;
          };
          // Update static constants
          C.DOMDOC = D[i];
          C.XMLHTTP = E[i];
          // Stop loop here
          break;
        };
      };
    }
  });
})();
(function(){

  var s = "xml.implementation",r = "xml.attributens",q = "xml.selectnodes",p = "xml.getqualifieditem",o = "SelectionLanguage",n = "xml.getelementsbytagnamens",m = "qx.bom.client.Xml",l = "xml.domproperties",k = "xml.selectsinglenode",j = "1.0",d = "xml.createnode",i = "xml.domparser",g = "getProperty",c = "XML",b = "string",f = "xml.createelementns",e = "<a></a>",h = "function",a = "undefined";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (d_wagner)
  
  ************************************************************************ */
  /**
   * Internal class which contains the checks used by {@link qx.core.Environment}.
   * All checks in here are marked as internal which means you should never use
   * them directly.
   *
   * This class should contain all XML-related checks
   *
   * @internal
   */
  qx.Bootstrap.define(m, {
    statics : {
      /**
       * Checks if XML is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if XML is supported
       */
      getImplementation : function(){

        return document.implementation && document.implementation.hasFeature && document.implementation.hasFeature(c, j);
      },
      /**
       * Checks if an XML DOMParser is available
       *
       * @internal
       * @return {Boolean} <code>true</code> if DOMParser is supported
       */
      getDomParser : function(){

        return typeof window.DOMParser !== a;
      },
      /**
       * Checks if the proprietary selectSingleNode method is available on XML DOM
       * nodes.
       *
       * @internal
       * @return {Boolean} <code>true</code> if selectSingleNode is available
       */
      getSelectSingleNode : function(){

        return typeof qx.xml.Document.create().selectSingleNode !== a;
      },
      /**
       * Checks if the proprietary selectNodes method is available on XML DOM
       * nodes.
       *
       * @internal
       * @return {Boolean} <code>true</code> if selectSingleNode is available
       */
      getSelectNodes : function(){

        return typeof qx.xml.Document.create().selectNodes !== a;
      },
      /**
       * Checks availablity of the getElementsByTagNameNS XML DOM method.
       *
       * @internal
       * @return {Boolean} <code>true</code> if getElementsByTagNameNS is available
       */
      getElementsByTagNameNS : function(){

        return typeof qx.xml.Document.create().getElementsByTagNameNS !== a;
      },
      /**
       * Checks if MSXML-style DOM Level 2 properties are supported.
       *
       * @internal
       * @return {Boolean} <code>true</code> if DOM Level 2 properties are supported
       */
      getDomProperties : function(){

        var t = qx.xml.Document.create();
        return (g in t && typeof t.getProperty(o) === b);
      },
      /**
       * Checks if the getAttributeNS and setAttributeNS methods are supported on
       * XML DOM elements
       *
       * @internal
       * @return {Boolean} <code>true</code> if get/setAttributeNS is supported
       */
      getAttributeNS : function(){

        var u = qx.xml.Document.fromString(e).documentElement;
        return typeof u.getAttributeNS === h && typeof u.setAttributeNS === h;
      },
      /**
       * Checks if the createElementNS method is supported on XML DOM documents
       *
       * @internal
       * @return {Boolean} <code>true</code> if createElementNS is supported
       */
      getCreateElementNS : function(){

        return typeof qx.xml.Document.create().createElementNS === h;
      },
      /**
       * Checks if the proprietary createNode method is supported on XML DOM
       * documents
       *
       * @internal
       * @return {Boolean} <code>true</code> if DOM Level 2 properties are supported
       */
      getCreateNode : function(){

        return typeof qx.xml.Document.create().createNode !== a;
      },
      /**
       * Checks if the proprietary getQualifiedItem method is supported for XML
       * element attributes
       *
       * @internal
       * @return {Boolean} <code>true</code> if DOM Level 2 properties are supported
       */
      getQualifiedItem : function(){

        var v = qx.xml.Document.fromString(e).documentElement;
        return typeof v.attributes.getQualifiedItem !== a;
      }
    },
    defer : function(w){

      qx.core.Environment.add(s, w.getImplementation);
      qx.core.Environment.add(i, w.getDomParser);
      qx.core.Environment.add(k, w.getSelectSingleNode);
      qx.core.Environment.add(q, w.getSelectNodes);
      qx.core.Environment.add(n, w.getElementsByTagNameNS);
      qx.core.Environment.add(l, w.getDomProperties);
      qx.core.Environment.add(r, w.getAttributeNS);
      qx.core.Environment.add(f, w.getCreateElementNS);
      qx.core.Environment.add(d, w.getCreateNode);
      qx.core.Environment.add(p, w.getQualifiedItem);
    }
  });
})();
(function(){

  var a = "qx.event.type.Focus";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Common base class for all focus events.
   */
  qx.Class.define(a, {
    extend : qx.event.type.Event,
    members : {
      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param target {Object} Any possible event target
       * @param relatedTarget {Object} Any possible event target
       * @param canBubble {Boolean?false} Whether or not the event is a bubbling event.
       *     If the event is bubbling, the bubbling can be stopped using
       *     {@link qx.event.type.Event#stopPropagation}
       * @return {qx.event.type.Event} The initialized event instance
       */
      init : function(b, c, d){

        qx.event.type.Event.prototype.init.call(this, d, false);
        this._target = b;
        this._relatedTarget = c;
        return this;
      }
    }
  });
})();
(function(){

  var k = "borderBottomWidth",j = "borderTopWidth",i = "left",h = "borderLeftWidth",g = "bottom",f = "top",e = "right",d = "qx.bom.element.Scroll",c = "borderRightWidth",b = "visible",a = "scroll";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains methods to control and query the element's scroll properties
   */
  qx.Class.define(d, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /*
      ---------------------------------------------------------------------------
        SCROLL INTO VIEW
      ---------------------------------------------------------------------------
      */
      /**
       * The method scrolls the element into view (x-axis only).
       *
       * @param element {Element} DOM element to scroll into view
       * @param stop {Element?null} Any parent element which functions as
       *   outest element to scroll. Default is the HTML document.
       * @param align {String?null} Alignment of the element. Allowed values:
       *   <code>left</code> or <code>right</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       */
      intoViewX : function(l, stop, m){

        var parent = l.parentNode;
        var r = qx.dom.Node.getDocument(l);
        var n = r.body;
        var z,x,u;
        var B,s,C;
        var v,D,G;
        var E,p,y,o;
        var t,F,w;
        var q = m === i;
        var A = m === e;
        // Correcting stop position
        stop = stop ? stop.parentNode : r;
        // Go up the parent chain
        while(parent && parent != stop){

          // "overflow" is always visible for both: document.body and document.documentElement
          if(parent.scrollWidth > parent.clientWidth && (parent === n || qx.bom.element.Overflow.getY(parent) != b)){

            // console.debug("Process: " + parent.$$hash);
            // Calculate parent data
            // Special handling for body element
            if(parent === n){

              x = parent.scrollLeft;
              u = x + qx.bom.Viewport.getWidth();
              B = qx.bom.Viewport.getWidth();
              s = parent.clientWidth;
              C = parent.scrollWidth;
              v = 0;
              D = 0;
              G = 0;
            } else {

              z = qx.bom.element.Location.get(parent);
              x = z.left;
              u = z.right;
              B = parent.offsetWidth;
              s = parent.clientWidth;
              C = parent.scrollWidth;
              v = parseInt(qx.bom.element.Style.get(parent, h), 10) || 0;
              D = parseInt(qx.bom.element.Style.get(parent, c), 10) || 0;
              G = B - s - v - D;
            };
            // Calculate element data
            E = qx.bom.element.Location.get(l);
            p = E.left;
            y = E.right;
            o = l.offsetWidth;
            // Relative position from each other
            t = p - x - v;
            F = y - u + D;
            // Scroll position rearrangment
            w = 0;
            // be sure that element is on left edge
            if(q){

              // console.debug("Align left...");
              w = t;
            } else if(A){

              // console.debug("Align right...");
              w = F + G;
            } else if(t < 0 || o > s){

              // console.debug("Go Down...");
              w = t;
            } else if(F > 0){

              // console.debug("Go Up...");
              w = F + G;
            };;;
            // console.log("Scroll by: " + scrollDiff);
            parent.scrollLeft += w;
            // Browsers that follow the CSSOM View Spec fire the "scroll"
            // event asynchronously. See #intoViewY for more details.
            qx.event.Registration.fireNonBubblingEvent(parent, a);
          };
          if(parent === n){

            break;
          };
          parent = parent.parentNode;
        };
      },
      /**
       * The method scrolls the element into view (y-axis only).
       *
       * @param element {Element} DOM element to scroll into view
       * @param stop {Element?null} Any parent element which functions as
       *   outest element to scroll. Default is the HTML document.
       * @param align {String?null} Alignment of the element. Allowed values:
       *   <code>top</code> or <code>bottom</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       */
      intoViewY : function(H, stop, I){

        var parent = H.parentNode;
        var O = qx.dom.Node.getDocument(H);
        var J = O.body;
        var W,K,S;
        var Y,V,Q;
        var M,N,L;
        var bb,bc,X,R;
        var U,P,bd;
        var ba = I === f;
        var T = I === g;
        // Correcting stop position
        stop = stop ? stop.parentNode : O;
        // Go up the parent chain
        while(parent && parent != stop){

          // "overflow" is always visible for both: document.body and document.documentElement
          if(parent.scrollHeight > parent.clientHeight && (parent === J || qx.bom.element.Overflow.getY(parent) != b)){

            // console.debug("Process: " + parent.$$hash);
            // Calculate parent data
            // Special handling for body element
            if(parent === J){

              K = parent.scrollTop;
              S = K + qx.bom.Viewport.getHeight();
              Y = qx.bom.Viewport.getHeight();
              V = parent.clientHeight;
              Q = parent.scrollHeight;
              M = 0;
              N = 0;
              L = 0;
            } else {

              W = qx.bom.element.Location.get(parent);
              K = W.top;
              S = W.bottom;
              Y = parent.offsetHeight;
              V = parent.clientHeight;
              Q = parent.scrollHeight;
              M = parseInt(qx.bom.element.Style.get(parent, j), 10) || 0;
              N = parseInt(qx.bom.element.Style.get(parent, k), 10) || 0;
              L = Y - V - M - N;
            };
            // Calculate element data
            bb = qx.bom.element.Location.get(H);
            bc = bb.top;
            X = bb.bottom;
            R = H.offsetHeight;
            // Relative position from each other
            U = bc - K - M;
            P = X - S + N;
            // Scroll position rearrangment
            bd = 0;
            // be sure that element is on top edge
            if(ba){

              // console.debug("Align top...");
              bd = U;
            } else if(T){

              // console.debug("Align bottom...");
              bd = P + L;
            } else if(U < 0 || R > V){

              // console.debug("Go Down...");
              bd = U;
            } else if(P > 0){

              // console.debug("Go Up...");
              bd = P + L;
            };;;
            parent.scrollTop += bd;
            // Browsers that follow the CSSOM View Spec fire the "scroll"
            // event asynchronously.
            //
            // The widget layer expects the "scroll" event to be fired before
            // the "appear" event. Fire non-bubbling "scroll" in all browsers,
            // since a duplicate "scroll" should not cause any issues and it
            // is hard to track which version of the browser engine started to
            // follow the CSSOM Spec. Fixes [BUG #4570].
            qx.event.Registration.fireNonBubblingEvent(parent, a);
          };
          if(parent === J){

            break;
          };
          parent = parent.parentNode;
        };
      },
      /**
       * The method scrolls the element into view.
       *
       * @param element {Element} DOM element to scroll into view
       * @param stop {Element?null} Any parent element which functions as
       *   outest element to scroll. Default is the HTML document.
       * @param alignX {String} Alignment of the element. Allowed values:
       *   <code>left</code> or <code>right</code>. Could also be undefined.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param alignY {String} Alignment of the element. Allowed values:
       *   <code>top</code> or <code>bottom</code>. Could also be undefined.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       */
      intoView : function(be, stop, bf, bg){

        this.intoViewX(be, stop, bf);
        this.intoViewY(be, stop, bg);
      }
    }
  });
})();
(function(){

  var j = "qx.bom.element.Location",i = "paddingLeft",h = "static",g = "marginBottom",f = "visible",e = "BODY",d = "paddingBottom",c = "paddingTop",b = "gecko",a = "marginRight",D = "mshtml",C = "position",B = "margin",A = "overflow",z = "paddingRight",y = "browser.documentmode",x = "border",w = "borderBottomWidth",v = "borderRightWidth",u = "auto",q = "padding",r = "browser.quirksmode",o = "engine.version",p = "marginTop",m = "marginLeft",n = "border-box",k = "engine.name",l = "scroll",s = "borderTopWidth",t = "borderLeftWidth";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * jQuery Dimension Plugin
         http://jquery.com/
         Version 1.1.3
  
       Copyright:
         (c) 2007, Paul Bakaus & Brandon Aaron
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         Paul Bakaus
         Brandon Aaron
  
  ************************************************************************ */
  /**
   * Query the location of an arbitrary DOM element in relation to its top
   * level body element. Works in all major browsers:
   *
   * * Mozilla 1.5 + 2.0
   * * Internet Explorer 6.0 + 7.0 (both standard & quirks mode)
   * * Opera 9.2
   * * Safari 3.0 beta
   */
  qx.Bootstrap.define(j, {
    statics : {
      /**
       * Queries a style property for the given element
       *
       * @param elem {Element} DOM element to query
       * @param style {String} Style property
       * @return {String} Value of given style property
       */
      __style : function(E, F){

        return qx.bom.element.Style.get(E, F, qx.bom.element.Style.COMPUTED_MODE, false);
      },
      /**
       * Queries a style property for the given element and parses it to an integer value
       *
       * @param elem {Element} DOM element to query
       * @param style {String} Style property
       * @return {Integer} Value of given style property
       */
      __num : function(G, H){

        return parseInt(qx.bom.element.Style.get(G, H, qx.bom.element.Style.COMPUTED_MODE, false), 10) || 0;
      },
      /**
       * Computes the scroll offset of the given element relative to the document
       * <code>body</code>.
       *
       * @param elem {Element} DOM element to query
       * @return {Map} Map which contains the <code>left</code> and <code>top</code> scroll offsets
       */
      __computeScroll : function(I){

        var K = 0,top = 0;
        // Find window
        var J = qx.dom.Node.getWindow(I);
        K -= qx.bom.Viewport.getScrollLeft(J);
        top -= qx.bom.Viewport.getScrollTop(J);
        return {
          left : K,
          top : top
        };
      },
      /**
       * Computes the offset of the given element relative to the document
       * <code>body</code>.
       *
       * @param elem {Element} DOM element to query
       * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets
       */
      __computeBody : qx.core.Environment.select(k, {
        "mshtml" : function(L){

          // Find body element
          var N = qx.dom.Node.getDocument(L);
          var M = N.body;
          var O = 0;
          var top = 0;
          O -= M.clientLeft + N.documentElement.clientLeft;
          top -= M.clientTop + N.documentElement.clientTop;
          if(!qx.core.Environment.get(r)){

            O += this.__num(M, t);
            top += this.__num(M, s);
          };
          return {
            left : O,
            top : top
          };
        },
        "webkit" : function(P){

          // Find body element
          var R = qx.dom.Node.getDocument(P);
          var Q = R.body;
          // Start with the offset
          var S = Q.offsetLeft;
          var top = Q.offsetTop;
          // only for safari < version 4.0
          if(parseFloat(qx.core.Environment.get(o)) < 530.17){

            S += this.__num(Q, t);
            top += this.__num(Q, s);
          };
          return {
            left : S,
            top : top
          };
        },
        "gecko" : function(T){

          // Find body element
          var U = qx.dom.Node.getDocument(T).body;
          // Start with the offset
          var V = U.offsetLeft;
          var top = U.offsetTop;
          // add the body margin for firefox 3.0 and below
          if(parseFloat(qx.core.Environment.get(o)) < 1.9){

            V += this.__num(U, m);
            top += this.__num(U, p);
          };
          // Correct substracted border (only in content-box mode)
          if(qx.bom.element.BoxSizing.get(U) !== n){

            V += this.__num(U, t);
            top += this.__num(U, s);
          };
          return {
            left : V,
            top : top
          };
        },
        // At the moment only correctly supported by Opera
        "default" : function(W){

          // Find body element
          var X = qx.dom.Node.getDocument(W).body;
          // Start with the offset
          var Y = X.offsetLeft;
          var top = X.offsetTop;
          return {
            left : Y,
            top : top
          };
        }
      }),
      /**
       * Computes the sum of all offsets of the given element node.
       *
       * Traditionally this is a loop which goes up the whole parent tree
       * and sums up all found offsets.
       *
       * But both <code>mshtml</code> and <code>gecko >= 1.9</code> support
       * <code>getBoundingClientRect</code> which allows a
       * much faster access to the offset position.
       *
       * Please note: When gecko 1.9 does not use the <code>getBoundingClientRect</code>
       * implementation, and therefore use the traditional offset calculation
       * the gecko 1.9 fix in <code>__computeBody</code> must not be applied.
       *
       * @signature function(elem)
       * @param elem {Element} DOM element to query
       * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets
       */
      __computeOffset : qx.core.Environment.select(k, {
        "gecko" : function(ba){

          // Use faster getBoundingClientRect() if available (gecko >= 1.9)
          if(ba.getBoundingClientRect){

            var bd = ba.getBoundingClientRect();
            // Firefox 3.0 alpha 6 (gecko 1.9) returns floating point numbers
            // use Math.round() to round them to style compatible numbers
            // MSHTML returns integer numbers
            var be = Math.round(bd.left);
            var top = Math.round(bd.top);
          } else {

            var be = 0;
            var top = 0;
            // Stop at the body
            var bb = qx.dom.Node.getDocument(ba).body;
            var bc = qx.bom.element.BoxSizing;
            if(bc.get(ba) !== n){

              be -= this.__num(ba, t);
              top -= this.__num(ba, s);
            };
            while(ba && ba !== bb){

              // Add node offsets
              be += ba.offsetLeft;
              top += ba.offsetTop;
              // Mozilla does not add the borders to the offset
              // when using box-sizing=content-box
              if(bc.get(ba) !== n){

                be += this.__num(ba, t);
                top += this.__num(ba, s);
              };
              // Mozilla does not add the border for a parent that has
              // overflow set to anything but visible
              if(ba.parentNode && this.__style(ba.parentNode, A) != f){

                be += this.__num(ba.parentNode, t);
                top += this.__num(ba.parentNode, s);
              };
              // One level up (offset hierarchy)
              ba = ba.offsetParent;
            };
          };
          return {
            left : be,
            top : top
          };
        },
        "default" : function(bf){

          var bh = qx.dom.Node.getDocument(bf);
          // Use faster getBoundingClientRect() if available
          if(bf.getBoundingClientRect){

            var bi = bf.getBoundingClientRect();
            var bj = Math.round(bi.left);
            var top = Math.round(bi.top);
          } else {

            // Offset of the incoming element
            var bj = bf.offsetLeft;
            var top = bf.offsetTop;
            // Start with the first offset parent
            bf = bf.offsetParent;
            // Stop at the body
            var bg = bh.body;
            // Border correction is only needed for each parent
            // not for the incoming element itself
            while(bf && bf != bg){

              // Add node offsets
              bj += bf.offsetLeft;
              top += bf.offsetTop;
              // Fix missing border
              bj += this.__num(bf, t);
              top += this.__num(bf, s);
              // One level up (offset hierarchy)
              bf = bf.offsetParent;
            };
          };
          return {
            left : bj,
            top : top
          };
        }
      }),
      /**
       * Computes the location of the given element in context of
       * the document dimensions.
       *
       * Supported modes:
       *
       * * <code>margin</code>: Calculate from the margin box of the element (bigger than the visual appearance: including margins of given element)
       * * <code>box</code>: Calculates the offset box of the element (default, uses the same size as visible)
       * * <code>border</code>: Calculate the border box (useful to align to border edges of two elements).
       * * <code>scroll</code>: Calculate the scroll box (relevant for absolute positioned content).
       * * <code>padding</code>: Calculate the padding box (relevant for static/relative positioned content).
       *
       * @param elem {Element} DOM element to query
       * @param mode {String?box} A supported option. See comment above.
       * @return {Map} Returns a map with <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code> which contains the distance
       *   of the element relative to the document.
       */
      get : function(bk, bl){

        if(bk.tagName == e){

          var location = this.__getBodyLocation(bk);
          var bs = location.left;
          var top = location.top;
        } else {

          var bm = this.__computeBody(bk);
          var br = this.__computeOffset(bk);
          // Reduce by viewport scrolling.
          // Hint: getBoundingClientRect returns the location of the
          // element in relation to the viewport which includes
          // the scrolling
          var scroll = this.__computeScroll(bk);
          var bs = br.left + bm.left - scroll.left;
          var top = br.top + bm.top - scroll.top;
        };
        var bn = bs + bk.offsetWidth;
        var bo = top + bk.offsetHeight;
        if(bl){

          // In this modes we want the size as seen from a child what means that we want the full width/height
          // which may be higher than the outer width/height when the element has scrollbars.
          if(bl == q || bl == l){

            var bp = qx.bom.element.Overflow.getX(bk);
            if(bp == l || bp == u){

              bn += bk.scrollWidth - bk.offsetWidth + this.__num(bk, t) + this.__num(bk, v);
            };
            var bq = qx.bom.element.Overflow.getY(bk);
            if(bq == l || bq == u){

              bo += bk.scrollHeight - bk.offsetHeight + this.__num(bk, s) + this.__num(bk, w);
            };
          };
          switch(bl){case q:
          bs += this.__num(bk, i);
          top += this.__num(bk, c);
          bn -= this.__num(bk, z);
          bo -= this.__num(bk, d);// no break here
          case l:
          bs -= bk.scrollLeft;
          top -= bk.scrollTop;
          bn -= bk.scrollLeft;
          bo -= bk.scrollTop;// no break here
          case x:
          bs += this.__num(bk, t);
          top += this.__num(bk, s);
          bn -= this.__num(bk, v);
          bo -= this.__num(bk, w);
          break;case B:
          bs -= this.__num(bk, m);
          top -= this.__num(bk, p);
          bn += this.__num(bk, a);
          bo += this.__num(bk, g);
          break;};
        };
        return {
          left : bs,
          top : top,
          right : bn,
          bottom : bo
        };
      },
      /**
       * Get the location of the body element relative to the document.
       * @param body {Element} The body element.
       */
      __getBodyLocation : function(bt){

        var top = bt.offsetTop;
        var bu = bt.offsetLeft;
        if(qx.core.Environment.get(k) !== D || !((parseFloat(qx.core.Environment.get(o)) < 8 || qx.core.Environment.get(y) < 8) && !qx.core.Environment.get(r))){

          top += this.__num(bt, p);
          bu += this.__num(bt, m);
        };
        if(qx.core.Environment.get(k) === b){

          top += this.__num(bt, t);
          bu += this.__num(bt, s);
        };
        return {
          left : bu,
          top : top
        };
      },
      /**
       * Computes the location of the given element in context of
       * the document dimensions. For supported modes please
       * have a look at the {@link qx.bom.element.Location#get} method.
       *
       * @param elem {Element} DOM element to query
       * @param mode {String} A supported option. See comment above.
       * @return {Integer} The left distance
       *   of the element relative to the document.
       */
      getLeft : function(bv, bw){

        return this.get(bv, bw).left;
      },
      /**
       * Computes the location of the given element in context of
       * the document dimensions. For supported modes please
       * have a look at the {@link qx.bom.element.Location#get} method.
       *
       * @param elem {Element} DOM element to query
       * @param mode {String} A supported option. See comment above.
       * @return {Integer} The top distance
       *   of the element relative to the document.
       */
      getTop : function(bx, by){

        return this.get(bx, by).top;
      },
      /**
       * Computes the location of the given element in context of
       * the document dimensions. For supported modes please
       * have a look at the {@link qx.bom.element.Location#get} method.
       *
       * @param elem {Element} DOM element to query
       * @param mode {String} A supported option. See comment above.
       * @return {Integer} The right distance
       *   of the element relative to the document.
       */
      getRight : function(bz, bA){

        return this.get(bz, bA).right;
      },
      /**
       * Computes the location of the given element in context of
       * the document dimensions. For supported modes please
       * have a look at the {@link qx.bom.element.Location#get} method.
       *
       * @param elem {Element} DOM element to query
       * @param mode {String} A supported option. See comment above.
       * @return {Integer} The bottom distance
       *   of the element relative to the document.
       */
      getBottom : function(bB, bC){

        return this.get(bB, bC).bottom;
      },
      /**
       * Returns the distance between two DOM elements. For supported modes please
       * have a look at the {@link qx.bom.element.Location#get} method.
       *
       * @param elem1 {Element} First element
       * @param elem2 {Element} Second element
       * @param mode1 {String?null} Mode for first element
       * @param mode2 {String?null} Mode for second element
       * @return {Map} Returns a map with <code>left</code> and <code>top</code>
       *   which contains the distance of the elements from each other.
       */
      getRelative : function(bD, bE, bF, bG){

        var bI = this.get(bD, bF);
        var bH = this.get(bE, bG);
        return {
          left : bI.left - bH.left,
          top : bI.top - bH.top,
          right : bI.right - bH.right,
          bottom : bI.bottom - bH.bottom
        };
      },
      /**
       * Returns the distance between the given element to its offset parent.
       *
       * @param elem {Element} DOM element to query
       * @return {Map} Returns a map with <code>left</code> and <code>top</code>
       *   which contains the distance of the elements from each other.
       */
      getPosition : function(bJ){

        return this.getRelative(bJ, this.getOffsetParent(bJ));
      },
      /**
       * Detects the offset parent of the given element
       *
       * @param element {Element} Element to query for offset parent
       * @return {Element} Detected offset parent
       */
      getOffsetParent : function(bK){

        var bM = bK.offsetParent || document.body;
        var bL = qx.bom.element.Style;
        while(bM && (!/^body|html$/i.test(bM.tagName) && bL.get(bM, C) === h)){

          bM = bM.offsetParent;
        };
        return bM;
      }
    }
  });
})();
(function(){

  var t = "touchend",s = " due to exceptions in user code. The application has to be reloaded!",r = "Error in the 'Appearance' queue:",q = "Error in the 'Widget' queue:",p = "\n",o = "Error in the 'Layout' queue:",n = "Error in the 'Visibility' queue:",m = "useraction",l = "Error while layout flush: ",k = 'ie',d = "Error in the 'Dispose' queue:",j = "Stack trace: \n",h = "event.touch",c = "browser.version",b = " times in a row",g = "qx.ui.core.queue.Manager",f = "browser.name",i = "Fatal Error: Flush terminated ",a = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.UserAction)
  
  ************************************************************************ */
  /**
   * This class performs the auto flush of all layout relevant queues.
   */
  qx.Class.define(g, {
    statics : {
      /** {Boolean} Whether a flush was scheduled */
      __scheduled : false,
      /** {Map} Internal data structure for the current job list */
      __jobs : {
      },
      /** {Integer} Counts how often a flush failed due to exceptions */
      __retries : 0,
      /** {Integer} Maximum number of flush retries */
      MAX_RETRIES : 10,
      /**
       * Schedule a deferred flush of all queues.
       *
       * @param job {String} The job, which should be performed. Valid values are
       *     <code>layout</code>, <code>decoration</code> and <code>element</code>.
       * @return {void}
       */
      scheduleFlush : function(u){

        // Sometimes not executed in context, fix this
        var self = qx.ui.core.queue.Manager;
        self.__jobs[u] = true;
        if(!self.__scheduled){

          self.__deferredCall.schedule();
          self.__scheduled = true;
        };
      },
      /**
       * Flush all layout queues in the correct order. This function is called
       * deferred if {@link #scheduleFlush} is called.
       *
       * @return {void}
       */
      flush : function(){

        if(qx.ui.core.queue.Manager.PAUSE){

          return;
        };
        // Sometimes not executed in context, fix this
        var self = qx.ui.core.queue.Manager;
        // Stop when already executed
        if(self.__inFlush){

          return;
        };
        self.__inFlush = true;
        // Cancel timeout if called manually
        self.__deferredCall.cancel();
        var v = self.__jobs;
        self.__executeAndRescheduleOnError(function(){

          // Process jobs
          while(v.visibility || v.widget || v.appearance || v.layout || v.element){

            // No else blocks here because each flush can influence the following flushes!
            if(v.widget){

              delete v.widget;
              if(qx.core.Environment.get(a)){

                try{

                  qx.ui.core.queue.Widget.flush();
                } catch(e) {

                  qx.log.Logger.error(q + e);
                };
              } else {

                qx.ui.core.queue.Widget.flush();
              };
            };
            if(v.visibility){

              delete v.visibility;
              if(qx.core.Environment.get(a)){

                try{

                  qx.ui.core.queue.Visibility.flush();
                } catch(e) {

                  qx.log.Logger.error(n + e);
                };
              } else {

                qx.ui.core.queue.Visibility.flush();
              };
            };
            if(v.appearance){

              delete v.appearance;
              if(qx.core.Environment.get(a)){

                try{

                  qx.ui.core.queue.Appearance.flush();
                } catch(e) {

                  qx.log.Logger.error(r + e);
                };
              } else {

                qx.ui.core.queue.Appearance.flush();
              };
            };
            // Defer layout as long as possible
            if(v.widget || v.visibility || v.appearance){

              continue;
            };
            if(v.layout){

              delete v.layout;
              if(qx.core.Environment.get(a)){

                try{

                  qx.ui.core.queue.Layout.flush();
                } catch(e) {

                  qx.log.Logger.error(o + e);
                };
              } else {

                qx.ui.core.queue.Layout.flush();
              };
            };
            // Defer element as long as possible
            if(v.widget || v.visibility || v.appearance || v.layout){

              continue;
            };
            if(v.element){

              delete v.element;
              qx.html.Element.flush();
            };
          };
        }, function(){

          self.__scheduled = false;
        });
        self.__executeAndRescheduleOnError(function(){

          if(v.dispose){

            delete v.dispose;
            if(qx.core.Environment.get(a)){

              try{

                qx.ui.core.queue.Dispose.flush();
              } catch(e) {

                qx.log.Logger.error(d + e);
              };
            } else {

              qx.ui.core.queue.Dispose.flush();
            };
          };
        }, function(){

          // Clear flag
          self.__inFlush = false;
        });
        // flush succeeded successfully. Reset retries
        self.__retries = 0;
      },
      /**
       * Executes the callback code. If the callback throws an error the current
       * flush is cleaned up and rescheduled. The finally code is called after the
       * callback even if it has thrown an exception.
       *
       * @signature function(callback, finallyCode)
       * @param callback {Function} the callback function
       * @param finallyCode {Function} function to be called in the finally block
       */
      __executeAndRescheduleOnError : qx.core.Environment.select(a, {
        "true" : function(w, x){

          w();
          x();
        },
        "false" : function(y, z){

          var self = qx.ui.core.queue.Manager;
          try{

            y();
          } catch(e) {

            if(qx.core.Environment.get(a)){

              qx.log.Logger.error(l + e + p + j + qx.dev.StackTrace.getStackTraceFromError(e));
            };
            self.__scheduled = false;
            self.__inFlush = false;
            self.__retries += 1;
            // this hack is used to fix [BUG #3688]
            if(qx.core.Environment.get(f) == k && qx.core.Environment.get(c) <= 7){

              z();
            };
            if(self.__retries <= self.MAX_RETRIES){

              self.scheduleFlush();
            } else {

              throw new Error(i + (self.__retries - 1) + b + s);
            };
            throw e;
          }finally{

            z();
          };
        }
      }),
      /**
       * Handler used on touch devices to prevent the queue from manipulating
       * the dom during the touch - mouse - ... event sequence. Usually, iOS
       * devices fire a click event 300ms after the touchend event. So using
       * 500ms should be a good value to be on the save side. This is necessary
       * due to the fact that the event chain is stopped if a manipulation in
       * the DOM is done.
       *
       * @param e {qx.event.type.Data} The user action data event.
       */
      __onUserAction : function(e){

        var A = qx.ui.core.queue.Manager;
        // pospone the flush for 500ms due to the fact that iOS stops firing
        // events if the dom gets changed during the vent chain [BUG #4033]
        if(e.getData() == t){

          A.PAUSE = true;
          if(A.__pauseTimeout){

            window.clearTimeout(A.__pauseTimeout);
          };
          A.__pauseTimeout = window.setTimeout(function(){

            A.PAUSE = false;
            A.__pauseTimeout = null;
            A.flush();
          }, 500);
        } else {

          A.flush();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    defer : function(B){

      // Initialize deferred call
      B.__deferredCall = new qx.util.DeferredCall(B.flush);
      // Replace default scheduler for HTML element with local one.
      // This is quite a hack, but allows us to force other flushes
      // before the HTML element flush.
      qx.html.Element._scheduleFlush = B.scheduleFlush;
      // Register to user action
      qx.event.Registration.addListener(window, m, qx.core.Environment.get(h) ? B.__onUserAction : B.flush);
    }
  });
})();
(function(){

  var c = "qx.ui.core.queue.Widget",b = "widget",a = "$$default";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  /**
   * The widget queue handles the deferred computation of certain widget properties.
   * It is used e.g. for the tree to update the indentation of tree nodes.
   *
   * This queue calls the method {@link qx.ui.core.Widget#syncWidget} of each
   * queued widget before the layout queues are processed.
   */
  qx.Class.define(c, {
    statics : {
      /** {Array} This contains all the queued widgets for the next flush. */
      __queue : [],
      /**
       * {Object} This contains a map of widgets hash ($$hash) and their
       * corresponding map of jobs.
       */
      __jobs : {
      },
      /**
       * Clears given job of a widget from the internal queue. If no jobs left, the
       * widget will be removed completely from queue. If job param is <code>null</code>
       * or <code>undefined</code> widget will be removed completely from queue.
       * Normally only used during interims disposes of one or a few widgets.
       *
       * @param widget {qx.ui.core.Widget} The widget to clear
       * @param job {String?} Job identifier. If not used, it will be converted to
       * "$$default".
       */
      remove : function(d, e){

        var f = this.__queue;
        if(!qx.lang.Array.contains(f, d)){

          return;
        };
        var g = d.$$hash;
        // remove widget and all corresponding jobs, if job param is not given.
        if(e == null){

          qx.lang.Array.remove(f, d);
          delete this.__jobs[g];
          return;
        };
        if(this.__jobs[g]){

          delete this.__jobs[g][e];
          if(qx.lang.Object.getLength(this.__jobs[g]) == 0){

            qx.lang.Array.remove(f, d);
          };
        };
      },
      /**
       * Adds a widget to the queue. The second param can be used to identify
       * several jobs. You can add one job at once, which will be returned as
       * an map at flushing on method {@link qx.ui.core.Widget#syncWidget}.
       *
       * @param widget {qx.ui.core.Widget} The widget to add.
       * @param job {String?} Job identifier. If not used, it will be converted to
       * "$$default".
       */
      add : function(h, j){

        var k = this.__queue;
        //add widget if not containing
        if(!qx.lang.Array.contains(k, h)){

          k.unshift(h);
        };
        //add job
        if(j == null){

          j = a;
        };
        var l = h.$$hash;
        if(!this.__jobs[l]){

          this.__jobs[l] = {
          };
        };
        this.__jobs[l][j] = true;
        qx.ui.core.queue.Manager.scheduleFlush(b);
      },
      /**
       * Flushes the widget queue.
       *
       * This is used exclusively by the {@link qx.ui.core.queue.Manager}.
       */
      flush : function(){

        // Process all registered widgets
        var m = this.__queue;
        var o,n;
        for(var i = m.length - 1;i >= 0;i--){

          // Order is important to allow the same widget to be requeued directly
          o = m[i];
          n = this.__jobs[o.$$hash];
          m.splice(i, 1);
          o.syncWidget(n);
        };
        // Empty check
        if(m.length != 0){

          return;
        };
        // Recreate the array is cheaper compared to keep a holey array over time
        // This is especially true for IE7
        this.__queue = [];
        this.__jobs = {
        };
      }
    }
  });
})();
(function(){

  var b = "qx.ui.core.queue.Visibility",a = "visibility";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Keeps data about the visibility of all widgets. Updates the internal
   * tree when widgets are added, removed or modify their visibility.
   */
  qx.Class.define(b, {
    statics : {
      /** {Array} This contains all the queued widgets for the next flush. */
      __queue : [],
      /** {Map} Maps hash codes to visibility */
      __data : {
      },
      /**
       * Clears the cached data of the given widget. Normally only used
       * during interims disposes of one or a few widgets.
       *
       * @param widget {qx.ui.core.Widget} The widget to clear
       */
      remove : function(c){

        delete this.__data[c.$$hash];
        qx.lang.Array.remove(this.__queue, c);
      },
      /**
       * Whether the given widget is visible.
       *
       * Please note that the information given by this method is queued and may not be accurate
       * until the next queue flush happens.
       *
       * @param widget {qx.ui.core.Widget} The widget to query
       * @return {Boolean} Whether the widget is visible
       */
      isVisible : function(d){

        return this.__data[d.$$hash] || false;
      },
      /**
       * Computes the visibility for the given widget
       *
       * @param widget {qx.ui.core.Widget} The widget to update
       * @return {Boolean} Whether the widget is visible
       */
      __computeVisible : function(e){

        var g = this.__data;
        var f = e.$$hash;
        var h;
        // Respect local value
        if(e.isExcluded()){

          h = false;
        } else {

          // Parent hierarchy
          var parent = e.$$parent;
          if(parent){

            h = this.__computeVisible(parent);
          } else {

            h = e.isRootWidget();
          };
        };
        return g[f] = h;
      },
      /**
       * Adds a widget to the queue.
       *
       * Should only be used by {@link qx.ui.core.Widget}.
       *
       * @param widget {qx.ui.core.Widget} The widget to add.
       */
      add : function(j){

        var k = this.__queue;
        if(qx.lang.Array.contains(k, j)){

          return;
        };
        k.unshift(j);
        qx.ui.core.queue.Manager.scheduleFlush(a);
      },
      /**
       * Flushes the visibility queue.
       *
       * This is used exclusively by the {@link qx.ui.core.queue.Manager}.
       */
      flush : function(){

        // Dispose all registered objects
        var o = this.__queue;
        var p = this.__data;
        // Dynamically add children to queue
        // Only respect already known widgets because otherwise the children
        // are also already in the queue (added on their own)
        for(var i = o.length - 1;i >= 0;i--){

          var n = o[i].$$hash;
          if(p[n] != null){

            // recursive method call which adds widgets to the queue so be
            // careful with that one (performance critical)
            o[i].addChildrenToQueue(o);
          };
        };
        // Cache old data, clear current data
        // Do this before starting with recompution because
        // new data may also be added by related widgets and not
        // only the widget itself.
        var l = {
        };
        for(var i = o.length - 1;i >= 0;i--){

          var n = o[i].$$hash;
          l[n] = p[n];
          p[n] = null;
        };
        // Finally recompute
        for(var i = o.length - 1;i >= 0;i--){

          var m = o[i];
          var n = m.$$hash;
          o.splice(i, 1);
          // Only update when not already updated by another widget
          if(p[n] == null){

            this.__computeVisible(m);
          };
          // Check for updates required to the appearance.
          // Hint: Invisible widgets are ignored inside appearance flush
          if(p[n] && p[n] != l[n]){

            m.checkAppearanceNeeds();
          };
        };
        // Recreate the array is cheaper compared to keep a holey array over time
        // This is especially true for IE7
        this.__queue = [];
      }
    }
  });
})();
(function(){

  var b = "appearance",a = "qx.ui.core.queue.Appearance";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The AppearanceQueue registers all widgets which are influences through
   * state changes.
   */
  qx.Class.define(a, {
    statics : {
      /** {Array} This contains all the queued widgets for the next flush. */
      __queue : [],
      /**
       * Clears the widget from the internal queue. Normally only used
       * during interims disposes of one or a few widgets.
       *
       * @param widget {qx.ui.core.Widget} The widget to clear
       */
      remove : function(c){

        qx.lang.Array.remove(this.__queue, c);
      },
      /**
       * Adds a widget to the queue.
       *
       * Should only be used by {@link qx.ui.core.Widget}.
       *
       * @param widget {qx.ui.core.Widget} The widget to add.
       */
      add : function(d){

        var e = this.__queue;
        if(qx.lang.Array.contains(e, d)){

          return;
        };
        e.unshift(d);
        qx.ui.core.queue.Manager.scheduleFlush(b);
      },
      /**
       * Whether the given widget is already queued
       *
       * @param widget {qx.ui.core.Widget} The widget to check
       */
      has : function(f){

        return qx.lang.Array.contains(this.__queue, f);
      },
      /**
       * Flushes the appearance queue.
       *
       * This is used exclusively by the {@link qx.ui.core.queue.Manager}.
       */
      flush : function(){

        var j = qx.ui.core.queue.Visibility;
        var g = this.__queue;
        var h;
        for(var i = g.length - 1;i >= 0;i--){

          // Order is important to allow the same widget to be re-queued directly
          h = g[i];
          g.splice(i, 1);
          // Only apply to currently visible widgets
          if(j.isVisible(h)){

            h.syncAppearance();
          } else {

            h.$$stateChanges = true;
          };
        };
      }
    }
  });
})();
(function(){

  var b = "dispose",a = "qx.ui.core.queue.Dispose";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The DisposeQueue registers all widgets which are should be disposed.
   * This queue makes it possible to remove widgets from the DOM using
   * the layout and element queues and dispose them afterwards.
   */
  qx.Class.define(a, {
    statics : {
      /** {Array} This contains all the queued widgets for the next flush. */
      __queue : [],
      /**
       * Adds a widget to the queue.
       *
       * Should only be used by {@link qx.ui.core.Widget}.
       *
       * @param widget {qx.ui.core.Widget} The widget to add.
       */
      add : function(c){

        var d = this.__queue;
        if(qx.lang.Array.contains(d, c)){

          return;
        };
        d.unshift(c);
        qx.ui.core.queue.Manager.scheduleFlush(b);
      },
      /**
       * Whether the dispose queue is empty
       * @return {Boolean}
       * @internal
       */
      isEmpty : function(){

        return this.__queue.length == 0;
      },
      /**
       * Flushes the dispose queue.
       *
       * This is used exclusively by the {@link qx.ui.core.queue.Manager}.
       */
      flush : function(){

        // Dispose all registered objects
        var e = this.__queue;
        for(var i = e.length - 1;i >= 0;i--){

          var f = e[i];
          e.splice(i, 1);
          f.dispose();
        };
        // Empty check
        if(e.length != 0){

          return;
        };
        // Recreate the array is cheaper compared to keep a holey array over time
        // This is especially true for IE7
        this.__queue = [];
      }
    }
  });
})();
(function(){

  var i = "decorator",h = "qxType",g = "",f = "qx.ui.core.DecoratorFactory",e = "qx.ui.core.DecoratorFactory[",d = "] ",c = "keys: ",b = ", elements: ",a = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This class is responsible for creating and maintaining {@link qx.html.Element}
   * instances. It pools decorator elements for reuse.
   *
   *  @internal
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    construct : function(){

      qx.core.Object.call(this);
      this.__pool = {
      };
    },
    statics : {
      MAX_SIZE : 15,
      __NO_POOL_ID : "$$nopool$$"
    },
    members : {
      __pool : null,
      /**
       * Get a decorator element configured with the given decorator.
       *
       * @param decorator {qx.ui.decoration.IDecorator} The decorator to use
       * @return {qx.html.Decorator} The configured decorator element
       */
      getDecoratorElement : function(j){

        var o = qx.ui.core.DecoratorFactory;
        if(qx.lang.Type.isString(j)){

          var m = j;
          var l = qx.theme.manager.Decoration.getInstance().resolve(j);
        } else {

          var m = o.__NO_POOL_ID;
          l = j;
        };
        var n = this.__pool;
        if(n[m] && n[m].length > 0){

          var k = n[m].pop();
        } else {

          var k = this._createDecoratorElement(l, m);
        };
        k.$$pooled = false;
        return k;
      },
      /**
       * Pool or dispose the given decorator element
       *
       * @param decoratorElement {qx.html.Decorator} the decorator element to pool
       */
      poolDecorator : function(p){

        if(!p || p.$$pooled || p.isDisposed()){

          return;
        };
        var s = qx.ui.core.DecoratorFactory;
        var q = p.getId();
        if(q == s.__NO_POOL_ID){

          p.dispose();
          return;
        };
        var r = this.__pool;
        if(!r[q]){

          r[q] = [];
        };
        if(r[q].length > s.MAX_SIZE){

          p.dispose();
        } else {

          p.$$pooled = true;
          r[q].push(p);
        };
      },
      /**
       * Creates an element which may be used for a
       * decoration render to fill.
       *
       * @param decorator {qx.ui.decoration.IDecorator} Any instance implementing
       *     the decorator interface
       * @param id {String?} An optional id for the decorator
       * @return {qx.html.Decorator} The element to be used for decorations/shadows
       */
      _createDecoratorElement : function(t, u){

        var v = new qx.html.Decorator(t, u);
        if(qx.core.Environment.get(a)){

          v.setAttribute(h, i);
        };
        return v;
      },
      toString : qx.core.Environment.select(a, {
        "true" : function(){

          var w = 0;
          var x = 0;
          for(var y in this.__pool){

            w += 1;
            x += this.__pool[y].length;
          };
          return [e, this.$$hash, d, c, w, b, x].join(g);
        },
        "false" : function(){

          return qx.core.Object.prototype.toString.call(this);
        }
      })
    },
    destruct : function(){

      if(!qx.core.ObjectRegistry.inShutDown){

        var A = this.__pool;
        for(var z in A){

          qx.util.DisposeUtil.disposeArray(A, z);
        };
      };
      this.__pool = null;
    }
  });
})();
(function(){

  var d = "event.pointer",c = "none",b = "qx.html.Decorator",a = "absolute";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * An element preconfigured with a decorator. The decorator cannot be changed
   * after creation. This class is used to render the backgrounds, shadows and
   * separators in widgets.
   */
  qx.Class.define(b, {
    extend : qx.html.Element,
    /**
     * @param decorator {qx.ui.decoration.IDecorator} The decorator to use
     * @param decoratorId {String?} An optional id for the decorator.
     */
    construct : function(e, f){

      var g = {
        position : a,
        top : 0,
        left : 0
      };
      if(qx.core.Environment.get(d)){

        g.pointerEvents = c;
      };
      qx.html.Element.call(this, null, g);
      this.__decorator = e;
      this.__id = f || e.toHashCode();
      this.useMarkup(e.getMarkup());
    },
    members : {
      __id : null,
      __decorator : null,
      /**
       * Get the decorator's id
       *
       * @return {String} the id
       */
      getId : function(){

        return this.__id;
      },
      /**
       * Get the decorator
       *
       * @return {qx.ui.decoration.IDecorator} the decorator used
       */
      getDecorator : function(){

        return this.__decorator;
      },
      /**
       * Resizes the element respecting the configured borders
       * to the given width and height. Should automatically
       * respect the box model of the client to correctly
       * compute the dimensions.
       *
       * @param width {Integer} Width of the element
       * @param height {Integer} Height of the element
       */
      resize : function(h, i){

        this.__decorator.resize(this.getDomElement(), h, i);
        // hack to reset the elements cache which might be wrong due to direct
        // style settings in the resize method
        this.getAllStyles().left = this.getDomElement().style.left;
        this.getAllStyles().top = this.getDomElement().style.top;
      },
      /**
       * Applies the given background color to the element
       * or fallback to the background color defined
       * by the decoration itself.
       *
       * @param color {Color|null} The color to apply or <code>null</code>
       */
      tint : function(j){

        this.__decorator.tint(this.getDomElement(), j);
      },
      /**
       * Get the amount of space, the decoration needs for its border on each
       * side.
       *
       * @return {Map} the desired insets. A map with the keys <code>top</code>,
       *     <code>right</code>, <code>bottom</code>, <code>left</code>.
       */
      getInsets : function(){

        return this.__decorator.getInsets();
      }
    },
    destruct : function(){

      this.__decorator = null;
    }
  });
})();
(function(){

  var cE = "_applyNativeContextMenu",cD = "Decorator instances may increase memory usage and ",cC = "content",cB = "engine.version",cA = "_applyBackgroundColor",cz = "event.pointer",cy = "_applyFocusable",cx = " requires a layout, but no one was defined!",cw = "changeShadow",cv = "qx.event.type.KeyInput",bF = "createChildControl",bE = "browser.documentmode",bD = "Unsupported control: ",bC = "Invalid left decorator inset detected: ",bB = "Font",bA = "_applyShadow",bz = "Invalid layout data: ",by = "Could not add widget to itself: ",bx = "_applyEnabled",bw = "_applySelectable",cL = "Number",cM = "_applyKeepActive",cJ = "_applyVisibility",cK = "The 'before' widget is not a child of this widget!",cH = "Child control '",cI = "repeat",cF = "qxDraggable",cG = "syncAppearance",cN = '" while styling ',cO = "paddingLeft",ce = "__containerElement",cd = "_applyDroppable",cg = "Wrong 'left' argument. ",cf = "protector",ci = "#",ch = "__widgetChildren",ck = "'Child' must be an instance of qx.ui.core.LayoutItem!",cj = "Remove Error: ",cc = "qx.event.type.MouseWheel",cb = "__layoutManager",n = "_applyCursor",o = "_applyDraggable",p = "At least one child in control ",q = "changeTextColor",r = "$$widget",s = "changeContextMenu",t = "paddingTop",u = "changeSelectable",v = "hideFocus",w = "Invalid top decorator inset detected: ",dd = "none",dc = "__protectorElement",db = "outline",da = "The 'after' widget is not a child of this widget!",dh = "_applyAppearance",dg = " returned an invalid size hint!",df = "_applyOpacity",de = "url(",dj = ")",di = "qx.ui.core.Widget",V = "minHeight is larger than maxHeight!",W = "TabIndex property must be between 1 and 32000",T = "_applyFont",U = "cursor",ba = "__decoratorElement",bb = "qxDroppable",X = "' already created!",Y = "changeZIndex",R = "changeEnabled",S = "Abstract method call: _getContentHeightForWidth()!",E = "changeFont",D = "_applyDecorator",G = "_applyZIndex",F = "_applyTextColor",A = "__separators",z = ' has no themeable property "',C = "qx.ui.menu.Menu",B = "Invalid right decorator inset detected: ",y = "Invalid widget to add: ",x = "_applyToolTipText",bg = "The layout of the widget",bh = " is not a child of this widget!",bi = "true",bj = "widget",bc = "Wrong 'top' argument. ",bd = "__shadowElement",be = "changeDecorator",bf = "changeBackgroundColor",bk = "_applyTabIndex",bl = "Invalid bottom decorator inset detected: ",O = "changeAppearance",N = "shorthand",M = "/",L = "__contentElement",K = "processing time. Often it is better to lay them out to a ",J = "",I = "_applyContextMenu",H = "container",Q = "paddingBottom",P = "changeNativeContextMenu",bm = "undefined",bn = "qx.ui.tooltip.ToolTip",bo = "qxKeepActive",bp = "_applyKeepFocus",bq = "theme file. Hash code of decorator object: ",br = "paddingRight",bs = "minWidth is larger than maxWidth!",bt = "changeLocale",bu = "qxKeepFocus",bv = "opera",bJ = "qx/static/blank.gif",bI = "backgroundColor",bH = "drag",bG = "div",bN = "object",bM = "disabled",bL = "move",bK = "dragstart",bP = "qx.dynlocale",bO = "dragchange",bW = "dragend",bX = "resize",bU = "Decorator",bV = "zIndex",bS = "opacity",bT = "This widget has no children!",bQ = "default",bR = "Color",bY = "Widget is not focusable!",ca = "qxType",co = "changeToolTipText",cn = "beforeContextmenuOpen",cq = "focused",cp = "changeVisibility",cs = "hovered",cr = "qx.event.type.KeySequence",cu = "DOM element is not yet created!",ct = "absolute",cm = "_applyPadding",cl = "qx.event.type.Event",cV = "on",cW = "mshtml",cX = "hidden",cY = "contextmenu",cR = "String",cS = "tabIndex",cT = "qx.event.type.Data",cU = "engine.name",cP = "excluded",cQ = "qx.event.type.Focus",m = "Integer",k = "qx.event.type.Touch",j = "visible",h = "qx.event.type.Drag",g = "qx.event.type.Mouse",f = "Boolean",d = "qx.debug",c = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.ui.core.EventHandler)
  #use(qx.event.handler.DragDrop)
  
  #asset(qx/static/blank.gif)
  
  ************************************************************************ */
  /**
   * This is the base class for all widgets.
   *
   * A widget consists of at least three HTML elements. The container element,
   * which is
   * added to the parent widget has two child Element: The "decoration" and the
   * "content" element. The decoration element has a lower z-Index and contains
   * markup to render the widget's background and border using an implementation
   * of {@link qx.ui.decoration.IDecorator}.The content element is positioned
   * inside the "container" element to respect paddings and contains the "real"
   * widget element.
   *
   * <pre>
   * -container------------
   * |                    |
   * |  -decoration----   |
   * |  | -content----|-  |
   * |  | |           ||  |
   * |  --|------------|  |
   * |    --------------  |
   * |                    |
   * ----------------------
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/widget.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   *
   * @state disabled set by {@link #enabled}
   */
  qx.Class.define(di, {
    extend : qx.ui.core.LayoutItem,
    include : [qx.locale.MTranslation],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.LayoutItem.call(this);
      // Create basic element structure
      this.__containerElement = this._createContainerElement();
      this.__contentElement = this.__createContentElement();
      this.__containerElement.add(this.__contentElement);
      // Initialize properties
      this.initFocusable();
      this.initSelectable();
      this.initNativeContextMenu();
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired after the widget appears on the screen.
       */
      appear : cl,
      /**
       * Fired after the widget disappears from the screen.
       */
      disappear : cl,
      /**
       * Fired after the creation of a child control. The passed data is the
       * newly created child widget.
       */
      createChildControl : cT,
      /**
       * Fired on resize (after layout) of the widget.
       * The data property of the event contains the widget's computed location
       * and dimension as returned by {@link qx.ui.core.LayoutItem#getBounds}
       */
      resize : cT,
      /**
       * Fired on move (after layout) of the widget.
       * The data property of the event contains the widget's computed location
       * and dimension as returned by {@link qx.ui.core.LayoutItem#getBounds}
       */
      move : cT,
      /**
       * Fired after the appearance has been applied. This happens before the
       * widget becomes visible, on state and appearance changes. The data field
       * contains the state map. This can be used to react on state changes or to
       * read properties set by the appearance.
       */
      syncAppearance : cT,
      /** Fired if the mouse cursor moves over the widget.
       *  The data property of the event contains the widget's computed location
       *  and dimension as returned by {@link qx.ui.core.LayoutItem#getBounds}
       */
      mousemove : g,
      /**
       * Fired if the mouse cursor enters the widget.
       *
       * Note: This event is also dispatched if the widget is disabled!
       */
      mouseover : g,
      /**
       * Fired if the mouse cursor leaves widget.
       *
       * Note: This event is also dispatched if the widget is disabled!
       */
      mouseout : g,
      /** Mouse button is pressed on the widget. */
      mousedown : g,
      /** Mouse button is released on the widget. */
      mouseup : g,
      /** Widget is clicked using left or middle button.
          {@link qx.event.type.Mouse#getButton} for more details.*/
      click : g,
      /** Widget is double clicked using left or middle button.
          {@link qx.event.type.Mouse#getButton} for more details.*/
      dblclick : g,
      /** Widget is clicked using the right mouse button. */
      contextmenu : g,
      /** Fired before the context menu is opened. */
      beforeContextmenuOpen : cT,
      /** Fired if the mouse wheel is used over the widget. */
      mousewheel : cc,
      /** Fired if a touch at the screen is started. */
      touchstart : k,
      /** Fired if a touch at the screen has ended. */
      touchend : k,
      /** Fired during a touch at the screen. */
      touchmove : k,
      /** Fired if a touch at the screen is canceled. */
      touchcancel : k,
      /** Fired when a finger taps on the screen. */
      tap : k,
      /** Fired when a finger swipes over the screen. */
      swipe : k,
      /**
       * This event if fired if a keyboard key is released.
       **/
      keyup : cr,
      /**
       * This event if fired if a keyboard key is pressed down. This event is
       * only fired once if the user keeps the key pressed for a while.
       */
      keydown : cr,
      /**
       * This event is fired any time a key is pressed. It will be repeated if
       * the user keeps the key pressed. The pressed key can be determined using
       * {@link qx.event.type.KeySequence#getKeyIdentifier}.
       */
      keypress : cr,
      /**
       * This event is fired if the pressed key or keys result in a printable
       * character. Since the character is not necessarily associated with a
       * single physical key press, the event does not have a key identifier
       * getter. This event gets repeated if the user keeps pressing the key(s).
       *
       * The unicode code of the pressed key can be read using
       * {@link qx.event.type.KeyInput#getCharCode}.
       */
      keyinput : cv,
      /**
       * The event is fired when the widget gets focused. Only widgets which are
       * {@link #focusable} receive this event.
       */
      focus : cQ,
      /**
       * The event is fired when the widget gets blurred. Only widgets which are
       * {@link #focusable} receive this event.
       */
      blur : cQ,
      /**
       * When the widget itself or any child of the widget receive the focus.
       */
      focusin : cQ,
      /**
       * When the widget itself or any child of the widget lost the focus.
       */
      focusout : cQ,
      /**
       * When the widget gets active (receives keyboard events etc.)
       */
      activate : cQ,
      /**
       * When the widget gets inactive
       */
      deactivate : cQ,
      /**
       * Fired if the widget becomes the capturing widget by a call to {@link #capture}.
       */
      capture : cl,
      /**
       * Fired if the widget looses the capturing mode by a call to
       * {@link #releaseCapture} or a mouse click.
       */
      losecapture : cl,
      /**
       * Fired on the drop target when the drag&drop action is finished
       * successfully. This event is normally used to transfer the data
       * from the drag to the drop target.
       *
       * Modeled after the WHATWG specification of Drag&Drop:
       * http://www.whatwg.org/specs/web-apps/current-work/#dnd
       */
      drop : h,
      /**
       * Fired on a potential drop target when leaving it.
       *
       * Modeled after the WHATWG specification of Drag&Drop:
       * http://www.whatwg.org/specs/web-apps/current-work/#dnd
       */
      dragleave : h,
      /**
       * Fired on a potential drop target when reaching it via the mouse.
       * This event can be canceled if none of the incoming data types
       * are supported.
       *
       * Modeled after the WHATWG specification of Drag&Drop:
       * http://www.whatwg.org/specs/web-apps/current-work/#dnd
       */
      dragover : h,
      /**
       * Fired during the drag. Contains the current mouse coordinates
       * using {@link qx.event.type.Drag#getDocumentLeft} and
       * {@link qx.event.type.Drag#getDocumentTop}
       *
       * Modeled after the WHATWG specification of Drag&Drop:
       * http://www.whatwg.org/specs/web-apps/current-work/#dnd
       */
      drag : h,
      /**
       * Initiate the drag-and-drop operation. This event is cancelable
       * when the drag operation is currently not allowed/possible.
       *
       * Modeled after the WHATWG specification of Drag&Drop:
       * http://www.whatwg.org/specs/web-apps/current-work/#dnd
       */
      dragstart : h,
      /**
       * Fired on the source (drag) target every time a drag session was ended.
       */
      dragend : h,
      /**
       * Fired when the drag configuration has been modified e.g. the user
       * pressed a key which changed the selected action.
       */
      dragchange : h,
      /**
       * Fired when the drop was successfully done and the target widget
       * is now asking for data. The listener should transfer the data,
       * respecting the selected action, to the event. This can be done using
       * the event's {@link qx.event.type.Drag#addData} method.
       */
      droprequest : h
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        PADDING
      ---------------------------------------------------------------------------
      */
      /** Padding of the widget (top) */
      paddingTop : {
        check : m,
        init : 0,
        apply : cm,
        themeable : true
      },
      /** Padding of the widget (right) */
      paddingRight : {
        check : m,
        init : 0,
        apply : cm,
        themeable : true
      },
      /** Padding of the widget (bottom) */
      paddingBottom : {
        check : m,
        init : 0,
        apply : cm,
        themeable : true
      },
      /** Padding of the widget (left) */
      paddingLeft : {
        check : m,
        init : 0,
        apply : cm,
        themeable : true
      },
      /**
       * The 'padding' property is a shorthand property for setting 'paddingTop',
       * 'paddingRight', 'paddingBottom' and 'paddingLeft' at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left respectively.
       * If there is only one value, it applies to all sides, if there are two or three,
       * the missing values are taken from the opposite side.
       */
      padding : {
        group : [t, br, Q, cO],
        mode : N,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        STYLING PROPERTIES
      ---------------------------------------------------------------------------
      */
      /**
       * The z-index property sets the stack order of an element. An element with
       * greater stack order is always in front of another element with lower stack order.
       */
      zIndex : {
        nullable : true,
        init : null,
        apply : G,
        event : Y,
        check : m,
        themeable : true
      },
      /**
       * The decorator property points to an object, which is responsible
       * for drawing the widget's decoration, e.g. border, background or shadow.
       *
       * This can be a decorator object or a string pointing to a decorator
       * defined in the decoration theme.
       */
      decorator : {
        nullable : true,
        init : null,
        apply : D,
        event : be,
        check : bU,
        themeable : true
      },
      /**
       * The decorator used to render the widget's outline/shadow. The decorator's
       * insets are interpreted as the amount of pixels the shadow extends the
       * widget's size.
       *
       * This can be a decorator object or a string pointing to a decorator
       * defined in the decoration theme.
       *
       * Note that shadows work only properly in top level widgets like menus, windows
       * or tooltips. If used in inner widgets the shadow may not be cut by the
       * parent widget.
       */
      shadow : {
        nullable : true,
        init : null,
        apply : bA,
        event : cw,
        check : bU,
        themeable : true
      },
      /**
       * The background color the rendered widget.
       */
      backgroundColor : {
        nullable : true,
        check : bR,
        apply : cA,
        event : bf,
        themeable : true
      },
      /**
       * The text color the rendered widget.
       */
      textColor : {
        nullable : true,
        check : bR,
        apply : F,
        event : q,
        themeable : true,
        inheritable : true
      },
      /**
       * The widget's font. The value is either a font name defined in the font
       * theme or an instance of {@link qx.bom.Font}.
       */
      font : {
        nullable : true,
        apply : T,
        check : bB,
        event : E,
        themeable : true,
        inheritable : true,
        dereference : true
      },
      /**
       * Mapping to native style property opacity.
       *
       * The uniform opacity setting to be applied across an entire object.
       * Behaves like the new CSS-3 Property.
       * Any values outside the range 0.0 (fully transparent) to 1.0
       * (fully opaque) will be clamped to this range.
       */
      opacity : {
        check : cL,
        apply : df,
        themeable : true,
        nullable : true,
        init : null
      },
      /**
       * Mapping to native style property cursor.
       *
       * The name of the cursor to show when the mouse pointer is over the widget.
       * This is any valid CSS2 cursor name defined by W3C.
       *
       * The following values are possible crossbrowser:
       * <ul><li>default</li>
       * <li>crosshair</li>
       * <li>pointer</li>
       * <li>move</li>
       * <li>n-resize</li>
       * <li>ne-resize</li>
       * <li>e-resize</li>
       * <li>se-resize</li>
       * <li>s-resize</li>
       * <li>sw-resize</li>
       * <li>w-resize</li>
       * <li>nw-resize</li>
       * <li>text</li>
       * <li>wait</li>
       * <li>help </li>
       * </ul>
       */
      cursor : {
        check : cR,
        apply : n,
        themeable : true,
        inheritable : true,
        nullable : true,
        init : null
      },
      /**
       * Sets the tooltip instance to use for this widget. If only the tooltip
       * text and icon have to be set its better to use the {@link #toolTipText}
       * and {@link #toolTipIcon} properties since they use a shared tooltip
       * instance.
       *
       * If this property is set the {@link #toolTipText} and {@link #toolTipIcon}
       * properties are ignored.
       */
      toolTip : {
        check : bn,
        nullable : true
      },
      /**
       * The text of the widget's tooltip. This text can contain HTML markup.
       * The text is displayed using a shared tooltip instance. If the tooltip
       * must be customized beyond the text and an icon {@link #toolTipIcon}, the
       * {@link #toolTip} property has to be used
       */
      toolTipText : {
        check : cR,
        nullable : true,
        event : co,
        apply : x
      },
      /**
      * The icon URI of the widget's tooltip. This icon is displayed using a shared
      * tooltip instance. If the tooltip must be customized beyond the tooltip text
      * {@link #toolTipText} and the icon, the {@link #toolTip} property has to be
      * used.
      */
      toolTipIcon : {
        check : cR,
        nullable : true,
        event : co
      },
      /**
       * Controls if a tooltip should shown or not.
       */
      blockToolTip : {
        check : f,
        init : false
      },
      /*
      ---------------------------------------------------------------------------
        MANAGEMENT PROPERTIES
      ---------------------------------------------------------------------------
      */
      /**
       * Controls the visibility. Valid values are:
       *
       * <ul>
       *   <li><b>visible</b>: Render the widget</li>
       *   <li><b>hidden</b>: Hide the widget but don't relayout the widget's parent.</li>
       *   <li><b>excluded</b>: Hide the widget and relayout the parent as if the
       *     widget was not a child of its parent.</li>
       * </ul>
       */
      visibility : {
        check : [j, cX, cP],
        init : j,
        apply : cJ,
        event : cp
      },
      /**
       * Whether the widget is enabled. Disabled widgets are usually grayed out
       * and do not process user created events. While in the disabled state most
       * user input events are blocked. Only the {@link #mouseover} and
       * {@link #mouseout} events will be dispatched.
       */
      enabled : {
        init : true,
        check : f,
        inheritable : true,
        apply : bx,
        event : R
      },
      /**
       * Whether the widget is anonymous.
       *
       * Anonymous widgets are ignored in the event hierarchy. This is useful
       * for combined widgets where the internal structure do not have a custom
       * appearance with a different styling from the element around. This is
       * especially true for widgets like checkboxes or buttons where the text
       * or icon are handled synchronously for state changes to the outer widget.
       */
      anonymous : {
        init : false,
        check : f
      },
      /**
       * Defines the tab index of an widget. If widgets with tab indexes are part
       * of the current focus root these elements are sorted in first priority. Afterwards
       * the sorting continues by rendered position, zIndex and other criteria.
       *
       * Please note: The value must be between 1 and 32000.
       */
      tabIndex : {
        check : m,
        nullable : true,
        apply : bk
      },
      /**
       * Whether the widget is focusable e.g. rendering a focus border and visualize
       * as active element.
       *
       * See also {@link #isTabable} which allows runtime checks for
       * <code>isChecked</code> or other stuff to test whether the widget is
       * reachable via the TAB key.
       */
      focusable : {
        check : f,
        init : false,
        apply : cy
      },
      /**
       * If this property is enabled, the widget and all of its child widgets
       * will never get focused. The focus keeps at the currently
       * focused widget.
       *
       * This only works for widgets which are not {@link #focusable}.
       *
       * This is mainly useful for widget authors. Please use with caution!
       */
      keepFocus : {
        check : f,
        init : false,
        apply : bp
      },
      /**
       * If this property if enabled, the widget and all of its child widgets
       * will never get activated. The activation keeps at the currently
       * activated widget.
       *
       * This is mainly useful for widget authors. Please use with caution!
       */
      keepActive : {
        check : f,
        init : false,
        apply : cM
      },
      /** Whether the widget acts as a source for drag&drop operations */
      draggable : {
        check : f,
        init : false,
        apply : o
      },
      /** Whether the widget acts as a target for drag&drop operations */
      droppable : {
        check : f,
        init : false,
        apply : cd
      },
      /**
       * Whether the widget contains content which may be selected by the user.
       *
       * If the value set to <code>true</code> the native browser selection can
       * be used for text selection. But it is normally useful for
       * forms fields, longer texts/documents, editors, etc.
       */
      selectable : {
        check : f,
        init : false,
        event : u,
        apply : bw
      },
      /**
       * Whether to show a context menu and which one
       */
      contextMenu : {
        check : C,
        apply : I,
        nullable : true,
        event : s
      },
      /**
       * Whether the native context menu should be enabled for this widget. To
       * globally enable the native context menu set the {@link #nativeContextMenu}
       * property of the root widget ({@link qx.ui.root.Abstract}) to
       * <code>true</code>.
       */
      nativeContextMenu : {
        check : f,
        init : false,
        themeable : true,
        event : P,
        apply : cE
      },
      /**
       * The appearance ID. This ID is used to identify the appearance theme
       * entry to use for this widget. This controls the styling of the element.
       */
      appearance : {
        check : cR,
        init : bj,
        apply : dh,
        event : O
      }
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Whether the widget should print out hints and debug messages */
      DEBUG : false,
      /**
       * Returns the widget, which contains the given DOM element.
       *
       * @param element {Element} The DOM element to search the widget for.
       * @param considerAnonymousState {Boolean?false} If true, anonymous widget
       *   will not be returned.
       * @return {qx.ui.core.Widget} The widget containing the element.
       */
      getWidgetByElement : function(dk, dl){

        while(dk){

          var dm = dk.$$widget;
          // dereference "weak" reference to the widget.
          if(dm != null){

            var dn = qx.core.ObjectRegistry.fromHashCode(dm);
            // check for anonymous widgets
            if(!dl || !dn.getAnonymous()){

              return dn;
            };
          };
          // Fix for FF, which occasionally breaks (BUG#3525)
          try{

            dk = dk.parentNode;
          } catch(e) {

            return null;
          };
        };
        return null;
      },
      /**
       * Whether the "parent" widget contains the "child" widget.
       *
       * @param parent {qx.ui.core.Widget} The parent widget
       * @param child {qx.ui.core.Widget} The child widget
       * @return {Boolean} Whether one of the "child"'s parents is "parent"
       */
      contains : function(parent, dp){

        while(dp){

          if(parent == dp){

            return true;
          };
          dp = dp.getLayoutParent();
        };
        return false;
      },
      /** {Map} Contains all pooled decorators for reuse */
      __decoratorPool : new qx.ui.core.DecoratorFactory(),
      /** {Map} Contains all pooled shadows for reuse */
      __shadowPool : new qx.ui.core.DecoratorFactory()
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __containerElement : null,
      __contentElement : null,
      __decoratorElement : null,
      __shadowElement : null,
      __protectorElement : null,
      __initialAppearanceApplied : null,
      __toolTipTextListenerId : null,
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      /**
       * {qx.ui.layout.Abstract} The connected layout manager
       */
      __layoutManager : null,
      // overridden
      _getLayout : function(){

        return this.__layoutManager;
      },
      /**
       * Set a layout manager for the widget. A a layout manager can only be connected
       * with one widget. Reset the connection with a previous widget first, if you
       * like to use it in another widget instead.
       *
       * @param layout {qx.ui.layout.Abstract} The new layout or
       *     <code>null</code> to reset the layout.
       * @return {void}
       */
      _setLayout : function(dq){

        if(qx.core.Environment.get(d)){

          if(dq){

            this.assertInstance(dq, qx.ui.layout.Abstract);
          };
        };
        if(this.__layoutManager){

          this.__layoutManager.connectToWidget(null);
        };
        if(dq){

          dq.connectToWidget(this);
        };
        this.__layoutManager = dq;
        qx.ui.core.queue.Layout.add(this);
      },
      // overridden
      setLayoutParent : function(parent){

        if(this.$$parent === parent){

          return;
        };
        var dr = this.getContainerElement();
        if(this.$$parent && !this.$$parent.$$disposed){

          this.$$parent.getContentElement().remove(dr);
        };
        this.$$parent = parent || null;
        if(parent && !parent.$$disposed){

          this.$$parent.getContentElement().add(dr);
        };
        // Update inheritable properties
        this.$$refreshInheritables();
        // Update visibility cache
        qx.ui.core.queue.Visibility.add(this);
      },
      /** {Boolean} Whether insets have changed and must be updated */
      _updateInsets : null,
      /**
       * Detects whether the move from decorator <code>a</code> to <code>b</code>
       * results into modified insets.
       *
       * @param a {Decorator} Old decorator or <code>null</code>
       * @param b {Decorator} New decorator or <code>null</code>
       * @return {Boolean} Whether the insets have been modified
       */
      __checkInsetsModified : function(a, b){

        if(a == b){

          return false;
        };
        if(a == null || b == null){

          return true;
        };
        var ds = qx.theme.manager.Decoration.getInstance();
        var du = ds.resolve(a).getInsets();
        var dt = ds.resolve(b).getInsets();
        if(du.top != dt.top || du.right != dt.right || du.bottom != dt.bottom || du.left != dt.left){

          return true;
        };
        return false;
      },
      // overridden
      renderLayout : function(dv, top, dw, dx){

        var dG = qx.ui.core.LayoutItem.prototype.renderLayout.call(this, dv, top, dw, dx);
        // Directly return if superclass has detected that no
        // changes needs to be applied
        if(!dG){

          return null;
        };
        if(qx.lang.Object.isEmpty(dG) && !this._updateInsets){

          return null;
        };
        var dz = this.getContainerElement();
        var content = this.getContentElement();
        var dD = dG.size || this._updateInsets;
        var dH = c;
        var dE = {
        };
        // Move container to new position
        if(dG.position){

          dE.left = dv + dH;
          dE.top = top + dH;
        };
        // Update container size
        if(dG.size){

          dE.width = dw + dH;
          dE.height = dx + dH;
        };
        if(dG.position || dG.size){

          dz.setStyles(dE);
        };
        if(dD || dG.local || dG.margin){

          var dy = this.getInsets();
          var innerWidth = dw - dy.left - dy.right;
          var innerHeight = dx - dy.top - dy.bottom;
          // ensure that the width and height never get negative
          innerWidth = innerWidth < 0 ? 0 : innerWidth;
          innerHeight = innerHeight < 0 ? 0 : innerHeight;
        };
        var dB = {
        };
        if(this._updateInsets){

          dB.left = dy.left + dH;
          dB.top = dy.top + dH;
        };
        if(dD){

          dB.width = innerWidth + dH;
          dB.height = innerHeight + dH;
        };
        if(dD || this._updateInsets){

          content.setStyles(dB);
        };
        if(dG.size){

          var dF = this.__protectorElement;
          if(dF){

            dF.setStyles({
              width : dw + c,
              height : dx + c
            });
          };
        };
        if(dG.size || this._updateInsets){

          if(this.__decoratorElement){

            this.__decoratorElement.resize(dw, dx);
          };
        };
        if(dG.size){

          if(this.__shadowElement){

            var dy = this.__shadowElement.getInsets();
            var dC = dw + dy.left + dy.right;
            var dA = dx + dy.top + dy.bottom;
            this.__shadowElement.resize(dC, dA);
            // Move out of container by top/left inset
            this.__shadowElement.setStyles({
              left : -dy.left + c,
              top : -dy.top + c
            }, true);
          };
        };
        if(dD || dG.local || dG.margin){

          if(this.__layoutManager && this.hasLayoutChildren()){

            this.__layoutManager.renderLayout(innerWidth, innerHeight);
          } else if(this.hasLayoutChildren()){

            throw new Error(p + this._findTopControl() + cx);
          };
        };
        // Fire events
        if(dG.position && this.hasListener(bL)){

          this.fireDataEvent(bL, this.getBounds());
        };
        if(dG.size && this.hasListener(bX)){

          this.fireDataEvent(bX, this.getBounds());
        };
        // Cleanup flags
        delete this._updateInsets;
        return dG;
      },
      /*
      ---------------------------------------------------------------------------
        SEPARATOR SUPPORT
      ---------------------------------------------------------------------------
      */
      __separators : null,
      // overridden
      clearSeparators : function(){

        var dJ = this.__separators;
        if(!dJ){

          return;
        };
        var dK = qx.ui.core.Widget.__decoratorPool;
        var content = this.getContentElement();
        var dI;
        for(var i = 0,l = dJ.length;i < l;i++){

          dI = dJ[i];
          dK.poolDecorator(dI);
          content.remove(dI);
        };
        // Clear registry
        dJ.length = 0;
      },
      // overridden
      renderSeparator : function(dL, dM){

        // Insert
        var dO = qx.ui.core.Widget.__decoratorPool.getDecoratorElement(dL);
        this.getContentElement().add(dO);
        // Resize
        dO.resize(dM.width, dM.height);
        // Move
        var dN = dO.getDomElement();
        // use the DOM element because the cache of the qx.html.Element could be
        // wrong due to changes made by the decorators which work on the DOM element too
        if(dN){

          dN.style.top = dM.top + c;
          dN.style.left = dM.left + c;
        } else {

          dO.setStyles({
            left : dM.left + c,
            top : dM.top + c
          });
        };
        // Remember element
        if(!this.__separators){

          this.__separators = [dO];
        } else {

          this.__separators.push(dO);
        };
      },
      /*
      ---------------------------------------------------------------------------
        SIZE HINTS
      ---------------------------------------------------------------------------
      */
      // overridden
      _computeSizeHint : function(){

        // Start with the user defined values
        var dV = this.getWidth();
        var dU = this.getMinWidth();
        var dQ = this.getMaxWidth();
        var dT = this.getHeight();
        var dR = this.getMinHeight();
        var dS = this.getMaxHeight();
        if(qx.core.Environment.get(d)){

          if(dU !== null && dQ !== null){

            this.assert(dU <= dQ, bs);
          };
          if(dR !== null && dS !== null){

            this.assert(dR <= dS, V);
          };
        };
        // Ask content
        var dW = this._getContentHint();
        var dP = this.getInsets();
        var dY = dP.left + dP.right;
        var dX = dP.top + dP.bottom;
        if(dV == null){

          dV = dW.width + dY;
        };
        if(dT == null){

          dT = dW.height + dX;
        };
        if(dU == null){

          dU = dY;
          if(dW.minWidth != null){

            dU += dW.minWidth;
            // do not apply bigger min width than max width [BUG #5008]
            if(dU > dQ && dQ != null){

              dU = dQ;
            };
          };
        };
        if(dR == null){

          dR = dX;
          if(dW.minHeight != null){

            dR += dW.minHeight;
            // do not apply bigger min height than max height [BUG #5008]
            if(dR > dS && dS != null){

              dR = dS;
            };
          };
        };
        if(dQ == null){

          if(dW.maxWidth == null){

            dQ = Infinity;
          } else {

            dQ = dW.maxWidth + dY;
            // do not apply bigger min width than max width [BUG #5008]
            if(dQ < dU && dU != null){

              dQ = dU;
            };
          };
        };
        if(dS == null){

          if(dW.maxHeight == null){

            dS = Infinity;
          } else {

            dS = dW.maxHeight + dX;
            // do not apply bigger min width than max width [BUG #5008]
            if(dS < dR && dR != null){

              dS = dR;
            };
          };
        };
        // Build size hint and return
        return {
          width : dV,
          minWidth : dU,
          maxWidth : dQ,
          height : dT,
          minHeight : dR,
          maxHeight : dS
        };
      },
      // overridden
      invalidateLayoutCache : function(){

        qx.ui.core.LayoutItem.prototype.invalidateLayoutCache.call(this);
        if(this.__layoutManager){

          this.__layoutManager.invalidateLayoutCache();
        };
      },
      /**
       * Returns the recommended/natural dimensions of the widget's content.
       *
       * For labels and images this may be their natural size when defined without
       * any dimensions. For containers this may be the recommended size of the
       * underlying layout manager.
       *
       * Developer note: This can be overwritten by the derived classes to allow
       * a custom handling here.
       *
       * @return {Map}
       */
      _getContentHint : function(){

        var eb = this.__layoutManager;
        if(eb){

          if(this.hasLayoutChildren()){

            var ec = eb.getSizeHint();
            if(qx.core.Environment.get(d)){

              var ea = bg + this.toString() + dg;
              this.assertInteger(ec.width, cg + ea);
              this.assertInteger(ec.height, bc + ea);
            };
            return ec;
          } else {

            return {
              width : 0,
              height : 0
            };
          };
        } else {

          return {
            width : 100,
            height : 50
          };
        };
      },
      // overridden
      _getHeightForWidth : function(ed){

        // Prepare insets
        var eh = this.getInsets();
        var ek = eh.left + eh.right;
        var ej = eh.top + eh.bottom;
        // Compute content width
        var ei = ed - ek;
        // Compute height
        var ef = this._getLayout();
        if(ef && ef.hasHeightForWidth()){

          var ee = ef.getHeightForWidth(ed);
        } else {

          ee = this._getContentHeightForWidth(ei);
        };
        // Computed box height
        var eg = ee + ej;
        return eg;
      },
      /**
       * Returns the computed height for the given width.
       *
       * @abstract
       * @param width {Integer} Incoming width (as limitation)
       * @return {Integer} Computed height while respecting the given width.
       */
      _getContentHeightForWidth : function(em){

        throw new Error(S);
      },
      /*
      ---------------------------------------------------------------------------
        INSET CALCULATION SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Return the insets of the widget's inner element relative to its
       * container element. The inset is the sum of the padding and border width.
       *
       * @return {Map} Contains the keys <code>top</code>, <code>right</code>,
       *   <code>bottom</code> and <code>left</code>. All values are integers.
       */
      getInsets : function(){

        var top = this.getPaddingTop();
        var eo = this.getPaddingRight();
        var eq = this.getPaddingBottom();
        var ep = this.getPaddingLeft();
        if(this.__decoratorElement){

          var en = this.__decoratorElement.getInsets();
          if(qx.core.Environment.get(d)){

            this.assertNumber(en.top, w + en.top);
            this.assertNumber(en.right, B + en.right);
            this.assertNumber(en.bottom, bl + en.bottom);
            this.assertNumber(en.left, bC + en.left);
          };
          top += en.top;
          eo += en.right;
          eq += en.bottom;
          ep += en.left;
        };
        return {
          "top" : top,
          "right" : eo,
          "bottom" : eq,
          "left" : ep
        };
      },
      /*
      ---------------------------------------------------------------------------
        COMPUTED LAYOUT SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the widget's computed inner size as available
       * through the layout process.
       *
       * This function is guaranteed to return a correct value
       * during a {@link #resize} or {@link #move} event dispatch.
       *
       * @return {Map} The widget inner dimension in pixel (if the layout is
       *    valid). Contains the keys <code>width</code> and <code>height</code>.
       */
      getInnerSize : function(){

        var es = this.getBounds();
        if(!es){

          return null;
        };
        // Return map data
        var er = this.getInsets();
        return {
          width : es.width - er.left - er.right,
          height : es.height - er.top - er.bottom
        };
      },
      /*
      ---------------------------------------------------------------------------
        VISIBILITY SUPPORT: USER API
      ---------------------------------------------------------------------------
      */
      /**
       * Make this widget visible.
       *
       * @return {void}
       */
      show : function(){

        this.setVisibility(j);
      },
      /**
       * Hide this widget.
       *
       * @return {void}
       */
      hide : function(){

        this.setVisibility(cX);
      },
      /**
       * Hide this widget and exclude it from the underlying layout.
       *
       * @return {void}
       */
      exclude : function(){

        this.setVisibility(cP);
      },
      /**
       * Whether the widget is locally visible.
       *
       * Note: This method does not respect the hierarchy.
       *
       * @return {Boolean} Returns <code>true</code> when the widget is visible
       */
      isVisible : function(){

        return this.getVisibility() === j;
      },
      /**
       * Whether the widget is locally hidden.
       *
       * Note: This method does not respect the hierarchy.
       *
       * @return {Boolean} Returns <code>true</code> when the widget is hidden
       */
      isHidden : function(){

        return this.getVisibility() !== j;
      },
      /**
       * Whether the widget is locally excluded.
       *
       * Note: This method does not respect the hierarchy.
       *
       * @return {Boolean} Returns <code>true</code> when the widget is excluded
       */
      isExcluded : function(){

        return this.getVisibility() === cP;
      },
      /**
       * Detects if the widget and all its parents are visible.
       *
       * WARNING: Please use this method with caution becuase it flushes the
       * internal queues which might be an expensive operation.
       *
       * @return {Boolean} true, if the widget is currently on the screen
       */
      isSeeable : function(){

        // Flush the queues because to detect if the widget ins visible, the
        // queues need to be flushed (see bug #5254)
        qx.ui.core.queue.Manager.flush();
        // if the element is already rendered, a check for the offsetWidth is enough
        var et = this.getContainerElement().getDomElement();
        if(et){

          // will also be 0 if the parents are not visible
          return et.offsetWidth > 0;
        };
        // if no element is available, it can not be visible
        return false;
      },
      /*
      ---------------------------------------------------------------------------
        CREATION OF HTML ELEMENTS
      ---------------------------------------------------------------------------
      */
      /**
       * Create the widget's container HTML element.
       *
       * @return {qx.html.Element} The container HTML element
       */
      _createContainerElement : function(){

        var ev = {
          "$$widget" : this.toHashCode()
        };
        if(qx.core.Environment.get(d)){

          ev.qxType = H;
          ev.qxClass = this.classname;
        };
        var eu = {
          zIndex : 0,
          position : ct
        };
        return new qx.html.Element(bG, eu, ev);
      },
      /**
       * Create the widget's content HTML element.
       *
       * @return {qx.html.Element} The content HTML element
       */
      __createContentElement : function(){

        var ew = this._createContentElement();
        if(qx.core.Environment.get(d)){

          ew.setAttribute(ca, cC);
        };
        ew.setStyles({
          "position" : ct,
          "zIndex" : 10
        });
        return ew;
      },
      /**
       * Creates the content element. The style properties
       * position and zIndex are modified from the Widget
       * core.
       *
       * This function may be overridden to customize a class
       * content.
       */
      _createContentElement : function(){

        return new qx.html.Element(bG, {
          overflowX : cX,
          overflowY : cX
        });
      },
      /**
       * Returns the element wrapper of the widget's container element.
       * This method exposes widget internal and must be used with caution!
       *
       * @return {qx.html.Element} The widget's container element
       */
      getContainerElement : function(){

        return this.__containerElement;
      },
      /**
       * Returns the element wrapper of the widget's content element.
       * This method exposes widget internal and must be used with caution!
       *
       * @return {qx.html.Element} The widget's content element
       */
      getContentElement : function(){

        return this.__contentElement;
      },
      /**
       * Returns the element wrapper of the widget's decorator element.
       * This method exposes widget internals and must be used with caution!
       *
       * @return {qx.html.Decorator|null} The widget's decorator element (may be null)
       */
      getDecoratorElement : function(){

        return this.__decoratorElement || null;
      },
      /**
       * Returns the element wrapper of the widget's shadow element.
       * This method exposes widget internals and must be used with caution!
       *
       * @return {qx.html.Decorator|null} The widget's shadow element (may be null)
       */
      getShadowElement : function(){

        return this.__shadowElement || null;
      },
      /*
      ---------------------------------------------------------------------------
        CHILDREN HANDLING
      ---------------------------------------------------------------------------
      */
      /** {qx.ui.core.LayoutItem[]} List of all child widgets */
      __widgetChildren : null,
      /**
       * Returns all children, which are layout relevant. This excludes all widgets,
       * which have a {@link qx.ui.core.Widget#visibility} value of <code>exclude</code>.
       *
       * @internal
       * @return {qx.ui.core.Widget[]} All layout relevant children.
       */
      getLayoutChildren : function(){

        var ey = this.__widgetChildren;
        if(!ey){

          return this.__emptyChildren;
        };
        var ez;
        for(var i = 0,l = ey.length;i < l;i++){

          var ex = ey[i];
          if(ex.hasUserBounds() || ex.isExcluded()){

            if(ez == null){

              ez = ey.concat();
            };
            qx.lang.Array.remove(ez, ex);
          };
        };
        return ez || ey;
      },
      /**
       * Marks the layout of this widget as invalid and triggers a layout update.
       * This is a shortcut for <code>qx.ui.core.queue.Layout.add(this);</code>.
       */
      scheduleLayoutUpdate : function(){

        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Resets the cache for children which should be laid out.
       */
      invalidateLayoutChildren : function(){

        var eA = this.__layoutManager;
        if(eA){

          eA.invalidateChildrenCache();
        };
        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Returns whether the layout has children, which are layout relevant. This
       * excludes all widgets, which have a {@link qx.ui.core.Widget#visibility}
       * value of <code>exclude</code>.
       *
       * @return {Boolean} Whether the layout has layout relevant children
       */
      hasLayoutChildren : function(){

        var eB = this.__widgetChildren;
        if(!eB){

          return false;
        };
        var eC;
        for(var i = 0,l = eB.length;i < l;i++){

          eC = eB[i];
          if(!eC.hasUserBounds() && !eC.isExcluded()){

            return true;
          };
        };
        return false;
      },
      /**
       * Returns the widget which contains the children and
       * is relevant for laying them out. This is from the user point of
       * view and may not be identical to the technical structure.
       *
       * @return {qx.ui.core.Widget} Widget which contains the children.
       */
      getChildrenContainer : function(){

        return this;
      },
      /**
       * {Array} Placeholder for children list in empty widgets.
       *     Mainly to keep instance number low.
       *
       * @lint ignoreReferenceField(__emptyChildren)
       */
      __emptyChildren : [],
      /**
       * Returns the children list
       *
       * @return {LayoutItem[]} The children array (Arrays are
       *   reference types, so please do not modify it in-place).
       */
      _getChildren : function(){

        return this.__widgetChildren || this.__emptyChildren;
      },
      /**
       * Returns the index position of the given widget if it is
       * a child widget. Otherwise it returns <code>-1</code>.
       *
       * @param child {Widget} the widget to query for
       * @return {Integer} The index position or <code>-1</code> when
       *   the given widget is no child of this layout.
       */
      _indexOf : function(eD){

        var eE = this.__widgetChildren;
        if(!eE){

          return -1;
        };
        return eE.indexOf(eD);
      },
      /**
       * Whether the widget contains children.
       *
       * @return {Boolean} Returns <code>true</code> when the widget has children.
       */
      _hasChildren : function(){

        var eF = this.__widgetChildren;
        return eF != null && (!!eF[0]);
      },
      /**
       * Recursively adds all children to the given queue
       *
       * @param queue {Array} The queue to add widgets to
       */
      addChildrenToQueue : function(eG){

        var eH = this.__widgetChildren;
        if(!eH){

          return;
        };
        var eI;
        for(var i = 0,l = eH.length;i < l;i++){

          eI = eH[i];
          eG.push(eI);
          eI.addChildrenToQueue(eG);
        };
      },
      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout manager
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {LayoutItem} the widget to add.
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      _add : function(eJ, eK){

        if(qx.core.Environment.get(d)){

          this.assertInstance(eJ, qx.ui.core.LayoutItem.constructor, ck);
        };
        // When moving in the same widget, remove widget first
        if(eJ.getLayoutParent() == this){

          qx.lang.Array.remove(this.__widgetChildren, eJ);
        };
        if(this.__widgetChildren){

          this.__widgetChildren.push(eJ);
        } else {

          this.__widgetChildren = [eJ];
        };
        this.__addHelper(eJ, eK);
      },
      /**
       * Add a child widget at the specified index
       *
       * @param child {LayoutItem} widget to add
       * @param index {Integer} Index, at which the widget will be inserted
       * @param options {Map?null} Optional layout data for widget.
       */
      _addAt : function(eL, eM, eN){

        if(!this.__widgetChildren){

          this.__widgetChildren = [];
        };
        // When moving in the same widget, remove widget first
        if(eL.getLayoutParent() == this){

          qx.lang.Array.remove(this.__widgetChildren, eL);
        };
        var eO = this.__widgetChildren[eM];
        if(eO === eL){

          eL.setLayoutProperties(eN);
        };
        if(eO){

          qx.lang.Array.insertBefore(this.__widgetChildren, eL, eO);
        } else {

          this.__widgetChildren.push(eL);
        };
        this.__addHelper(eL, eN);
      },
      /**
       * Add a widget before another already inserted widget
       *
       * @param child {LayoutItem} widget to add
       * @param before {LayoutItem} widget before the new widget will be inserted.
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      _addBefore : function(eP, eQ, eR){

        if(qx.core.Environment.get(d)){

          this.assertInArray(eQ, this._getChildren(), cK);
        };
        if(eP == eQ){

          return;
        };
        if(!this.__widgetChildren){

          this.__widgetChildren = [];
        };
        // When moving in the same widget, remove widget first
        if(eP.getLayoutParent() == this){

          qx.lang.Array.remove(this.__widgetChildren, eP);
        };
        qx.lang.Array.insertBefore(this.__widgetChildren, eP, eQ);
        this.__addHelper(eP, eR);
      },
      /**
       * Add a widget after another already inserted widget
       *
       * @param child {LayoutItem} widget to add
       * @param after {LayoutItem} widget, after which the new widget will
       *   be inserted
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      _addAfter : function(eS, eT, eU){

        if(qx.core.Environment.get(d)){

          this.assertInArray(eT, this._getChildren(), da);
        };
        if(eS == eT){

          return;
        };
        if(!this.__widgetChildren){

          this.__widgetChildren = [];
        };
        // When moving in the same widget, remove widget first
        if(eS.getLayoutParent() == this){

          qx.lang.Array.remove(this.__widgetChildren, eS);
        };
        qx.lang.Array.insertAfter(this.__widgetChildren, eS, eT);
        this.__addHelper(eS, eU);
      },
      /**
       * Remove the given child widget.
       *
       * @param child {LayoutItem} the widget to remove
       * @return {void}
       */
      _remove : function(eV){

        if(!this.__widgetChildren){

          throw new Error(bT);
        };
        qx.lang.Array.remove(this.__widgetChildren, eV);
        this.__removeHelper(eV);
      },
      /**
       * Remove the widget at the specified index.
       *
       * @param index {Integer} Index of the widget to remove.
       * @return {qx.ui.core.LayoutItem} The removed item.
       */
      _removeAt : function(eW){

        if(!this.__widgetChildren){

          throw new Error(bT);
        };
        var eX = this.__widgetChildren[eW];
        qx.lang.Array.removeAt(this.__widgetChildren, eW);
        this.__removeHelper(eX);
        return eX;
      },
      /**
       * Remove all children.
       *
       * @return {Array} An array containing the removed children.
       */
      _removeAll : function(){

        if(!this.__widgetChildren){

          return [];
        };
        // Working on a copy to make it possible to clear the
        // internal array before calling setLayoutParent()
        var eY = this.__widgetChildren.concat();
        this.__widgetChildren.length = 0;
        for(var i = eY.length - 1;i >= 0;i--){

          this.__removeHelper(eY[i]);
        };
        qx.ui.core.queue.Layout.add(this);
        return eY;
      },
      /*
      ---------------------------------------------------------------------------
        CHILDREN HANDLING - TEMPLATE METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * This method gets called each time after a child widget was added and can
       * be overridden to get notified about child adds.
       *
       * @signature function(child)
       * @param child {qx.ui.core.LayoutItem} The added child.
       */
      _afterAddChild : null,
      /**
       * This method gets called each time after a child widget was removed and
       * can be overridden to get notified about child removes.
       *
       * @signature function(child)
       * @param child {qx.ui.core.LayoutItem} The removed child.
       */
      _afterRemoveChild : null,
      /*
      ---------------------------------------------------------------------------
        CHILDREN HANDLING - IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      /**
       * Convenience function to add a child widget. It will insert the child to
       * the parent widget and schedule a layout update.
       *
       * @param child {LayoutItem} The child to add.
       * @param options {Map|null} Optional layout data for the widget.
       */
      __addHelper : function(fa, fb){

        if(qx.core.Environment.get(d)){

          this.assertInstance(fa, qx.ui.core.LayoutItem, y + fa);
          this.assertNotIdentical(fa, this, by + fa);
          if(fb != null){

            this.assertType(fb, bN, bz + fb);
          };
        };
        // Remove from old parent
        var parent = fa.getLayoutParent();
        if(parent && parent != this){

          parent._remove(fa);
        };
        // Remember parent
        fa.setLayoutParent(this);
        // Import options: This call will
        //  - clear the layout's children cache as well and
        //  - add its parent (this widget) to the layout queue
        if(fb){

          fa.setLayoutProperties(fb);
        } else {

          this.updateLayoutProperties();
        };
        // call the template method
        if(this._afterAddChild){

          this._afterAddChild(fa);
        };
      },
      /**
       * Convenience function to remove a child widget. It will remove it
       * from the parent widget and schedule a layout update.
       *
       * @param child {LayoutItem} The child to remove.
       */
      __removeHelper : function(fc){

        if(qx.core.Environment.get(d)){

          this.assertNotUndefined(fc);
        };
        if(fc.getLayoutParent() !== this){

          throw new Error(cj + fc + bh);
        };
        // Clear parent connection
        fc.setLayoutParent(null);
        // clear the layout's children cache
        if(this.__layoutManager){

          this.__layoutManager.invalidateChildrenCache();
        };
        // Add to layout queue
        qx.ui.core.queue.Layout.add(this);
        // call the template method
        if(this._afterRemoveChild){

          this._afterRemoveChild(fc);
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */
      /**
       * Enables mouse event capturing. All mouse events will dispatched on this
       * widget until capturing is disabled using {@link #releaseCapture} or a
       * mouse button is clicked. If the widgets becomes the capturing widget the
       * {@link #capture} event is fired. Once it looses capture mode the
       * {@link #losecapture} event is fired.
       *
       * @param containerCapture {Boolean?true} If true all events originating in
       *   the container are captured. If false events originating in the container
       *   are not captured.
       */
      capture : function(fd){

        this.getContainerElement().capture(fd);
      },
      /**
       * Disables mouse capture mode enabled by {@link #capture}.
       */
      releaseCapture : function(){

        this.getContainerElement().releaseCapture();
      },
      /*
      ---------------------------------------------------------------------------
        PADDING SUPPORT
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPadding : function(fe, ff, name){

        this._updateInsets = true;
        qx.ui.core.queue.Layout.add(this);
      },
      /*
      ---------------------------------------------------------------------------
        DECORATION SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Creates the protector element used to block mouse events
       * from the decoration.
       *
       * This is needed because of the way the decorations work. Most
       * of them tend to replace the underlying HTML of a widget
       * dynamically on mouse over. But this also means that the
       * native mouse out is not fired on the new content with which
       * the old content is replaced. This is a fact given through
       * the native behavior of the browser.
       *
       * The protector is placed between the content and the decoration.
       *
       * @return {qx.html.Element} The protector element
       */
      _createProtectorElement : function(){

        if(this.__protectorElement){

          return;
        };
        var fg = this.__protectorElement = new qx.html.Element;
        if(qx.core.Environment.get(d)){

          fg.setAttribute(ca, cf);
        };
        fg.setStyles({
          position : ct,
          top : 0,
          left : 0,
          zIndex : 7
        });
        var fh = this.getBounds();
        if(fh){

          this.__protectorElement.setStyles({
            width : fh.width + c,
            height : fh.height + c
          });
        };
        // IE needs some extra love here to convince it to block events.
        if((qx.core.Environment.get(cU) == cW)){

          fg.setStyles({
            backgroundImage : de + qx.util.ResourceManager.getInstance().toUri(bJ) + dj,
            backgroundRepeat : cI
          });
        };
        this.getContainerElement().add(fg);
      },
      // property apply
      _applyDecorator : function(fi, fj){

        if(qx.core.Environment.get(d)){

          if(fi && typeof fi === bN){

            if(qx.ui.core.Widget.DEBUG){

              this.warn(cD + K + bq + fi);
            };
          };
        };
        var fm = qx.ui.core.Widget.__decoratorPool;
        var fk = this.getContainerElement();
        // Create protector
        // if the browser supports pointer events the decorator will never receive
        // any mouse events so the protector is not required.
        if(!this.__protectorElement && !qx.core.Environment.get(cz)){

          this._createProtectorElement();
        };
        // Process old value
        if(fj){

          fk.remove(this.__decoratorElement);
          fm.poolDecorator(this.__decoratorElement);
        };
        // Process new value
        if(fi){

          var fl = this.__decoratorElement = fm.getDecoratorElement(fi);
          fl.setStyle(bV, 5);
          // Add to container
          fk.add(fl);
        } else {

          delete this.__decoratorElement;
        };
        // Apply background color
        this._applyBackgroundColor(this.getBackgroundColor());
        // Apply change
        if(this.__checkInsetsModified(fj, fi)){

          // We have changes to the insets, which means we
          // delegate the resize to the layout system.
          this._updateInsets = true;
          qx.ui.core.queue.Layout.add(this);
        } else if(fi){

          // When bounds are existing directly resize the decorator
          // otherwise wait for initial resize through layouter
          var fn = this.getBounds();
          if(fn){

            fl.resize(fn.width, fn.height);
            // Update protector element
            this.__protectorElement && this.__protectorElement.setStyles({
              width : fn.width + c,
              height : fn.height + c
            });
          };
        };
      },
      // property apply
      _applyShadow : function(fo, fp){

        var fw = qx.ui.core.Widget.__shadowPool;
        var fr = this.getContainerElement();
        // Clear old value
        if(fp){

          fr.remove(this.__shadowElement);
          fw.poolDecorator(this.__shadowElement);
        };
        // Apply new value
        if(fo){

          var ft = this.__shadowElement = fw.getDecoratorElement(fo);
          // Add to container
          fr.add(ft);
          var fv = ft.getInsets();
          // Directly update for size when possible
          var fu = this.getBounds();
          if(fu){

            var fs = fu.width + fv.left + fv.right;
            var fq = fu.height + fv.top + fv.bottom;
            ft.resize(fs, fq);
            // Move out of container by top/left inset
            ft.setStyles({
              left : -fv.left + c,
              top : -fv.top + c
            }, true);
          };
          ft.tint(null);
        } else {

          delete this.__shadowElement;
        };
      },
      /*
      ---------------------------------------------------------------------------
        OTHER PROPERTIES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyToolTipText : function(fx, fy){

        if(qx.core.Environment.get(bP)){

          if(this.__toolTipTextListenerId){

            return;
          };
          var fz = qx.locale.Manager.getInstance();
          this.__toolTipTextListenerId = fz.addListener(bt, function(){

            var fA = this.getToolTipText();
            if(fA && fA.translate){

              this.setToolTipText(fA.translate());
            };
          }, this);
        };
      },
      // property apply
      _applyTextColor : function(fB, fC){
      },
      // property apply
      _applyZIndex : function(fD, fE){

        this.getContainerElement().setStyle(bV, fD == null ? 0 : fD);
      },
      // property apply
      _applyVisibility : function(fF, fG){

        var fH = this.getContainerElement();
        if(fF === j){

          fH.show();
        } else {

          fH.hide();
        };
        // only force a layout update if visibility change from/to "exclude"
        var parent = this.$$parent;
        if(parent && (fG == null || fF == null || fG === cP || fF === cP)){

          parent.invalidateLayoutChildren();
        };
        // Update visibility cache
        qx.ui.core.queue.Visibility.add(this);
      },
      // property apply
      _applyOpacity : function(fI, fJ){

        this.getContainerElement().setStyle(bS, fI == 1 ? null : fI);
        // Fix for AlphaImageLoader - see Bug #1894 for details
        if((qx.core.Environment.get(cU) == cW) && qx.bom.element.Decoration.isAlphaImageLoaderEnabled()){

          // Do not apply this fix on images - see Bug #2748
          if(!qx.Class.isSubClassOf(this.getContentElement().constructor, qx.html.Image)){

            // 0.99 is necessary since 1.0 is ignored and not being applied
            var fK = (fI == 1 || fI == null) ? null : 0.99;
            this.getContentElement().setStyle(bS, fK);
          };
        };
      },
      // property apply
      _applyCursor : function(fL, fM){

        if(fL == null && !this.isSelectable()){

          fL = bQ;
        };
        // In Opera the cursor must be set directly.
        // http://bugzilla.qooxdoo.org/show_bug.cgi?id=1729
        this.getContainerElement().setStyle(U, fL, qx.core.Environment.get(cU) == bv);
      },
      // property apply
      _applyBackgroundColor : function(fN, fO){

        var fP = this.getBackgroundColor();
        var fR = this.getContainerElement();
        if(this.__decoratorElement){

          // Apply to decoration element
          this.__decoratorElement.tint(fP);
          fR.setStyle(bI, null);
        } else {

          // Add color to container
          var fQ = qx.theme.manager.Color.getInstance().resolve(fP);
          fR.setStyle(bI, fQ);
        };
      },
      // property apply
      _applyFont : function(fS, fT){
      },
      /*
      ---------------------------------------------------------------------------
        STATE HANDLING
      ---------------------------------------------------------------------------
      */
      /** {Map} The current widget states */
      __states : null,
      /** {Boolean} Whether the widget has state changes which are not yet queued */
      $$stateChanges : null,
      /** {Map} Can be overridden to forward states to the child controls. */
      _forwardStates : null,
      /**
       * Returns whether a state is set.
       *
       * @param state {String} the state to check.
       * @return {Boolean} whether the state is set.
       */
      hasState : function(fU){

        var fV = this.__states;
        return !!fV && !!fV[fU];
      },
      /**
       * Sets a state.
       *
       * @param state {String} The state to add
       * @return {void}
       */
      addState : function(fW){

        // Dynamically create state map
        var fX = this.__states;
        if(!fX){

          fX = this.__states = {
          };
        };
        if(fX[fW]){

          return;
        };
        // Add state and queue
        this.__states[fW] = true;
        // Fast path for hovered state
        if(fW === cs){

          this.syncAppearance();
        } else if(!qx.ui.core.queue.Visibility.isVisible(this)){

          this.$$stateChanges = true;
        } else {

          qx.ui.core.queue.Appearance.add(this);
        };
        // Forward state change to child controls
        var forward = this._forwardStates;
        var gb = this.__childControls;
        if(forward && forward[fW] && gb){

          var fY;
          for(var ga in gb){

            fY = gb[ga];
            if(fY instanceof qx.ui.core.Widget){

              gb[ga].addState(fW);
            };
          };
        };
      },
      /**
       * Clears a state.
       *
       * @param state {String} the state to clear.
       * @return {void}
       */
      removeState : function(gc){

        // Check for existing state
        var gd = this.__states;
        if(!gd || !gd[gc]){

          return;
        };
        // Clear state and queue
        delete this.__states[gc];
        // Fast path for hovered state
        if(gc === cs){

          this.syncAppearance();
        } else if(!qx.ui.core.queue.Visibility.isVisible(this)){

          this.$$stateChanges = true;
        } else {

          qx.ui.core.queue.Appearance.add(this);
        };
        // Forward state change to child controls
        var forward = this._forwardStates;
        var gg = this.__childControls;
        if(forward && forward[gc] && gg){

          for(var gf in gg){

            var ge = gg[gf];
            if(ge instanceof qx.ui.core.Widget){

              ge.removeState(gc);
            };
          };
        };
      },
      /**
       * Replaces the first state with the second one.
       *
       * This method is ideal for state transitions e.g. normal => selected.
       *
       * @param old {String} Previous state
       * @param value {String} New state
       * @return {void}
       */
      replaceState : function(gh, gi){

        var gj = this.__states;
        if(!gj){

          gj = this.__states = {
          };
        };
        if(!gj[gi]){

          gj[gi] = true;
        };
        if(gj[gh]){

          delete gj[gh];
        };
        if(!qx.ui.core.queue.Visibility.isVisible(this)){

          this.$$stateChanges = true;
        } else {

          qx.ui.core.queue.Appearance.add(this);
        };
        // Forward state change to child controls
        var forward = this._forwardStates;
        var gm = this.__childControls;
        if(forward && forward[gi] && gm){

          for(var gl in gm){

            var gk = gm[gl];
            if(gk instanceof qx.ui.core.Widget){

              gk.replaceState(gh, gi);
            };
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        APPEARANCE SUPPORT
      ---------------------------------------------------------------------------
      */
      /** {String} The currently compiled selector to lookup the matching appearance */
      __appearanceSelector : null,
      /** {Boolean} Whether the selectors needs to be recomputed before updating appearance */
      __updateSelector : null,
      /**
       * Renders the appearance using the current widget states.
       *
       * Used exclusively by {qx.ui.core.queue.Appearance}.
       */
      syncAppearance : function(){

        var gr = this.__states;
        var gq = this.__appearanceSelector;
        var gs = qx.theme.manager.Appearance.getInstance();
        // Cache deep accessor
        var go = qx.core.Property.$$method.setThemed;
        var gw = qx.core.Property.$$method.resetThemed;
        // Check for requested selector update
        if(this.__updateSelector){

          // Clear flag
          delete this.__updateSelector;
          // Check if the selector was created previously
          if(gq){

            // Query old selector
            var gn = gs.styleFrom(gq, gr, null, this.getAppearance());
            // Clear current selector (to force recompute)
            gq = null;
          };
        };
        // Build selector
        if(!gq){

          var gp = this;
          var gv = [];
          do {

            gv.push(gp.$$subcontrol || gp.getAppearance());
          }while(gp = gp.$$subparent);
          // Combine parent control IDs, add top level appearance, filter result
          // to not include positioning information anymore (e.g. #3)
          gq = gv.reverse().join(M).replace(/#[0-9]+/g, J);
          this.__appearanceSelector = gq;
        };
        // Query current selector
        var gt = gs.styleFrom(gq, gr, null, this.getAppearance());
        if(gt){

          if(gn){

            for(var gu in gn){

              if(gt[gu] === undefined){

                this[gw[gu]]();
              };
            };
          };
          // Check property availability of new data
          if(qx.core.Environment.get(d)){

            for(var gu in gt){

              if(!this[go[gu]]){

                throw new Error(this.classname + z + gu + cN + gq);
              };
            };
          };
          // Apply new data
          for(var gu in gt){

            gt[gu] === undefined ? this[gw[gu]]() : this[go[gu]](gt[gu]);
          };
        } else if(gn){

          // Clear old data
          for(var gu in gn){

            this[gw[gu]]();
          };
        };
        this.fireDataEvent(cG, this.__states);
      },
      // property apply
      _applyAppearance : function(gx, gy){

        this.updateAppearance();
      },
      /**
       * Helper method called from the visibility queue to detect outstanding changes
       * to the appearance.
       *
       * @internal
       */
      checkAppearanceNeeds : function(){

        // CASE 1: Widget has never got an appearance already because it was never
        // visible before. Normally add it to the queue is the easiest way to update it.
        if(!this.__initialAppearanceApplied){

          qx.ui.core.queue.Appearance.add(this);
          this.__initialAppearanceApplied = true;
        } else if(this.$$stateChanges){

          qx.ui.core.queue.Appearance.add(this);
          delete this.$$stateChanges;
        };
      },
      /**
       * Refreshes the appearance of this widget and all
       * registered child controls.
       */
      updateAppearance : function(){

        // Clear selector
        this.__updateSelector = true;
        // Add to appearance queue
        qx.ui.core.queue.Appearance.add(this);
        // Update child controls
        var gB = this.__childControls;
        if(gB){

          var gz;
          for(var gA in gB){

            gz = gB[gA];
            if(gz instanceof qx.ui.core.Widget){

              gz.updateAppearance();
            };
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        WIDGET QUEUE
      ---------------------------------------------------------------------------
      */
      /**
       * This method is called during the flush of the
       * {@link qx.ui.core.queue.Widget widget queue}.
       *
       * @param jobs {Map} A map of jobs.
       */
      syncWidget : function(gC){
      },
      /*
      ---------------------------------------------------------------------------
        EVENT SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the next event target in the parent chain. May
       * also return the widget itself if it is not anonymous.
       *
       * @return {qx.ui.core.Widget} A working event target of this widget.
       *    May be <code>null</code> as well.
       */
      getEventTarget : function(){

        var gD = this;
        while(gD.getAnonymous()){

          gD = gD.getLayoutParent();
          if(!gD){

            return null;
          };
        };
        return gD;
      },
      /**
       * Returns the next focus target in the parent chain. May
       * also return the widget itself if it is not anonymous and focusable.
       *
       * @return {qx.ui.core.Widget} A working focus target of this widget.
       *    May be <code>null</code> as well.
       */
      getFocusTarget : function(){

        var gE = this;
        if(!gE.getEnabled()){

          return null;
        };
        while(gE.getAnonymous() || !gE.getFocusable()){

          gE = gE.getLayoutParent();
          if(!gE || !gE.getEnabled()){

            return null;
          };
        };
        return gE;
      },
      /**
       * Returns the element which should be focused.
       *
       * @return {qx.html.Element} The html element to focus.
       */
      getFocusElement : function(){

        return this.getContainerElement();
      },
      /**
       * Whether the widget is reachable by pressing the TAB key.
       *
       * Normally tests for both, the focusable property and a positive or
       * undefined tabIndex property. The widget must have a DOM element
       * since only visible widgets are tabable.
       *
       * @return {Boolean} Whether the element is tabable.
       */
      isTabable : function(){

        return (!!this.getContainerElement().getDomElement()) && this.isFocusable();
      },
      // property apply
      _applyFocusable : function(gF, gG){

        var gH = this.getFocusElement();
        // Apply native tabIndex attribute
        if(gF){

          var gI = this.getTabIndex();
          if(gI == null){

            gI = 1;
          };
          gH.setAttribute(cS, gI);
          // Omit native dotted outline border
          if((qx.core.Environment.get(cU) == cW && parseFloat(qx.core.Environment.get(cB)) < 8) || (qx.core.Environment.get(cU) == cW && qx.core.Environment.get(bE) < 8)){

            gH.setAttribute(v, bi);
          } else {

            gH.setStyle(db, dd);
          };
        } else {

          if(gH.isNativelyFocusable()){

            gH.setAttribute(cS, -1);
          } else if(gG){

            gH.setAttribute(cS, null);
          };
        };
      },
      // property apply
      _applyKeepFocus : function(gJ){

        var gK = this.getFocusElement();
        gK.setAttribute(bu, gJ ? cV : null);
      },
      // property apply
      _applyKeepActive : function(gL){

        var gM = this.getContainerElement();
        gM.setAttribute(bo, gL ? cV : null);
      },
      // property apply
      _applyTabIndex : function(gN){

        if(gN == null){

          gN = 1;
        } else if(gN < 1 || gN > 32000){

          throw new Error(W);
        };
        if(this.getFocusable() && gN != null){

          this.getFocusElement().setAttribute(cS, gN);
        };
      },
      // property apply
      _applySelectable : function(gO, gP){

        // Re-apply cursor if not in "initSelectable"
        if(gP !== null){

          this._applyCursor(this.getCursor());
        };
        // Apply qooxdoo attribute
        this.getContentElement().setSelectable(gO);
      },
      // property apply
      _applyEnabled : function(gQ, gR){

        if(gQ === false){

          this.addState(bM);
          // hovered not configured in widget, but as this is a
          // standardized name in qooxdoo and we never want a hover
          // state for disabled widgets, remove this state everytime
          this.removeState(cs);
          // Blur when focused
          if(this.isFocusable()){

            // Remove focused state
            this.removeState(cq);
            // Remove tabIndex
            this._applyFocusable(false, true);
          };
          // Remove draggable
          if(this.isDraggable()){

            this._applyDraggable(false, true);
          };
          // Remove droppable
          if(this.isDroppable()){

            this._applyDroppable(false, true);
          };
        } else {

          this.removeState(bM);
          // Re-add tabIndex
          if(this.isFocusable()){

            this._applyFocusable(true, false);
          };
          // Re-add draggable
          if(this.isDraggable()){

            this._applyDraggable(true, false);
          };
          // Re-add droppable
          if(this.isDroppable()){

            this._applyDroppable(true, false);
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        CONTEXT MENU
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyNativeContextMenu : function(gS, gT, name){
      },
      // property apply
      _applyContextMenu : function(gU, gV){

        if(gV){

          gV.removeState(cY);
          if(gV.getOpener() == this){

            gV.resetOpener();
          };
          if(!gU){

            this.removeListener(cY, this._onContextMenuOpen);
            gV.removeListener(cp, this._onBeforeContextMenuOpen, this);
          };
        };
        if(gU){

          gU.setOpener(this);
          gU.addState(cY);
          if(!gV){

            this.addListener(cY, this._onContextMenuOpen);
            gU.addListener(cp, this._onBeforeContextMenuOpen, this);
          };
        };
      },
      /**
       * Event listener for <code>contextmenu</code> event
       *
       * @param e {qx.event.type.Mouse} The event object
       */
      _onContextMenuOpen : function(e){

        this.getContextMenu().openAtMouse(e);
        // Do not show native menu
        // don't open any other contextmenus
        e.stop();
      },
      /**
       * Event listener for <code>beforeContextmenuOpen</code> event
       *
       * @param e {qx.event.type.Data} The data event
       */
      _onBeforeContextMenuOpen : function(e){

        if(e.getData() == j && this.hasListener(cn)){

          this.fireDataEvent(cn, e);
        };
      },
      /*
      ---------------------------------------------------------------------------
        USEFUL COMMON EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener which stops a bubbling event from
       * propagates further.
       *
       * @param e {qx.event.type.Event} Any bubbling event
       */
      _onStopEvent : function(e){

        e.stopPropagation();
      },
      /*
      ---------------------------------------------------------------------------
        DRAG & DROP SUPPORT
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyDraggable : function(gW, gX){

        if(!this.isEnabled() && gW === true){

          gW = false;
        };
        // Force cursor creation
        qx.ui.core.DragDropCursor.getInstance();
        // Process listeners
        if(gW){

          this.addListener(bK, this._onDragStart);
          this.addListener(bH, this._onDrag);
          this.addListener(bW, this._onDragEnd);
          this.addListener(bO, this._onDragChange);
        } else {

          this.removeListener(bK, this._onDragStart);
          this.removeListener(bH, this._onDrag);
          this.removeListener(bW, this._onDragEnd);
          this.removeListener(bO, this._onDragChange);
        };
        // Sync DOM attribute
        this.getContainerElement().setAttribute(cF, gW ? cV : null);
      },
      // property apply
      _applyDroppable : function(gY, ha){

        if(!this.isEnabled() && gY === true){

          gY = false;
        };
        // Sync DOM attribute
        this.getContainerElement().setAttribute(bb, gY ? cV : null);
      },
      /**
       * Event listener for own <code>dragstart</code> event.
       *
       * @param e {qx.event.type.Drag} Drag event
       */
      _onDragStart : function(e){

        qx.ui.core.DragDropCursor.getInstance().placeToMouse(e);
        this.getApplicationRoot().setGlobalCursor(bQ);
      },
      /**
       * Event listener for own <code>dragmove</code> event.
       *
       * @param e {qx.event.type.Drag} Drag event
       */
      _onDrag : function(e){

        qx.ui.core.DragDropCursor.getInstance().placeToMouse(e);
      },
      /**
       * Event listener for own <code>dragend</code> event.
       *
       * @param e {qx.event.type.Drag} Drag event
       */
      _onDragEnd : function(e){

        qx.ui.core.DragDropCursor.getInstance().moveTo(-1000, -1000);
        this.getApplicationRoot().resetGlobalCursor();
      },
      /**
       * Event listener for own <code>dragchange</code> event.
       *
       * @param e {qx.event.type.Drag} Drag event
       */
      _onDragChange : function(e){

        var hb = qx.ui.core.DragDropCursor.getInstance();
        var hc = e.getCurrentAction();
        hc ? hb.setAction(hc) : hb.resetAction();
      },
      /*
      ---------------------------------------------------------------------------
        VISUALIZE FOCUS STATES
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler which is executed when the widget receives the focus.
       *
       * This method is used by the {@link qx.ui.core.FocusHandler} to
       * apply states etc. to a focused widget.
       *
       * @internal
       * @return {void}
       */
      visualizeFocus : function(){

        this.addState(cq);
      },
      /**
       * Event handler which is executed when the widget lost the focus.
       *
       * This method is used by the {@link qx.ui.core.FocusHandler} to
       * remove states etc. from a previously focused widget.
       *
       * @internal
       * @return {void}
       */
      visualizeBlur : function(){

        this.removeState(cq);
      },
      /*
      ---------------------------------------------------------------------------
        SCROLL CHILD INTO VIEW
      ---------------------------------------------------------------------------
      */
      /**
       * The method scrolls the given item into view.
       *
       * @param child {qx.ui.core.Widget} Child to scroll into view
       * @param alignX {String?null} Alignment of the item. Allowed values:
       *   <code>left</code> or <code>right</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param alignY {String?null} Alignment of the item. Allowed values:
       *   <code>top</code> or <code>bottom</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param direct {Boolean?true} Whether the execution should be made
       *   directly when possible
       */
      scrollChildIntoView : function(hd, he, hf, hg){

        // Scroll directly on default
        hg = typeof hg == bm ? true : hg;
        // Always lazy scroll when either
        // - the child
        // - its layout parent
        // - its siblings
        // have layout changes scheduled.
        //
        // This is to make sure that the scroll position is computed
        // after layout changes have been applied to the DOM. Note that changes
        // scheduled for the grand parent (and up) are not tracked and need to
        // be signalled manually.
        var hh = qx.ui.core.queue.Layout;
        var parent;
        // Child
        if(hg){

          hg = !hh.isScheduled(hd);
          parent = hd.getLayoutParent();
          // Parent
          if(hg && parent){

            hg = !hh.isScheduled(parent);
            // Siblings
            if(hg){

              parent.getChildren().forEach(function(hi){

                hg = hg && !hh.isScheduled(hi);
              });
            };
          };
        };
        this.scrollChildIntoViewX(hd, he, hg);
        this.scrollChildIntoViewY(hd, hf, hg);
      },
      /**
       * The method scrolls the given item into view (x-axis only).
       *
       * @param child {qx.ui.core.Widget} Child to scroll into view
       * @param align {String?null} Alignment of the item. Allowed values:
       *   <code>left</code> or <code>right</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param direct {Boolean?true} Whether the execution should be made
       *   directly when possible
       */
      scrollChildIntoViewX : function(hj, hk, hl){

        this.getContentElement().scrollChildIntoViewX(hj.getContainerElement(), hk, hl);
      },
      /**
       * The method scrolls the given item into view (y-axis only).
       *
       * @param child {qx.ui.core.Widget} Child to scroll into view
       * @param align {String?null} Alignment of the element. Allowed values:
       *   <code>top</code> or <code>bottom</code>. Could also be null.
       *   Without a given alignment the method tries to scroll the widget
       *   with the minimum effort needed.
       * @param direct {Boolean?true} Whether the execution should be made
       *   directly when possible
       */
      scrollChildIntoViewY : function(hm, hn, ho){

        this.getContentElement().scrollChildIntoViewY(hm.getContainerElement(), hn, ho);
      },
      /*
      ---------------------------------------------------------------------------
        FOCUS SYSTEM USER ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Focus this widget.
       *
       * @return {void}
       */
      focus : function(){

        if(this.isFocusable()){

          this.getFocusElement().focus();
        } else {

          throw new Error(bY);
        };
      },
      /**
       * Remove focus from this widget.
       *
       * @return {void}
       */
      blur : function(){

        if(this.isFocusable()){

          this.getFocusElement().blur();
        } else {

          throw new Error(bY);
        };
      },
      /**
       * Activate this widget e.g. for keyboard events.
       *
       * @return {void}
       */
      activate : function(){

        this.getContainerElement().activate();
      },
      /**
       * Deactivate this widget e.g. for keyboard events.
       *
       * @return {void}
       */
      deactivate : function(){

        this.getContainerElement().deactivate();
      },
      /**
       * Focus this widget when using the keyboard. This is
       * mainly thought for the advanced qooxdoo keyboard handling
       * and should not be used by the application developer.
       *
       * @internal
       * @return {void}
       */
      tabFocus : function(){

        this.getFocusElement().focus();
      },
      /*
      ---------------------------------------------------------------------------
        CHILD CONTROL SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Whether the given ID is assigned to a child control.
       *
       * @param id {String} ID of the child control
       * @return {Boolean} <code>true</code> when the child control is registered.
       */
      hasChildControl : function(hp){

        if(!this.__childControls){

          return false;
        };
        return !!this.__childControls[hp];
      },
      /** {Map} Map of instantiated child controls */
      __childControls : null,
      /**
       * Returns a map of all already created child controls
       *
       * @return {Map} mapping of child control id to the child widget.
       */
      _getCreatedChildControls : function(){

        return this.__childControls;
      },
      /**
       * Returns the child control from the given ID. Returns
       * <code>null</code> when the child control is unknown.
       *
       * It is designed for widget authors, who want to access child controls,
       * which are created by the widget itself.
       *
       * <b>Warning</b>: This method exposes widget internals and modifying the
       * returned sub widget may bring the widget into an inconsistent state.
       * Accessing child controls defined in a super class or in an foreign class
       * is not supported. Do not use it if the result can be achieved using public
       * API or theming.
       *
       * @param id {String} ID of the child control
       * @param notcreate {Boolean?false} Whether the child control
       *    should not be created dynamically if not yet available.
       * @return {qx.ui.core.Widget} Child control
       */
      getChildControl : function(hq, hr){

        if(!this.__childControls){

          if(hr){

            return null;
          };
          this.__childControls = {
          };
        };
        var hs = this.__childControls[hq];
        if(hs){

          return hs;
        };
        if(hr === true){

          return null;
        };
        return this._createChildControl(hq);
      },
      /**
       * Shows the given child control by ID
       *
       * @param id {String} ID of the child control
       * @return {qx.ui.core.Widget} the child control
       */
      _showChildControl : function(ht){

        var hu = this.getChildControl(ht);
        hu.show();
        return hu;
      },
      /**
       * Excludes the given child control by ID
       *
       * @param id {String} ID of the child control
       */
      _excludeChildControl : function(hv){

        var hw = this.getChildControl(hv, true);
        if(hw){

          hw.exclude();
        };
      },
      /**
       * Whether the given child control is visible.
       *
       * @param id {String} ID of the child control
       * @return {Boolean} <code>true</code> when the child control is visible.
       */
      _isChildControlVisible : function(hx){

        var hy = this.getChildControl(hx, true);
        if(hy){

          return hy.isVisible();
        };
        return false;
      },
      /**
       * Force the creation of the given child control by ID.
       *
       * Do not override this method! Override {@link #_createChildControlImpl}
       * instead if you need to support new controls.
       *
       * @param id {String} ID of the child control
       * @return {qx.ui.core.Widget} The created control
       * @throws when the control was created before
       */
      _createChildControl : function(hz){

        if(!this.__childControls){

          this.__childControls = {
          };
        } else if(this.__childControls[hz]){

          throw new Error(cH + hz + X);
        };
        var hD = hz.indexOf(ci);
        if(hD == -1){

          var hA = this._createChildControlImpl(hz);
        } else {

          var hA = this._createChildControlImpl(hz.substring(0, hD), hz.substring(hD + 1, hz.length));
        };
        if(!hA){

          throw new Error(bD + hz);
        };
        // Establish connection to parent
        hA.$$subcontrol = hz;
        hA.$$subparent = this;
        // Support for state forwarding
        var hB = this.__states;
        var forward = this._forwardStates;
        if(hB && forward && hA instanceof qx.ui.core.Widget){

          for(var hC in hB){

            if(forward[hC]){

              hA.addState(hC);
            };
          };
        };
        this.fireDataEvent(bF, hA);
        // Register control and return
        return this.__childControls[hz] = hA;
      },
      /**
       * Internal method to create child controls. This method
       * should be overwritten by classes which extends this one
       * to support new child control types.
       *
       * @param id {String} ID of the child control. If a # is used, the id is
       *   the part infront of the #.
       * @param hash {String?undefined} If a child control name contains a #,
       *   all text following the # will be the hash argument.
       * @return {qx.ui.core.Widget} The created control or <code>null</code>
       */
      _createChildControlImpl : function(hE, hF){

        return null;
      },
      /**
       * Dispose all registered controls. This is automatically
       * executed by the widget.
       *
       * @return {void}
       */
      _disposeChildControls : function(){

        var hJ = this.__childControls;
        if(!hJ){

          return;
        };
        var hH = qx.ui.core.Widget;
        for(var hI in hJ){

          var hG = hJ[hI];
          if(!hH.contains(this, hG)){

            hG.destroy();
          } else {

            hG.dispose();
          };
        };
        delete this.__childControls;
      },
      /**
       * Finds and returns the top level control. This is the first
       * widget which is not a child control of any other widget.
       *
       * @return {qx.ui.core.Widget} The top control
       */
      _findTopControl : function(){

        var hK = this;
        while(hK){

          if(!hK.$$subparent){

            return hK;
          };
          hK = hK.$$subparent;
        };
        return null;
      },
      /*
      ---------------------------------------------------------------------------
        LOWER LEVEL ACCESS
      ---------------------------------------------------------------------------
      */
      /**
       * Computes the location of the container element in context of the document dimensions.
       *
       * Supported modes:
       *
       * * <code>margin</code>: Calculate from the margin box of the element
       *   (bigger than the visual appearance: including margins of given element)
       * * <code>box</code>: Calculates the offset box of the element
       *   (default, uses the same size as visible)
       * * <code>border</code>: Calculate the border box
       *   (useful to align to border edges of two elements).
       * * <code>scroll</code>: Calculate the scroll box
       *   (relevant for absolute positioned content).
       * * <code>padding</code>: Calculate the padding box
       *   (relevant for static/relative positioned content).
       *
       * @param mode {String?box} A supported option. See comment above.
       * @return {Map} Returns a map with <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code> which contains the distance
       *   of the element relative to the document.
       */
      getContainerLocation : function(hL){

        var hM = this.getContainerElement().getDomElement();
        return hM ? qx.bom.element.Location.get(hM, hL) : null;
      },
      /**
       * Computes the location of the content element in context of the document
       * dimensions.
       *
       * Supported modes:
       *
       * * <code>margin</code>: Calculate from the margin box of the element
       *   (bigger than the visual appearance: including margins of given element)
       * * <code>box</code>: Calculates the offset box of the element (default,
       *   uses the same size as visible)
       * * <code>border</code>: Calculate the border box (useful to align to
       *   border edges of two elements).
       * * <code>scroll</code>: Calculate the scroll box (relevant for absolute
       *   positioned content).
       * * <code>padding</code>: Calculate the padding box (relevant for
       *   static/relative positioned content).
       *
       * @param mode {String?box} A supported option. See comment above.
       * @return {Map} Returns a map with <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code> which contains the distance
       *   of the element relative to the document.
       */
      getContentLocation : function(hN){

        var hO = this.getContentElement().getDomElement();
        return hO ? qx.bom.element.Location.get(hO, hN) : null;
      },
      /**
       * Directly modifies the relative left position in relation
       * to the parent element.
       *
       * Use with caution! This may be used for animations, drag&drop
       * or other cases where high performance location manipulation
       * is important. Otherwise please use {@link qx.ui.core.LayoutItem#setUserBounds} instead.
       *
       * @param value {Integer} Left position
       * @return {void}
       */
      setDomLeft : function(hP){

        var hQ = this.getContainerElement().getDomElement();
        if(hQ){

          hQ.style.left = hP + c;
        } else {

          throw new Error(cu);
        };
      },
      /**
       * Directly modifies the relative top position in relation
       * to the parent element.
       *
       * Use with caution! This may be used for animations, drag&drop
       * or other cases where high performance location manipulation
       * is important. Otherwise please use {@link qx.ui.core.LayoutItem#setUserBounds} instead.
       *
       * @param value {Integer} Top position
       * @return {void}
       */
      setDomTop : function(hR){

        var hS = this.getContainerElement().getDomElement();
        if(hS){

          hS.style.top = hR + c;
        } else {

          throw new Error(cu);
        };
      },
      /**
       * Directly modifies the relative left and top position in relation
       * to the parent element.
       *
       * Use with caution! This may be used for animations, drag&drop
       * or other cases where high performance location manipulation
       * is important. Otherwise please use {@link qx.ui.core.LayoutItem#setUserBounds} instead.
       *
       * @param left {Integer} Left position
       * @param top {Integer} Top position
       * @return {void}
       */
      setDomPosition : function(hT, top){

        var hU = this.getContainerElement().getDomElement();
        if(hU){

          hU.style.left = hT + c;
          hU.style.top = top + c;
        } else {

          throw new Error(cu);
        };
      },
      /*
      ---------------------------------------------------------------------------
        ENHANCED DISPOSE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Removes this widget from its parent and disposes it.
       *
       * Please note that the widget is not disposed synchronously. The
       * real dispose happens after the next queue flush.
       *
       * @return {void}
       */
      destroy : function(){

        if(this.$$disposed){

          return;
        };
        var parent = this.$$parent;
        if(parent){

          parent._remove(this);
        };
        qx.ui.core.queue.Dispose.add(this);
      },
      /*
      ---------------------------------------------------------------------------
        CLONE SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      clone : function(){

        var hV = qx.ui.core.LayoutItem.prototype.clone.call(this);
        if(this.getChildren){

          var hW = this.getChildren();
          for(var i = 0,l = hW.length;i < l;i++){

            hV.add(hW[i].clone());
          };
        };
        return hV;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      // Some dispose stuff is not needed in global shutdown, otherwise
      // it just slows down things a bit, so do not do them.
      if(!qx.core.ObjectRegistry.inShutDown){

        if(qx.core.Environment.get(bP)){

          if(this.__toolTipTextListenerId){

            qx.locale.Manager.getInstance().removeListenerById(this.__toolTipTextListenerId);
          };
        };
        // Remove widget pointer from DOM
        this.getContainerElement().setAttribute(r, null, true);
        // Clean up all child controls
        this._disposeChildControls();
        // Remove from ui queues
        qx.ui.core.queue.Appearance.remove(this);
        qx.ui.core.queue.Layout.remove(this);
        qx.ui.core.queue.Visibility.remove(this);
        qx.ui.core.queue.Widget.remove(this);
      };
      if(this.getContextMenu()){

        this.setContextMenu(null);
      };
      // pool decorators if not in global shutdown
      if(!qx.core.ObjectRegistry.inShutDown){

        var hY = qx.ui.core.Widget;
        var hX = this.getContainerElement();
        if(this.__decoratorElement){

          hX.remove(this.__decoratorElement);
          hY.__decoratorPool.poolDecorator(this.__decoratorElement);
        };
        if(this.__shadowElement){

          hX.remove(this.__shadowElement);
          hY.__shadowPool.poolDecorator(this.__shadowElement);
        };
        this.clearSeparators();
        this.__decoratorElement = this.__shadowElement = this.__separators = null;
      } else {

        this._disposeArray(A);
        this._disposeObjects(ba, bd);
      };
      // Clear children array
      this._disposeArray(ch);
      // Cleanup map of appearance states
      this.__states = this.__childControls = null;
      // Dispose layout manager and HTML elements
      this._disposeObjects(cb, ce, L, dc);
    }
  });
})();
(function(){

  var f = "qx.ui.core.EventHandler",e = "activate",d = "blur",c = "focus",b = "input",a = "load";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Connects the widgets to the browser DOM events.
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__manager = qx.event.Registration.getManager(window);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_FIRST,
      /** {Map} Supported event types. Identical to events map of qx.ui.core.Widget */
      SUPPORTED_TYPES : {
        // mouse events
        mousemove : 1,
        mouseover : 1,
        mouseout : 1,
        mousedown : 1,
        mouseup : 1,
        click : 1,
        dblclick : 1,
        contextmenu : 1,
        mousewheel : 1,
        // key events
        keyup : 1,
        keydown : 1,
        keypress : 1,
        keyinput : 1,
        // mouse capture
        capture : 1,
        losecapture : 1,
        // focus events
        focusin : 1,
        focusout : 1,
        focus : 1,
        blur : 1,
        activate : 1,
        deactivate : 1,
        // appear events
        appear : 1,
        disappear : 1,
        // drag drop events
        dragstart : 1,
        dragend : 1,
        dragover : 1,
        dragleave : 1,
        drop : 1,
        drag : 1,
        dragchange : 1,
        droprequest : 1,
        // touch events
        touchstart : 1,
        touchend : 1,
        touchmove : 1,
        touchcancel : 1,
        tap : 1,
        swipe : 1
      },
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __manager : null,
      /**
       * {Map} Supported focus event types
       *
       * @lint ignoreReferenceField(__focusEvents)
       */
      __focusEvents : {
        focusin : 1,
        focusout : 1,
        focus : 1,
        blur : 1
      },
      /**
       * {Map} Map of events which should be fired independently from being disabled
       *
       * @lint ignoreReferenceField(__ignoreDisabled)
       */
      __ignoreDisabled : {
        // mouse events
        mouseover : 1,
        mouseout : 1,
        // appear events
        appear : 1,
        disappear : 1
      },
      // interface implementation
      canHandleEvent : function(g, h){

        return g instanceof qx.ui.core.Widget;
      },
      /**
       * Dispatches a DOM event on a widget.
       *
       * @param domEvent {qx.event.type.Event} The event object to dispatch.
       */
      _dispatchEvent : function(j){

        // EVENT TARGET
        var p = j.getTarget();
        var o = qx.ui.core.Widget.getWidgetByElement(p);
        var q = false;
        while(o && o.isAnonymous()){

          var q = true;
          o = o.getLayoutParent();
        };
        // don't activate anonymous widgets!
        if(o && q && j.getType() == e){

          o.getContainerElement().activate();
        };
        // Correcting target for focus events
        if(this.__focusEvents[j.getType()]){

          o = o && o.getFocusTarget();
          // Whether nothing is returned
          if(!o){

            return;
          };
        };
        // EVENT RELATED TARGET
        if(j.getRelatedTarget){

          var x = j.getRelatedTarget();
          var w = qx.ui.core.Widget.getWidgetByElement(x);
          while(w && w.isAnonymous()){

            w = w.getLayoutParent();
          };
          if(w){

            // Correcting target for focus events
            if(this.__focusEvents[j.getType()]){

              w = w.getFocusTarget();
            };
            // If target and related target are identical ignore the event
            if(w === o){

              return;
            };
          };
        };
        // EVENT CURRENT TARGET
        var s = j.getCurrentTarget();
        var u = qx.ui.core.Widget.getWidgetByElement(s);
        if(!u || u.isAnonymous()){

          return;
        };
        // Correcting target for focus events
        if(this.__focusEvents[j.getType()]){

          u = u.getFocusTarget();
        };
        // Ignore most events in the disabled state.
        var v = j.getType();
        if(!u || !(u.isEnabled() || this.__ignoreDisabled[v])){

          return;
        };
        // PROCESS LISTENERS
        // Load listeners
        var k = j.getEventPhase() == qx.event.type.Event.CAPTURING_PHASE;
        var r = this.__manager.getListeners(u, v, k);
        if(!r || r.length === 0){

          return;
        };
        // Create cloned event with correct target
        var m = qx.event.Pool.getInstance().getObject(j.constructor);
        j.clone(m);
        m.setTarget(o);
        m.setRelatedTarget(w || null);
        m.setCurrentTarget(u);
        // Keep original target of DOM event, otherwise map it to the original
        var y = j.getOriginalTarget();
        if(y){

          var n = qx.ui.core.Widget.getWidgetByElement(y);
          while(n && n.isAnonymous()){

            n = n.getLayoutParent();
          };
          m.setOriginalTarget(n);
        } else {

          m.setOriginalTarget(p);
        };
        // Dispatch it on all listeners
        for(var i = 0,l = r.length;i < l;i++){

          var t = r[i].context || u;
          r[i].handler.call(t, m);
        };
        // Synchronize propagation stopped/prevent default property
        if(m.getPropagationStopped()){

          j.stopPropagation();
        };
        if(m.getDefaultPrevented()){

          j.preventDefault();
        };
        // Release the event instance to the event pool
        qx.event.Pool.getInstance().poolObject(m);
      },
      // interface implementation
      registerEvent : function(z, A, B){

        var C;
        if(A === c || A === d){

          C = z.getFocusElement();
        } else if(A === a || A === b){

          C = z.getContentElement();
        } else {

          C = z.getContainerElement();
        };
        if(C){

          C.addListener(A, this._dispatchEvent, this, B);
        };
      },
      // interface implementation
      unregisterEvent : function(D, E, F){

        var G;
        if(E === c || E === d){

          G = D.getFocusElement();
        } else if(E === a || E === b){

          G = D.getContentElement();
        } else {

          G = D.getContainerElement();
        };
        if(G){

          G.removeListener(E, this._dispatchEvent, this, F);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__manager = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(H){

      qx.event.Registration.addHandler(H);
    }
  });
})();
(function(){

  var f = "Missing renderLayout() implementation!",e = "abstract",d = "Missing getHeightForWidth() implementation!",c = "qx.debug",b = "It is not possible to manually set the connected widget.",a = "qx.ui.layout.Abstract";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Base class for all layout managers.
   *
   * Custom layout manager must derive from
   * this class and implement the methods {@link #invalidateLayoutCache},
   * {@link #renderLayout} and {@link #getSizeHint}.
   */
  qx.Class.define(a, {
    type : e,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {Map} The cached size hint */
      __sizeHint : null,
      /** {Boolean} Whether the children cache is valid. This field is protected
       *    because sub classes must be able to access it quickly.
       */
      _invalidChildrenCache : null,
      /** {qx.ui.core.Widget} The connected widget */
      __widget : null,
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      /**
       * Invalidate all layout relevant caches. Automatically deletes the size hint.
       *
       * @abstract
       * @return {void}
       */
      invalidateLayoutCache : function(){

        this.__sizeHint = null;
      },
      /**
       * Applies the children layout.
       *
       * @abstract
       * @param availWidth {Integer} Final width available for the content (in pixel)
       * @param availHeight {Integer} Final height available for the content (in pixel)
       * @return {void}
       */
      renderLayout : function(g, h){

        this.warn(f);
      },
      /**
       * Computes the layout dimensions and possible ranges of these.
       *
       * @return {Map|null} The map with the preferred width/height and the allowed
       *   minimum and maximum values in cases where shrinking or growing
       *   is required. Can also return <code>null</code> when this detection
       *   is not supported by the layout.
       */
      getSizeHint : function(){

        if(this.__sizeHint){

          return this.__sizeHint;
        };
        return this.__sizeHint = this._computeSizeHint();
      },
      /**
       * Whether the layout manager supports height for width.
       *
       * @return {Boolean} Whether the layout manager supports height for width
       */
      hasHeightForWidth : function(){

        return false;
      },
      /**
       * If layout wants to trade height for width it has to implement this
       * method and return the preferred height if it is resized to
       * the given width. This function returns <code>null</code> if the item
       * do not support height for width.
       *
       * @param width {Integer} The computed width
       * @return {Integer} The desired height
       */
      getHeightForWidth : function(i){

        this.warn(d);
        return null;
      },
      /**
       * This computes the size hint of the layout and returns it.
       *
       * @abstract
       * @return {Map} The size hint.
       */
      _computeSizeHint : function(){

        return null;
      },
      /**
       * This method is called, on each child "add" and "remove" action and
       * whenever the layout data of a child is changed. The method should be used
       * to clear any children relevant cached data.
       *
       * @return {void}
       */
      invalidateChildrenCache : function(){

        this._invalidChildrenCache = true;
      },
      /**
       * Verifies the value of a layout property.
       *
       * Note: This method is only available in the debug builds.
       *
       * @signature function(item, name, value)
       * @param item {Object} The affected layout item
       * @param name {Object} Name of the layout property
       * @param value {Object} Value of the layout property
       */
      verifyLayoutProperty : qx.core.Environment.select(c, {
        "true" : function(j, name, k){
        },
        "false" : null
      }),
      /**
       * Remove all currently visible separators
       */
      _clearSeparators : function(){

        // It may be that the widget do not implement clearSeparators which is especially true
        // when it do not inherit from LayoutItem.
        var l = this.__widget;
        if(l instanceof qx.ui.core.LayoutItem){

          l.clearSeparators();
        };
      },
      /**
       * Renders a separator between two children
       *
       * @param separator {Separator} The separator to render
       * @param bounds {Map} Contains the left and top coordinate and the width and height
       *    of the separator to render.
       */
      _renderSeparator : function(m, n){

        this.__widget.renderSeparator(m, n);
      },
      /**
       * This method is called by the widget to connect the widget with the layout.
       *
       * @param widget {qx.ui.core.Widget} The widget to connect to.
       */
      connectToWidget : function(o){

        if(o && this.__widget){

          throw new Error(b);
        };
        this.__widget = o;
        // Invalidate cache
        this.invalidateChildrenCache();
      },
      /**
       * Return the widget that is this layout is responsible for.
       *
       * @return {qx.ui.core.Widget} The widget connected to this layout.
       */
      _getWidget : function(){

        return this.__widget;
      },
      /**
       * Indicate that the layout has layout changed and propagate this information
       * up the widget hierarchy.
       *
       * Also a generic property apply method for all layout relevant properties.
       */
      _applyLayoutChange : function(){

        if(this.__widget){

          this.__widget.scheduleLayoutUpdate();
        };
      },
      /**
       * Returns the list of all layout relevant children.
       *
       * @return {Array} List of layout relevant children.
       */
      _getLayoutChildren : function(){

        return this.__widget.getLayoutChildren();
      }
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      this.__widget = this.__sizeHint = null;
    }
  });
})();
(function(){

  var u = 'indexOf',t = 'slice',s = 'concat',r = 'toLocaleLowerCase',q = "qx.type.BaseString",p = 'match',o = "qx.debug",n = 'search',m = 'replace',k = 'toLowerCase',d = 'charCodeAt',j = 'split',g = 'substring',c = 'lastIndexOf',b = 'substr',f = 'toLocaleUpperCase',e = 'toUpperCase',h = 'charAt',a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
     ======================================================================
  
       This class uses documentation of the native String methods from the MDC
       documentation of Mozilla.
  
       License:
         CC Attribution-Sharealike License:
         http://creativecommons.org/licenses/by-sa/2.5/
  
  ************************************************************************ */
  /**
   * This class emulates the built-in JavaScript String class. It can be used as
   * base class for classes, which need to derive from String.
   *
   * Instances of this class can be used in any place a JavaScript string can.
   */
  qx.Class.define(q, {
    extend : Object,
    /**
     * @param txt {String?""} Initialize with this string
     */
    construct : function(v){

      var v = v || a;
      // no base call needed
      this.__txt = v;
      this.length = v.length;
    },
    members : {
      $$isString : true,
      length : 0,
      __txt : null,
      /**
       * Returns a string representing the specified object.
       *
       * The valueOf method of String returns the primitive value of a String
       * object as a string data type.
       * This method is usually called internally by JavaScript and not
       * explicitly in code.
       *
       * @return {String} A new string containing the string value.
       */
      toString : function(){

        return this.__txt;
      },
      /**
       *  Returns the specified character from a string.
       *
       * Characters in a string are indexed from left to right. The index of the
       * first character is 0, and the index of the last character in a string
       * called stringName is stringName.length - 1. If the index you supply is
       * out of range, JavaScript returns an empty string.
       *
       * @signature function(index)
       * @param index {Integer} An integer between 0 and 1 less than the length
       *   of the string.
       * @return {String} The character.
       */
      charAt : null,
      /**
       * Returns the primitive value of a String object.
       *
       * The valueOf method of String returns the primitive value of a String
       * object as a string data type.
       * This method is usually called internally by JavaScript and not
       * explicitly in code.
       *
       * @signature function()
       * @return {String} A new string containing the primitive value.
       */
      valueOf : null,
      /**
       * Returns a number indicating the Unicode value of the character at the given index.
       *
       * @signature function(index)
       * @param index {Integer} An integer greater than 0 and less than the length
       *   of the string; if it is not a number, it defaults to 0.
       * @return {Integer} The number.
       */
      charCodeAt : null,
      /**
       * Combines the text of two or more strings and returns a new string.
       * Changes to the text in one string do not affect the other string.
       *
       * @signature function(stringN)
       * @param stringN {String} One or more strings to be combined.
       * @return {String} The combined string.
       */
      concat : null,
      /**
       * Returns the index within the calling String object of the first
       * occurrence of the specified value, starting the search at fromIndex,
       * returns -1 if the value is not found.
       *
       * @signature function(index, offset)
       * @param index {String} A string representing the value to search for.
       * @param offset {Integer?0} The location within the calling string to start
       *   the search from. It can be any integer between 0 and the length of the
       *   string. The default value is 0.
       * @return {Integer} The index or -1.
       */
      indexOf : null,
      /**
       * Returns the index within the calling String object of the last occurrence
       * of the specified value, or -1 if not found. The calling string is
       * searched backward, starting at fromIndex.
       *
       * @signature function(index, offset)
       * @param index {String} A string representing the value to search for.
       * @param offset {Integer?0} The location within the calling string to start
       *   the search from, indexed from left to right. It can be any integer
       *   between 0 and the length of the string. The default value is the length
       *    of the string.
       * @return {Integer} The index or -1.
       */
      lastIndexOf : null,
      /**
       * Used to retrieve the matches when matching a string against a regular
       * expression.
       *
       * If the regular expression does not include the g flag, returns the same
       * result as regexp.exec(string). If the regular expression includes the g
       * flag, the method returns an Array containing all matches.
       *
       * @signature function(regexp)
       * @param regexp {Object} A regular expression object. If a non-RegExp object
       *  obj is passed, it is implicitly converted to a RegExp by using
       *   new RegExp(obj).
       * @return {Object} The matching RegExp object or an array containing all
       *   matches.
       */
      match : null,
      /**
       * Finds a match between a regular expression and a string, and replaces the
       * matched substring with a new substring.
       *
       * @signature function(regexp, aFunction)
       * @param regexp {Object} A RegExp object. The match is replaced by the
       *   return value of parameter #2. Or a String that is to be replaced by
       *   newSubStr.
       * @param aFunction {Function} A function to be invoked to create the new
       *   substring (to put in place of the substring received from parameter
       *   #1).
       * @return {String} The new substring.
       */
      replace : null,
      /**
       * Executes the search for a match between a regular expression and this
       * String object.
       *
       * If successful, search returns the index of the regular expression inside
       * the string. Otherwise, it returns -1.
       *
       * @signature function(regexp)
       * @param regexp {Object} A regular expression object. If a non-RegExp object
       *  obj is passed, it is implicitly converted to a RegExp by using
       *   new RegExp(obj).
       * @return {Object} The matching RegExp object or -1.
       *   matches.
       */
      search : null,
      /**
       * Extracts a section of a string and returns a new string.
       *
       * Slice extracts the text from one string and returns a new string. Changes
       * to the text in one string do not affect the other string.
       * As a negative index, endSlice indicates an offset from the end of the
       * string.
       *
       * @signature function(beginslice, endSlice)
       * @param beginslice {Integer} The zero-based index at which to begin
       *   extraction.
       * @param endSlice {Integer?null} The zero-based index at which to end
       *   extraction. If omitted, slice extracts to the end of the string.
       * @return {String} The extracted string.
       */
      slice : null,
      /**
       * Splits a String object into an array of strings by separating the string
       * into substrings.
       *
       * When found, separator is removed from the string and the substrings are
       * returned in an array. If separator is omitted, the array contains one
       * element consisting of the entire string.
       *
       * If separator is a regular expression that contains capturing parentheses,
       * then each time separator is matched the results (including any undefined
       * results) of the capturing parentheses are spliced into the output array.
       * However, not all browsers support this capability.
       *
       * Note: When the string is empty, split returns an array containing one
       *
       * @signature function(separator, limit)
       * @param separator {String?null} Specifies the character to use for
       *   separating the string. The separator is treated as a string or a regular
       *   expression. If separator is omitted, the array returned contains one
       *   element consisting of the entire string.
       * @param limit {Integer?null} Integer specifying a limit on the number of
       *   splits to be found.
       * @return {Array} The Array containing substrings.
       */
      split : null,
      /**
       * Returns the characters in a string beginning at the specified location
       * through the specified number of characters.
       *
       * Start is a character index. The index of the first character is 0, and the
       * index of the last character is 1 less than the length of the string. substr
       *  begins extracting characters at start and collects length characters
       * (unless it reaches the end of the string first, in which case it will
       * return fewer).
       * If start is positive and is greater than or equal to the length of the
       * string, substr returns an empty string.
       *
       * @signature function(start, length)
       * @param start {Integer} Location at which to begin extracting characters
       *   (an integer between 0 and one less than the length of the string).
       * @param length {Integer?null} The number of characters to extract.
       * @return {String} The substring.
       */
      substr : null,
      /**
       * Returns a subset of a String object.
       *
       * substring extracts characters from indexA up to but not including indexB.
       * In particular:
       * If indexA equals indexB, substring returns an empty string.
       * If indexB is omitted, substring extracts characters to the end of the
       * string.
       * If either argument is less than 0 or is NaN, it is treated as if it were
       * 0.
       * If either argument is greater than stringName.length, it is treated as if
       * it were stringName.length.
       * If indexA is larger than indexB, then the effect of substring is as if
       * the two arguments were swapped; for example, str.substring(1, 0) == str.substring(0, 1).
       *
       * @signature function(indexA, indexB)
       * @param indexA {Integer} An integer between 0 and one less than the
       *   length of the string.
       * @param indexB {Integer?null} (optional) An integer between 0 and the
       *   length of the string.
       * @return {String} The subset.
       */
      substring : null,
      /**
       * Returns the calling string value converted to lowercase.
       * The toLowerCase method returns the value of the string converted to
       * lowercase. toLowerCase does not affect the value of the string itself.
       *
       * @signature function()
       * @return {String} The new string.
       */
      toLowerCase : null,
      /**
       * Returns the calling string value converted to uppercase.
       * The toUpperCase method returns the value of the string converted to
       * uppercase. toUpperCase does not affect the value of the string itself.
       *
       * @signature function()
       * @return {String} The new string.
       */
      toUpperCase : null,
      /**
       * Return unique hash code of object
       *
       * @return {Integer} unique hash code of the object
       */
      toHashCode : function(){

        return qx.core.ObjectRegistry.toHashCode(this);
      },
      /**
       * The characters within a string are converted to lower case while
       * respecting the current locale.
       *
       * The toLowerCase method returns the value of the string converted to
       * lowercase. toLowerCase does not affect the value of the string itself.
       *
       * @signature function()
       * @return {String} The new string.
       */
      toLocaleLowerCase : null,
      /**
       * The characters within a string are converted to upper case while
       * respecting the current locale.
       * The toUpperCase method returns the value of the string converted to
       * uppercase. toUpperCase does not affect the value of the string itself.
       *
       * @signature function()
       * @return {String} The new string.
       */
      toLocaleUpperCase : null,
      /**
       * Call the same method of the super class.
       *
       * @param args {arguments} the arguments variable of the calling method
       * @param varags {var} variable number of arguments passed to the overwritten function
       * @return {var} the return value of the method of the base class.
       */
      base : function(w, x){

        return qx.core.Object.prototype.base.apply(this, arguments);
      }
    },
    /*
     *****************************************************************************
        DEFER
     *****************************************************************************
     */
    defer : function(y, z){

      // add asserts into each debug build
      if(qx.core.Environment.get(o)){

        qx.Class.include(y, qx.core.MAssert);
      };
      var A = [h, d, s, u, c, p, m, n, t, j, b, g, k, e, r, f];
      // feature/bug detection:
      // Some older Firefox version (<2) break if valueOf is overridden
      z.valueOf = z.toString;
      if(new y(a).valueOf() == null){

        delete z.valueOf;
      };
      for(var i = 0,l = A.length;i < l;i++){

        z[A[i]] = String.prototype[A[i]];
      };
    }
  });
})();
(function(){

  var a = "qx.locale.LocalizedString";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This class contains the translation of a message and all information
   * to translate it again into a different language.
   */
  qx.Class.define(a, {
    extend : qx.type.BaseString,
    /**
     * @param translation {String} The translated message
     * @param messageId {String} The messageId to translate
     * @param args {Array} list of arguments passed used as values for format strings
     */
    construct : function(b, c, d){

      qx.type.BaseString.call(this, b);
      this.__messageId = c;
      this.__args = d;
    },
    members : {
      __messageId : null,
      __args : null,
      /**
       * Get a translation of the string using the current locale.
       *
       * @return {LocalizedString} This string translated using the current
       *    locale.
       */
      translate : function(){

        return qx.locale.Manager.getInstance().translate(this.__messageId, this.__args);
      }
    }
  });
})();
(function(){

  var o = "locale",n = "_applyLocale",m = "changeLocale",l = "Locale: ",k = "C",j = "locale.variant",h = "qx.dynlocale",g = " not available.",f = "qx.locale.Manager",e = "String",b = "singleton",d = "",c = "qx.debug",a = "_";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /*
  #require(qx.event.dispatch.Direct)
  #require(qx.locale.LocalizedString)
  #cldr
  */
  /**
   * The qx.locale.Manager provides static translation methods (like tr()) and
   * general locale information.
   */
  qx.Class.define(f, {
    type : b,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__translations = qx.$$translations || {
      };
      this.__locales = qx.$$locales || {
      };
      var p = qx.core.Environment.get(o);
      var q = qx.core.Environment.get(j);
      if(q !== d){

        p += a + q;
      };
      this.__clientLocale = p;
      this.setLocale(p || this.__defaultLocale);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Translate a message
       *
       * @param messageId {String} message id (may contain format strings)
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       * @see qx.lang.String.format
       */
      tr : function(r, s){

        var t = qx.lang.Array.fromArguments(arguments);
        t.splice(0, 1);
        return qx.locale.Manager.getInstance().translate(r, t);
      },
      /**
       * Translate a plural message
       *
       * Depending on the third argument the plural or the singular form is chosen.
       *
       * @param singularMessageId {String} message id of the singular form (may contain format strings)
       * @param pluralMessageId {String} message id of the plural form (may contain format strings)
       * @param count {Integer} singular form if equals 1, otherwise plural
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       * @see qx.lang.String.format
       */
      trn : function(u, v, w, x){

        var y = qx.lang.Array.fromArguments(arguments);
        y.splice(0, 3);
        // assumes "Two forms, singular used for one only" (seems to be the most common form)
        // (http://www.gnu.org/software/gettext/manual/html_node/gettext_150.html#Plural-forms)
        // closely related with bug #745
        if(w != 1){

          return qx.locale.Manager.getInstance().translate(v, y);
        } else {

          return qx.locale.Manager.getInstance().translate(u, y);
        };
      },
      /**
       * Translate a message with translation hint
       *
       * @param hint {String} hint for the translator of the message. Will be included in the .po file.
       * @param messageId {String} message id (may contain format strings)
       * @param varargs {Object} variable number of arguments applied to the format string
       * @return {String | LocalizedString} The translated message or localized string
       * @see qx.lang.String.format
       */
      trc : function(z, A, B){

        var C = qx.lang.Array.fromArguments(arguments);
        C.splice(0, 2);
        return qx.locale.Manager.getInstance().translate(A, C);
      },
      /**
       * Mark the message for translation but return the original message.
       *
       * @param messageId {String} the message ID
       * @return {String} messageId
       */
      marktr : function(D){

        return D;
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** current locale. locale is an language code like de, de_AT, en, en_GB, fr, ... */
      locale : {
        check : e,
        nullable : true,
        apply : n,
        event : m
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __defaultLocale : k,
      __locale : null,
      __language : null,
      __translations : null,
      __locales : null,
      __clientLocale : null,
      /**
       * Get the language code of the current locale
       *
       * This is the first part of a locale definition. The language for "de_DE" would be "de"
       *
       * @return {String} language code
       */
      getLanguage : function(){

        return this.__language;
      },
      /**
       * Get the territory code of the current locale
       *
       * This is the second part of a locale definition. The territory for "de_DE" would be "DE"
       *
       * @return {String} territory code
       */
      getTerritory : function(){

        return this.getLocale().split(a)[1] || d;
      },
      /**
       * Return the available application locales
       *
       * This corresponds to the LOCALES setting in config.json. Without argument,
       * it only returns the currently loaded locales, with an argument of true
       * all locales that went into the build. This is particularly interesting if
       * locales were generated as dedicated I18N parts, and have to be loaded
       * explicitly before being available.
       *
       * @param includeNonloaded {Boolean?null} include locales not yet loaded
       * @return {String[]} array of available locales
       */
      getAvailableLocales : function(E){

        var G = [];
        for(var F in this.__locales){

          if(F != this.__defaultLocale){

            if(this.__locales[F] === null && !E){

              continue;
            };
            G.push(F);
          };
        };
        return G;
      },
      /**
       * Extract the language part from a locale.
       *
       * @param locale {String} locale to be used
       * @return {String} language
       */
      __extractLanguage : function(H){

        var J;
        if(H == null){

          return null;
        };
        var I = H.indexOf(a);
        if(I == -1){

          J = H;
        } else {

          J = H.substring(0, I);
        };
        return J;
      },
      // property apply
      _applyLocale : function(K, L){

        if(qx.core.Environment.get(c)){

          if(!(K in this.__locales || K == this.__clientLocale)){

            qx.log.Logger.warn(l + K + g);
          };
        };
        this.__locale = K;
        this.__language = this.__extractLanguage(K);
      },
      /**
       * Add a translation to the translation manager.
       *
       * If <code>languageCode</code> already exists, its map will be updated with
       * <code>translationMap</code> (new keys will be added, existing keys will be
       * overwritten).
       *
       * @param languageCode {String} language code of the translation like <i>de, de_AT, en, en_GB, fr, ...</i>
       * @param translationMap {Map} mapping of message identifiers to message strings in the target
       *                             language, e.g. <i>{"greeting_short" : "Hello"}</i>. Plural forms
       *                             are separate keys.
       * @return {void}
       */
      addTranslation : function(M, N){

        var O = this.__translations;
        if(O[M]){

          for(var P in N){

            O[M][P] = N[P];
          };
        } else {

          O[M] = N;
        };
      },
      /**
       * Add a localization to the localization manager.
       *
       * If <code>localeCode</code> already exists, its map will be updated with
       * <code>localeMap</code> (new keys will be added, existing keys will be overwritten).
       *
       * @param localeCode {String} locale code of the translation like <i>de, de_AT, en, en_GB, fr, ...</i>
       * @param localeMap {Map} mapping of locale keys to the target locale values, e.g.
       *                        <i>{"cldr_date_format_short" : "M/d/yy"}</i>.
       * @return {void}
       */
      addLocale : function(Q, R){

        var S = this.__locales;
        if(S[Q]){

          for(var T in R){

            S[Q][T] = R[T];
          };
        } else {

          S[Q] = R;
        };
      },
      /**
       * Translate a message using the current locale and apply format string to the arguments.
       *
       * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->
       * default locale (e.g. C). Localizes the arguments if possible and splices
       * them into the message. If qx.dynlocale is on, returns a {@link
       * LocalizedString}.
       *
       * @param messageId {String} message id (may contain format strings)
       * @param args {Object[]} array of objects, which are inserted into the format string
       * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}
       * @return {String | LocalizedString} translated message or localized string
       */
      translate : function(U, V, W){

        var X = this.__translations;
        return this.__lookupAndExpand(X, U, V, W);
      },
      /**
       * Provide localisation (CLDR) data.
       *
       * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->
       * default locale (e.g. C). Localizes the arguments if possible and splices
       * them into the message. If qx.dynlocale is on, returns a {@link
       * LocalizedString}.
       *
       * @param messageId {String} message id (may contain format strings)
       * @param args {Object[]} array of objects, which are inserted into the format string
       * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}
       * @return {String | LocalizedString} translated message or localized string
       */
      localize : function(Y, ba, bb){

        var bc = this.__locales;
        return this.__lookupAndExpand(bc, Y, ba, bb);
      },
      /**
       * Look up an I18N key in a catalog and expand format strings.
       *
       * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->
       * default locale (e.g. C). Localizes the arguments if possible and splices
       * them into the message. If qx.dynlocale is on, returns a {@link
       * LocalizedString}.
       *
       * @param catalog {Map} map of I18N keys and their values
       * @param messageId {String} message id (may contain format strings)
       * @param args {Object[]} array of objects, which are inserted into the format string
       * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}
       * @return {String | LocalizedString} translated message or localized string
       */
      __lookupAndExpand : function(bd, be, bf, bg){

        if(qx.core.Environment.get(c)){

          this.assertObject(bd);
          this.assertString(be);
          this.assertArray(bf);
        };
        var bh;
        if(!bd){

          return be;
        };
        if(bg){

          var bj = this.__extractLanguage(bg);
        } else {

          bg = this.__locale;
          bj = this.__language;
        };
        // e.g. DE_at
        if(!bh && bd[bg]){

          bh = bd[bg][be];
        };
        // e.g. DE
        if(!bh && bd[bj]){

          bh = bd[bj][be];
        };
        // C
        if(!bh && bd[this.__defaultLocale]){

          bh = bd[this.__defaultLocale][be];
        };
        if(!bh){

          bh = be;
        };
        if(bf.length > 0){

          var bi = [];
          for(var i = 0;i < bf.length;i++){

            var bk = bf[i];
            if(bk && bk.translate){

              bi[i] = bk.translate();
            } else {

              bi[i] = bk;
            };
          };
          bh = qx.lang.String.format(bh, bi);
        };
        if(qx.core.Environment.get(h)){

          bh = new qx.locale.LocalizedString(bh, be, bf);
        };
        return bh;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__translations = this.__locales = null;
    }
  });
})();
(function(){

  var f = "qx.bom.client.Locale",e = "locale",d = "android",c = "locale.variant",b = "-",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class comes with all relevant information regarding
   * the client's selected locale.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(f, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * The name of the system locale e.g. "de" when the full locale is "de_AT"
       * @return {String} The current locale
       * @internal
       */
      getLocale : function(){

        var g = qx.bom.client.Locale.__getNavigatorLocale();
        var h = g.indexOf(b);
        if(h != -1){

          g = g.substr(0, h);
        };
        return g;
      },
      /**
       * The name of the variant for the system locale e.g. "at" when the
       * full locale is "de_AT"
       *
       * @return {String} The locales variant.
       * @internal
       */
      getVariant : function(){

        var i = qx.bom.client.Locale.__getNavigatorLocale();
        var k = a;
        var j = i.indexOf(b);
        if(j != -1){

          k = i.substr(j + 1);
        };
        return k;
      },
      /**
       * Internal helper for accessing the navigators language.
       *
       * @return {String} The language set by the navigator.
       */
      __getNavigatorLocale : function(){

        var l = (navigator.userLanguage || navigator.language || a);
        // Android Bug: Android does not return the system language from the
        // navigator language. Try to parse the language from the userAgent.
        // See http://code.google.com/p/android/issues/detail?id=4641
        if(qx.bom.client.OperatingSystem.getName() == d){

          var m = /(\w{2})-(\w{2})/i.exec(navigator.userAgent);
          if(m){

            l = m[0];
          };
        };
        return l.toLowerCase();
      }
    },
    defer : function(n){

      qx.core.Environment.add(e, n.getLocale);
      qx.core.Environment.add(c, n.getVariant);
    }
  });
})();
(function(){

  var k = "qx/icon",j = ".png",i = "crop",h = "engine.version",g = "Potential clipped image candidate: ",f = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='",d = '<div style="',c = "repeat-y",b = '<img src="',a = "qx.bom.element.Decoration",N = "Image modification not possible because elements could not be replaced at runtime anymore!",M = "', sizingMethod='",L = "'!",K = '"/>',J = "png",I = "')",H = '"></div>',G = '" style="',F = "none",E = "ImageLoader: Not recognized format of external image '",r = "webkit",s = " ",p = "repeat-x",q = "DXImageTransform.Microsoft.AlphaImageLoader",n = "qx/static/blank.gif",o = "absolute",l = "repeat",m = "scale",t = "mshtml",u = "b64",x = "scale-y",w = "no-repeat",z = "qx.debug",y = "scale-x",B = "",A = "engine.name",v = "div",D = "img",C = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  /**
   * Powerful creation and update features for images used for decoration
   * purposes like for rounded borders, icons, etc.
   *
   * Includes support for image clipping, PNG alpha channel support, additional
   * repeat options like <code>scale-x</code> or <code>scale-y</code>.
   */
  qx.Class.define(a, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Boolean} Whether clipping hints should be logged */
      DEBUG : false,
      /** {Map} Collect warnings for potential clipped images */
      __warnings : {
      },
      /**
       * {Boolean} Whether the alpha image loader is needed.
       * We enable this for all IE browser because of issues reported by Maria
       * Siebert and others in combination with the opacity filter applied
       * to e.g. disabled icons. Thanks Maria.
       *
       * To prevent these issues use the "disabled" images. This is done by adding
       * a special second image which is already in a disabled state. In order to
       * make use of this feature the image has to follow the convention "-disabled".
       * (e.g. "button.png" -> "button-disabled.png")
       *
       * The situation for IE8 is that running in "IE8 Standards Mode" IE8 has a
       * runtime performance issue. The updates are compared to IE7 really slow.
       * The cause for this is the dynamic adding/removing of the IMG elements
       * which are part of the decorator. Using the alpha image loader does change
       * this DOM structure to only use DIV elements which do not have a negative
       * performance impact. See Bug #2185 for details.
       */
      __enableAlphaFix : (qx.core.Environment.get(A) == t) && qx.core.Environment.get(h) < 9,
      /** {Map} List of repeat modes which supports the IE AlphaImageLoader */
      __alphaFixRepeats : qx.core.Environment.select(A, {
        "mshtml" : {
          "scale-x" : true,
          "scale-y" : true,
          "scale" : true,
          "no-repeat" : true
        },
        "default" : null
      }),
      /** {Map} Mapping between background repeat and the tag to create */
      __repeatToTagname : {
        "scale-x" : D,
        "scale-y" : D,
        "scale" : D,
        "repeat" : v,
        "no-repeat" : v,
        "repeat-x" : v,
        "repeat-y" : v
      },
      /**
       * Updates the element to display the given source
       * with the repeat option.
       *
       * @param element {Element} DOM element to update
       * @param source {String} Any valid URI
       * @param repeat {String} One of <code>scale-x</code>, <code>scale-y</code>,
       *   <code>scale</code>, <code>repeat</code>, <code>repeat-x</code>,
       *   <code>repeat-y</code>, <code>repeat</code>
       * @param style {Map} Additional styles to apply
       */
      update : function(O, P, Q, R){

        var T = this.getTagName(Q, P);
        if(T != O.tagName.toLowerCase()){

          throw new Error(N);
        };
        var U = this.getAttributes(P, Q, R);
        if(T === D){

          O.src = U.src || qx.util.ResourceManager.getInstance().toUri(n);
        };
        // Fix for old background position
        if(O.style.backgroundPosition != B && U.style.backgroundPosition === undefined){

          U.style.backgroundPosition = null;
        };
        // Fix for old clip
        if(O.style.clip != B && U.style.clip === undefined){

          U.style.clip = null;
        };
        // Apply new styles
        var S = qx.bom.element.Style;
        S.setStyles(O, U.style);
        // we need to apply the filter to prevent black rendering artifacts
        // http://blog.hackedbrain.com/archive/2007/05/21/6110.aspx
        if(this.__enableAlphaFix){

          try{

            O.filters[q].apply();
          } catch(e) {
          };
        };
      },
      /**
       * Creates a decorator image element with the given options.
       *
       * @param source {String} Any valid URI
       * @param repeat {String} One of <code>scale-x</code>, <code>scale-y</code>,
       *   <code>scale</code>, <code>repeat</code>, <code>repeat-x</code>,
       *   <code>repeat-y</code>, <code>repeat</code>
       * @param style {Map} Additional styles to apply
       */
      create : function(V, W, X){

        var Y = this.getTagName(W, V);
        var bb = this.getAttributes(V, W, X);
        var ba = qx.bom.element.Style.compile(bb.style);
        if(Y === D){

          return b + bb.src + G + ba + K;
        } else {

          return d + ba + H;
        };
      },
      /**
       * Translates the given repeat option to a tag name. Useful
       * for systems which depends on early information of the tag
       * name to prepare element like {@link qx.html.Image}.
       *
       * @param repeat {String} One of <code>scale-x</code>, <code>scale-y</code>,
       *   <code>scale</code>, <code>repeat</code>, <code>repeat-x</code>,
       *   <code>repeat-y</code>, <code>repeat</code>
       * @param source {String?null} Source used to identify the image format
       * @return {String} The tag name: <code>div</code> or <code>img</code>
       */
      getTagName : function(bc, bd){

        if(bd && this.__enableAlphaFix && this.__alphaFixRepeats[bc] && qx.lang.String.endsWith(bd, j)){

          return v;
        };
        return this.__repeatToTagname[bc];
      },
      /**
       * This method is used to collect all needed attributes for
       * the tag name detected by {@link #getTagName}.
       *
       * @param source {String} Image source
       * @param repeat {String} Repeat mode of the image
       * @param style {Map} Additional styles to apply
       * @return {String} Markup for image
       */
      getAttributes : function(be, bf, bh){

        if(!bh){

          bh = {
          };
        };
        if(!bh.position){

          bh.position = o;
        };
        if((qx.core.Environment.get(A) == t)){

          // Add a fix for small blocks where IE has a minHeight
          // of the fontSize in quirks mode
          bh.fontSize = 0;
          bh.lineHeight = 0;
        } else if((qx.core.Environment.get(A) == r)){

          // This stops images from being dragable in webkit
          bh.WebkitUserDrag = F;
        };
        var bj = qx.util.ResourceManager.getInstance().getImageFormat(be) || qx.io.ImageLoader.getFormat(be);
        if(qx.core.Environment.get(z)){

          if(be != null && bj == null){

            qx.log.Logger.warn(E + be + L);
          };
        };
        var bi;
        // Enable AlphaImageLoader in IE6/IE7/IE8
        if(this.__enableAlphaFix && this.__alphaFixRepeats[bf] && bj === J){

          bi = this.__processAlphaFix(bh, bf, be);
        } else {

          if(bf === m){

            bi = this.__processScale(bh, bf, be);
          } else if(bf === y || bf === x){

            bi = this.__processScaleXScaleY(bh, bf, be);
          } else {

            // Native repeats or "no-repeat"
            bi = this.__processRepeats(bh, bf, be);
          };
        };
        return bi;
      },
      /**
       * Normalize the given width and height values
       *
       * @param style {Map} style information
       * @param width {Integer?null} width as number or null
       * @param height {Integer?null} height as number or null
       */
      __normalizeWidthHeight : function(bk, bl, bm){

        if(bk.width == null && bl != null){

          bk.width = bl + C;
        };
        if(bk.height == null && bm != null){

          bk.height = bm + C;
        };
        return bk;
      },
      /**
       * Returns the dimension of the image by calling
       * {@link qx.util.ResourceManager} or {@link qx.io.ImageLoader}
       * depending on if the image is a managed one.
       *
       * @param source {String} image source
       * @return {Map} dimension of image
       */
      __getDimension : function(bn){

        var bo = qx.util.ResourceManager.getInstance().getImageWidth(bn) || qx.io.ImageLoader.getWidth(bn);
        var bp = qx.util.ResourceManager.getInstance().getImageHeight(bn) || qx.io.ImageLoader.getHeight(bn);
        return {
          width : bo,
          height : bp
        };
      },
      /**
       * Get all styles for IE browser which need to load the image
       * with the help of the AlphaImageLoader
       *
       * @param style {Map} style information
       * @param repeat {String} repeat mode
       * @param source {String} image source
       *
       * @return {Map} style infos
       */
      __processAlphaFix : function(bq, br, bs){

        var bv = this.__getDimension(bs);
        bq = this.__normalizeWidthHeight(bq, bv.width, bv.height);
        var bu = br == w ? i : m;
        var bt = f + qx.util.ResourceManager.getInstance().toUri(bs) + M + bu + I;
        bq.filter = bt;
        bq.backgroundImage = bq.backgroundRepeat = B;
        return {
          style : bq
        };
      },
      /**
       * Process scaled images.
       *
       * @param style {Map} style information
       * @param repeat {String} repeat mode
       * @param source {String} image source
       *
       * @return {Map} image URI and style infos
       */
      __processScale : function(bw, bx, by){

        var bz = qx.util.ResourceManager.getInstance().toUri(by);
        var bA = this.__getDimension(by);
        bw = this.__normalizeWidthHeight(bw, bA.width, bA.height);
        return {
          src : bz,
          style : bw
        };
      },
      /**
       * Process images which are either scaled horizontally or
       * vertically.
       *
       * @param style {Map} style information
       * @param repeat {String} repeat mode
       * @param sourceid {String} image resource id
       *
       * @return {Map} image URI and style infos
       */
      __processScaleXScaleY : function(bB, bC, bD){

        var bE = qx.util.ResourceManager.getInstance();
        var bH = bE.getCombinedFormat(bD);
        var bJ = this.__getDimension(bD);
        var bF;
        if(bH){

          var bI = bE.getData(bD);
          var bG = bI[4];
          if(bH == u){

            bF = bE.toDataUri(bD);
          } else {

            bF = bE.toUri(bG);
          };
          if(bC === y){

            bB = this.__getStylesForClippedScaleX(bB, bI, bJ.height);
          } else {

            bB = this.__getStylesForClippedScaleY(bB, bI, bJ.width);
          };
          return {
            src : bF,
            style : bB
          };
        } else {

          if(qx.core.Environment.get(z)){

            this.__checkForPotentialClippedImage(bD);
          };
          if(bC == y){

            bB.height = bJ.height == null ? null : bJ.height + C;
          } else if(bC == x){

            bB.width = bJ.width == null ? null : bJ.width + C;
          };
          bF = bE.toUri(bD);
          return {
            src : bF,
            style : bB
          };
        };
      },
      /**
       * Generates the style infos for horizontally scaled clipped images.
       *
       * @param style {Map} style infos
       * @param data {Array} image data retrieved from the {@link qx.util.ResourceManager}
       * @param height {Integer} image height
       *
       * @return {Map} style infos and image URI
       */
      __getStylesForClippedScaleX : function(bK, bL, bM){

        // Use clipped image (multi-images on x-axis)
        var bN = qx.util.ResourceManager.getInstance().getImageHeight(bL[4]);
        // Add size and clipping
        bK.clip = {
          top : -bL[6],
          height : bM
        };
        bK.height = bN + C;
        // note: width is given by the user
        // Fix user given y-coordinate to include the combined image offset
        if(bK.top != null){

          bK.top = (parseInt(bK.top, 10) + bL[6]) + C;
        } else if(bK.bottom != null){

          bK.bottom = (parseInt(bK.bottom, 10) + bM - bN - bL[6]) + C;
        };
        return bK;
      },
      /**
       * Generates the style infos for vertically scaled clipped images.
       *
       * @param style {Map} style infos
       * @param data {Array} image data retrieved from the {@link qx.util.ResourceManager}
       * @param width {Integer} image width
       *
       * @return {Map} style infos and image URI
       */
      __getStylesForClippedScaleY : function(bO, bP, bQ){

        // Use clipped image (multi-images on x-axis)
        var bR = qx.util.ResourceManager.getInstance().getImageWidth(bP[4]);
        // Add size and clipping
        bO.clip = {
          left : -bP[5],
          width : bQ
        };
        bO.width = bR + C;
        // note: height is given by the user
        // Fix user given x-coordinate to include the combined image offset
        if(bO.left != null){

          bO.left = (parseInt(bO.left, 10) + bP[5]) + C;
        } else if(bO.right != null){

          bO.right = (parseInt(bO.right, 10) + bQ - bR - bP[5]) + C;
        };
        return bO;
      },
      /**
       * Process repeated images.
       *
       * @param style {Map} style information
       * @param repeat {String} repeat mode
       * @param sourceid {String} image resource id
       *
       * @return {Map} image URI and style infos
       */
      __processRepeats : function(bS, bT, bU){

        var bX = qx.util.ResourceManager.getInstance();
        var cd = bX.getCombinedFormat(bU);
        var cf = this.__getDimension(bU);
        // Double axis repeats cannot be clipped
        if(cd && bT !== l){

          // data = [ 8, 5, "png", "qx", "qx/decoration/Modern/arrows-combined.png", -36, 0]
          var ce = bX.getData(bU);
          var cc = ce[4];
          if(cd == u){

            var cb = bX.toDataUri(bU);
            var ca = 0;
            var bY = 0;
          } else {

            var cb = bX.toUri(cc);
            var ca = ce[5];
            var bY = ce[6];
          };
          var bV = qx.bom.element.Background.getStyles(cb, bT, ca, bY);
          for(var bW in bV){

            bS[bW] = bV[bW];
          };
          if(cf.width != null && bS.width == null && (bT == c || bT === w)){

            bS.width = cf.width + C;
          };
          if(cf.height != null && bS.height == null && (bT == p || bT === w)){

            bS.height = cf.height + C;
          };
          return {
            style : bS
          };
        } else {

          if(qx.core.Environment.get(z)){

            if(bT !== l){

              this.__checkForPotentialClippedImage(bU);
            };
          };
          bS = this.__normalizeWidthHeight(bS, cf.width, cf.height);
          bS = this.__getStylesForSingleRepeat(bS, bU, bT);
          return {
            style : bS
          };
        };
      },
      /**
       * Generate all style infos for single repeated images
       *
       * @param style {Map} style information
       * @param repeat {String} repeat mode
       * @param source {String} image source
       *
       * @return {Map} style infos
       */
      __getStylesForSingleRepeat : function(cg, ch, ci){

        // retrieve the "backgroundPosition" style if available to prevent
        // overwriting with default values
        var top = null;
        var cm = null;
        if(cg.backgroundPosition){

          var cj = cg.backgroundPosition.split(s);
          cm = parseInt(cj[0], 10);
          if(isNaN(cm)){

            cm = cj[0];
          };
          top = parseInt(cj[1], 10);
          if(isNaN(top)){

            top = cj[1];
          };
        };
        var cl = qx.bom.element.Background.getStyles(ch, ci, cm, top);
        for(var ck in cl){

          cg[ck] = cl[ck];
        };
        // Reset the AlphaImageLoader filter if applied
        // This prevents IE from setting BOTH CSS filter AND backgroundImage
        // This is only a fallback if the image is not recognized as PNG
        // If it's a Alpha-PNG file it *may* result in display problems
        if(cg.filter){

          cg.filter = B;
        };
        return cg;
      },
      /**
       * Output a warning if the image can be clipped.
       *
       * @param source {String} image source
       */
      __checkForPotentialClippedImage : function(cn){

        if(this.DEBUG && qx.util.ResourceManager.getInstance().has(cn) && cn.indexOf(k) == -1){

          if(!this.__warnings[cn]){

            qx.log.Logger.debug(g + cn);
            this.__warnings[cn] = true;
          };
        };
      },
      /**
       * For IE browsers the alpha image loader might be necessary. This accessor
       * method provides an API for high-level classes to check if the alpha image
       * loader is enabled.
       *
       * @return {Boolean} <code>true</code> when the AlphaImageLoader is used, <code>false</code> otherwise.
       */
      isAlphaImageLoaderEnabled : function(){

        return qx.bom.element.Decoration.__enableAlphaFix;
      }
    }
  });
})();
(function(){

  var c = "load",b = "qx.io.ImageLoader",a = "html.image.naturaldimensions";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * The ImageLoader can preload and manage loaded image resources. It easily
   * handles multiple requests and supports callbacks for successful and failed
   * requests.
   *
   * After loading of an image the dimension of the image is stored as long
   * as the application is running. This is quite useful for in-memory layouting.
   *
   * Use {@link #load} to preload your own images.
   */
  qx.Bootstrap.define(b, {
    statics : {
      /** {Map} Internal data structure to cache image sizes */
      __data : {
      },
      /** {Map} Default image size */
      __defaultSize : {
        width : null,
        height : null
      },
      /** {RegExp} Known image types */
      __knownImageTypesRegExp : /\.(png|gif|jpg|jpeg|bmp)\b/i,
      /** {RegExp} Image types of a data URL */
      __dataUrlRegExp : /^data:image\/(png|gif|jpg|jpeg|bmp)\b/i,
      /**
       * Whether the given image has previously been loaded using the
       * {@link #load} method.
       *
       * @param source {String} Image source to query
       * @return {Boolean} <code>true</code> when the image is loaded
       */
      isLoaded : function(d){

        var e = this.__data[d];
        return !!(e && e.loaded);
      },
      /**
       * Whether the given image has previously been requested using the
       * {@link #load} method but failed.
       *
       * @param source {String} Image source to query
       * @return {Boolean} <code>true</code> when the image loading failed
       */
      isFailed : function(f){

        var g = this.__data[f];
        return !!(g && g.failed);
      },
      /**
       * Whether the given image is currently loading.
       *
       * @param source {String} Image source to query
       * @return {Boolean} <code>true</code> when the image is loading in the moment.
       */
      isLoading : function(h){

        var j = this.__data[h];
        return !!(j && j.loading);
      },
      /**
       * Returns the format of a previously loaded image
       *
       * @param source {String} Image source to query
       * @return {String ? null} The format of the image or <code>null</code>
       */
      getFormat : function(k){

        var m = this.__data[k];
        if(!m || !m.format){

          var o = this.__dataUrlRegExp.exec(k);
          if(o != null){

            // If width and height aren't defined, provide some defaults
            var p = (m && qx.lang.Type.isNumber(m.width) ? m.width : this.__defaultSize.width);
            var n = (m && qx.lang.Type.isNumber(m.height) ? m.height : this.__defaultSize.height);
            m = {
              loaded : true,
              format : o[1],
              width : p,
              height : n
            };
          };
        };
        return m ? m.format : null;
      },
      /**
       * Returns the size of a previously loaded image
       *
       * @param source {String} Image source to query
       * @return {Map} The dimension of the image (<code>width</code> and
       *    <code>height</code> as key). If the image is not yet loaded, the
       *    dimensions are given as <code>null</code> for width and height.
       */
      getSize : function(q){

        var r = this.__data[q];
        return r ? {
          width : r.width,
          height : r.height
        } : this.__defaultSize;
      },
      /**
       * Returns the image width
       *
       * @param source {String} Image source to query
       * @return {Integer} The width or <code>null</code> when the image is not loaded
       */
      getWidth : function(s){

        var t = this.__data[s];
        return t ? t.width : null;
      },
      /**
       * Returns the image height
       *
       * @param source {String} Image source to query
       * @return {Integer} The height or <code>null</code> when the image is not loaded
       */
      getHeight : function(u){

        var v = this.__data[u];
        return v ? v.height : null;
      },
      /**
       * Loads the given image. Supports a callback which is
       * executed when the image is loaded.
       *
       * This method works asychronous.
       *
       * @param source {String} Image source to load
       * @param callback {Function} Callback function to execute
       *   The first parameter of the callback is the given source url, the
       *   second parameter is the data entry which contains additional
       *   information about the image.
       * @param context {Object} Context in which the given callback should be executed
       */
      load : function(w, x, y){

        // Shorthand
        var z = this.__data[w];
        if(!z){

          z = this.__data[w] = {
          };
        };
        // Normalize context
        if(x && !y){

          y = window;
        };
        // Already known image source
        if(z.loaded || z.loading || z.failed){

          if(x){

            if(z.loading){

              z.callbacks.push(x, y);
            } else {

              x.call(y, w, z);
            };
          };
        } else {

          // Updating entry
          z.loading = true;
          z.callbacks = [];
          if(x){

            z.callbacks.push(x, y);
          };
          // Create image element
          var B = new Image();
          // Create common callback routine
          var A = qx.lang.Function.listener(this.__onload, this, B, w);
          // Assign callback to element
          B.onload = A;
          B.onerror = A;
          // Start loading of image
          B.src = w;
          // save the element for aborting
          z.element = B;
        };
      },
      /**
       * Abort the loading for the given url.
       *
       * @param source {String} URL of the image to abort its loading.
       */
      abort : function(C){

        var D = this.__data[C];
        if(D && !D.loaded){

          D.aborted = true;
          var F = D.callbacks;
          var E = D.element;
          // Cleanup listeners
          E.onload = E.onerror = null;
          // Cleanup entry
          delete D.callbacks;
          delete D.element;
          delete D.loading;
          for(var i = 0,l = F.length;i < l;i += 2){

            F[i].call(F[i + 1], C, D);
          };
        };
        this.__data[C] = null;
      },
      /**
       * Internal event listener for all load/error events.
       *
       * @signature function(event, element, source)
       *
       * @param event {Event} Native event object
       * @param element {Element} DOM element which represents the image
       * @param source {String} The image source loaded
       */
      __onload : qx.event.GlobalError.observeMethod(function(event, G, H){

        // Shorthand
        var I = this.__data[H];
        // Store dimensions
        if(event.type === c){

          I.loaded = true;
          I.width = this.__getWidth(G);
          I.height = this.__getHeight(G);
          // try to determine the image format
          var J = this.__knownImageTypesRegExp.exec(H);
          if(J != null){

            I.format = J[1];
          };
        } else {

          I.failed = true;
        };
        // Cleanup listeners
        G.onload = G.onerror = null;
        // Cache callbacks
        var K = I.callbacks;
        // Cleanup entry
        delete I.loading;
        delete I.callbacks;
        delete I.element;
        // Execute callbacks
        for(var i = 0,l = K.length;i < l;i += 2){

          K[i].call(K[i + 1], H, I);
        };
      }),
      /**
       * Returns the natural width of the given image element.
       *
       * @param element {Element} DOM element which represents the image
       * @return {Integer} Image width
       */
      __getWidth : function(L){

        return qx.core.Environment.get(a) ? L.naturalWidth : L.width;
      },
      /**
       * Returns the natural height of the given image element.
       *
       * @param element {Element} DOM element which represents the image
       * @return {Integer} Image height
       */
      __getHeight : function(M){

        return qx.core.Environment.get(a) ? M.naturalHeight : M.height;
      }
    }
  });
})();
(function(){

  var u = "')",t = "gecko",s = "background-image:url(",r = ");",q = "",p = ")",o = "background-repeat:",n = "engine.version",m = "data:",l = " ",e = "qx.bom.element.Background",k = "url(",h = "background-position:",c = "base64",b = "url('",g = "engine.name",f = "0",i = "px",a = ";",j = "'",d = "number";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * The background class contains methods to compute and set the background image
   * of a DOM element.
   *
   * It fixes a background position issue in Firefox 2.
   */
  qx.Class.define(e, {
    statics : {
      /** {Array} Internal helper to improve compile performance */
      __tmpl : [s, null, r, h, null, a, o, null, a],
      /** {Map} Empty styles when no image is given */
      __emptyStyles : {
        backgroundImage : null,
        backgroundPosition : null,
        backgroundRepeat : null
      },
      /**
       * Computes the background position CSS value
       *
       * @param left {Integer|String} either an integer pixel value or a CSS
       *    string value
       * @param top {Integer|String} either an integer pixel value or a CSS
       *    string value
       * @return {String} The background position CSS value
       */
      __computePosition : function(v, top){

        // Correcting buggy Firefox background-position implementation
        // Have problems with identical values
        var w = qx.core.Environment.get(g);
        var x = qx.core.Environment.get(n);
        if(w == t && x < 1.9 && v == top && typeof v == d){

          top += 0.01;
        };
        if(v){

          var z = (typeof v == d) ? v + i : v;
        } else {

          z = f;
        };
        if(top){

          var y = (typeof top == d) ? top + i : top;
        } else {

          y = f;
        };
        return z + l + y;
      },
      /**
       * Checks if the given image URL is a base64-encoded one.
       *
       * @param url {String} image url to check for
       * @return {Boolean} whether it is a base64-encoded image url
       */
      __isBase64EncodedImage : function(A){

        var String = qx.lang.String;
        // only check the first 50 characters for performance, since we do not
        // know how long a base64 image url can be.
        var B = A.substr(0, 50);
        return String.startsWith(B, m) && String.contains(B, c);
      },
      /**
       * Compiles the background into a CSS compatible string.
       *
       * @param source {String?null} The URL of the background image
       * @param repeat {String?null} The background repeat property. valid values
       *     are <code>repeat</code>, <code>repeat-x</code>,
       *     <code>repeat-y</code>, <code>no-repeat</code>
       * @param left {Integer|String?null} The horizontal offset of the image
       *      inside of the image element. If the value is an integer it is
       *      interpreted as pixel value otherwise the value is taken as CSS value.
       *      CSS the values are "center", "left" and "right"
       * @param top {Integer|String?null} The vertical offset of the image
       *      inside of the image element. If the value is an integer it is
       *      interpreted as pixel value otherwise the value is taken as CSS value.
       *      CSS the values are "top", "bottom" and "center"
       * @return {String} CSS string
       */
      compile : function(C, D, E, top){

        var F = this.__computePosition(E, top);
        var G = qx.util.ResourceManager.getInstance().toUri(C);
        if(this.__isBase64EncodedImage(G)){

          G = j + G + j;
        };
        // Updating template
        var H = this.__tmpl;
        H[1] = G;
        H[4] = F;
        H[7] = D;
        return H.join(q);
      },
      /**
       * Get standard css background styles
       *
       * @param source {String} The URL of the background image
       * @param repeat {String?null} The background repeat property. valid values
       *     are <code>repeat</code>, <code>repeat-x</code>,
       *     <code>repeat-y</code>, <code>no-repeat</code>
       * @param left {Integer|String?null} The horizontal offset of the image
       *      inside of the image element. If the value is an integer it is
       *      interpreted as pixel value otherwise the value is taken as CSS value.
       *      CSS the values are "center", "left" and "right"
       * @param top {Integer|String?null} The vertical offset of the image
       *      inside of the image element. If the value is an integer it is
       *      interpreted as pixel value otherwise the value is taken as CSS value.
       *      CSS the values are "top", "bottom" and "center"
       * @return {Map} A map of CSS styles
       */
      getStyles : function(I, J, K, top){

        if(!I){

          return this.__emptyStyles;
        };
        var L = this.__computePosition(K, top);
        var N = qx.util.ResourceManager.getInstance().toUri(I);
        var O;
        if(this.__isBase64EncodedImage(N)){

          O = b + N + u;
        } else {

          O = k + N + p;
        };
        var M = {
          backgroundPosition : L,
          backgroundImage : O
        };
        if(J != null){

          M.backgroundRepeat = J;
        };
        return M;
      },
      /**
       * Set the background on the given DOM element
       *
       * @param element {Element} The element to modify
       * @param source {String?null} The URL of the background image
       * @param repeat {String?null} The background repeat property. valid values
       *     are <code>repeat</code>, <code>repeat-x</code>,
       *     <code>repeat-y</code>, <code>no-repeat</code>
       * @param left {Integer?null} The horizontal offset of the image inside of
       *     the image element.
       * @param top {Integer?null} The vertical offset of the image inside of
       *     the image element.
       */
      set : function(P, Q, R, S, top){

        var T = this.getStyles(Q, R, S, top);
        for(var U in T){

          P.style[U] = T[U];
        };
      }
    }
  });
})();
(function(){

  var k = "",j = "mshtml",i = "backgroundImage",h = "webkit",g = "div",f = "qx.html.Image",e = "qx/static/blank.gif",d = "engine.name",c = "no-repeat",b = "scale",a = "source";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This is a simple image class using the low level image features of
   * qooxdoo and wraps it for the qx.html layer.
   */
  qx.Class.define(f, {
    extend : qx.html.Element,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // this member variable is only used for IE browsers to be able
      // to the tag name which will be set. This is heavily connected to the runtime
      // change of decorators and the use of external (=unmanaged images). It is
      // necessary to be able to determine what tag will be used e.g. before the
      // ImageLoader has finished its loading of an external image.
      // See Bug #3894 for more details
      tagNameHint : null,
      /*
      ---------------------------------------------------------------------------
        ELEMENT API
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyProperty : function(name, l){

        qx.html.Element.prototype._applyProperty.call(this, name, l);
        if(name === a){

          var p = this.getDomElement();
          // To prevent any wrong background-position or -repeat it is necessary
          // to reset those styles whenever a background-image is updated.
          // This is only necessary if any backgroundImage was set already.
          // See bug #3376 for details
          var m = this.getAllStyles();
          if(this.getNodeName() == g && this.getStyle(i)){

            m.backgroundPosition = null;
            m.backgroundRepeat = null;
          };
          var n = this._getProperty(a);
          var o = this._getProperty(b);
          var q = o ? b : c;
          // Source can be null in certain circumstances.
          // See bug #3701 for details.
          if(n != null){

            // Normalize "" to null
            n = n || null;
            qx.bom.element.Decoration.update(p, n, q, m);
          };
        };
      },
      // overridden
      _removeProperty : function(r, s){

        if(r == a){

          // Work-around check for null in #_applyProperty, introduced with fix
          // for bug #3701. Use empty string that is later normalized to null.
          // This fixes bug #4524.
          this._setProperty(r, k, s);
        } else {

          this._setProperty(r, null, s);
        };
      },
      // overridden
      _createDomElement : function(){

        var u = this._getProperty(b);
        var v = u ? b : c;
        if((qx.core.Environment.get(d) == j)){

          var t = this._getProperty(a);
          if(this.tagNameHint != null){

            this.setNodeName(this.tagNameHint);
          } else {

            this.setNodeName(qx.bom.element.Decoration.getTagName(v, t));
          };
        } else {

          this.setNodeName(qx.bom.element.Decoration.getTagName(v));
        };
        return qx.html.Element.prototype._createDomElement.call(this);
      },
      // overridden
      // be sure that style attributes are merged and not overwritten
      _copyData : function(w){

        return qx.html.Element.prototype._copyData.call(this, true);
      },
      /*
      ---------------------------------------------------------------------------
        IMAGE API
      ---------------------------------------------------------------------------
      */
      /**
       * Configures the image source
       *
       * @param value {Boolean} Whether the HTML mode should be used.
       * @return {qx.html.Label} This instance for for chaining support.
       */
      setSource : function(x){

        this._setProperty(a, x);
        return this;
      },
      /**
       * Returns the image source.
       *
       * @return {String} Current image source.
       */
      getSource : function(){

        return this._getProperty(a);
      },
      /**
       * Resets the current source to null which means that no image
       * is shown anymore.
       */
      resetSource : function(){

        // webkit browser do not allow to remove the required "src" attribute.
        // If removing the attribute the old image is still visible.
        if((qx.core.Environment.get(d) == h)){

          this._setProperty(a, e);
        } else {

          this._removeProperty(a, true);
        };
        return this;
      },
      /**
       * Whether the image should be scaled or not.
       *
       * @param value {Boolean} Scale the image
       * @return {qx.html.Label} This instance for for chaining support.
       */
      setScale : function(y){

        this._setProperty(b, y);
        return this;
      },
      /**
       * Returns whether the image is scaled or not.
       *
       * @return {Boolean} Whether the image is scaled
       */
      getScale : function(){

        return this._getProperty(b);
      }
    }
  });
})();
(function(){

  var j = "Boolean",i = "bottom-right",h = "' ",g = "widget",f = "qx.ui.core.MPlacement",e = "left-top",d = "[qx.ui.core.MPlacement.setMoveDirection()], the value was '",c = "offsetRight",b = "shorthand",a = "Invalid value for the parameter 'direction' ",F = "offsetLeft",E = "top-left",D = "appear",C = "offsetBottom",B = "top",A = "top-right",z = "offsetTop",y = "but 'top' or 'left' are allowed.",x = "right-bottom",w = "right-top",q = "left-bottom",r = "best-fit",o = "placementRight",p = "placementLeft",m = "mouse",n = "bottom-left",k = "direct",l = "disappear",s = "left",t = "Integer",v = "interval",u = "keep-align";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Methods to place popup like widgets to other widgets, points,
   * mouse event coordinates, etc.
   */
  qx.Mixin.define(f, {
    statics : {
      __visible : null,
      __direction : s,
      /**
       * Set the always visible element. If an element is set, the
       * {@link #moveTo} method takes care of every move and tries not to cover
       * the given element with a movable widget like a popup or context menu.
       *
       * @param elem {qx.ui.core.Widget} The widget which should always be visible.
       */
      setVisibleElement : function(G){

        this.__visible = G;
      },
      /**
       * Returns the given always visible element. See {@link #setVisibleElement}
       * for more details.
       *
       * @return {qx.ui.core.Widget|null} The given widget.
       */
      getVisibleElement : function(){

        return this.__visible;
      },
      /**
       * Set the move direction for an element which hides always visible element.
       * The value has only an effect when the {@link #setVisibleElement} is set.
       *
       * @param direction {String} The direction <code>left</code> or <code>top</code>.
       */
      setMoveDirection : function(H){

        if(H === B || H === s){

          this.__direction = H;
        } else {

          throw new Error(a + d + H + h + y);
        };
      },
      /**
       * Returns the move direction for an element which hides always visible element.
       * See {@link #setMoveDirection} for more details.
       *
       * @return {String} The move direction.
       */
      getMoveDirection : function(){

        return this.__direction;
      }
    },
    properties : {
      /**
       * Position of the aligned object in relation to the opener.
       *
       * Please note than changes to this property are only applied
       * when re-aligning the widget.
       *
       * The first part of the value is the edge to attach to. The second
       * part the alignment of the orthogonal edge after the widget
       * has been attached.
       *
       * The default value "bottom-left" for example means that the
       * widget should be shown directly under the given target and
       * then should be aligned to be left edge:
       *
       * <pre>
       * +--------+
       * | target |
       * +--------+
       * +-------------+
       * |   widget    |
       * +-------------+
       * </pre>
       */
      position : {
        check : [E, A, n, i, e, q, w, x],
        init : n,
        themeable : true
      },
      /**
       * Whether the widget should be placed relative to an other widget or to
       * the mouse cursor.
       */
      placeMethod : {
        check : [g, m],
        init : m,
        themeable : true
      },
      /** Whether the widget should moved using DOM methods. */
      domMove : {
        check : j,
        init : false
      },
      /**
       * Selects the algorithm to place the widget horizontally. <code>direct</code>
       * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>
       * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>
       * uses {@link qx.util.placement.BestFitAxis}.
       */
      placementModeX : {
        check : [k, u, r],
        init : u,
        themeable : true
      },
      /**
       * Selects the algorithm to place the widget vertically. <code>direct</code>
       * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>
       * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>
       * uses {@link qx.util.placement.BestFitAxis}.
       */
      placementModeY : {
        check : [k, u, r],
        init : u,
        themeable : true
      },
      /** Left offset of the mouse pointer (in pixel) */
      offsetLeft : {
        check : t,
        init : 0,
        themeable : true
      },
      /** Top offset of the mouse pointer (in pixel) */
      offsetTop : {
        check : t,
        init : 0,
        themeable : true
      },
      /** Right offset of the mouse pointer (in pixel) */
      offsetRight : {
        check : t,
        init : 0,
        themeable : true
      },
      /** Bottom offset of the mouse pointer (in pixel) */
      offsetBottom : {
        check : t,
        init : 0,
        themeable : true
      },
      /** Offsets in one group */
      offset : {
        group : [z, c, C, F],
        mode : b,
        themeable : true
      }
    },
    members : {
      __ptwLiveUpdater : null,
      __ptwLiveDisappearListener : null,
      __ptwLiveUpdateDisappearListener : null,
      /**
       * Returns the location data like {qx.bom.element.Location#get} does,
       * but does not rely on DOM elements coordinates to be rendered. Instead,
       * this method works with the available layout data available in the moment
       * when it is executed.
       * This works best when called in some type of <code>resize</code> or
       * <code>move</code> event which are supported by all widgets out of the
       * box.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Map} Returns a map with <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code> which contains the distance
       *   of the widget relative coords the document.
       */
      getLayoutLocation : function(I){

        // Use post-layout dimensions
        // which do not rely on the final rendered DOM element
        var L,K,M,top;
        // Add bounds of the widget itself
        K = I.getBounds();
        if(!K){

          return null;
        };
        M = K.left;
        top = K.top;
        // Keep size to protect it for loop
        var N = K;
        // Now loop up with parents until reaching the root
        I = I.getLayoutParent();
        while(I && !I.isRootWidget()){

          // Add coordinates
          K = I.getBounds();
          M += K.left;
          top += K.top;
          // Add insets
          L = I.getInsets();
          M += L.left;
          top += L.top;
          // Next parent
          I = I.getLayoutParent();
        };
        // Add the rendered location of the root widget
        if(I.isRootWidget()){

          var J = I.getContainerLocation();
          if(J){

            M += J.left;
            top += J.top;
          };
        };
        // Build location data
        return {
          left : M,
          top : top,
          right : M + N.width,
          bottom : top + N.height
        };
      },
      /**
       * Sets the position. Uses low-level, high-performance DOM
       * methods when the property {@link #domMove} is enabled.
       * Checks if an always visible element is set and moves the widget to not
       * overlay the always visible widget if possible. The algorithm tries to
       * move the widget as far left as necessary but not of the screen.
       * ({@link #setVisibleElement})
       *
       * @param left {Integer} The left position
       * @param top {Integer} The top position
       */
      moveTo : function(O, top){

        var U = qx.ui.core.MPlacement.getVisibleElement();
        // if we have an always visible element
        if(U){

          var T = this.getBounds();
          var S = U.getContentLocation();
          // if we have bounds for both elements
          if(T && S){

            var R = top + T.height;
            var Q = O + T.width;
            // horizontal placement wrong
            // each number is for the upcomming check (huge element is
            // the always visible, eleme prefixed)
            //     | 3 |
            //   ---------
            //   | |---| |
            //   |       |
            // --|-|   |-|--
            // 1 | |   | | 2
            // --|-|   |-|--
            //   |       |
            //   | |---| |
            //   ---------
            //     | 4 |
            if((Q > S.left && O < S.right) && (R > S.top && top < S.bottom)){

              var P = qx.ui.core.MPlacement.getMoveDirection();
              if(P === s){

                O = Math.max(S.left - T.width, 0);
              } else {

                top = Math.max(S.top - T.height, 0);
              };
            };
          };
        };
        if(this.getDomMove()){

          this.setDomPosition(O, top);
        } else {

          this.setLayoutProperties({
            left : O,
            top : top
          });
        };
      },
      /**
       * Places the widget to another (at least laid out) widget. The DOM
       * element is not needed, but the bounds are needed to compute the
       * location of the widget to align to.
       *
       * @param target {qx.ui.core.Widget} Target coords align coords
       * @param liveupdate {Boolean} Flag indicating if the position of the
       * widget should be checked and corrected automatically.
       * @return {Boolean} true if the widget was successfully placed
       */
      placeToWidget : function(V, W){

        // Use the idle event to make sure that the widget's position gets
        // updated automatically (e.g. the widget gets scrolled).
        if(W){

          this.__cleanupFromLastPlaceToWidgetLiveUpdate();
          // Bind target and livupdate to placeToWidget
          this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToWidget, this, V, false);
          qx.event.Idle.getInstance().addListener(v, this.__ptwLiveUpdater);
          // Remove the listener when the element disappears.
          this.__ptwLiveUpdateDisappearListener = function(){

            this.__cleanupFromLastPlaceToWidgetLiveUpdate();
          };
          this.addListener(l, this.__ptwLiveUpdateDisappearListener, this);
        };
        var X = V.getContainerLocation() || this.getLayoutLocation(V);
        if(X != null){

          this.__place(X);
          return true;
        } else {

          return false;
        };
      },
      /**
       * Removes all resources allocated by the last run of placeToWidget with liveupdate=true
       */
      __cleanupFromLastPlaceToWidgetLiveUpdate : function(){

        if(this.__ptwLiveUpdater){

          qx.event.Idle.getInstance().removeListener(v, this.__ptwLiveUpdater);
          this.__ptwLiveUpdater = null;
        };
        if(this.__ptwLiveUpdateDisappearListener){

          this.removeListener(l, this.__ptwLiveUpdateDisappearListener, this);
          this.__ptwLiveUpdateDisappearListener = null;
        };
      },
      /**
       * Places the widget to the mouse cursor position.
       *
       * @param event {qx.event.type.Mouse} Mouse event to align to
       */
      placeToMouse : function(event){

        var ba = event.getDocumentLeft();
        var top = event.getDocumentTop();
        var Y = {
          left : ba,
          top : top,
          right : ba,
          bottom : top
        };
        this.__place(Y);
      },
      /**
       * Places the widget to any (rendered) DOM element.
       *
       * @param elem {Element} DOM element to align to
       * @param liveupdate {Boolean} Flag indicating if the position of the
       * widget should be checked and corrected automatically.
       */
      placeToElement : function(bb, bc){

        var location = qx.bom.element.Location.get(bb);
        var bd = {
          left : location.left,
          top : location.top,
          right : location.left + bb.offsetWidth,
          bottom : location.top + bb.offsetHeight
        };
        // Use the idle event to make sure that the widget's position gets
        // updated automatically (e.g. the widget gets scrolled).
        if(bc){

          // Bind target and livupdate to placeToWidget
          this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToElement, this, bb, false);
          qx.event.Idle.getInstance().addListener(v, this.__ptwLiveUpdater);
          // Remove the listener when the element disappears.
          this.addListener(l, function(){

            if(this.__ptwLiveUpdater){

              qx.event.Idle.getInstance().removeListener(v, this.__ptwLiveUpdater);
              this.__ptwLiveUpdater = null;
            };
          }, this);
        };
        this.__place(bd);
      },
      /**
       * Places the widget in relation to the given point
       *
       * @param point {Map} Coordinate of any point with the keys <code>left</code>
       *   and <code>top</code>.
       */
      placeToPoint : function(be){

        var bf = {
          left : be.left,
          top : be.top,
          right : be.left,
          bottom : be.top
        };
        this.__place(bf);
      },
      /**
       * Returns the placement offsets as a map
       *
       * @return {Map} The placement offsets
       */
      _getPlacementOffsets : function(){

        return {
          left : this.getOffsetLeft(),
          top : this.getOffsetTop(),
          right : this.getOffsetRight(),
          bottom : this.getOffsetBottom()
        };
      },
      /**
       * Get the size of the object to place. The callback will be called with
       * the size as first argument. This methods works asynchronously.
       *
       * The size of the object to place is the size of the widget. If a widget
       * including this mixin needs a different size it can implement the method
       * <code>_computePlacementSize</code>, which returns the size.
       *
       *  @param callback {Function} This function will be called with the size as
       *    first argument
       */
      __getPlacementSize : function(bg){

        var bh = null;
        if(this._computePlacementSize){

          var bh = this._computePlacementSize();
        } else if(this.isVisible()){

          var bh = this.getBounds();
        };
        if(bh == null){

          this.addListenerOnce(D, function(){

            this.__getPlacementSize(bg);
          }, this);
        } else {

          bg.call(this, bh);
        };
      },
      /**
       * Internal method to read specific this properties and
       * apply the results to the this afterwards.
       *
       * @param coords {Map} Location of the object to align the this to. This map
       *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>
       *   and <code>bottom</code>.
       */
      __place : function(bi){

        this.__getPlacementSize(function(bj){

          var bk = qx.util.placement.Placement.compute(bj, this.getLayoutParent().getBounds(), bi, this._getPlacementOffsets(), this.getPosition(), this.getPlacementModeX(), this.getPlacementModeY());
          // state handling for tooltips e.g.
          this.removeState(p);
          this.removeState(o);
          this.addState(bi.left < bk.left ? o : p);
          this.moveTo(bk.left, bk.top);
        });
      }
    },
    destruct : function(){

      this.__cleanupFromLastPlaceToWidgetLiveUpdate();
    }
  });
})();
(function(){

  var f = "Number",e = "_applyTimeoutInterval",d = "qx.event.type.Event",c = "qx.event.Idle",b = "singleton",a = "interval";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * A generic singleton that fires an "interval" event all 100 miliseconds. It
   * can be used whenever one needs to run code periodically. The main purpose of
   * this class is reduce the number of timers.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    type : b,
    construct : function(){

      qx.core.Object.call(this);
      var g = new qx.event.Timer(this.getTimeoutInterval());
      g.addListener(a, this._onInterval, this);
      g.start();
      this.__timer = g;
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** This event if fired each time the interval time has elapsed */
      "interval" : d
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Interval for the timer, which periodically fires the "interval" event,
       * in milliseconds.
       */
      timeoutInterval : {
        check : f,
        init : 100,
        apply : e
      }
    },
    members : {
      __timer : null,
      // property apply
      _applyTimeoutInterval : function(h){

        this.__timer.setInterval(h);
      },
      /**
       * Fires an "interval" event
       */
      _onInterval : function(){

        this.fireEvent(a);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__timer){

        this.__timer.stop();
      };
      this.__timer = null;
    }
  });
})();
(function(){

  var j = "-",i = "best-fit",h = "size",g = "target.bottom",f = "offsets",e = "size.width",d = "offsets.bottom",c = "qx.util.placement.Placement",b = "qx.debug",a = "keep-align",G = "target.right",F = "direct",E = "offsets.right",D = "target",C = "Invalid 'mode' argument!'",B = "offsets.left",A = "area",z = "target.top",y = '__defaultAxis',x = "area.height",q = "target.left",r = "area.width",o = "size.height",p = "offsets.top",m = "edge-start",n = "align-start",k = "align-end",l = "Class",s = "edge-end",t = "bottom",v = "left",u = "top",w = "right";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Contains methods to compute a position for any object which should
   * be positioned relative to another object.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    construct : function(){

      qx.core.Object.call(this);
      this.__defaultAxis = qx.util.placement.DirectAxis;
    },
    properties : {
      /**
       * The axis object to use for the horizontal placement
       */
      axisX : {
        check : l
      },
      /**
       * The axis object to use for the vertical placement
       */
      axisY : {
        check : l
      },
      /**
       * Specify to which edge of the target object, the object should be attached
       */
      edge : {
        check : [u, w, t, v],
        init : u
      },
      /**
       * Specify with which edge of the target object, the object should be aligned
       */
      align : {
        check : [u, w, t, v],
        init : w
      }
    },
    statics : {
      __instance : null,
      /**
       * DOM and widget independent method to compute the location
       * of an object to make it relative to any other object.
       *
       * @param size {Map} With the keys <code>width</code> and <code>height</code>
       *   of the object to align
       * @param area {Map} Available area to position the object. Has the keys
       *   <code>width</code> and <code>height</code>. Normally this is the parent
       *   object of the one to align.
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>
       *   and <code>bottom</code>.
       * @param offsets {Map} Map with all offsets for each direction.
       *   Comes with the keys <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code>.
       * @param position {String} Alignment of the object on the target, any of
       *   "top-left", "top-right", "bottom-left", "bottom-right", "left-top",
       *   "left-bottom", "right-top", "right-bottom".
       * @param modeX {String} Horizontal placement mode. Valid values are:
       *   <ul>
       *   <li><code>direct</code>: place the object directly at the given
       *   location.</li>
       *   <li><code>keep-align</code>: if parts of the object is outside of the visible
       *   area it is moved to the best fitting 'edge' and 'alignment' of the target.
       *   It is guaranteed the the new position attaches the object to one of the
       *   target edges and that that is aligned with a target edge.</li>
       *   <li>best-fit</li>: If parts of the object are outside of the visible
       *   area it is moved into the view port ignoring any offset, and position
       *   values.
       *   </ul>
       * @param modeY {String} Vertical placement mode. Accepts the same values as
       *   the 'modeX' argument.
       * @return {Map} A map with the final location stored in the keys
       *   <code>left</code> and <code>top</code>.
       */
      compute : function(H, I, J, K, L, M, N){

        this.__instance = this.__instance || new qx.util.placement.Placement();
        var Q = L.split(j);
        var P = Q[0];
        var O = Q[1];
        this.__instance.set({
          axisX : this.__getAxis(M),
          axisY : this.__getAxis(N),
          edge : P,
          align : O
        });
        return this.__instance.compute(H, I, J, K);
      },
      __direct : null,
      __keepAlign : null,
      __bestFit : null,
      /**
       * Get the axis implementation for the given mode
       *
       * @param mode {String} One of <code>direct</code>, <code>keep-align</code> or
       *   <code>best-fit</code>
       * @return {qx.util.placement.AbstractAxis}
       */
      __getAxis : function(R){

        switch(R){case F:
        this.__direct = this.__direct || qx.util.placement.DirectAxis;
        return this.__direct;case a:
        this.__keepAlign = this.__keepAlign || qx.util.placement.KeepAlignAxis;
        return this.__keepAlign;case i:
        this.__bestFit = this.__bestFit || qx.util.placement.BestFitAxis;
        return this.__bestFit;default:
        throw new Error(C);};
      }
    },
    members : {
      __defaultAxis : null,
      /**
       * DOM and widget independent method to compute the location
       * of an object to make it relative to any other object.
       *
       * @param size {Map} With the keys <code>width</code> and <code>height</code>
       *   of the object to align
       * @param area {Map} Available area to position the object. Has the keys
       *   <code>width</code> and <code>height</code>. Normally this is the parent
       *   object of the one to align.
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>
       *   and <code>bottom</code>.
       * @param offsets {Map} Map with all offsets for each direction.
       *   Comes with the keys <code>left</code>, <code>top</code>,
       *   <code>right</code> and <code>bottom</code>.
       * @return {Map} A map with the final location stored in the keys
       *   <code>left</code> and <code>top</code>.
       */
      compute : function(S, T, U, V){

        if(qx.core.Environment.get(b)){

          this.assertObject(S, h);
          this.assertNumber(S.width, e);
          this.assertNumber(S.height, o);
          this.assertObject(T, A);
          this.assertNumber(T.width, r);
          this.assertNumber(T.height, x);
          this.assertObject(U, D);
          this.assertNumber(U.top, z);
          this.assertNumber(U.right, G);
          this.assertNumber(U.bottom, g);
          this.assertNumber(U.left, q);
          this.assertObject(V, f);
          this.assertNumber(V.top, p);
          this.assertNumber(V.right, E);
          this.assertNumber(V.bottom, d);
          this.assertNumber(V.left, B);
        };
        var W = this.getAxisX() || this.__defaultAxis;
        var Y = W.computeStart(S.width, {
          start : U.left,
          end : U.right
        }, {
          start : V.left,
          end : V.right
        }, T.width, this.__getPositionX());
        var X = this.getAxisY() || this.__defaultAxis;
        var top = X.computeStart(S.height, {
          start : U.top,
          end : U.bottom
        }, {
          start : V.top,
          end : V.bottom
        }, T.height, this.__getPositionY());
        return {
          left : Y,
          top : top
        };
      },
      /**
       * Get the position value for the horizontal axis
       *
       * @return {String} the position
       */
      __getPositionX : function(){

        var bb = this.getEdge();
        var ba = this.getAlign();
        if(bb == v){

          return m;
        } else if(bb == w){

          return s;
        } else if(ba == v){

          return n;
        } else if(ba == w){

          return k;
        };;;
      },
      /**
       * Get the position value for the vertical axis
       *
       * @return {String} the position
       */
      __getPositionY : function(){

        var bd = this.getEdge();
        var bc = this.getAlign();
        if(bd == u){

          return m;
        } else if(bd == t){

          return s;
        } else if(bc == u){

          return n;
        } else if(bc == t){

          return k;
        };;;
      }
    },
    destruct : function(){

      this._disposeObjects(y);
    }
  });
})();
(function(){

  var f = "align-start",e = "align-end",d = "qx.util.placement.AbstractAxis",c = "edge-start",b = "abstract method call!",a = "edge-end";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Abstract class to compute the position of an object on one axis.
   */
  qx.Bootstrap.define(d, {
    extend : Object,
    statics : {
      /**
       * Computes the start of the object on the axis
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param areaSize {Integer} Size of the axis.
       * @param position {String} Alignment of the object on the target. Valid values are
       *   <ul>
       *   <li><code>edge-start</code> The object is placed before the target</li>
       *   <li><code>edge-end</code> The object is placed after the target</li>
       *   <li><code>align-start</code>The start of the object is aligned with the start of the target</li>
       *   <li><code>align-end</code>The end of the object is aligned with the end of the object</li>
       *   </ul>
       * @return {Integer} The computed start position of the object.
       */
      computeStart : function(g, h, i, j, k){

        throw new Error(b);
      },
      /**
       * Computes the start of the object by taking only the attachment and
       * alignment into account. The object by be not fully visible.
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param position {String} Accepts the same values as the <code> position</code>
       *   argument of {@link #computeStart}.
       * @return {Integer} The computed start position of the object.
       */
      _moveToEdgeAndAlign : function(l, m, n, o){

        switch(o){case c:
        return m.start - n.end - l;case a:
        return m.end + n.start;case f:
        return m.start + n.start;case e:
        return m.end - n.end - l;};
      },
      /**
       * Whether the object specified by <code>start</code> and <code>size</code>
       * is completely inside of the axis' range..
       *
       * @param start {Integer} Computed start position of the object
       * @param size {Integer} Size of the object
       * @param areaSize {Integer} The size of the axis
       * @return {Boolean} Whether the object is inside of the axis' range
       */
      _isInRange : function(p, q, r){

        return p >= 0 && p + q <= r;
      }
    }
  });
})();
(function(){

  var a = "qx.util.placement.DirectAxis";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Places the object directly at the specified position. It is not moved if
   * parts of the object are outside of the axis' range.
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * Computes the start of the object by taking only the attachment and
       * alignment into account. The object by be not fully visible.
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param position {String} Accepts the same values as the <code> position</code>
       *   argument of {@link #computeStart}.
       * @return {Integer} The computed start position of the object.
       */
      _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
      /**
       * Computes the start of the object on the axis
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param areaSize {Integer} Size of the axis.
       * @param position {String} Alignment of the object on the target. Valid values are
       *   <ul>
       *   <li><code>edge-start</code> The object is placed before the target</li>
       *   <li><code>edge-end</code> The object is placed after the target</li>
       *   <li><code>align-start</code>The start of the object is aligned with the start of the target</li>
       *   <li><code>align-end</code>The end of the object is aligned with the end of the object</li>
       *   </ul>
       * @return {Integer} The computed start position of the object.
       */
      computeStart : function(b, c, d, e, f){

        return this._moveToEdgeAndAlign(b, c, d, f);
      }
    }
  });
})();
(function(){

  var c = "qx.util.placement.KeepAlignAxis",b = "edge-start",a = "edge-end";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Places the object to the target. If parts of the object are outside of the
   * range this class places the object at the best "edge", "alignment"
   * combination so that the overlap between object and range is maximized.
   */
  qx.Bootstrap.define(c, {
    statics : {
      /**
       * Computes the start of the object by taking only the attachment and
       * alignment into account. The object by be not fully visible.
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param position {String} Accepts the same values as the <code> position</code>
       *   argument of {@link #computeStart}.
       * @return {Integer} The computed start position of the object.
       */
      _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
      /**
       * Whether the object specified by <code>start</code> and <code>size</code>
       * is completely inside of the axis' range..
       *
       * @param start {Integer} Computed start position of the object
       * @param size {Integer} Size of the object
       * @param areaSize {Integer} The size of the axis
       * @return {Boolean} Whether the object is inside of the axis' range
       */
      _isInRange : qx.util.placement.AbstractAxis._isInRange,
      /**
       * Computes the start of the object on the axis
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param areaSize {Integer} Size of the axis.
       * @param position {String} Alignment of the object on the target. Valid values are
       *   <ul>
       *   <li><code>edge-start</code> The object is placed before the target</li>
       *   <li><code>edge-end</code> The object is placed after the target</li>
       *   <li><code>align-start</code>The start of the object is aligned with the start of the target</li>
       *   <li><code>align-end</code>The end of the object is aligned with the end of the object</li>
       *   </ul>
       * @return {Integer} The computed start position of the object.
       */
      computeStart : function(d, e, f, g, h){

        var i = this._moveToEdgeAndAlign(d, e, f, h);
        var j,k;
        if(this._isInRange(i, d, g)){

          return i;
        };
        if(h == b || h == a){

          j = e.start - f.end;
          k = e.end + f.start;
        } else {

          j = e.end - f.end;
          k = e.start + f.start;
        };
        if(j > g - k){

          i = j - d;
        } else {

          i = k;
        };
        return i;
      }
    }
  });
})();
(function(){

  var a = "qx.util.placement.BestFitAxis";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Places the object according to the target. If parts of the object are outside
   * of the axis' range the object's start is adjusted so that the overlap between
   * the object and the axis is maximized.
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * Whether the object specified by <code>start</code> and <code>size</code>
       * is completely inside of the axis' range..
       *
       * @param start {Integer} Computed start position of the object
       * @param size {Integer} Size of the object
       * @param areaSize {Integer} The size of the axis
       * @return {Boolean} Whether the object is inside of the axis' range
       */
      _isInRange : qx.util.placement.AbstractAxis._isInRange,
      /**
       * Computes the start of the object by taking only the attachment and
       * alignment into account. The object by be not fully visible.
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param position {String} Accepts the same values as the <code> position</code>
       *   argument of {@link #computeStart}.
       * @return {Integer} The computed start position of the object.
       */
      _moveToEdgeAndAlign : qx.util.placement.AbstractAxis._moveToEdgeAndAlign,
      /**
       * Computes the start of the object on the axis
       *
       * @param size {Integer} Size of the object to align
       * @param target {Map} Location of the object to align the object to. This map
       *   should have the keys <code>start</code> and <code>end</code>.
       * @param offsets {Map} Map with all offsets on each side.
       *   Comes with the keys <code>start</code> and <code>end</code>.
       * @param areaSize {Integer} Size of the axis.
       * @param position {String} Alignment of the object on the target. Valid values are
       *   <ul>
       *   <li><code>edge-start</code> The object is placed before the target</li>
       *   <li><code>edge-end</code> The object is placed after the target</li>
       *   <li><code>align-start</code>The start of the object is aligned with the start of the target</li>
       *   <li><code>align-end</code>The end of the object is aligned with the end of the object</li>
       *   </ul>
       * @return {Integer} The computed start position of the object.
       */
      computeStart : function(b, c, d, e, f){

        var g = this._moveToEdgeAndAlign(b, c, d, f);
        if(this._isInRange(g, b, e)){

          return g;
        };
        if(g < 0){

          g = Math.min(0, e - b);
        };
        if(g + b > e){

          g = Math.max(0, e - b);
        };
        return g;
      }
    }
  });
})();
(function(){

  var j = "Image could not be loaded: ",i = "Boolean",h = "px",g = "http",f = "engine.version",e = "scale",d = "changeSource",c = "qx.ui.basic.Image",b = "loaded",a = "qx.debug",E = "-disabled.$1",D = "loadingFailed",C = "String",B = "_applySource",A = "img",z = "data:image/",y = "__contentElements",x = "image",w = "mshtml",v = "_applyScale",q = "try to load an unmanaged relative image: ",r = "no-repeat",o = ".png",p = "div",m = "replacement",n = "qx.event.type.Event",k = "engine.name",l = "hidden",s = "alphaScaled",t = "scaled",u = "nonScaled";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * The image class displays an image file
   *
   * This class supports image clipping, which means that multiple images can be combined
   * into one large image and only the relevant part is shown.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var image = new qx.ui.basic.Image("icon/32/actions/format-justify-left.png");
   *
   *   this.getRoot().add(image);
   * </pre>
   *
   * This example create a widget to display the image
   * <code>icon/32/actions/format-justify-left.png</code>.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/image.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(c, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param source {String?null} The URL of the image to display.
     */
    construct : function(F){

      this.__contentElements = {
      };
      qx.ui.core.Widget.call(this);
      if(F){

        this.setSource(F);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The URL of the image */
      source : {
        check : C,
        init : null,
        nullable : true,
        event : d,
        apply : B,
        themeable : true
      },
      /**
       * Whether the image should be scaled to the given dimensions
       *
       * This is disabled by default because it prevents the usage
       * of image clipping when enabled.
       */
      scale : {
        check : i,
        init : false,
        themeable : true,
        apply : v
      },
      // overridden
      appearance : {
        refine : true,
        init : x
      },
      // overridden
      allowShrinkX : {
        refine : true,
        init : false
      },
      // overridden
      allowShrinkY : {
        refine : true,
        init : false
      },
      // overridden
      allowGrowX : {
        refine : true,
        init : false
      },
      // overridden
      allowGrowY : {
        refine : true,
        init : false
      }
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired if the image source can not be loaded.
       *
       * *Attention*: This event is only used for images which are loaded externally
       * (aka unmanaged images).
       */
      loadingFailed : n,
      /**
       * Fired if the image has been loaded.
       *
       * *Attention*: This event is only used for images which are loaded externally
       * (aka unmanaged images).
       */
      loaded : n
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __width : null,
      __height : null,
      __mode : null,
      __contentElements : null,
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getContentElement : function(){

        return this.__getSuitableContentElement();
      },
      // overridden
      _createContentElement : function(){

        return this.__getSuitableContentElement();
      },
      // overridden
      _getContentHint : function(){

        return {
          width : this.__width || 0,
          height : this.__height || 0
        };
      },
      /*
      ---------------------------------------------------------------------------
        IMAGE API
      ---------------------------------------------------------------------------
      */
      // property apply, overridden
      _applyEnabled : function(G, H){

        qx.ui.core.Widget.prototype._applyEnabled.call(this, G, H);
        if(this.getSource()){

          this._styleSource();
        };
      },
      // property apply
      _applySource : function(I){

        this._styleSource();
      },
      // property apply
      _applyScale : function(J){

        this._styleSource();
      },
      /**
       * Remembers the mode to keep track which contentElement is currently in use.
       * @param mode {String} internal mode (alphaScaled|scaled|nonScaled)
       */
      __setMode : function(K){

        this.__mode = K;
      },
      /**
       * Returns the current mode if set. Otherwise checks the current source and
       * the current scaling to determine the current mode.
       *
       * @return {String} current internal mode
       */
      __getMode : function(){

        if(this.__mode == null){

          var M = this.getSource();
          var L = false;
          if(M != null){

            L = qx.lang.String.endsWith(M, o);
          };
          if(this.getScale() && L && qx.bom.element.Decoration.isAlphaImageLoaderEnabled()){

            this.__mode = s;
          } else if(this.getScale()){

            this.__mode = t;
          } else {

            this.__mode = u;
          };
        };
        return this.__mode;
      },
      /**
       * Creates a contentElement suitable for the current mode
       *
       * @param mode {String} internal mode
       * @return {qx.html.Image} suitable image content element
       */
      __createSuitableContentElement : function(N){

        var O;
        var P;
        if(N == s){

          O = true;
          P = p;
        } else if(N == u){

          O = false;
          P = p;
        } else {

          O = true;
          P = A;
        };
        var Q = new qx.html.Image(P);
        Q.setScale(O);
        Q.setStyles({
          "overflowX" : l,
          "overflowY" : l
        });
        return Q;
      },
      /**
       * Returns a contentElement suitable for the current mode
       *
       * @return {qx.html.Image} suitable image contentElement
       */
      __getSuitableContentElement : function(){

        var R = this.__getMode();
        if(this.__contentElements[R] == null){

          this.__contentElements[R] = this.__createSuitableContentElement(R);
        };
        return this.__contentElements[R];
      },
      /**
       * Applies the source to the clipped image instance or preload
       * an image to detect sizes and apply it afterwards.
       *
       * @return {void}
       */
      _styleSource : function(){

        var S = qx.util.AliasManager.getInstance().resolve(this.getSource());
        if(!S){

          this.getContentElement().resetSource();
          return;
        };
        this.__checkForContentElementSwitch(S);
        if((qx.core.Environment.get(k) == w) && parseInt(qx.core.Environment.get(f), 10) < 9){

          var T = this.getScale() ? e : r;
          this.getContentElement().tagNameHint = qx.bom.element.Decoration.getTagName(T, S);
        };
        // Detect if the image registry knows this image
        if(qx.util.ResourceManager.getInstance().has(S)){

          this.__setManagedImage(this.getContentElement(), S);
        } else if(qx.io.ImageLoader.isLoaded(S)){

          this.__setUnmanagedImage(this.getContentElement(), S);
        } else {

          this.__loadUnmanagedImage(this.getContentElement(), S);
        };
      },
      /**
       * Checks if the current content element is capable to display the image
       * with the current settings (scaling, alpha PNG)
       *
       * @param source {String} source of the image
       * @return {void}
       */
      __checkForContentElementSwitch : qx.core.Environment.select(k, {
        "mshtml" : function(U){

          var W = qx.bom.element.Decoration.isAlphaImageLoaderEnabled();
          var V = qx.lang.String.endsWith(U, o);
          if(W && V){

            if(this.getScale() && this.__getMode() != s){

              this.__setMode(s);
            } else if(!this.getScale() && this.__getMode() != u){

              this.__setMode(u);
            };
          } else {

            if(this.getScale() && this.__getMode() != t){

              this.__setMode(t);
            } else if(!this.getScale() && this.__getMode() != u){

              this.__setMode(u);
            };
          };
          this.__checkForContentElementReplacement(this.__getSuitableContentElement());
        },
        "default" : function(X){

          if(this.getScale() && this.__getMode() != t){

            this.__setMode(t);
          } else if(!this.getScale() && this.__getMode(u)){

            this.__setMode(u);
          };
          this.__checkForContentElementReplacement(this.__getSuitableContentElement());
        }
      }),
      /**
       * Checks the current child and replaces it if necessary
       *
       * @param elementToAdd {qx.html.Image} content element to add
       * @return {void}
       */
      __checkForContentElementReplacement : function(Y){

        var bc = this.getContainerElement();
        var bd = bc.getChild(0);
        if(bd != Y){

          if(bd != null){

            var bf = h;
            var ba = {
            };
            // Copy dimension and location of the current content element
            var bb = this.getInnerSize();
            if(bb != null){

              ba.width = bb.width + bf;
              ba.height = bb.height + bf;
            };
            var be = this.getInsets();
            ba.left = be.left + bf;
            ba.top = be.top + bf;
            // Set the default zIndex to avoid any issues with decorators
            // since these would otherwise cover the content element
            ba.zIndex = 10;
            Y.setStyles(ba, true);
            Y.setSelectable(this.getSelectable());
            bc.removeAt(0);
            bc.addAt(Y, 0);
          };
        };
      },
      /**
       * Use the ResourceManager to set a managed image
       *
       * @param el {Element} image DOM element
       * @param source {String} source path
       * @return {void}
       */
      __setManagedImage : function(bg, bh){

        var bj = qx.util.ResourceManager.getInstance();
        // Try to find a disabled image in registry
        if(!this.getEnabled()){

          var bi = bh.replace(/\.([a-z]+)$/, E);
          if(bj.has(bi)){

            bh = bi;
            this.addState(m);
          } else {

            this.removeState(m);
          };
        };
        // Optimize case for enabled changes when no disabled image was found
        if(bg.getSource() === bh){

          return;
        };
        // Apply source
        bg.setSource(bh);
        // Compare with old sizes and relayout if necessary
        this.__updateContentHint(bj.getImageWidth(bh), bj.getImageHeight(bh));
      },
      /**
       * Use the infos of the ImageLoader to set an unmanaged image
       *
       * @param el {Element} image DOM element
       * @param source {String} source path
       * @return {void}
       */
      __setUnmanagedImage : function(bk, bl){

        var bn = qx.io.ImageLoader;
        // Apply source
        bk.setSource(bl);
        // Compare with old sizes and relayout if necessary
        var bm = bn.getWidth(bl);
        var bo = bn.getHeight(bl);
        this.__updateContentHint(bm, bo);
      },
      /**
       * Use the ImageLoader to load an unmanaged image
       *
       * @param el {Element} image DOM element
       * @param source {String} source path
       * @return {void}
       */
      __loadUnmanagedImage : function(bp, bq){

        var bt = qx.io.ImageLoader;
        if(qx.core.Environment.get(a)){

          // loading external images via HTTP/HTTPS is a common usecase, as is
          // using data URLs.
          var br = bq.toLowerCase();
          var bs = qx.lang.String.startsWith;
          if(!bs(br, g) && !bs(br, z)){

            var self = this.self(arguments);
            if(!self.__warned){

              self.__warned = {
              };
            };
            if(!self.__warned[bq]){

              this.debug(q + bq);
              self.__warned[bq] = true;
            };
          };
        };
        // only try to load the image if it not already failed
        if(!bt.isFailed(bq)){

          bt.load(bq, this.__loaderCallback, this);
        } else {

          if(bp != null){

            bp.resetSource();
          };
        };
      },
      /**
       * Event handler fired after the preloader has finished loading the icon
       *
       * @param source {String} Image source which was loaded
       * @param imageInfo {Map} Dimensions of the loaded image
       * @return {void}
       */
      __loaderCallback : function(bu, bv){

        // Ignore the callback on already disposed images
        if(this.$$disposed === true){

          return;
        };
        // Ignore when the source has already been modified
        if(bu !== qx.util.AliasManager.getInstance().resolve(this.getSource())){

          return;
        };
        // Output a warning if the image could not loaded and quit
        if(bv.failed){

          this.warn(j + bu);
          this.fireEvent(D);
        } else if(bv.aborted){

          // ignore the rest because it is aborted
          return;
        } else {

          this.fireEvent(b);
        };
        // Update image (again)
        this._styleSource();
      },
      /**
       * Updates the content hint when the image size has been changed
       *
       * @param width {Integer} width of the image
       * @param height {Integer} height of the image
       * @return {void}
       */
      __updateContentHint : function(bw, bx){

        // Compare with old sizes and relayout if necessary
        if(bw !== this.__width || bx !== this.__height){

          this.__width = bw;
          this.__height = bx;
          qx.ui.core.queue.Layout.add(this);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeMap(y);
    }
  });
})();
(function(){

  var g = "dragdrop-cursor",f = "_applyAction",e = "alias",d = "qx.ui.core.DragDropCursor",c = "move",b = "singleton",a = "copy";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This widget is used as feedback widget in drag and drop actions.
   */
  qx.Class.define(d, {
    extend : qx.ui.basic.Image,
    include : qx.ui.core.MPlacement,
    type : b,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.basic.Image.call(this);
      // Put above other stuff
      this.setZIndex(1e8);
      // Move using DOM
      this.setDomMove(true);
      // Automatically add to root
      var h = this.getApplicationRoot();
      h.add(this, {
        left : -1000,
        top : -1000
      });
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      appearance : {
        refine : true,
        init : g
      },
      /** The current drag&drop action */
      action : {
        check : [e, a, c],
        apply : f,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    members : {
      // property apply
      _applyAction : function(i, j){

        if(j){

          this.removeState(j);
        };
        if(i){

          this.addState(i);
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.core.MChildrenHandling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin exposes all basic methods to manage widget children as public methods.
   * It can only be included into instances of {@link Widget}.
   *
   * To optimize the method calls the including widget should call the method
   * {@link #remap} in its defer function. This will map the protected
   * methods to the public ones and save one method call for each function.
   */
  qx.Mixin.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Returns the children list
       *
       * @return {LayoutItem[]} The children array (Arrays are
       *   reference types, please to not modify them in-place)
       */
      getChildren : function(){

        return this._getChildren();
      },
      /**
       * Whether the widget contains children.
       *
       * @return {Boolean} Returns <code>true</code> when the widget has children.
       */
      hasChildren : function(){

        return this._hasChildren();
      },
      /**
       * Returns the index position of the given widget if it is
       * a child widget. Otherwise it returns <code>-1</code>.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {Widget} the widget to query for
       * @return {Integer} The index position or <code>-1</code> when
       *   the given widget is no child of this layout.
       */
      indexOf : function(b){

        return this._indexOf(b);
      },
      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout manager
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {LayoutItem} the widget to add.
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      add : function(c, d){

        this._add(c, d);
      },
      /**
       * Add a child widget at the specified index
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} Widget to add
       * @param index {Integer} Index, at which the widget will be inserted
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      addAt : function(e, f, g){

        this._addAt(e, f, g);
      },
      /**
       * Add a widget before another already inserted widget
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} Widget to add
       * @param before {LayoutItem} Widget before the new widget will be inserted.
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      addBefore : function(h, i, j){

        this._addBefore(h, i, j);
      },
      /**
       * Add a widget after another already inserted widget
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} Widget to add
       * @param after {LayoutItem} Widget, after which the new widget will be inserted
       * @param options {Map?null} Optional layout data for widget.
       * @return {void}
       */
      addAfter : function(k, l, m){

        this._addAfter(k, l, m);
      },
      /**
       * Remove the given child widget.
       *
       * @param child {LayoutItem} the widget to remove
       * @return {void}
       */
      remove : function(n){

        this._remove(n);
      },
      /**
       * Remove the widget at the specified index.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param index {Integer} Index of the widget to remove.
       * @return {LayoutItem} The child removed.
       */
      removeAt : function(o){

        return this._removeAt(o);
      },
      /**
       * Remove all children.
       *
       * @return {Array} An array of the removed children.
       */
      removeAll : function(){

        return this._removeAll();
      }
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Mapping of protected methods to public.
       * This omits an additional function call when using these methods. Call
       * this methods in the defer block of the including class.
       *
       * @param members {Map} The including classes members map
       */
      remap : function(p){

        p.getChildren = p._getChildren;
        p.hasChildren = p._hasChildren;
        p.indexOf = p._indexOf;
        p.add = p._add;
        p.addAt = p._addAt;
        p.addBefore = p._addBefore;
        p.addAfter = p._addAfter;
        p.remove = p._remove;
        p.removeAt = p._removeAt;
        p.removeAll = p._removeAll;
      }
    }
  });
})();
(function(){

  var d = "qx.ui.container.Composite",c = "addChildWidget",b = "removeChildWidget",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The Composite is a generic container widget.
   *
   * It exposes all methods to set layouts and to manage child widgets
   * as public methods. You must configure this widget with a layout manager to
   * define the way the widget's children are positioned.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create the composite
   *   var composite = new qx.ui.container.Composite()
   *
   *   // configure it with a horizontal box layout with a spacing of '5'
   *   composite.setLayout(new qx.ui.layout.HBox(5));
   *
   *   // add some children
   *   composite.add(new qx.ui.basic.Label("Name: "));
   *   composite.add(new qx.ui.form.TextField());
   *
   *   this.getRoot().add(composite);
   * </pre>
   *
   * This example horizontally groups a label and text field by using a
   * Composite configured with a horizontal box layout as a container.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/composite.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(d, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MChildrenHandling, qx.ui.core.MLayoutHandling],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param layout {qx.ui.layout.Abstract} A layout instance to use to
     *   place widgets on the screen.
     */
    construct : function(e){

      qx.ui.core.Widget.call(this);
      if(e != null){

        this._setLayout(e);
      };
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * This event is fired after a child widget was added to this widget. The
       * {@link qx.event.type.Data#getData} method of the event returns the
       * added child.
       */
      addChildWidget : a,
      /**
       * This event is fired after a child widget has been removed from this widget.
       * The {@link qx.event.type.Data#getData} method of the event returns the
       * removed child.
       */
      removeChildWidget : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _afterAddChild : function(f){

        this.fireNonBubblingEvent(c, qx.event.type.Data, [f]);
      },
      // overridden
      _afterRemoveChild : function(g){

        this.fireNonBubblingEvent(b, qx.event.type.Data, [g]);
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(h, i){

      qx.ui.core.MChildrenHandling.remap(i);
      qx.ui.core.MLayoutHandling.remap(i);
    }
  });
})();
(function(){

  var e = "qx.ui.popup.Popup",d = "visible",c = "excluded",b = "popup",a = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Popups are widgets, which can be placed on top of the application.
   * They are automatically added to the application root.
   *
   * Popups are used to display menus, the lists of combo or select boxes,
   * tooltips, etc.
   */
  qx.Class.define(e, {
    extend : qx.ui.container.Composite,
    include : qx.ui.core.MPlacement,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(f){

      qx.ui.container.Composite.call(this, f);
      // Initialize visibiltiy
      this.initVisibility();
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : b
      },
      // overridden
      visibility : {
        refine : true,
        init : c
      },
      /**
       * Whether to let the system decide when to hide the popup. Setting
       * this to false gives you better control but it also requires you
       * to handle the closing of the popup.
       */
      autoHide : {
        check : a,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      show : function(){

        // Lazy adding to the root element, otherwise it could happen that
        // IE scrolls automatically to top, see bug #3955 for details.
        if(this.getLayoutParent() == null){

          // Automatically add to application's root
          qx.core.Init.getApplication().getRoot().add(this);
        };
        qx.ui.container.Composite.prototype.show.call(this);
      },
      // overridden
      _applyVisibility : function(g, h){

        qx.ui.container.Composite.prototype._applyVisibility.call(this, g, h);
        var i = qx.ui.popup.Manager.getInstance();
        g === d ? i.add(this) : i.remove(this);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      qx.ui.popup.Manager.getInstance().remove(this);
    }
  });
})();
(function(){

  var h = "blur",g = "qx.ui.popup.Manager",f = "__objects",d = "singleton",c = "mousedown",b = "qx.debug",a = "Object is no popup: ";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This singleton is used to manager multiple instances of popups and their
   * state.
   */
  qx.Class.define(g, {
    type : d,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      // Create data structure, use an array becasue order matters [BUG #4323]
      this.__objects = [];
      // Register mousedown handler
      qx.event.Registration.addListener(document.documentElement, c, this.__onMouseDown, this, true);
      // Hide all popups on window blur
      qx.bom.Element.addListener(window, h, this.hideAll, this);
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __objects : null,
      /**
       * Registers a visible popup.
       *
       * @param obj {qx.ui.popup.Popup} The popup to register
       */
      add : function(j){

        if(qx.core.Environment.get(b)){

          if(!(j instanceof qx.ui.popup.Popup)){

            throw new Error(a + j);
          };
        };
        this.__objects.push(j);
        this.__updateIndexes();
      },
      /**
       * Removes a popup from the registry
       *
       * @param obj {qx.ui.popup.Popup} The popup which was excluded
       */
      remove : function(k){

        if(qx.core.Environment.get(b)){

          if(!(k instanceof qx.ui.popup.Popup)){

            throw new Error(a + k);
          };
        };
        if(this.__objects){

          qx.lang.Array.remove(this.__objects, k);
          this.__updateIndexes();
        };
      },
      /**
       * Excludes all currently open popups,
       * except those with {@link qx.ui.popup.Popup#autoHide} set to false.
       */
      hideAll : function(){

        var m;
        var n = this.__objects;
        if(n){

          for(var i = 0,l = n.length;i < l;i++){

            var m = n[i];
            m.getAutoHide() && m.exclude();
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Updates the zIndex of all registered items to push
       * newly added ones on top of existing ones
       *
       * @return {void}
       */
      __updateIndexes : function(){

        var o = 1e7;
        for(var i = 0;i < this.__objects.length;i++){

          this.__objects[i].setZIndex(o++);
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler for mouse down events
       *
       * @param e {qx.event.type.Mouse} Mouse event object
       */
      __onMouseDown : function(e){

        // Get the corresponding widget of the target since we are dealing with
        // DOM elements here. This is necessary because we have to be aware of
        // Inline applications which are not covering the whole document and
        // therefore are not able to get all mouse events when only the
        // application root is monitored.
        var q = qx.ui.core.Widget.getWidgetByElement(e.getTarget());
        var r = this.__objects;
        for(var i = 0;i < r.length;i++){

          var p = r[i];
          if(!p.getAutoHide() || q == p || qx.ui.core.Widget.contains(p, q)){

            continue;
          };
          p.exclude();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      qx.event.Registration.removeListener(document.documentElement, c, this.__onMouseDown, this, true);
      this._disposeArray(f);
    }
  });
})();
(function(){

  var l = "_applyRich",k = "qx.ui.tooltip.ToolTip",j = "_applyIcon",i = "tooltip",h = "qx.ui.core.Widget",g = "mouseover",f = "Boolean",d = "_applyLabel",c = "Integer",b = "String",a = "atom";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A Tooltip provides additional information for widgets when the user hovers
   * over a widget.
   *
   * @childControl atom {qx.ui.basic.Atom} atom widget which represents the content of the tooltip
   */
  qx.Class.define(k, {
    extend : qx.ui.popup.Popup,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} label of the tooltip
     * @param icon {String?null} Icon URL of the tooltip
     */
    construct : function(m, n){

      qx.ui.popup.Popup.call(this);
      // Use static layout
      this.setLayout(new qx.ui.layout.Grow);
      // Integrate atom
      this._createChildControl(a);
      // Initialize properties
      if(m != null){

        this.setLabel(m);
      };
      if(n != null){

        this.setIcon(n);
      };
      this.addListener(g, this._onMouseOver, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : i
      },
      /** Interval after the tooltip is shown (in milliseconds) */
      showTimeout : {
        check : c,
        init : 700,
        themeable : true
      },
      /** Interval after the tooltip is hidden (in milliseconds) */
      hideTimeout : {
        check : c,
        init : 4000,
        themeable : true
      },
      /** The label/caption/text of the ToolTip's atom. */
      label : {
        check : b,
        nullable : true,
        apply : d
      },
      /**
       * Any URI String supported by qx.ui.basic.Image to display an icon in
       * ToolTips's atom.
       */
      icon : {
        check : b,
        nullable : true,
        apply : j,
        themeable : true
      },
      /**
       * Switches between rich HTML and text content. The text mode
       * (<code>false</code>) supports advanced features like ellipsis when the
       * available space is not enough. HTML mode (<code>true</code>) supports
       * multi-line content and all the markup features of HTML content.
       */
      rich : {
        check : f,
        init : false,
        apply : l
      },
      /** Widget that opened the tooltip */
      opener : {
        check : h,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _createChildControlImpl : function(o, p){

        var q;
        switch(o){case a:
        q = new qx.ui.basic.Atom;
        this._add(q);
        break;};
        return q || qx.ui.popup.Popup.prototype._createChildControlImpl.call(this, o);
      },
      /**
       * Listener method for "mouseover" event
       *
       * @param e {qx.event.type.Event} Mouse event
       */
      _onMouseOver : function(e){

        this.hide();
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon : function(r, s){

        var t = this.getChildControl(a);
        r == null ? t.resetIcon() : t.setIcon(r);
      },
      // property apply
      _applyLabel : function(u, v){

        var w = this.getChildControl(a);
        u == null ? w.resetLabel() : w.setLabel(u);
      },
      // property apply
      _applyRich : function(x, y){

        var z = this.getChildControl(a);
        z.setRich(x);
      }
    }
  });
})();
(function(){

  var d = "' is not supported by the Grow layout!",c = "qx.ui.layout.Grow",b = "qx.debug",a = "The property '";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * The grow layout stretches all children to the full available size
   * but still respects limits configured by min/max values.
   *
   * It will place all children over each other with the top and left coordinates
   * set to <code>0</code>. The {@link qx.ui.container.Stack} and the
   * {@link qx.ui.core.scroll.ScrollPane} are using this layout.
   *
   * *Features*
   *
   * * Auto-sizing
   * * Respects minimum and maximum child dimensions
   *
   * *Item Properties*
   *
   * None
   *
   * *Example*
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Grow();
   *
   * var w1 = new qx.ui.core.Widget();
   * var w2 = new qx.ui.core.Widget();
   * var w3 = new qx.ui.core.Widget();
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(w1);
   * container.add(w2);
   * container.add(w3);
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/grow.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define(c, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(b, {
        "true" : function(e, name, f){

          this.assert(false, a + name + d);
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(g, h){

        var n = this._getLayoutChildren();
        var m,o,k,j;
        // Render children
        for(var i = 0,l = n.length;i < l;i++){

          m = n[i];
          o = m.getSizeHint();
          k = g;
          if(k < o.minWidth){

            k = o.minWidth;
          } else if(k > o.maxWidth){

            k = o.maxWidth;
          };
          j = h;
          if(j < o.minHeight){

            j = o.minHeight;
          } else if(j > o.maxHeight){

            j = o.maxHeight;
          };
          m.renderLayout(0, 0, k, j);
        };
      },
      // overridden
      _computeSizeHint : function(){

        var v = this._getLayoutChildren();
        var t,x;
        var w = 0,u = 0;
        var s = 0,q = 0;
        var p = Infinity,r = Infinity;
        // Iterate over children
        for(var i = 0,l = v.length;i < l;i++){

          t = v[i];
          x = t.getSizeHint();
          w = Math.max(w, x.width);
          u = Math.max(u, x.height);
          s = Math.max(s, x.minWidth);
          q = Math.max(q, x.minHeight);
          p = Math.min(p, x.maxWidth);
          r = Math.min(r, x.maxHeight);
        };
        // Return hint
        return {
          width : w,
          height : u,
          minWidth : s,
          minHeight : q,
          maxWidth : p,
          maxHeight : r
        };
      }
    }
  });
})();
(function(){

  var j = "changeGap",i = "changeShow",h = "bottom",g = "_applyCenter",f = "changeIcon",e = "qx.ui.basic.Atom",d = "changeLabel",c = "Integer",b = "_applyIconPosition",a = "qx.debug",z = "bottom-left",y = "top-left",x = "top",w = "right",v = "_applyRich",u = "_applyIcon",t = "_applyShow",s = "_applyLabel",r = "_applyGap",q = "atom",o = "Boolean",p = "both",m = "String",n = "left",k = "icon",l = "label";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A multi-purpose widget, which combines a label with an icon.
   *
   * The intended purpose of qx.ui.basic.Atom is to easily align the common icon-text
   * combination in different ways.
   *
   * This is useful for all types of buttons, tooltips, ...
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var atom = new qx.ui.basic.Atom("Icon Right", "icon/32/actions/go-next.png");
   *   this.getRoot().add(atom);
   * </pre>
   *
   * This example creates an atom with the label "Icon Right" and an icon.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/atom.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   *
   *
   * @childControl label {qx.ui.basic.Label} label part of the atom
   * @childControl icon {qx.ui.basic.Image} icon part of the atom
   */
  qx.Class.define(e, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct : function(A, B){

      if(qx.core.Environment.get(a)){

        this.assertArgumentsCount(arguments, 0, 2);
      };
      qx.ui.core.Widget.call(this);
      this._setLayout(new qx.ui.layout.Atom());
      if(A != null){

        this.setLabel(A);
      };
      if(B != null){

        this.setIcon(B);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : q
      },
      /** The label/caption/text of the qx.ui.basic.Atom instance */
      label : {
        apply : s,
        nullable : true,
        check : m,
        event : d
      },
      /**
       * Switches between rich HTML and text content. The text mode (<code>false</code>) supports
       * advanced features like ellipsis when the available space is not
       * enough. HTML mode (<code>true</code>) supports multi-line content and all the
       * markup features of HTML content.
       */
      rich : {
        check : o,
        init : false,
        apply : v
      },
      /** Any URI String supported by qx.ui.basic.Image to display an icon */
      icon : {
        check : m,
        apply : u,
        nullable : true,
        themeable : true,
        event : f
      },
      /**
       * The space between the icon and the label
       */
      gap : {
        check : c,
        nullable : false,
        event : j,
        apply : r,
        themeable : true,
        init : 4
      },
      /**
       * Configure the visibility of the sub elements/widgets.
       * Possible values: both, label, icon
       */
      show : {
        init : p,
        check : [p, l, k],
        themeable : true,
        inheritable : true,
        apply : t,
        event : i
      },
      /**
       * The position of the icon in relation to the text.
       * Only useful/needed if text and icon is configured and 'show' is configured as 'both' (default)
       */
      iconPosition : {
        init : n,
        check : [x, w, h, n, y, z],
        themeable : true,
        apply : b
      },
      /**
       * Whether the content should be rendered centrally when to much space
       * is available. Affects both axis.
       */
      center : {
        init : false,
        check : o,
        themeable : true,
        apply : g
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      _createChildControlImpl : function(C, D){

        var E;
        switch(C){case l:
        E = new qx.ui.basic.Label(this.getLabel());
        E.setAnonymous(true);
        E.setRich(this.getRich());
        this._add(E);
        if(this.getLabel() == null || this.getShow() === k){

          E.exclude();
        };
        break;case k:
        E = new qx.ui.basic.Image(this.getIcon());
        E.setAnonymous(true);
        this._addAt(E, 0);
        if(this.getIcon() == null || this.getShow() === l){

          E.exclude();
        };
        break;};
        return E || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, C);
      },
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        focused : true,
        hovered : true
      },
      /**
       * Updates the visibility of the label
       */
      _handleLabel : function(){

        if(this.getLabel() == null || this.getShow() === k){

          this._excludeChildControl(l);
        } else {

          this._showChildControl(l);
        };
      },
      /**
       * Updates the visibility of the icon
       */
      _handleIcon : function(){

        if(this.getIcon() == null || this.getShow() === l){

          this._excludeChildControl(k);
        } else {

          this._showChildControl(k);
        };
      },
      // property apply
      _applyLabel : function(F, G){

        var H = this.getChildControl(l, true);
        if(H){

          H.setValue(F);
        };
        this._handleLabel();
      },
      // property apply
      _applyRich : function(I, J){

        var K = this.getChildControl(l, true);
        if(K){

          K.setRich(I);
        };
      },
      // property apply
      _applyIcon : function(L, M){

        var N = this.getChildControl(k, true);
        if(N){

          N.setSource(L);
        };
        this._handleIcon();
      },
      // property apply
      _applyGap : function(O, P){

        this._getLayout().setGap(O);
      },
      // property apply
      _applyShow : function(Q, R){

        this._handleLabel();
        this._handleIcon();
      },
      // property apply
      _applyIconPosition : function(S, T){

        this._getLayout().setIconPosition(S);
      },
      // property apply
      _applyCenter : function(U, V){

        this._getLayout().setCenter(U);
      },
      // overridden
      _applySelectable : function(W, X){

        qx.ui.core.Widget.prototype._applySelectable.call(this, W, X);
        var Y = this.getChildControl(l, true);
        if(Y){

          this.getChildControl(l).setSelectable(W);
        };
      }
    }
  });
})();
(function(){

  var p = "middle",o = "' is not supported by the Atom layout!",n = "qx.debug",m = "center",l = "qx.ui.layout.Atom",k = "Integer",j = "The property '",h = "Boolean",g = "top-left",f = "bottom-left",c = "left",e = "right",d = "_applyLayoutChange",b = "top",a = "bottom";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A atom layout. Used to place an image and label in relation
   * to each other. Useful to create buttons, list items, etc.
   *
   * *Features*
   *
   * * Gap between icon and text (using {@link #gap})
   * * Vertical and horizontal mode (using {@link #iconPosition})
   * * Sorting options to place first child on top/left or bottom/right (using {@link #iconPosition})
   * * Automatically middles/centers content to the available space
   * * Auto-sizing
   * * Supports more than two children (will be processed the same way like the previous ones)
   *
   * *Item Properties*
   *
   * None
   *
   * *Notes*
   *
   * * Does not support margins and alignment of {@link qx.ui.core.LayoutItem}.
   *
   * *Alternative Names*
   *
   * None
   */
  qx.Class.define(l, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The gap between the icon and the text */
      gap : {
        check : k,
        init : 4,
        apply : d
      },
      /** The position of the icon in relation to the text */
      iconPosition : {
        check : [c, b, e, a, g, f],
        init : c,
        apply : d
      },
      /**
       * Whether the content should be rendered centrally when to much space
       * is available. Affects both axis.
       */
      center : {
        check : h,
        init : false,
        apply : d
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(n, {
        "true" : function(q, name, r){

          this.assert(false, j + name + o);
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(s, t){

        var C = qx.ui.layout.Util;
        var v = this.getIconPosition();
        var y = this._getLayoutChildren();
        var length = y.length;
        var N,top,M,w;
        var H,B;
        var F = this.getGap();
        var K = this.getCenter();
        // reverse ordering
        if(v === a || v === e){

          var D = length - 1;
          var z = -1;
          var x = -1;
        } else {

          var D = 0;
          var z = length;
          var x = 1;
        };
        // vertical
        if(v == b || v == a){

          if(K){

            var G = 0;
            for(var i = D;i != z;i += x){

              w = y[i].getSizeHint().height;
              if(w > 0){

                G += w;
                if(i != D){

                  G += F;
                };
              };
            };
            top = Math.round((t - G) / 2);
          } else {

            top = 0;
          };
          for(var i = D;i != z;i += x){

            H = y[i];
            B = H.getSizeHint();
            M = Math.min(B.maxWidth, Math.max(s, B.minWidth));
            w = B.height;
            N = C.computeHorizontalAlignOffset(m, M, s);
            H.renderLayout(N, top, M, w);
            // Ignore pseudo invisible elements
            if(w > 0){

              top += w + F;
            };
          };
        } else {

          var A = s;
          var u = null;
          var J = 0;
          for(var i = D;i != z;i += x){

            H = y[i];
            M = H.getSizeHint().width;
            if(M > 0){

              if(!u && H instanceof qx.ui.basic.Label){

                u = H;
              } else {

                A -= M;
              };
              J++;
            };
          };
          if(J > 1){

            var I = (J - 1) * F;
            A -= I;
          };
          if(u){

            var B = u.getSizeHint();
            var E = Math.max(B.minWidth, Math.min(A, B.maxWidth));
            A -= E;
          };
          if(K && A > 0){

            N = Math.round(A / 2);
          } else {

            N = 0;
          };
          for(var i = D;i != z;i += x){

            H = y[i];
            B = H.getSizeHint();
            w = Math.min(B.maxHeight, Math.max(t, B.minHeight));
            if(H === u){

              M = E;
            } else {

              M = B.width;
            };
            var L = p;
            if(v == g){

              L = b;
            } else if(v == f){

              L = a;
            };
            top = C.computeVerticalAlignOffset(L, B.height, t);
            H.renderLayout(N, top, M, w);
            // Ignore pseudo invisible childs for gap e.g.
            // empty text or unavailable images
            if(M > 0){

              N += M + F;
            };
          };
        };
      },
      // overridden
      _computeSizeHint : function(){

        var Y = this._getLayoutChildren();
        var length = Y.length;
        var Q,W;
        // Fast path for only one child
        if(length === 1){

          var Q = Y[0].getSizeHint();
          // Work on a copy, but do not respect max
          // values as a Atom can be rendered bigger
          // than its content.
          W = {
            width : Q.width,
            height : Q.height,
            minWidth : Q.minWidth,
            minHeight : Q.minHeight
          };
        } else {

          var U = 0,V = 0;
          var R = 0,T = 0;
          var S = this.getIconPosition();
          var X = this.getGap();
          if(S === b || S === a){

            var O = 0;
            for(var i = 0;i < length;i++){

              Q = Y[i].getSizeHint();
              // Max of widths
              V = Math.max(V, Q.width);
              U = Math.max(U, Q.minWidth);
              // Sum of heights
              if(Q.height > 0){

                T += Q.height;
                R += Q.minHeight;
                O++;
              };
            };
            if(O > 1){

              var P = (O - 1) * X;
              T += P;
              R += P;
            };
          } else {

            var O = 0;
            for(var i = 0;i < length;i++){

              Q = Y[i].getSizeHint();
              // Max of heights
              T = Math.max(T, Q.height);
              R = Math.max(R, Q.minHeight);
              // Sum of widths
              if(Q.width > 0){

                V += Q.width;
                U += Q.minWidth;
                O++;
              };
            };
            if(O > 1){

              var P = (O - 1) * X;
              V += P;
              U += P;
            };
          };
          // Build hint
          W = {
            minWidth : U,
            width : V,
            minHeight : R,
            height : T
          };
        };
        return W;
      }
    }
  });
})();
(function(){

  var g = "middle",f = "qx.ui.layout.Util",e = "left",d = "center",c = "top",b = "bottom",a = "right";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Common set of utility methods used by the standard qooxdoo layouts.
   *
   * @internal
   */
  qx.Class.define(f, {
    statics : {
      /** {Regexp} Regular expression to match percent values */
      PERCENT_VALUE : /[0-9]+(?:\.[0-9]+)?%/,
      /**
       * Computes the flex offsets needed to reduce the space
       * difference as much as possible by respecting the
       * potential of the given elements (being in the range of
       * their min/max values)
       *
       * @param flexibles {Map} Each entry must have these keys:
       *   <code>id</code>, <code>potential</code> and <code>flex</code>.
       *   The ID is used in the result map as the key for the user to work
       *   with later (e.g. upgrade sizes etc. to respect the given offset)
       *   The potential is an integer value which is the difference of the
       *   currently interesting direction (e.g. shrinking=width-minWidth, growing=
       *   maxWidth-width). The flex key holds the flex value of the item.
       * @param avail {Integer} Full available space to allocate (ignoring used one)
       * @param used {Integer} Size of already allocated space
       * @return {Map} A map which contains the calculated offsets under the key
       *   which is identical to the ID given in the incoming map.
       */
      computeFlexOffsets : function(h, j, k){

        var n,r,m,s;
        var o = j > k;
        var t = Math.abs(j - k);
        var u,p;
        // Preprocess data
        var q = {
        };
        for(r in h){

          n = h[r];
          q[r] = {
            potential : o ? n.max - n.value : n.value - n.min,
            flex : o ? n.flex : 1 / n.flex,
            offset : 0
          };
        };
        // Continue as long as we need to do anything
        while(t != 0){

          // Find minimum potential for next correction
          s = Infinity;
          m = 0;
          for(r in q){

            n = q[r];
            if(n.potential > 0){

              m += n.flex;
              s = Math.min(s, n.potential / n.flex);
            };
          };
          // No potential found, quit here
          if(m == 0){

            break;
          };
          // Respect maximum potential given through remaining space
          // The parent should always win in such conflicts.
          s = Math.min(t, s * m) / m;
          // Start with correction
          u = 0;
          for(r in q){

            n = q[r];
            if(n.potential > 0){

              // Compute offset for this step
              p = Math.min(t, n.potential, Math.ceil(s * n.flex));
              // Fix rounding issues
              u += p - s * n.flex;
              if(u >= 1){

                u -= 1;
                p -= 1;
              };
              // Update child status
              n.potential -= p;
              if(o){

                n.offset += p;
              } else {

                n.offset -= p;
              };
              // Update parent status
              t -= p;
            };
          };
        };
        return q;
      },
      /**
       * Computes the offset which needs to be added to the top position
       * to result in the stated vertical alignment. Also respects
       * existing margins (without collapsing).
       *
       * @param align {String} One of <code>top</code>, <code>center</code> or <code>bottom</code>.
       * @param width {Integer} The visible width of the widget
       * @param availWidth {Integer} The available inner width of the parent
       * @param marginLeft {Integer?0} Optional left margin of the widget
       * @param marginRight {Integer?0} Optional right margin of the widget
       * @return {Integer} Computed top coordinate
       */
      computeHorizontalAlignOffset : function(v, w, x, y, z){

        if(y == null){

          y = 0;
        };
        if(z == null){

          z = 0;
        };
        var A = 0;
        switch(v){case e:
        A = y;
        break;case a:
        // Align right changes priority to right edge:
        // To align to the right is more important here than to left.
        A = x - w - z;
        break;case d:
        // Ideal center position
        A = Math.round((x - w) / 2);
        // Try to make this possible (with left-right priority)
        if(A < y){

          A = y;
        } else if(A < z){

          A = Math.max(y, x - w - z);
        };
        break;};
        return A;
      },
      /**
       * Computes the offset which needs to be added to the top position
       * to result in the stated vertical alignment. Also respects
       * existing margins (without collapsing).
       *
       * @param align {String} One of <code>top</code>, <code>middle</code> or <code>bottom</code>.
       * @param height {Integer} The visible height of the widget
       * @param availHeight {Integer} The available inner height of the parent
       * @param marginTop {Integer?0} Optional top margin of the widget
       * @param marginBottom {Integer?0} Optional bottom margin of the widget
       * @return {Integer} Computed top coordinate
       */
      computeVerticalAlignOffset : function(B, C, D, E, F){

        if(E == null){

          E = 0;
        };
        if(F == null){

          F = 0;
        };
        var G = 0;
        switch(B){case c:
        G = E;
        break;case b:
        // Align bottom changes priority to bottom edge:
        // To align to the bottom is more important here than to top.
        G = D - C - F;
        break;case g:
        // Ideal middle position
        G = Math.round((D - C) / 2);
        // Try to make this possible (with top-down priority)
        if(G < E){

          G = E;
        } else if(G < F){

          G = Math.max(E, D - C - F);
        };
        break;};
        return G;
      },
      /**
       * Collapses two margins.
       *
       * Supports positive and negative margins.
       * Collapsing find the largest positive and the largest
       * negative value. Afterwards the result is computed through the
       * subtraction of the negative from the positive value.
       *
       * @param varargs {arguments} Any number of configured margins
       * @return {Integer} The collapsed margin
       */
      collapseMargins : function(H){

        var I = 0,K = 0;
        for(var i = 0,l = arguments.length;i < l;i++){

          var J = arguments[i];
          if(J < 0){

            K = Math.min(K, J);
          } else if(J > 0){

            I = Math.max(I, J);
          };
        };
        return I + K;
      },
      /**
       * Computes the sum of all horizontal gaps. Normally the
       * result is used to compute the available width in a widget.
       *
       * The method optionally respects margin collapsing as well. In
       * this mode the spacing is collapsed together with the margins.
       *
       * @param children {Array} List of children
       * @param spacing {Integer?0} Spacing between every child
       * @param collapse {Boolean?false} Optional margin collapsing mode
       * @return {Integer} Sum of all gaps in the final layout.
       */
      computeHorizontalGaps : function(L, M, N){

        if(M == null){

          M = 0;
        };
        var O = 0;
        if(N){

          // Add first child
          O += L[0].getMarginLeft();
          for(var i = 1,l = L.length;i < l;i += 1){

            O += this.collapseMargins(M, L[i - 1].getMarginRight(), L[i].getMarginLeft());
          };
          // Add last child
          O += L[l - 1].getMarginRight();
        } else {

          // Simple adding of all margins
          for(var i = 1,l = L.length;i < l;i += 1){

            O += L[i].getMarginLeft() + L[i].getMarginRight();
          };
          // Add spacing
          O += (M * (l - 1));
        };
        return O;
      },
      /**
       * Computes the sum of all vertical gaps. Normally the
       * result is used to compute the available height in a widget.
       *
       * The method optionally respects margin collapsing as well. In
       * this mode the spacing is collapsed together with the margins.
       *
       * @param children {Array} List of children
       * @param spacing {Integer?0} Spacing between every child
       * @param collapse {Boolean?false} Optional margin collapsing mode
       * @return {Integer} Sum of all gaps in the final layout.
       */
      computeVerticalGaps : function(P, Q, R){

        if(Q == null){

          Q = 0;
        };
        var S = 0;
        if(R){

          // Add first child
          S += P[0].getMarginTop();
          for(var i = 1,l = P.length;i < l;i += 1){

            S += this.collapseMargins(Q, P[i - 1].getMarginBottom(), P[i].getMarginTop());
          };
          // Add last child
          S += P[l - 1].getMarginBottom();
        } else {

          // Simple adding of all margins
          for(var i = 1,l = P.length;i < l;i += 1){

            S += P[i].getMarginTop() + P[i].getMarginBottom();
          };
          // Add spacing
          S += (Q * (l - 1));
        };
        return S;
      },
      /**
       * Computes the gaps together with the configuration of separators.
       *
       * @param children {qx.ui.core.LayoutItem[]} List of children
       * @param spacing {Integer} Configured spacing
       * @param separator {Separator} Separator to render
       * @return {Integer} Sum of gaps
       */
      computeHorizontalSeparatorGaps : function(T, U, V){

        var Y = qx.theme.manager.Decoration.getInstance().resolve(V);
        var X = Y.getInsets();
        var W = X.left + X.right;
        var ba = 0;
        for(var i = 0,l = T.length;i < l;i++){

          var bb = T[i];
          ba += bb.getMarginLeft() + bb.getMarginRight();
        };
        ba += (U + W + U) * (l - 1);
        return ba;
      },
      /**
       * Computes the gaps together with the configuration of separators.
       *
       * @param children {qx.ui.core.LayoutItem[]} List of children
       * @param spacing {Integer} Configured spacing
       * @param separator {Separator} Separator to render
       * @return {Integer} Sum of gaps
       */
      computeVerticalSeparatorGaps : function(bc, bd, be){

        var bh = qx.theme.manager.Decoration.getInstance().resolve(be);
        var bg = bh.getInsets();
        var bf = bg.top + bg.bottom;
        var bi = 0;
        for(var i = 0,l = bc.length;i < l;i++){

          var bj = bc[i];
          bi += bj.getMarginTop() + bj.getMarginBottom();
        };
        bi += (bd + bf + bd) * (l - 1);
        return bi;
      },
      /**
       * Arranges two sizes in one box to best respect their individual limitations.
       *
       * Mainly used by split layouts (Split Panes) where the layout is mainly defined
       * by the outer dimensions.
       *
       * @param beginMin {Integer} Minimum size of first widget (from size hint)
       * @param beginIdeal {Integer} Ideal size of first widget (maybe after dragging the splitter)
       * @param beginMax {Integer} Maximum size of first widget (from size hint)
       * @param endMin {Integer} Minimum size of second widget (from size hint)
       * @param endIdeal {Integer} Ideal size of second widget (maybe after dragging the splitter)
       * @param endMax {Integer} Maximum size of second widget (from size hint)
       * @return {Map} Map with the keys <code>begin</code and <code>end</code> with the
       *   arranged dimensions.
       */
      arrangeIdeals : function(bk, bl, bm, bn, bo, bp){

        if(bl < bk || bo < bn){

          if(bl < bk && bo < bn){

            // Just increase both, can not rearrange them otherwise
            // Result into overflowing of the overlapping content
            // Should normally not happen through auto sizing!
            bl = bk;
            bo = bn;
          } else if(bl < bk){

            // Reduce end, increase begin to min
            bo -= (bk - bl);
            bl = bk;
            // Re-check to keep min size of end
            if(bo < bn){

              bo = bn;
            };
          } else if(bo < bn){

            // Reduce begin, increase end to min
            bl -= (bn - bo);
            bo = bn;
            // Re-check to keep min size of begin
            if(bl < bk){

              bl = bk;
            };
          };;
        };
        if(bl > bm || bo > bp){

          if(bl > bm && bo > bp){

            // Just reduce both, can not rearrange them otherwise
            // Leaves a blank area in the pane!
            bl = bm;
            bo = bp;
          } else if(bl > bm){

            // Increase end, reduce begin to max
            bo += (bl - bm);
            bl = bm;
            // Re-check to keep max size of end
            if(bo > bp){

              bo = bp;
            };
          } else if(bo > bp){

            // Increase begin, reduce end to max
            bl += (bo - bp);
            bo = bp;
            // Re-check to keep max size of begin
            if(bl > bm){

              bl = bm;
            };
          };;
        };
        return {
          begin : bl,
          end : bo
        };
      }
    }
  });
})();
(function(){

  var b = "qx.event.type.Data",a = "qx.ui.form.IStringForm";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all form widgets which have strings as their primary
   * data type like textfield's.
   */
  qx.Interface.define(a, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the value was modified */
      "changeValue" : b
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the element's value.
       *
       * @param value {String|null} The new value of the element.
       */
      setValue : function(c){

        return arguments.length == 1;
      },
      /**
       * Resets the element's value to its initial value.
       */
      resetValue : function(){
      },
      /**
       * The element's user set value.
       *
       * @return {String|null} The value.
       */
      getValue : function(){
      }
    }
  });
})();
(function(){

  var k = "os.name",j = "_applyTextAlign",i = "qx.ui.core.Widget",h = "nowrap",g = "changeStatus",f = "changeTextAlign",d = "_applyWrap",c = "changeValue",b = "qx.ui.basic.Label",a = "osx",M = "css.textoverflow",L = "textAlign",K = "html.xul",J = "_applyValue",I = "center",H = "Only rich labels support wrap.",G = "_applyBuddy",F = "String",E = "whiteSpace",D = "Only rich labels are selectable in browsers with Gecko engine!",r = "right",s = "gecko",p = "justify",q = "changeRich",n = "normal",o = "_applyRich",l = "engine.name",m = "click",t = "label",u = "left",x = "A",w = "Boolean",z = "qx.debug",y = "enabled",B = "engine.version",A = "changeLocale",v = "color",C = "qx.dynlocale";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * The label class brings typical text content to the widget system.
   *
   * It supports simple text nodes and complex HTML (rich). The default
   * content mode is for text only. The mode is changeable through the property
   * {@link #rich}.
   *
   * The label supports heightForWidth when used in HTML mode. This means
   * that multi line HTML automatically computes the correct preferred height.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // a simple text label without wrapping and markup support
   *   var label1 = new qx.ui.basic.Label("Simple text label");
   *   this.getRoot().add(label1, {left:20, top:10});
   *
   *   // a HTML label with automatic line wrapping
   *   var label2 = new qx.ui.basic.Label().set({
   *     value: "A <b>long label</b> text with auto-wrapping. This also may contain <b style='color:red'>rich HTML</b> markup.",
   *     rich : true,
   *     width: 120
   *   });
   *   this.getRoot().add(label2, {left:20, top:50});
   * </pre>
   *
   * The first label in this example is a basic text only label. As such no
   * automatic wrapping is supported. The second label is a long label containing
   * HTML markup with automatic line wrapping.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/label.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(b, {
    extend : qx.ui.core.Widget,
    implement : [qx.ui.form.IStringForm],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param value {String} Text or HTML content to use
     */
    construct : function(N){

      qx.ui.core.Widget.call(this);
      if(N != null){

        this.setValue(N);
      };
      if(qx.core.Environment.get(C)){

        qx.locale.Manager.getInstance().addListener(A, this._onChangeLocale, this);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Switches between rich HTML and text content. The text mode (<code>false</code>) supports
       * advanced features like ellipsis when the available space is not
       * enough. HTML mode (<code>true</code>) supports multi-line content and all the
       * markup features of HTML content.
       */
      rich : {
        check : w,
        init : false,
        event : q,
        apply : o
      },
      /**
       * Controls whether text wrap is activated or not. But please note, that
       * this property works only in combination with the property {@link #rich}.
       * The {@link #wrap} has only an effect if the {@link #rich} property is
       * set to <code>true</code>, otherwise {@link #wrap} has no effect.
       */
      wrap : {
        check : w,
        init : true,
        apply : d
      },
      /**
       * Contains the HTML or text content. Interpretation depends on the value
       * of {@link #rich}. In text mode entities and other HTML special content
       * is not supported. But it is possible to use unicode escape sequences
       * to insert symbols and other non ASCII characters.
       */
      value : {
        check : F,
        apply : J,
        event : c,
        nullable : true
      },
      /**
       * The buddy property can be used to connect the label to another widget.
       * That causes two things:
       * <ul>
       *   <li>The label will always take the same enabled state as the buddy
       *       widget.
       *   </li>
       *   <li>A click on the label will focus the buddy widget.
       *   </li>
       * </ul>
       * This is the behavior of the for attribute of HTML:
       * http://www.w3.org/TR/html401/interact/forms.html#adef-for
       */
      buddy : {
        check : i,
        apply : G,
        nullable : true,
        init : null,
        dereference : true
      },
      /** Control the text alignment */
      textAlign : {
        check : [u, I, r, p],
        nullable : true,
        themeable : true,
        apply : j,
        event : f
      },
      // overridden
      appearance : {
        refine : true,
        init : t
      },
      // overridden
      selectable : {
        refine : true,
        init : false
      },
      // overridden
      allowGrowX : {
        refine : true,
        init : false
      },
      // overridden
      allowGrowY : {
        refine : true,
        init : false
      },
      // overridden
      allowShrinkY : {
        refine : true,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __font : null,
      __invalidContentSize : null,
      __buddyEnabledBinding : null,
      __clickListenerId : null,
      __webfontListenerId : null,
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _getContentHint : function(){

        if(this.__invalidContentSize){

          this.__contentSize = this.__computeContentSize();
          delete this.__invalidContentSize;
        };
        return {
          width : this.__contentSize.width,
          height : this.__contentSize.height
        };
      },
      // overridden
      _hasHeightForWidth : function(){

        return this.getRich() && this.getWrap();
      },
      // overridden
      _applySelectable : function(O){

        // This is needed for all browsers not having text-overflow:ellipsis
        // but supporting XUL (firefox < 4)
        // https://bugzilla.mozilla.org/show_bug.cgi?id=312156
        if(!qx.core.Environment.get(M) && qx.core.Environment.get(K)){

          if(O && !this.isRich()){

            if(qx.core.Environment.get(z)){

              this.warn(D);
            };
            return;
          };
        };
        qx.ui.core.Widget.prototype._applySelectable.call(this, O);
      },
      // overridden
      _getContentHeightForWidth : function(P){

        if(!this.getRich() && !this.getWrap()){

          return null;
        };
        return this.__computeContentSize(P).height;
      },
      // overridden
      _createContentElement : function(){

        return new qx.html.Label;
      },
      // property apply
      _applyTextAlign : function(Q, R){

        this.getContentElement().setStyle(L, Q);
      },
      // overridden
      _applyTextColor : function(S, T){

        if(S){

          this.getContentElement().setStyle(v, qx.theme.manager.Color.getInstance().resolve(S));
        } else {

          this.getContentElement().removeStyle(v);
        };
      },
      /*
      ---------------------------------------------------------------------------
        LABEL ADDONS
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} Internal fallback of label size when no font is defined
       *
       * @lint ignoreReferenceField(__contentSize)
       */
      __contentSize : {
        width : 0,
        height : 0
      },
      // property apply
      _applyFont : function(U, V){

        if(V && this.__font && this.__webfontListenerId){

          this.__font.removeListenerById(this.__webfontListenerId);
          this.__webfontListenerId = null;
        };
        // Apply
        var W;
        if(U){

          this.__font = qx.theme.manager.Font.getInstance().resolve(U);
          if(this.__font instanceof qx.bom.webfonts.WebFont){

            this.__webfontListenerId = this.__font.addListener(g, this._onWebFontStatusChange, this);
          };
          W = this.__font.getStyles();
        } else {

          this.__font = null;
          W = qx.bom.Font.getDefaultStyles();
        };
        // check if text color already set - if so this local value has higher priority
        if(this.getTextColor() != null){

          delete W[v];
        };
        this.getContentElement().setStyles(W);
        // Invalidate text size
        this.__invalidContentSize = true;
        // Update layout
        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Internal utility to compute the content dimensions.
       *
       * @param width {Integer?null} Optional width constraint
       * @return {void}
       */
      __computeContentSize : function(X){

        var bc = qx.bom.Label;
        var ba = this.getFont();
        var Y = ba ? this.__font.getStyles() : qx.bom.Font.getDefaultStyles();
        var content = this.getValue() || x;
        var bb = this.getRich();
        if(this.__webfontListenerId){

          this.__fixEllipsis();
        };
        return bb ? bc.getHtmlSize(content, Y, X) : bc.getTextSize(content, Y);
      },
      /**
      * Firefox > 9 on OS X will draw an ellipsis on top of the label content even
      * though there is enough space for the text. Re-applying the content forces
      * a recalculation and fixes the problem. See qx bug #6293
      */
      __fixEllipsis : function(){

        if(!this.getContentElement()){

          return;
        };
        if(qx.core.Environment.get(k) == a && qx.core.Environment.get(l) == s && parseInt(qx.core.Environment.get(B), 10) < 16 && parseInt(qx.core.Environment.get(B), 10) > 9){

          var bd = this.getContentElement().getDomElement();
          if(bd){

            bd.innerHTML = bd.innerHTML;
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLIER
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyBuddy : function(be, bf){

        if(bf != null){

          bf.removeBinding(this.__buddyEnabledBinding);
          this.__buddyEnabledBinding = null;
          this.removeListenerById(this.__clickListenerId);
          this.__clickListenerId = null;
        };
        if(be != null){

          this.__buddyEnabledBinding = be.bind(y, this, y);
          this.__clickListenerId = this.addListener(m, function(){

            // only focus focusable elements [BUG #3555]
            if(be.isFocusable()){

              be.focus.apply(be);
            };
          }, this);
        };
      },
      // property apply
      _applyRich : function(bg){

        // Sync with content element
        this.getContentElement().setRich(bg);
        // Mark text size cache as invalid
        this.__invalidContentSize = true;
        // Update layout
        qx.ui.core.queue.Layout.add(this);
      },
      // property apply
      _applyWrap : function(bh, bi){

        if(bh && !this.isRich()){

          if(qx.core.Environment.get(z)){

            this.warn(H);
          };
        };
        if(this.isRich()){

          // apply the white space style to the label to force it not
          // to wrap if wrap is set to false [BUG #3732]
          var bj = bh ? n : h;
          this.getContentElement().setStyle(E, bj);
        };
      },
      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale : qx.core.Environment.select(C, {
        "true" : function(e){

          var content = this.getValue();
          if(content && content.translate){

            this.setValue(content.translate());
          };
        },
        "false" : null
      }),
      /**
       * Triggers layout recalculation after a web font was loaded
       *
       * @param ev {qx.event.type.Data} "changeStatus" event
       */
      _onWebFontStatusChange : function(bk){

        if(bk.getData().valid === true){

          this.__invalidContentSize = true;
          qx.ui.core.queue.Layout.add(this);
        };
      },
      // property apply
      _applyValue : function(bl, bm){

        // Sync with content element
        this.getContentElement().setValue(bl);
        // Mark text size cache as invalid
        this.__invalidContentSize = true;
        // Update layout
        qx.ui.core.queue.Layout.add(this);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(qx.core.Environment.get(C)){

        qx.locale.Manager.getInstance().removeListener(A, this._onChangeLocale, this);
      };
      // remove the binding
      if(this.__buddyEnabledBinding != null){

        var bn = this.getBuddy();
        if(bn != null && !bn.isDisposed()){

          bn.removeBinding(this.__buddyEnabledBinding);
        };
      };
      if(this.__font && this.__webfontListenerId){

        this.__font.removeListenerById(this.__webfontListenerId);
      };
      this.__font = this.__buddyEnabledBinding = null;
    }
  });
})();
(function(){

  var c = "qx.html.Label",b = "The label mode cannot be modified after initial creation",a = "value";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * A cross browser label instance with support for rich HTML and text labels.
   *
   * Text labels supports ellipsis to reduce the text width.
   *
   * The mode can be changed through the method {@link #setRich}
   * which accepts a boolean value. The default mode is "text" which is
   * a good choice because it has a better performance.
   */
  qx.Class.define(c, {
    extend : qx.html.Element,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __rich : null,
      /*
      ---------------------------------------------------------------------------
        ELEMENT API
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyProperty : function(name, d){

        qx.html.Element.prototype._applyProperty.call(this, name, d);
        if(name == a){

          var e = this.getDomElement();
          qx.bom.Label.setValue(e, d);
        };
      },
      // overridden
      _createDomElement : function(){

        var g = this.__rich;
        var f = qx.bom.Label.create(this._content, g);
        return f;
      },
      // overridden
      // be sure that style attributes are merged and not overwritten
      _copyData : function(h){

        return qx.html.Element.prototype._copyData.call(this, true);
      },
      /*
      ---------------------------------------------------------------------------
        LABEL API
      ---------------------------------------------------------------------------
      */
      /**
       * Toggles between rich HTML mode and pure text mode.
       *
       * @param value {Boolean} Whether the HTML mode should be used.
       * @return {qx.html.Label} This instance for chaining support.
       */
      setRich : function(i){

        var j = this.getDomElement();
        if(j){

          throw new Error(b);
        };
        i = !!i;
        if(this.__rich == i){

          return;
        };
        this.__rich = i;
        return this;
      },
      /**
       * Sets the HTML/text content depending on the content mode.
       *
       * @param value {String} The content to be used.
       * @return {qx.html.Label} This instance for for chaining support.
       */
      setValue : function(k){

        this._setProperty(a, k);
        return this;
      },
      /**
       * Get the current content.
       *
       * @return {String} The labels's content
       */
      getValue : function(){

        return this._getProperty(a);
      }
    }
  });
})();
(function(){

  var j = "px",i = "crop",h = "gecko",g = "end",f = "100%",e = "chrome",d = "visible",c = "qx.bom.Label",b = "safari",a = "ellipsis",F = "engine.version",E = "mshtml",D = "-1000px",C = "absolute",B = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",A = "nowrap",z = "div",y = "browser.name",x = "browser.version",w = "normal",q = "engine.name",r = "block",o = "label",p = "text",m = "value",n = "",k = "hidden",l = "auto",s = "0",t = "inherit",v = "html.xul",u = "css.textoverflow";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Cross browser abstractions to work with labels.
   */
  qx.Bootstrap.define(c, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Map} Contains all supported styles */
      __styles : {
        fontFamily : 1,
        fontSize : 1,
        fontWeight : 1,
        fontStyle : 1,
        lineHeight : 1
      },
      /**
       * Generates the helper DOM element for text measuring
       *
       * @return {Element} Helper DOM element
       */
      __prepareText : function(){

        var G = this.__createMeasureElement(false);
        document.body.insertBefore(G, document.body.firstChild);
        return this._textElement = G;
      },
      /**
       * Generates the helper DOM element for HTML measuring
       *
       * @return {Element} Helper DOM element
       */
      __prepareHtml : function(){

        var H = this.__createMeasureElement(true);
        document.body.insertBefore(H, document.body.firstChild);
        return this._htmlElement = H;
      },
      /**
       * Creates the measure element
       *
       * @param html {Boolean?false} Whether HTML markup should be used.
       * @return {Element} The measure element
       */
      __createMeasureElement : function(I){

        var J = qx.dom.Element.create(z);
        var K = J.style;
        K.width = K.height = l;
        K.left = K.top = D;
        K.visibility = k;
        K.position = C;
        K.overflow = d;
        K.display = r;
        if(I){

          K.whiteSpace = w;
        } else {

          K.whiteSpace = A;
          if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

            var L = document.createElementNS(B, o);
            // Force style inheritance for font styles to omit usage of
            // CSS "label" selector, See bug #1349 for details.
            var K = L.style;
            K.padding = s;
            K.margin = s;
            K.width = l;
            for(var M in this.__styles){

              K[M] = t;
            };
            J.appendChild(L);
          };
        };
        return J;
      },
      /**
       * Returns a map of all styles which should be applied as
       * a basic set.
       *
       * @param html {Boolean?false} Whether HTML markup should be used.
       * @return {Map} Initial styles which should be applied to a label element.
       */
      __getStyles : function(N){

        var O = {
        };
        if(N){

          O.whiteSpace = w;
        } else if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

          O.display = r;
        } else {

          O.overflow = k;
          O.whiteSpace = A;
          O[qx.core.Environment.get(u)] = a;
        };
        return O;
      },
      /**
       * Creates a label.
       *
       * The default mode is 'text' which means that the overlapping text is cut off
       * using ellipsis automatically. Text wrapping is disabled in this mode
       * as well. Spaces are normalized. Umlauts and other special symbols are only
       * allowed in unicode mode as normal characters.
       *
       * In the HTML mode you can insert any HTML, but loose the capability to cut
       * of overlapping text. Automatic text wrapping is enabled by default.
       *
       * It is not possible to modify the mode afterwards.
       *
       * @param content {String} Content of the label
       * @param html {Boolean?false} Whether HTML markup should be used.
       * @param win {Window?null} Window to create the element for
       * @return {Element} The created iframe node
       */
      create : function(content, P, Q){

        if(!Q){

          Q = window;
        };
        var R = Q.document.createElement(z);
        if(P){

          R.useHtml = true;
        } else if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

          // Gecko as of Firefox 2.x and 3.0 does not support ellipsis
          // for text overflow. We use this feature from XUL instead.
          var T = Q.document.createElementNS(B, o);
          var S = T.style;
          S.cursor = t;
          S.color = t;
          S.overflow = k;
          S.maxWidth = f;
          S.padding = s;
          S.margin = s;
          S.width = l;
          // Force style inheritance for font styles to omit usage of
          // CSS "label" selector, See bug #1349 for details.
          for(var U in this.__styles){

            T.style[U] = t;
          };
          T.setAttribute(i, g);
          R.appendChild(T);
        } else {

          qx.bom.element.Style.setStyles(R, this.__getStyles(P));
        };
        if(content){

          this.setValue(R, content);
        };
        return R;
      },
      /**
       * Sets the content of the element.
       *
       * The possibilities of the value depends on the mode
       * defined using {@link #create}.
       *
       * @param element {Element} DOM element to modify.
       * @param value {String} Content to insert.
       * @return {void}
       */
      setValue : function(V, W){

        W = W || n;
        if(V.useHtml){

          V.innerHTML = W;
        } else if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

          V.firstChild.setAttribute(m, W);
        } else {

          qx.bom.element.Attribute.set(V, p, W);
        };
      },
      /**
       * Returns the content of the element.
       *
       * @param element {Element} DOM element to query.
       * @return {String} Content stored in the element.
       */
      getValue : function(X){

        if(X.useHtml){

          return X.innerHTML;
        } else if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

          return X.firstChild.getAttribute(m) || n;
        } else {

          return qx.bom.element.Attribute.get(X, p);
        };
      },
      /**
       * Returns the preferred dimensions of the given HTML content.
       *
       * @param content {String} The HTML markup to measure
       * @param styles {Map?null} Optional styles to apply
       * @param width {Integer} To support width for height it is possible to limit the width
       * @return {Map} A map with preferred <code>width</code> and <code>height</code>.
       */
      getHtmlSize : function(content, Y, ba){

        var bb = this._htmlElement || this.__prepareHtml();
        // apply width
        bb.style.width = ba != undefined ? ba + j : l;
        // insert content
        bb.innerHTML = content;
        return this.__measureSize(bb, Y);
      },
      /**
       * Returns the preferred dimensions of the given text.
       *
       * @param text {String} The text to measure
       * @param styles {Map} Optional styles to apply
       * @return {Map} A map with preferred <code>width</code> and <code>height</code>.
       */
      getTextSize : function(bc, bd){

        var be = this._textElement || this.__prepareText();
        if(!qx.core.Environment.get(u) && qx.core.Environment.get(v)){

          be.firstChild.setAttribute(m, bc);
        } else {

          qx.bom.element.Attribute.set(be, p, bc);
        };
        return this.__measureSize(be, bd);
      },
      /**
       * Measure the size of the given element
       *
       * @param element {Element} The element to measure
       * @param styles {Map?null} Optional styles to apply
       * @return {Map} A map with preferred <code>width</code> and <code>height</code>.
       */
      __measureSize : function(bf, bg){

        // sync styles
        var bh = this.__styles;
        if(!bg){

          bg = {
          };
        };
        for(var bi in bh){

          bf.style[bi] = bg[bi] || n;
        };
        // detect size
        var bj = qx.bom.element.Dimension.getSize(bf);
        // Under Mac at least with Firefox 3.0 alpha 6 and earlier
        // there was an issue that the text size calculation returns
        // a size which is a bit too small and results into ellipsis
        // even under the measured size.
        // Linux shows the same bug (FF 3.0.6)
        // https://bugzilla.mozilla.org/show_bug.cgi?id=450422
        // Also FF4 with Windows7 shows the same issue see bug #4961
        if((qx.core.Environment.get(q) == h)){

          bj.width++;
        };
        // IE9 has problems with the text size calculation for details have a look at bug #4038
        if((qx.core.Environment.get(q) == E) && parseFloat(qx.core.Environment.get(F)) >= 9){

          bj.width++;
        };
        // Chrome since version 22 also has the already known missing pixel [BUG #6799]
        if(qx.core.Environment.get(y) == e && parseFloat(qx.core.Environment.get(x)) >= 22){

          bj.width++;
        };
        // add another pixel for safari 6. web fonts have problems otheriwse [BUG #6785]
        if(qx.core.Environment.get(y) == b && parseFloat(qx.core.Environment.get(x)) >= 6){

          bj.width++;
        };
        return bj;
      }
    }
  });
})();
(function(){

  var b = "qx.ui.form.IForm",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all form widgets. It includes the API for enabled,
   * required and valid states.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the enabled state was modified */
      "changeEnabled" : a,
      /** Fired when the valid state was modified */
      "changeValid" : a,
      /** Fired when the invalidMessage was modified */
      "changeInvalidMessage" : a,
      /** Fired when the required was modified */
      "changeRequired" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        ENABLED PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Set the enabled state of the widget.
       *
       * @param enabled {Boolean} The enabled state.
       */
      setEnabled : function(c){

        return arguments.length == 1;
      },
      /**
       * Return the current set enabled state.
       *
       * @return {Boolean} If the widget is enabled.
       */
      getEnabled : function(){
      },
      /*
      ---------------------------------------------------------------------------
        REQUIRED PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the required state of a widget.
       *
       * @param required {Boolean} A flag signaling if the widget is required.
       */
      setRequired : function(d){

        return arguments.length == 1;
      },
      /**
       * Return the current required state of the widget.
       *
       * @return {Boolean} True, if the widget is required.
       */
      getRequired : function(){
      },
      /*
      ---------------------------------------------------------------------------
        VALID PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the valid state of the widget.
       *
       * @param valid {Boolean} The valid state of the widget.
       */
      setValid : function(e){

        return arguments.length == 1;
      },
      /**
       * Returns the valid state of the widget.
       *
       * @return {Boolean} If the state of the widget is valid.
       */
      getValid : function(){
      },
      /*
      ---------------------------------------------------------------------------
        INVALID MESSAGE PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the invalid message of the widget.
       *
       * @param message {String} The invalid message.
       */
      setInvalidMessage : function(f){

        return arguments.length == 1;
      },
      /**
       * Returns the invalid message of the widget.
       *
       * @return {String} The current set message.
       */
      getInvalidMessage : function(){
      },
      /*
      ---------------------------------------------------------------------------
        REQUIRED INVALID MESSAGE PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the invalid message if required of the widget.
       *
       * @param message {String} The invalid message.
       */
      setRequiredInvalidMessage : function(g){

        return arguments.length == 1;
      },
      /**
       * Returns the invalid message if required of the widget.
       *
       * @return {String} The current set message.
       */
      getRequiredInvalidMessage : function(){
      }
    }
  });
})();
(function(){

  var a = "qx.application.Inline";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.core.Init)
  
  ************************************************************************ */
  /**
   * For a GUI application on a traditional, HTML-dominated web page.
   *
   * The ideal environment for typical portal sites which use just a few qooxdoo
   * widgets. {@link qx.ui.root.Inline} can be used to embed qooxdoo widgets
   * into the page flow.
   */
  qx.Class.define(a, {
    extend : qx.application.AbstractGui,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _createRootWidget : function(){

        return new qx.ui.root.Page(document);
      }
    }
  });
})();
(function(){

  var i = "_applyActiveWindow",h = "__windows",g = "qx.ui.window.MDesktop",f = "__manager",d = "changeModal",c = "changeVisibility",b = "changeActive",a = "qx.ui.window.Window";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #ignore(qx.ui.window.Window)
  
  ************************************************************************ */
  /**
   * This mixin implements the key methods of the {@link qx.ui.window.IDesktop}.
   */
  qx.Mixin.define(g, {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The currently active window
       */
      activeWindow : {
        check : a,
        apply : i,
        init : null,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __windows : null,
      __manager : null,
      /**
       * Get the desktop's window manager. Each desktop must have a window manager.
       * If none is configured the default window manager {@link qx.ui.window.Window#DEFAULT_MANAGER_CLASS}
       * is used.
       *
       * @return {qx.ui.window.IWindowManager} The desktop's window manager
       */
      getWindowManager : function(){

        if(!this.__manager){

          this.setWindowManager(new qx.ui.window.Window.DEFAULT_MANAGER_CLASS());
        };
        return this.__manager;
      },
      /**
       * Whether the configured layout supports a maximized window
       * e.g. is a Canvas.
       *
       * @return {Boolean} Whether the layout supports maximized windows
       */
      supportsMaximize : function(){

        return true;
      },
      /**
       * Sets the desktop's window manager
       *
       * @param manager {qx.ui.window.IWindowManager} The window manager
       */
      setWindowManager : function(j){

        if(this.__manager){

          this.__manager.setDesktop(null);
        };
        j.setDesktop(this);
        this.__manager = j;
      },
      /**
       * Event handler. Called if one of the managed windows changes its active
       * state.
       *
       * @param e {qx.event.type.Event} the event object.
       */
      _onChangeActive : function(e){

        if(e.getData()){

          this.setActiveWindow(e.getTarget());
        } else if(this.getActiveWindow() == e.getTarget()){

          this.setActiveWindow(null);
        };
      },
      // property apply
      _applyActiveWindow : function(k, l){

        this.getWindowManager().changeActiveWindow(k, l);
        this.getWindowManager().updateStack();
      },
      /**
       * Event handler. Called if one of the managed windows changes its modality
       *
       * @param e {qx.event.type.Event} the event object.
       */
      _onChangeModal : function(e){

        this.getWindowManager().updateStack();
      },
      /**
       * Event handler. Called if one of the managed windows changes its visibility
       * state.
       */
      _onChangeVisibility : function(){

        this.getWindowManager().updateStack();
      },
      /**
       * Overrides the method {@link qx.ui.core.Widget#_afterAddChild}
       *
       * @param win {qx.core.Widget} added widget
       */
      _afterAddChild : function(m){

        if(qx.Class.isDefined(a) && m instanceof qx.ui.window.Window){

          this._addWindow(m);
        };
      },
      /**
       * Handles the case, when a window is added to the desktop.
       *
       * @param win {qx.ui.window.Window} Window, which has been added
       */
      _addWindow : function(n){

        if(!qx.lang.Array.contains(this.getWindows(), n)){

          this.getWindows().push(n);
          n.addListener(b, this._onChangeActive, this);
          n.addListener(d, this._onChangeModal, this);
          n.addListener(c, this._onChangeVisibility, this);
        };
        if(n.getActive()){

          this.setActiveWindow(n);
        };
        this.getWindowManager().updateStack();
      },
      /**
       * Overrides the method {@link qx.ui.core.Widget#_afterRemoveChild}
       *
       * @param win {qx.core.Widget} removed widget
       */
      _afterRemoveChild : function(o){

        if(qx.Class.isDefined(a) && o instanceof qx.ui.window.Window){

          this._removeWindow(o);
        };
      },
      /**
       * Handles the case, when a window is removed from the desktop.
       *
       * @param win {qx.ui.window.Window} Window, which has been removed
       */
      _removeWindow : function(p){

        qx.lang.Array.remove(this.getWindows(), p);
        p.removeListener(b, this._onChangeActive, this);
        p.removeListener(d, this._onChangeModal, this);
        p.removeListener(c, this._onChangeVisibility, this);
        this.getWindowManager().updateStack();
      },
      /**
       * Get a list of all windows added to the desktop (including hidden windows)
       *
       * @return {qx.ui.window.Window[]} Array of managed windows
       */
      getWindows : function(){

        if(!this.__windows){

          this.__windows = [];
        };
        return this.__windows;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeArray(h);
      this._disposeObjects(f);
    }
  });
})();
(function(){

  var f = "_applyBlockerColor",e = "Number",d = "__blocker",c = "qx.ui.core.MBlocker",b = "_applyBlockerOpacity",a = "Color";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin blocks events and can be included into all widgets.
   *
   * The {@link #block} and {@link #unblock} methods provided by this mixin can be used
   * to block any event from the widget. When blocked,
   * the blocker widget overlays the widget to block, including the padding area.
   *
   * The second set of methods ({@link #blockContent}, {@link #unblockContent})
   * can be used to block child widgets with a zIndex below a certain value.
   */
  qx.Mixin.define(c, {
    construct : function(){

      this.__blocker = this._createBlocker();
    },
    properties : {
      /**
       * Color of the blocker
       */
      blockerColor : {
        check : a,
        init : null,
        nullable : true,
        apply : f,
        themeable : true
      },
      /**
       * Opacity of the blocker
       */
      blockerOpacity : {
        check : e,
        init : 1,
        apply : b,
        themeable : true
      }
    },
    members : {
      __blocker : null,
      /**
       * Template method for creating the blocker item.
       * @return {qx.ui.core.Blocker} The blocker to use.
       */
      _createBlocker : function(){

        return new qx.ui.core.Blocker(this);
      },
      // property apply
      _applyBlockerColor : function(g, h){

        this.__blocker.setColor(g);
      },
      // property apply
      _applyBlockerOpacity : function(i, j){

        this.__blocker.setOpacity(i);
      },
      /**
       * Block all events from this widget by placing a transparent overlay widget,
       * which receives all events, exactly over the widget.
       */
      block : function(){

        this.__blocker.block();
      },
      /**
       * Returns whether the widget is blocked.
       *
       * @return {Boolean} Whether the widget is blocked.
       */
      isBlocked : function(){

        return this.__blocker.isBlocked();
      },
      /**
       * Unblock the widget blocked by {@link #block}, but it takes care of
       * the amount of {@link #block} calls. The blocker is only removed if
       * the numer of {@link #unblock} calls is identical to {@link #block} calls.
       */
      unblock : function(){

        this.__blocker.unblock();
      },
      /**
       * Unblock the widget blocked by {@link #block}, but it doesn't take care of
       * the amount of {@link #block} calls. The blocker is directly removed.
       */
      forceUnblock : function(){

        this.__blocker.forceUnblock();
      },
      /**
       * Block direct child widgets with a zIndex below <code>zIndex</code>
       *
       * @param zIndex {zIndex} All child widgets with a zIndex below this value
       *     will be blocked
       */
      blockContent : function(k){

        this.__blocker.blockContent(k);
      },
      /**
       * Whether the content is blocked
       *
       * @return {Boolean} Whether the content is blocked
       */
      isContentBlocked : function(){

        return this.__blocker.isContentBlocked();
      },
      /**
       * Unblock the content blocked by {@link #blockContent}, but it takes care of
       * the amount of {@link #blockContent} calls. The blocker is only removed if
       * the numer of {@link #unblockContent} calls is identical to
       * {@link #blockContent} calls.
       */
      unblockContent : function(){

        this.__blocker.unblockContent();
      },
      /**
       * Unblock the content blocked by {@link #blockContent}, but it doesn't take
       * care of the amount of {@link #blockContent} calls. The blocker is
       * directly removed.
       */
      forceUnblockContent : function(){

        this.__blocker.forceUnblockContent();
      },
      /**
       * Get the blocker
       *
       * @return {qx.ui.core.Blocker} The blocker
       */
      getBlocker : function(){

        return this.__blocker;
      }
    },
    destruct : function(){

      this._disposeObjects(d);
    }
  });
})();
(function(){

  var l = "backgroundColor",k = "_applyOpacity",j = "Boolean",h = "__timer",g = "__contentBlocker",f = "__blocker",d = "opacity",c = "interval",b = "Tab",a = "Color",A = "qx.ui.root.Page",z = "Number",y = "qx.ui.core.Blocker",x = "qx.ui.root.Application",w = "_applyColor",v = "px",u = "keydown",t = "deactivate",s = "qx.event.type.Event",r = "resize",p = "keyup",q = "keypress",n = "unblocked",o = "blocked",m = "zIndex";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /*
  #ignore(qx.ui.root.Page)
  */
  /**
   * This class blocks events and can be included into all widgets.
   *
   * The {@link #block} and {@link #unblock} methods provided by this class can be used
   * to block any event from the widget. When blocked,
   * the blocker widget overlays the widget to block, including the padding area.
   *
   * The second set of methods ({@link #blockContent}, {@link #unblockContent})
   * can be used to block child widgets with a zIndex below a certain value.
   */
  qx.Class.define(y, {
    extend : qx.core.Object,
    events : {
      /**
       * Fires after {@link #block} or {@link #blockContent} executed.
       */
      blocked : s,
      /**
       * Fires after {@link #unblock} or {@link #unblockContent} executed.
       */
      unblocked : s
    },
    /**
     * Creates a blocker for the passed widget.
     *
     * @param widget {qx.ui.core.Widget} Widget which should be added the blocker
     */
    construct : function(B){

      qx.core.Object.call(this);
      this._widget = B;
      this._isPageRoot = (qx.Class.isDefined(A) && B instanceof qx.ui.root.Page);
      if(this._isPageRoot){

        B.addListener(r, this.__onResize, this);
      };
      if(qx.Class.isDefined(x) && B instanceof qx.ui.root.Application){

        this.setKeepBlockerActive(true);
      };
      this.__activeElements = [];
      this.__focusElements = [];
      this.__contentBlockerCount = [];
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Color of the blocker
       */
      color : {
        check : a,
        init : null,
        nullable : true,
        apply : w,
        themeable : true
      },
      /**
       * Opacity of the blocker
       */
      opacity : {
        check : z,
        init : 1,
        apply : k,
        themeable : true
      },
      /**
       * If this property is enabled, the blocker created with {@link #block}
       * will always stay activated. This means that the blocker then gets all keyboard
       * events, this is useful to block keyboard input on other widgets.
       * Take care that only one blocker instance will be kept active, otherwise your
       * browser will freeze.
       */
      keepBlockerActive : {
        check : j,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __blocker : null,
      __blockerCount : 0,
      __contentBlocker : null,
      __contentBlockerCount : null,
      __activeElements : null,
      __focusElements : null,
      __oldAnonymous : null,
      __timer : null,
      _isPageRoot : false,
      _widget : null,
      /**
       * Adjust html element size on layout resizes.
       *
       * @param e {qx.event.type.Data} event object
       */
      __onResize : function(e){

        var C = e.getData();
        if(this.isContentBlocked()){

          this.getContentBlockerElement().setStyles({
            width : C.width,
            height : C.height
          });
        };
        if(this.isBlocked()){

          this.getBlockerElement().setStyles({
            width : C.width,
            height : C.height
          });
        };
      },
      // property apply
      _applyColor : function(D, E){

        var F = qx.theme.manager.Color.getInstance().resolve(D);
        this.__setBlockersStyle(l, F);
      },
      // property apply
      _applyOpacity : function(G, H){

        this.__setBlockersStyle(d, G);
      },
      /**
       * Set the style to all blockers (blocker and content blocker).
       *
       * @param key {String} The name of the style attribute.
       * @param value {String} The value.
       */
      __setBlockersStyle : function(I, J){

        var K = [];
        this.__blocker && K.push(this.__blocker);
        this.__contentBlocker && K.push(this.__contentBlocker);
        for(var i = 0;i < K.length;i++){

          K[i].setStyle(I, J);
        };
      },
      /**
       * Backup the current active and focused widget.
       */
      _backupActiveWidget : function(){

        var L = qx.event.Registration.getManager(window).getHandler(qx.event.handler.Focus);
        this.__activeElements.push(L.getActive());
        this.__focusElements.push(L.getFocus());
        if(this._widget.isFocusable()){

          this._widget.focus();
        };
      },
      /**
       * Restore the current active and focused widget.
       */
      _restoreActiveWidget : function(){

        var O = this.__activeElements.length;
        if(O > 0){

          var N = this.__activeElements[O - 1];
          if(N){

            qx.bom.Element.activate(N);
          };
          this.__activeElements.pop();
        };
        var M = this.__focusElements.length;
        if(M > 0){

          var N = this.__focusElements[M - 1];
          if(N){

            qx.bom.Element.focus(this.__focusElements[M - 1]);
          };
          this.__focusElements.pop();
        };
      },
      /**
       * Creates the blocker element.
       *
       * @return {qx.html.Element} The blocker element
       */
      __createBlockerElement : function(){

        return new qx.html.Blocker(this.getColor(), this.getOpacity());
      },
      /**
       * Get/create the blocker element
       *
       * @return {qx.html.Element} The blocker element
       */
      getBlockerElement : function(){

        if(!this.__blocker){

          this.__blocker = this.__createBlockerElement();
          this.__blocker.setStyle(m, 15);
          this._widget.getContainerElement().add(this.__blocker);
          this.__blocker.exclude();
        };
        return this.__blocker;
      },
      /**
       * Block all events from this widget by placing a transparent overlay widget,
       * which receives all events, exactly over the widget.
       */
      block : function(){

        this.__blockerCount++;
        if(this.__blockerCount < 2){

          this._backupActiveWidget();
          var P = this.getBlockerElement();
          P.include();
          P.activate();
          P.addListener(t, this.__activateBlockerElement, this);
          P.addListener(q, this.__stopTabEvent, this);
          P.addListener(u, this.__stopTabEvent, this);
          P.addListener(p, this.__stopTabEvent, this);
          this.fireEvent(o, qx.event.type.Event);
        };
      },
      /**
       * Returns whether the widget is blocked.
       *
       * @return {Boolean} Whether the widget is blocked.
       */
      isBlocked : function(){

        return this.__blockerCount > 0;
      },
      /**
       * Unblock the widget blocked by {@link #block}, but it takes care of
       * the amount of {@link #block} calls. The blocker is only removed if
       * the numer of {@link #unblock} calls is identical to {@link #block} calls.
       */
      unblock : function(){

        if(!this.isBlocked()){

          return;
        };
        this.__blockerCount--;
        if(this.__blockerCount < 1){

          this.__unblock();
          this.__blockerCount = 0;
        };
      },
      /**
       * Unblock the widget blocked by {@link #block}, but it doesn't take care of
       * the amount of {@link #block} calls. The blocker is directly removed.
       */
      forceUnblock : function(){

        if(!this.isBlocked()){

          return;
        };
        this.__blockerCount = 0;
        this.__unblock();
      },
      /**
       * Unblock the widget blocked by {@link #block}.
       */
      __unblock : function(){

        this._restoreActiveWidget();
        var Q = this.getBlockerElement();
        Q.removeListener(t, this.__activateBlockerElement, this);
        Q.removeListener(q, this.__stopTabEvent, this);
        Q.removeListener(u, this.__stopTabEvent, this);
        Q.removeListener(p, this.__stopTabEvent, this);
        Q.exclude();
        this.fireEvent(n, qx.event.type.Event);
      },
      /**
       * Get/create the content blocker element
       *
       * @return {qx.html.Element} The blocker element
       */
      getContentBlockerElement : function(){

        if(!this.__contentBlocker){

          this.__contentBlocker = this.__createBlockerElement();
          this._widget.getContentElement().add(this.__contentBlocker);
          this.__contentBlocker.exclude();
        };
        return this.__contentBlocker;
      },
      /**
       * Block direct child widgets with a zIndex below <code>zIndex</code>
       *
       * @param zIndex {zIndex} All child widgets with a zIndex below this value
       *     will be blocked
       */
      blockContent : function(R){

        var S = this.getContentBlockerElement();
        S.setStyle(m, R);
        this.__contentBlockerCount.push(R);
        if(this.__contentBlockerCount.length < 2){

          S.include();
          if(this._isPageRoot){

            // to block interaction we need to cover the HTML page with a div as well.
            // we do so by placing a div parallel to the page root with a slightly
            // lower zIndex and keep the size of this div in sync with the body
            // size.
            if(!this.__timer){

              this.__timer = new qx.event.Timer(300);
              this.__timer.addListener(c, this.__syncBlocker, this);
            };
            this.__timer.start();
            this.__syncBlocker();
          };
          this.fireEvent(o, qx.event.type.Event);
        };
      },
      /**
       * Whether the content is blocked
       *
       * @return {Boolean} Whether the content is blocked
       */
      isContentBlocked : function(){

        return this.__contentBlockerCount.length > 0;
      },
      /**
       * Unblock the content blocked by {@link #blockContent}, but it takes care of
       * the amount of {@link #blockContent} calls. The blocker is only removed if
       * the numer of {@link #unblockContent} calls is identical to
       * {@link #blockContent} calls.
       */
      unblockContent : function(){

        if(!this.isContentBlocked()){

          return;
        };
        this.__contentBlockerCount.pop();
        var T = this.__contentBlockerCount[this.__contentBlockerCount.length - 1];
        var U = this.getContentBlockerElement();
        U.setStyle(m, T);
        if(this.__contentBlockerCount.length < 1){

          this.__unblockContent();
          this.__contentBlockerCount = [];
        };
      },
      /**
       * Unblock the content blocked by {@link #blockContent}, but it doesn't take
       * care of the amount of {@link #blockContent} calls. The blocker is
       * directly removed.
       */
      forceUnblockContent : function(){

        if(!this.isContentBlocked()){

          return;
        };
        this.__contentBlockerCount = [];
        var V = this.getContentBlockerElement();
        V.setStyle(m, null);
        this.__unblockContent();
      },
      /**
       * Unblock the content blocked by {@link #blockContent}.
       */
      __unblockContent : function(){

        this.getContentBlockerElement().exclude();
        if(this._isPageRoot){

          this.__timer.stop();
        };
        this.fireEvent(n, qx.event.type.Event);
      },
      /**
       * Synchronize the size of the background blocker with the size of the
       * body element
       */
      __syncBlocker : function(){

        var W = this._widget.getContainerElement().getDomElement();
        var X = qx.dom.Node.getDocument(W);
        this.getContentBlockerElement().setStyles({
          height : X.documentElement.scrollHeight + v,
          width : X.documentElement.scrollWidth + v
        });
      },
      /**
       * Stops the passed "Tab" event.
       *
       * @param e {qx.event.type.KeySequence} event to stop.
       */
      __stopTabEvent : function(e){

        if(e.getKeyIdentifier() == b){

          e.stop();
        };
      },
      /**
       * Sets the blocker element to avtive.
       */
      __activateBlockerElement : function(){

        if(this.getKeepBlockerActive()){

          this.getBlockerElement().activate();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this._isPageRoot){

        this._widget.removeListener(r, this.__onResize, this);
      };
      this._disposeObjects(g, f, h);
      this.__oldAnonymous = this.__activeElements = this.__focusElements = this._widget = this.__contentBlockerCount = null;
    }
  });
})();
(function(){

  var u = "changeGlobalCursor",t = "engine.name",s = "keypress",r = "Boolean",q = "root",p = "",o = " !important",n = "input",m = "_applyGlobalCursor",l = "Space",d = "_applyNativeHelp",k = ";",h = "event.help",c = "qx.ui.root.Abstract",b = "abstract",g = "textarea",f = "String",i = "*",a = "help",j = "contextmenu";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Shared implementation for all root widgets.
   */
  qx.Class.define(c, {
    type : b,
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MChildrenHandling, qx.ui.core.MBlocker, qx.ui.window.MDesktop],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.Widget.call(this);
      // Register as root for the focus handler
      qx.ui.core.FocusHandler.getInstance().addRoot(this);
      // Directly add to visibility queue
      qx.ui.core.queue.Visibility.add(this);
      this.initNativeHelp();
      this.addListener(s, this.__preventScrollWhenFocused, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : q
      },
      // overridden
      enabled : {
        refine : true,
        init : true
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      },
      /**
       *  Sets the global cursor style
       *
       *  The name of the cursor to show when the mouse pointer is over the widget.
       *  This is any valid CSS2 cursor name defined by W3C.
       *
       *  The following values are possible:
       *  <ul><li>default</li>
       *  <li>crosshair</li>
       *  <li>pointer (hand is the ie name and will mapped to pointer in non-ie).</li>
       *  <li>move</li>
       *  <li>n-resize</li>
       *  <li>ne-resize</li>
       *  <li>e-resize</li>
       *  <li>se-resize</li>
       *  <li>s-resize</li>
       *  <li>sw-resize</li>
       *  <li>w-resize</li>
       *  <li>nw-resize</li>
       *  <li>text</li>
       *  <li>wait</li>
       *  <li>help </li>
       *  <li>url([file]) = self defined cursor, file should be an ANI- or CUR-type</li>
       *  </ul>
       *
       * Please note that in the current implementation this has no effect in IE.
       */
      globalCursor : {
        check : f,
        nullable : true,
        themeable : true,
        apply : m,
        event : u
      },
      /**
       * Whether the native context menu should be globally enabled. Setting this
       * property to <code>true</code> will allow native context menus in all
       * child widgets of this root.
       */
      nativeContextMenu : {
        refine : true,
        init : false
      },
      /**
       * If the user presses F1 in IE by default the onhelp event is fired and
       * IE’s help window is opened. Setting this property to <code>false</code>
       * prevents this behavior.
       */
      nativeHelp : {
        check : r,
        init : false,
        apply : d
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __globalCursorStyleSheet : null,
      // overridden
      isRootWidget : function(){

        return true;
      },
      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      getLayout : function(){

        return this._getLayout();
      },
      // property apply
      _applyGlobalCursor : qx.core.Environment.select(t, {
        "mshtml" : function(v, w){
        },
        // This would be the optimal solution.
        // For performance reasons this is impractical in IE
        "default" : function(x, y){

          var z = qx.bom.Stylesheet;
          var A = this.__globalCursorStyleSheet;
          if(!A){

            this.__globalCursorStyleSheet = A = z.createElement();
          };
          z.removeAllRules(A);
          if(x){

            z.addRule(A, i, qx.bom.element.Cursor.compile(x).replace(k, p) + o);
          };
        }
      }),
      // property apply
      _applyNativeContextMenu : function(B, C){

        if(B){

          this.removeListener(j, this._onNativeContextMenu, this, true);
        } else {

          this.addListener(j, this._onNativeContextMenu, this, true);
        };
      },
      /**
       * Stops the <code>contextmenu</code> event from showing the native context menu
       *
       * @param e {qx.event.type.Mouse} The event object
       */
      _onNativeContextMenu : function(e){

        if(e.getTarget().getNativeContextMenu()){

          return;
        };
        e.preventDefault();
      },
      /**
      * Fix unexpected scrolling when pressing "Space" while a widget is focused.
      *
      * @param e {qx.event.type.KeySequence} The KeySequence event
      */
      __preventScrollWhenFocused : function(e){

        // Require space pressed
        if(e.getKeyIdentifier() !== l){

          return;
        };
        var E = e.getTarget();
        // Require focused. Allow scroll when container or root widget.
        var D = qx.ui.core.FocusHandler.getInstance();
        if(!D.isFocused(E)){

          return;
        };
        // Require that widget does not accept text input
        var F = E.getContentElement().getNodeName();
        if(F === n || F === g){

          return;
        };
        // Ultimately, prevent default
        e.preventDefault();
      },
      // property apply
      _applyNativeHelp : function(G, H){

        if(qx.core.Environment.get(h)){

          if(H === false){

            qx.bom.Event.removeNativeListener(document, a, qx.lang.Function.returnFalse);
          };
          if(G === false){

            qx.bom.Event.addNativeListener(document, a, qx.lang.Function.returnFalse);
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__globalCursorStyleSheet = null;
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(I, J){

      qx.ui.core.MChildrenHandling.remap(J);
    }
  });
})();
(function(){

  var k = "keypress",j = "__roots",h = "focusout",g = "activate",f = "Tab",d = "singleton",c = "deactivate",b = "focusin",a = "qx.ui.core.FocusHandler";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Each focus root delegates the focus handling to instances of the FocusHandler.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    type : d,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      // Create data structure
      this.__roots = {
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __roots : null,
      __activeChild : null,
      __focusedChild : null,
      __currentRoot : null,
      /**
       * Connects to a top-level root element (which initially receives
       * all events of the root). This are normally all page and application
       * roots, but no inline roots (they are typically sitting inside
       * another root).
       *
       * @param root {qx.ui.root.Abstract} Any root
       */
      connectTo : function(m){

        // this.debug("Connect to: " + root);
        m.addListener(k, this.__onKeyPress, this);
        m.addListener(b, this._onFocusIn, this, true);
        m.addListener(h, this._onFocusOut, this, true);
        m.addListener(g, this._onActivate, this, true);
        m.addListener(c, this._onDeactivate, this, true);
      },
      /**
       * Registers a widget as a focus root. A focus root comes
       * with an separate tab sequence handling.
       *
       * @param widget {qx.ui.core.Widget} The widget to register
       */
      addRoot : function(n){

        // this.debug("Add focusRoot: " + widget);
        this.__roots[n.$$hash] = n;
      },
      /**
       * Deregisters a previous added widget.
       *
       * @param widget {qx.ui.core.Widget} The widget to deregister
       */
      removeRoot : function(o){

        // this.debug("Remove focusRoot: " + widget);
        delete this.__roots[o.$$hash];
      },
      /**
       * Get the active widget
       *
       * @return {qx.ui.core.Widget|null} The active widget or <code>null</code>
       *    if no widget is active
       */
      getActiveWidget : function(){

        return this.__activeChild;
      },
      /**
       * Whether the given widget is the active one
       *
       * @param widget {qx.ui.core.Widget} The widget to check
       */
      isActive : function(p){

        return this.__activeChild == p;
      },
      /**
       * Get the focused widget
       *
       * @return {qx.ui.core.Widget|null} The focused widget or <code>null</code>
       *    if no widget has the focus
       */
      getFocusedWidget : function(){

        return this.__focusedChild;
      },
      /**
       * Whether the given widget is the focused one.
       *
       * @param widget {qx.ui.core.Widget} The widget to check
       */
      isFocused : function(q){

        return this.__focusedChild == q;
      },
      /**
       * Whether the given widgets acts as a focus root.
       *
       * @param widget {qx.ui.core.Widget} The widget to check
       */
      isFocusRoot : function(r){

        return !!this.__roots[r.$$hash];
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Internal event handler for activate event.
       *
       * @param e {qx.event.type.Focus} Focus event
       * @return {void}
       */
      _onActivate : function(e){

        var t = e.getTarget();
        this.__activeChild = t;
        //this.debug("active: " + target);
        var s = this.__findFocusRoot(t);
        if(s != this.__currentRoot){

          this.__currentRoot = s;
        };
      },
      /**
       * Internal event handler for deactivate event.
       *
       * @param e {qx.event.type.Focus} Focus event
       * @return {void}
       */
      _onDeactivate : function(e){

        var u = e.getTarget();
        if(this.__activeChild == u){

          this.__activeChild = null;
        };
      },
      /**
       * Internal event handler for focusin event.
       *
       * @param e {qx.event.type.Focus} Focus event
       * @return {void}
       */
      _onFocusIn : function(e){

        var v = e.getTarget();
        if(v != this.__focusedChild){

          this.__focusedChild = v;
          v.visualizeFocus();
        };
      },
      /**
       * Internal event handler for focusout event.
       *
       * @param e {qx.event.type.Focus} Focus event
       * @return {void}
       */
      _onFocusOut : function(e){

        var w = e.getTarget();
        if(w == this.__focusedChild){

          this.__focusedChild = null;
          w.visualizeBlur();
        };
      },
      /**
       * Internal event handler for TAB key.
       *
       * @param e {qx.event.type.KeySequence} Key event
       * @return {void}
       */
      __onKeyPress : function(e){

        if(e.getKeyIdentifier() != f){

          return;
        };
        if(!this.__currentRoot){

          return;
        };
        // Stop all key-events with a TAB keycode
        e.stopPropagation();
        e.preventDefault();
        // Support shift key to reverse widget detection order
        var x = this.__focusedChild;
        if(!e.isShiftPressed()){

          var y = x ? this.__getWidgetAfter(x) : this.__getFirstWidget();
        } else {

          var y = x ? this.__getWidgetBefore(x) : this.__getLastWidget();
        };
        // If there was a widget found, focus it
        if(y){

          y.tabFocus();
        };
      },
      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */
      /**
       * Finds the next focus root, starting with the given widget.
       *
       * @param widget {qx.ui.core.Widget} The widget to find a focus root for.
       */
      __findFocusRoot : function(z){

        var A = this.__roots;
        while(z){

          if(A[z.$$hash]){

            return z;
          };
          z = z.getLayoutParent();
        };
        return null;
      },
      /*
      ---------------------------------------------------------------------------
        TAB SUPPORT IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      /**
       * Compares the order of two widgets
       *
       * @param widget1 {qx.ui.core.Widget} Widget A
       * @param widget2 {qx.ui.core.Widget} Widget B
       * @return {Integer} A sort() compatible integer with values
       *   small than 0, exactly 0 or bigger than 0.
       */
      __compareTabOrder : function(B, C){

        if(B === C){

          return 0;
        };
        // Sort-Check #1: Tab-Index
        var E = B.getTabIndex() || 0;
        var D = C.getTabIndex() || 0;
        if(E != D){

          return E - D;
        };
        // Computing location
        var J = B.getContainerElement().getDomElement();
        var I = C.getContainerElement().getDomElement();
        var H = qx.bom.element.Location;
        var G = H.get(J);
        var F = H.get(I);
        // Sort-Check #2: Top-Position
        if(G.top != F.top){

          return G.top - F.top;
        };
        // Sort-Check #3: Left-Position
        if(G.left != F.left){

          return G.left - F.left;
        };
        // Sort-Check #4: zIndex
        var K = B.getZIndex();
        var L = C.getZIndex();
        if(K != L){

          return K - L;
        };
        return 0;
      },
      /**
       * Returns the first widget.
       *
       * @return {qx.ui.core.Widget} Retuns the first (positioned) widget from
       *    the current root.
       */
      __getFirstWidget : function(){

        return this.__getFirst(this.__currentRoot, null);
      },
      /**
       * Returns the last widget.
       *
       * @return {qx.ui.core.Widget} Returns the last (positioned) widget from
       *    the current root.
       */
      __getLastWidget : function(){

        return this.__getLast(this.__currentRoot, null);
      },
      /**
       * Returns the widget after the given one.
       *
       * @param widget {qx.ui.core.Widget} Widget to start with
       * @return {qx.ui.core.Widget} The found widget.
       */
      __getWidgetAfter : function(M){

        var N = this.__currentRoot;
        if(N == M){

          return this.__getFirstWidget();
        };
        while(M && M.getAnonymous()){

          M = M.getLayoutParent();
        };
        if(M == null){

          return [];
        };
        var O = [];
        this.__collectAllAfter(N, M, O);
        O.sort(this.__compareTabOrder);
        var P = O.length;
        return P > 0 ? O[0] : this.__getFirstWidget();
      },
      /**
       * Returns the widget before the given one.
       *
       * @param widget {qx.ui.core.Widget} Widget to start with
       * @return {qx.ui.core.Widget} The found widget.
       */
      __getWidgetBefore : function(Q){

        var R = this.__currentRoot;
        if(R == Q){

          return this.__getLastWidget();
        };
        while(Q && Q.getAnonymous()){

          Q = Q.getLayoutParent();
        };
        if(Q == null){

          return [];
        };
        var S = [];
        this.__collectAllBefore(R, Q, S);
        S.sort(this.__compareTabOrder);
        var T = S.length;
        return T > 0 ? S[T - 1] : this.__getLastWidget();
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL API USED BY METHODS ABOVE
      ---------------------------------------------------------------------------
      */
      /**
       * Collects all widgets which are after the given widget in
       * the given parent widget. Append all found children to the
       * <code>list</code>.
       *
       * @param parent {qx.ui.core.Widget} Parent widget
       * @param widget {qx.ui.core.Widget} Child widget to start with
       * @param result {Array} Result list
       * @return {void}
       */
      __collectAllAfter : function(parent, U, V){

        var W = parent.getLayoutChildren();
        var X;
        for(var i = 0,l = W.length;i < l;i++){

          X = W[i];
          // Filter spacers etc.
          if(!(X instanceof qx.ui.core.Widget)){

            continue;
          };
          if(!this.isFocusRoot(X) && X.isEnabled() && X.isVisible()){

            if(X.isTabable() && this.__compareTabOrder(U, X) < 0){

              V.push(X);
            };
            this.__collectAllAfter(X, U, V);
          };
        };
      },
      /**
       * Collects all widgets which are before the given widget in
       * the given parent widget. Append all found children to the
       * <code>list</code>.
       *
       * @param parent {qx.ui.core.Widget} Parent widget
       * @param widget {qx.ui.core.Widget} Child widget to start with
       * @param result {Array} Result list
       * @return {void}
       */
      __collectAllBefore : function(parent, Y, ba){

        var bb = parent.getLayoutChildren();
        var bc;
        for(var i = 0,l = bb.length;i < l;i++){

          bc = bb[i];
          // Filter spacers etc.
          if(!(bc instanceof qx.ui.core.Widget)){

            continue;
          };
          if(!this.isFocusRoot(bc) && bc.isEnabled() && bc.isVisible()){

            if(bc.isTabable() && this.__compareTabOrder(Y, bc) > 0){

              ba.push(bc);
            };
            this.__collectAllBefore(bc, Y, ba);
          };
        };
      },
      /**
       * Find first (positioned) widget. (Sorted by coordinates, zIndex, etc.)
       *
       * @param parent {qx.ui.core.Widget} Parent widget
       * @param firstWidget {qx.ui.core.Widget?null} Current first widget
       * @return {qx.ui.core.Widget} The first (positioned) widget
       */
      __getFirst : function(parent, bd){

        var be = parent.getLayoutChildren();
        var bf;
        for(var i = 0,l = be.length;i < l;i++){

          bf = be[i];
          // Filter spacers etc.
          if(!(bf instanceof qx.ui.core.Widget)){

            continue;
          };
          // Ignore focus roots completely
          if(!this.isFocusRoot(bf) && bf.isEnabled() && bf.isVisible()){

            if(bf.isTabable()){

              if(bd == null || this.__compareTabOrder(bf, bd) < 0){

                bd = bf;
              };
            };
            // Deep iteration into children hierarchy
            bd = this.__getFirst(bf, bd);
          };
        };
        return bd;
      },
      /**
       * Find last (positioned) widget. (Sorted by coordinates, zIndex, etc.)
       *
       * @param parent {qx.ui.core.Widget} Parent widget
       * @param lastWidget {qx.ui.core.Widget?null} Current last widget
       * @return {qx.ui.core.Widget} The last (positioned) widget
       */
      __getLast : function(parent, bg){

        var bh = parent.getLayoutChildren();
        var bi;
        for(var i = 0,l = bh.length;i < l;i++){

          bi = bh[i];
          // Filter spacers etc.
          if(!(bi instanceof qx.ui.core.Widget)){

            continue;
          };
          // Ignore focus roots completely
          if(!this.isFocusRoot(bi) && bi.isEnabled() && bi.isVisible()){

            if(bi.isTabable()){

              if(bg == null || this.__compareTabOrder(bi, bg) > 0){

                bg = bi;
              };
            };
            // Deep iteration into children hierarchy
            bg = this.__getLast(bi, bg);
          };
        };
        return bg;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeMap(j);
      this.__focusedChild = this.__activeChild = this.__currentRoot = null;
    }
  });
})();
(function(){

  var q = "resize",p = "engine.name",o = "paddingLeft",n = "position",m = "The root widget does not support decorators with 'left', or 'top' insets!",l = "0px",k = "webkit",j = "The application could not be started due to a missing body tag in the HTML file!",i = "$$widget",h = "qx.ui.root.Application",c = "hidden",g = "div",f = "paddingTop",b = "The root widget does not support 'left', or 'top' paddings!",a = "100%",d = "absolute";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.Window)
  #ignore(qx.ui.popup.Manager)
  #ignore(qx.ui.menu.Manager)
  #ignore(qx.ui)
  
  ************************************************************************ */
  /**
   * This is the root widget for qooxdoo applications with an
   * "application" like behaviour. The widget will span the whole viewport
   * and the document body will have no scrollbars.
   *
   * The root widget does not support paddings and decorators with insets.
   *
   * If you want to enhance HTML pages with qooxdoo widgets please use
   * {@link qx.ui.root.Page} eventually in combination with
   * {@link qx.ui.root.Inline} widgets.
   *
   * This class uses a {@link qx.ui.layout.Canvas} as fixed layout. The layout
   * cannot be changed.
   */
  qx.Class.define(h, {
    extend : qx.ui.root.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param doc {Document} Document to use
     */
    construct : function(r){

      // Symbolic links
      this.__window = qx.dom.Node.getWindow(r);
      this.__doc = r;
      qx.ui.root.Abstract.call(this);
      // Resize handling
      qx.event.Registration.addListener(this.__window, q, this._onResize, this);
      // Use a hard-coded canvas layout
      this._setLayout(new qx.ui.layout.Canvas());
      // Directly schedule layout for root element
      qx.ui.core.queue.Layout.add(this);
      // Register as root
      qx.ui.core.FocusHandler.getInstance().connectTo(this);
      this.getContentElement().disableScrolling();
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __window : null,
      __doc : null,
      // overridden
      _createContainerElement : function(){

        var s = this.__doc;
        /**
         * @lint ignoreDeprecated(alert)
         */
        if((qx.core.Environment.get(p) == k)){

          // In the "DOMContentLoaded" event of WebKit (Safari, Chrome) no body
          // element seems to be available in the DOM, if the HTML file did not
          // contain a body tag explicitly. Unfortunately, it cannot be added
          // here dynamically.
          if(!s.body){

            alert(j);
          };
        };
        // Apply application layout
        var w = s.documentElement.style;
        var t = s.body.style;
        w.overflow = t.overflow = c;
        w.padding = w.margin = t.padding = t.margin = l;
        w.width = w.height = t.width = t.height = a;
        var v = s.createElement(g);
        s.body.appendChild(v);
        var u = new qx.html.Root(v);
        u.setStyle(n, d);
        // Store "weak" reference to the widget in the DOM element.
        u.setAttribute(i, this.toHashCode());
        return u;
      },
      /**
       * Listener for window's resize event
       *
       * @param e {qx.event.type.Event} Event object
       * @return {void}
       */
      _onResize : function(e){

        qx.ui.core.queue.Layout.add(this);
        // close all popups
        if(qx.ui.popup && qx.ui.popup.Manager){

          qx.ui.popup.Manager.getInstance().hideAll();
        };
        // close all menus
        if(qx.ui.menu && qx.ui.menu.Manager){

          qx.ui.menu.Manager.getInstance().hideAll();
        };
      },
      // overridden
      _computeSizeHint : function(){

        var x = qx.bom.Viewport.getWidth(this.__window);
        var y = qx.bom.Viewport.getHeight(this.__window);
        return {
          minWidth : x,
          width : x,
          maxWidth : x,
          minHeight : y,
          height : y,
          maxHeight : y
        };
      },
      // overridden
      _applyPadding : function(z, A, name){

        if(z && (name == f || name == o)){

          throw new Error(b);
        };
        qx.ui.root.Abstract.prototype._applyPadding.call(this, z, A, name);
      },
      // overridden
      _applyDecorator : function(B, C){

        qx.ui.root.Abstract.prototype._applyDecorator.call(this, B, C);
        if(!B){

          return;
        };
        var D = this.getDecoratorElement().getInsets();
        if(D.left || D.top){

          throw new Error(m);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      this.__window = this.__doc = null;
    }
  });
})();
(function(){

  var k = "': ",j = "width",h = "qx.ui.layout.Canvas",g = "qx.debug",f = "height",e = "Bad format of layout property '",d = "' is not supported by the Canvas layout!",c = ". The value must be either an integer or an percent string.",b = "The property '",a = "number";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The Canvas is an extended Basic layout.
   *
   * It is possible to position a widget relative to the right or bottom edge of
   * the available space. It further supports stretching between left and right
   * or top and bottom e.g. <code>left=20</code> and <code>right=20</code> would
   * keep a margin of 20 pixels to both edges. The Canvas layout has support for
   * percent dimensions and locations.
   *
   * *Features*
   *
   * * Pixel dimensions and locations
   * * Percent dimensions and locations
   * * Stretching between left+right and top+bottom
   * * Minimum and maximum dimensions
   * * Children are automatically shrunk to their minimum dimensions if not enough space is available
   * * Auto sizing (ignoring percent values)
   * * Margins (also negative ones)
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>left</strong> <em>(Integer|String)</em>: The left coordinate in pixel or as a percent string e.g. <code>20</code> or <code>30%</code>.</li>
   * <li><strong>top</strong> <em>(Integer|String)</em>: The top coordinate in pixel or as a percent string e.g. <code>20</code> or <code>30%</code>.</li>
   * <li><strong>right</strong> <em>(Integer|String)</em>: The right coordinate in pixel or as a percent string e.g. <code>20</code> or <code>30%</code>.</li>
   * <li><strong>bottom</strong> <em>(Integer|String)</em>: The bottom coordinate in pixel or as a percent string e.g. <code>20</code> or <code>30%</code>.</li>
   * <li><strong>width</strong> <em>(String)</em>: A percent width e.g. <code>40%</code>.</li>
   * <li><strong>height</strong> <em>(String)</em>: A percent height e.g. <code>60%</code>.</li>
   * </ul>
   *
   * *Notes*
   *
   * <ul>
   * <li>Stretching (<code>left</code>-><code>right</code> or <code>top</code>-><code>bottom</code>)
   *   has a higher priority than the preferred dimensions</li>
   * <li>Stretching has a lower priority than the min/max dimensions.</li>
   * <li>Percent values have no influence on the size hint of the layout.</li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the canvas layout.
   *
   * <pre class="javascript">
   * var container = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
   *
   * // simple positioning
   * container.add(new qx.ui.core.Widget(), {top: 10, left: 10});
   *
   * // stretch vertically with 10 pixel distance to the parent's top
   * // and bottom border
   * container.add(new qx.ui.core.Widget(), {top: 10, left: 10, bottom: 10});
   *
   * // percent positioning and size
   * container.add(new qx.ui.core.Widget(), {left: "50%", top: "50%", width: "25%", height: "40%"});
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/canvas.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define(h, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(g, {
        "true" : function(m, name, n){

          var o = {
            top : 1,
            left : 1,
            bottom : 1,
            right : 1,
            width : 1,
            height : 1,
            edge : 1
          };
          this.assert(o[name] == 1, b + name + d);
          if(name == j || name == f){

            this.assertMatch(n, qx.ui.layout.Util.PERCENT_VALUE);
          } else {

            if(typeof n === a){

              this.assertInteger(n);
            } else if(qx.lang.Type.isString(n)){

              this.assertMatch(n, qx.ui.layout.Util.PERCENT_VALUE);
            } else {

              this.fail(e + name + k + n + c);
            };
          };
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(p, q){

        var B = this._getLayoutChildren();
        var t,A,y;
        var D,top,r,s,v,u;
        var z,x,C,w;
        for(var i = 0,l = B.length;i < l;i++){

          t = B[i];
          A = t.getSizeHint();
          y = t.getLayoutProperties();
          // Cache margins
          z = t.getMarginTop();
          x = t.getMarginRight();
          C = t.getMarginBottom();
          w = t.getMarginLeft();
          // **************************************
          //   Processing location
          // **************************************
          D = y.left != null ? y.left : y.edge;
          if(qx.lang.Type.isString(D)){

            D = Math.round(parseFloat(D) * p / 100);
          };
          r = y.right != null ? y.right : y.edge;
          if(qx.lang.Type.isString(r)){

            r = Math.round(parseFloat(r) * p / 100);
          };
          top = y.top != null ? y.top : y.edge;
          if(qx.lang.Type.isString(top)){

            top = Math.round(parseFloat(top) * q / 100);
          };
          s = y.bottom != null ? y.bottom : y.edge;
          if(qx.lang.Type.isString(s)){

            s = Math.round(parseFloat(s) * q / 100);
          };
          // **************************************
          //   Processing dimension
          // **************************************
          // Stretching has higher priority than dimension data
          if(D != null && r != null){

            v = p - D - r - w - x;
            // Limit computed value
            if(v < A.minWidth){

              v = A.minWidth;
            } else if(v > A.maxWidth){

              v = A.maxWidth;
            };
            // Add margin
            D += w;
          } else {

            // Layout data has higher priority than data from size hint
            v = y.width;
            if(v == null){

              v = A.width;
            } else {

              v = Math.round(parseFloat(v) * p / 100);
              // Limit computed value
              if(v < A.minWidth){

                v = A.minWidth;
              } else if(v > A.maxWidth){

                v = A.maxWidth;
              };
            };
            if(r != null){

              D = p - v - r - x - w;
            } else if(D == null){

              D = w;
            } else {

              D += w;
            };
          };
          // Stretching has higher priority than dimension data
          if(top != null && s != null){

            u = q - top - s - z - C;
            // Limit computed value
            if(u < A.minHeight){

              u = A.minHeight;
            } else if(u > A.maxHeight){

              u = A.maxHeight;
            };
            // Add margin
            top += z;
          } else {

            // Layout data has higher priority than data from size hint
            u = y.height;
            if(u == null){

              u = A.height;
            } else {

              u = Math.round(parseFloat(u) * q / 100);
              // Limit computed value
              if(u < A.minHeight){

                u = A.minHeight;
              } else if(u > A.maxHeight){

                u = A.maxHeight;
              };
            };
            if(s != null){

              top = q - u - s - C - z;
            } else if(top == null){

              top = z;
            } else {

              top += z;
            };
          };
          // Apply layout
          t.renderLayout(D, top, v, u);
        };
      },
      // overridden
      _computeSizeHint : function(){

        var T = 0,S = 0;
        var Q = 0,O = 0;
        var M,L;
        var K,I;
        var E = this._getLayoutChildren();
        var H,R,G;
        var U,top,F,J;
        for(var i = 0,l = E.length;i < l;i++){

          H = E[i];
          R = H.getLayoutProperties();
          G = H.getSizeHint();
          // Cache margins
          var P = H.getMarginLeft() + H.getMarginRight();
          var N = H.getMarginTop() + H.getMarginBottom();
          // Compute width
          M = G.width + P;
          L = G.minWidth + P;
          U = R.left != null ? R.left : R.edge;
          if(U && typeof U === a){

            M += U;
            L += U;
          };
          F = R.right != null ? R.right : R.edge;
          if(F && typeof F === a){

            M += F;
            L += F;
          };
          T = Math.max(T, M);
          S = Math.max(S, L);
          // Compute height
          K = G.height + N;
          I = G.minHeight + N;
          top = R.top != null ? R.top : R.edge;
          if(top && typeof top === a){

            K += top;
            I += top;
          };
          J = R.bottom != null ? R.bottom : R.edge;
          if(J && typeof J === a){

            K += J;
            I += J;
          };
          Q = Math.max(Q, K);
          O = Math.max(O, I);
        };
        return {
          width : T,
          minWidth : S,
          height : Q,
          minHeight : O
        };
      }
    }
  });
})();
(function(){

  var a = "qx.html.Root";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * This is the root element for a set of {@link qx.html.Element}s.
   *
   * To make other elements visible these elements must be inserted
   * into an root element at any level.
   *
   * A root element uses an existing DOM element where is assumed that
   * this element is always visible. In the easiest case, the root element
   * is identical to the document's body.
   */
  qx.Class.define(a, {
    extend : qx.html.Element,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Creates a root element
     *
     * @constructor
     * @param elem {Element?null} DOM element to use
     */
    construct : function(b){

      qx.html.Element.call(this);
      if(b != null){

        this.useElement(b);
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Sets the element to an already existing node. It will be
       * assumed that this DOM element is already visible e.g.
       * like a normal displayed element in the document's body.
       *
       * @param elem {Element} the dom element to set
       * @return {void}
       * @throws an exception if the element is assigned again
       */
      useElement : function(c){

        qx.html.Element.prototype.useElement.call(this, c);
        // Mark as root
        this.setRoot(true);
        // Register for syncronization
        qx.html.Element._modified[this.$$hash] = this;
      }
    }
  });
})();
(function(){

  var k = "repeat",j = "mousedown",i = "url(",h = ")",g = "mouseout",f = "div",d = "dblclick",c = "mousewheel",b = "qx.html.Blocker",a = "mousemove",w = "mouseover",v = "appear",u = "click",t = "mshtml",s = "engine.name",r = "mouseup",q = "contextmenu",p = "disappear",o = "qx/static/blank.gif",n = "absolute",l = "100%",m = "cursor";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The blocker element is used to block interaction with the application.
   *
   * It is usually transparent or semi-transparent and blocks all events from
   * the underlying elements.
   */
  qx.Class.define(b, {
    extend : qx.html.Element,
    /**
     * @param backgroundColor {Color?null} the blocker's background color. This
     *    color can be themed and will be resolved by the blocker.
     * @param opacity {Number?0} The blocker's opacity
     */
    construct : function(x, y){

      var x = x ? qx.theme.manager.Color.getInstance().resolve(x) : null;
      var z = {
        position : n,
        width : l,
        height : l,
        opacity : y || 0,
        backgroundColor : x
      };
      // IE needs some extra love here to convince it to block events.
      if((qx.core.Environment.get(s) == t)){

        z.backgroundImage = i + qx.util.ResourceManager.getInstance().toUri(o) + h;
        z.backgroundRepeat = k;
      };
      qx.html.Element.call(this, f, z);
      this.addListener(j, this._stopPropagation, this);
      this.addListener(r, this._stopPropagation, this);
      this.addListener(u, this._stopPropagation, this);
      this.addListener(d, this._stopPropagation, this);
      this.addListener(a, this._stopPropagation, this);
      this.addListener(w, this._stopPropagation, this);
      this.addListener(g, this._stopPropagation, this);
      this.addListener(c, this._stopPropagation, this);
      this.addListener(q, this._stopPropagation, this);
      this.addListener(v, this.__refreshCursor, this);
      this.addListener(p, this.__refreshCursor, this);
    },
    members : {
      /**
       * Stop the event propagation from the passed event.
       *
       * @param e {qx.event.type.Mouse} mouse event to stop propagation.
       */
      _stopPropagation : function(e){

        e.stopPropagation();
      },
      /**
       * Refreshes the cursor by setting it to <code>null</code> and then to the
       * old value.
       */
      __refreshCursor : function(){

        var A = this.getStyle(m);
        this.setStyle(m, null, true);
        this.setStyle(m, A, true);
      }
    }
  });
})();
(function(){

  var o = "resize",n = "qx.ui.root.Page",m = "mshtml",l = "The root widget does not support decorators with 'left', or 'top' insets!",k = "gecko",j = "paddingLeft",i = "$$widget",h = "The root widget does not support 'left', or 'top' paddings!",g = "left",f = "paddingTop",b = "qxIsRootPage",d = "absolute",c = "engine.name",a = "div";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This widget provides a root widget for popups and tooltips if qooxdoo is used
   * inside a traditional HTML page. Widgets placed into a page will overlay the
   * HTML content.
   *
   * For this reason the widget's layout is initialized with an instance of
   * {@link qx.ui.layout.Basic}. The widget's layout cannot be changed.
   *
   * The page widget does not support paddings and decorators with insets.
   *
   * Note: This widget does not support decorations!
   *
   * If you want to place widgets inside existing DOM elements
   * use {@link qx.ui.root.Inline}.
   */
  qx.Class.define(n, {
    extend : qx.ui.root.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param doc {Document} Document to use
     */
    construct : function(p){

      // Temporary storage of element to use
      this.__doc = p;
      qx.ui.root.Abstract.call(this);
      // Use a hard-coded basic layout
      this._setLayout(new qx.ui.layout.Basic());
      // Set a high zIndex to make sure the widgets really overlay the HTML page.
      this.setZIndex(10000);
      // Directly add to layout queue
      qx.ui.core.queue.Layout.add(this);
      // Register resize listener
      this.addListener(o, this.__onResize, this);
      // Register as root
      qx.ui.core.FocusHandler.getInstance().connectTo(this);
      // Avoid the automatically scroll in to view.
      // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3236 for details.
      if((qx.core.Environment.get(c) == m)){

        this.setKeepFocus(true);
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __timer : null,
      __doc : null,
      // overridden
      _createContainerElement : function(){

        var r = this.__doc.createElement(a);
        this.__doc.body.appendChild(r);
        var q = new qx.html.Root(r);
        q.setStyles({
          position : d,
          textAlign : g
        });
        // Store "weak" reference to the widget in the DOM element.
        q.setAttribute(i, this.toHashCode());
        // Mark the element of this root with a special attribute to prevent
        // that qx.event.handler.Focus is performing a focus action.
        // This would end up in a scrolling to the top which is not wanted in
        // an inline scenario
        // see Bug #2740
        if((qx.core.Environment.get(c) == k)){

          q.setAttribute(b, 1);
        };
        return q;
      },
      // overridden
      _createContentElement : function(){

        // we do not want overflow=hidden for the page root
        return new qx.html.Element(a);
      },
      // overridden
      _computeSizeHint : function(){

        var s = qx.bom.Document.getWidth(this._window);
        var t = qx.bom.Document.getHeight(this._window);
        return {
          minWidth : s,
          width : s,
          maxWidth : s,
          minHeight : t,
          height : t,
          maxHeight : t
        };
      },
      /**
       * Adjust html element size on layout resizes.
       *
       * @param e {qx.event.type.Data} event object
       */
      __onResize : function(e){

        // set the size to 0 so make the content element invisible
        // this works because the content element has overflow "show"
        this.getContainerElement().setStyles({
          width : 0,
          height : 0
        });
        this.getContentElement().setStyles({
          width : 0,
          height : 0
        });
      },
      /**
       * Whether the configured layout supports a maximized window
       * e.g. is a Canvas.
       *
       * @return {Boolean} Whether the layout supports maximized windows
       */
      supportsMaximize : function(){

        return false;
      },
      // overridden
      _applyPadding : function(u, v, name){

        if(u && (name == f || name == j)){

          throw new Error(h);
        };
        qx.ui.root.Abstract.prototype._applyPadding.call(this, u, v, name);
      },
      // overridden
      _applyDecorator : function(w, x){

        qx.ui.root.Abstract.prototype._applyDecorator.call(this, w, x);
        if(!w){

          return;
        };
        var y = this.getDecoratorElement().getInsets();
        if(y.left || y.top){

          throw new Error(l);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      this.__doc = null;
    }
  });
})();
(function(){

  var f = "qx.ui.layout.Basic",e = "' is not supported by the Basic layout!",d = "qx.debug",c = "top",b = "left",a = "The property '";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A basic layout, which supports positioning of child widgets by absolute
   * left/top coordinates. This layout is very simple but should also
   * perform best.
   *
   * *Features*
   *
   * * Basic positioning using <code>left</code> and <code>top</code> properties
   * * Respects minimum and maximum dimensions without skrinking/growing
   * * Margins for top and left side (including negative ones)
   * * Respects right and bottom margins in the size hint
   * * Auto-sizing
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>left</strong> <em>(Integer)</em>: The left coordinate in pixel</li>
   * <li><strong>top</strong> <em>(Integer)</em>: The top coordinate in pixel</li>
   * </ul>
   *
   * *Details*
   *
   * The default location of any widget is zero for both
   * <code>left</code> and <code>top</code>.
   *
   * *Example*
   *
   * Here is a little example of how to use the basic layout.
   *
   * <pre class="javascript">
   * var container = new qx.ui.container.Composite(new qx.ui.layout.Basic());
   *
   * // simple positioning
   * container.add(new qx.ui.core.Widget(), {left: 10, top: 10});
   * container.add(new qx.ui.core.Widget(), {left: 100, top: 50});
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/basic.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define(f, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(d, {
        "true" : function(g, name, h){

          this.assert(name == b || name == c, a + name + e);
          this.assertInteger(h);
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(j, k){

        var p = this._getLayoutChildren();
        var m,o,n,q,top;
        // Render children
        for(var i = 0,l = p.length;i < l;i++){

          m = p[i];
          o = m.getSizeHint();
          n = m.getLayoutProperties();
          q = (n.left || 0) + m.getMarginLeft();
          top = (n.top || 0) + m.getMarginTop();
          m.renderLayout(q, top, o.width, o.height);
        };
      },
      // overridden
      _computeSizeHint : function(){

        var w = this._getLayoutChildren();
        var t,y,u;
        var x = 0,v = 0;
        var r,s;
        // Iterate over children
        for(var i = 0,l = w.length;i < l;i++){

          t = w[i];
          y = t.getSizeHint();
          u = t.getLayoutProperties();
          r = y.width + (u.left || 0) + t.getMarginLeft() + t.getMarginRight();
          s = y.height + (u.top || 0) + t.getMarginTop() + t.getMarginBottom();
          if(r > x){

            x = r;
          };
          if(s > v){

            v = s;
          };
        };
        // Return hint
        return {
          width : x,
          height : v
        };
      }
    }
  });
})();
(function(){

  var i = "dicomheaderview.Application",h = "numdays",g = "serverRoot",f = 'qx.debug',e = "archiveheader",d = "num",b = "on",a = "archive";
  /* ************************************************************************
  
  #asset(dicomheaderview/*)
  
  ************************************************************************ */
  /**
   * This is the main application class of your custom application "dicomheaderview"
   */
  qx.Class.define(i, {
    extend : qx.application.Inline,
    members : {
      main : function(){

        qx.application.Inline.prototype.main.call(this);
        if(qx.core.Environment.get(f) == b){

          qx.log.appender.Native;
          qx.log.appender.Console;
        };
        var l = document.getElementById(h).attributes[d].value;
        var j = new qx.ui.root.Inline(document.getElementById(e));
        j.setZIndex(0);
        var m = document.getElementById(g).title;
        var k = {
          open : function(c){
          },
          close : function(c){
          }
        };
        new dicomheaderview.DicomHeaderView(m, j, k, k, a, parseInt(l));
      }
    }
  });
})();
(function(){

  var l = "Use qx.dev.StackTrace.FORMAT_STACKTRACE instead",k = "function",h = "<span class='object'>",g = "]:",f = "&gt;",e = "<span class='object' title='Object instance with hash code: ",d = "FORMAT_STACK",c = "string",b = "level-",a = "0",M = "&lt;",L = "<span class='offset'>",K = ":",J = "qx.log.appender.Util",I = "&amp;",H = "&#39;",G = "DIV",F = "<span>",E = "&quot;",D = "<span class='type-key'>",s = "</span>:<span class='type-",t = "</span>: ",q = " ",r = "]</span>: ",o = "?",p = "</span> ",m = "}",n = "",u = "]",v = "\n",y = "{",x = "map",A = "<span class='type-",z = "[",C = ", ",B = "</span>",w = "'>";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * Contains some common methods available to all log appenders.
   */
  qx.Class.define(J, {
    statics : {
      /**
       * Converts a single log entry to HTML
       *
       * @signature function(entry)
       * @param entry {Map} The entry to process
       * @return {void}
       */
      toHtml : function(N){

        var X = [];
        var U,W,P,R;
        X.push(L, this.formatOffset(N.offset, 6), p);
        if(N.object){

          var O = N.win.qx.core.ObjectRegistry.fromHashCode(N.object);
          if(O){

            X.push(e + O.$$hash + w, O.classname, z, O.$$hash, r);
          };
        } else if(N.clazz){

          X.push(h + N.clazz.classname, t);
        };
        var Q = N.items;
        for(var i = 0,V = Q.length;i < V;i++){

          U = Q[i];
          W = U.text;
          if(W instanceof Array){

            var R = [];
            for(var j = 0,T = W.length;j < T;j++){

              P = W[j];
              if(typeof P === c){

                R.push(F + this.escapeHTML(P) + B);
              } else if(P.key){

                R.push(D + P.key + s + P.type + w + this.escapeHTML(P.text) + B);
              } else {

                R.push(A + P.type + w + this.escapeHTML(P.text) + B);
              };
            };
            X.push(A + U.type + w);
            if(U.type === x){

              X.push(y, R.join(C), m);
            } else {

              X.push(z, R.join(C), u);
            };
            X.push(B);
          } else {

            X.push(A + U.type + w + this.escapeHTML(W) + p);
          };
        };
        var S = document.createElement(G);
        S.innerHTML = X.join(n);
        S.className = b + N.level;
        return S;
      },
      /**
       * Formats a numeric time offset to 6 characters.
       *
       * @param offset {Integer} Current offset value
       * @param length {Integer?6} Refine the length
       * @return {String} Padded string
       */
      formatOffset : function(Y, length){

        var bc = Y.toString();
        var ba = (length || 6) - bc.length;
        var bb = n;
        for(var i = 0;i < ba;i++){

          bb += a;
        };
        return bb + bc;
      },
      /**
       * Escapes the HTML in the given value
       *
       * @param value {String} value to escape
       * @return {String} escaped value
       */
      escapeHTML : function(bd){

        return String(bd).replace(/[<>&"']/g, this.__escapeHTMLReplace);
      },
      /**
       * Internal replacement helper for HTML escape.
       *
       * @param ch {String} Single item to replace.
       * @return {String} Replaced item
       */
      __escapeHTMLReplace : function(be){

        var bf = {
          "<" : M,
          ">" : f,
          "&" : I,
          "'" : H,
          '"' : E
        };
        return bf[be] || o;
      },
      /**
       * Converts a single log entry to plain text
       *
       * @param entry {Map} The entry to process
       * @return {String} the formatted log entry
       */
      toText : function(bg){

        return this.toTextArray(bg).join(q);
      },
      /**
       * Converts a single log entry to an array of plain text
       *
       * @param entry {Map} The entry to process
       * @return {Array} Argument list ready message array.
       */
      toTextArray : function(bh){

        var bp = [];
        bp.push(this.formatOffset(bh.offset, 6));
        if(bh.object){

          var bi = bh.win.qx.core.ObjectRegistry.fromHashCode(bh.object);
          if(bi){

            bp.push(bi.classname + z + bi.$$hash + g);
          };
        } else if(bh.clazz){

          bp.push(bh.clazz.classname + K);
        };
        var bj = bh.items;
        var bm,bo;
        for(var i = 0,bn = bj.length;i < bn;i++){

          bm = bj[i];
          bo = bm.text;
          if(bm.trace && bm.trace.length > 0){

            if(typeof (this.FORMAT_STACK) == k){

              qx.log.Logger.deprecatedConstantWarning(qx.log.appender.Util, d, l);
              bo += v + this.FORMAT_STACK(bm.trace);
            } else {

              bo += v + bm.trace;
            };
          };
          if(bo instanceof Array){

            var bk = [];
            for(var j = 0,bl = bo.length;j < bl;j++){

              bk.push(bo[j].text);
            };
            if(bm.type === x){

              bp.push(y, bk.join(C), m);
            } else {

              bp.push(z, bk.join(C), u);
            };
          } else {

            bp.push(bo);
          };
        };
        return bp;
      }
    }
  });
})();
(function(){

  var c = "html.console",b = "qx.log.appender.Native",a = "log";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.log.appender.Util)
  #require(qx.bom.client.Html)  -- defer calls Logger.register which calls
                                   Native.process which needs "html.console"
                                   implementation
  
  ************************************************************************ */
  /**
   * Processes the incoming log entry and displays it by means of the native
   * logging capabilities of the client.
   *
   * Supported browsers:
   * * Firefox <4 using FireBug (if available).
   * * Firefox >=4 using the Web Console.
   * * WebKit browsers using the Web Inspector/Developer Tools.
   * * Internet Explorer 8+ using the F12 Developer Tools.
   * * Opera >=10.60 using either the Error Console or Dragonfly
   *
   * Currently unsupported browsers:
   * * Opera <10.60
   */
  qx.Class.define(b, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Processes a single log entry
       *
       * @param entry {Map} The entry to process
       */
      process : function(d){

        if(qx.core.Environment.get(c)){

          // Firefox 4's Web Console doesn't support "debug"
          var f = console[d.level] ? d.level : a;
          if(console[f]){

            var e = qx.log.appender.Util.toText(d);
            console[f](e);
          };
        };
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(g){

      qx.log.Logger.register(g);
    }
  });
})();
(function(){

  var k = '.qxconsole .messages{background:white;height:100%;width:100%;overflow:auto;}',j = "Enter",i = "px",h = '.qxconsole .messages .user-result{background:white}',g = '.qxconsole .messages .level-error{background:#FFE2D5}',f = "div",d = "user-command",c = '<div class="command">',b = '.qxconsole .command input:focus{outline:none;}',a = '.qxconsole .messages .type-key{color:#565656;font-style:italic}',V = '.qxconsole .messages .type-instance{color:#565656;font-weight:bold}',U = '.qxconsole .messages div{padding:0px 4px;}',T = '.qxconsole .messages .level-debug{background:white}',S = '.qxconsole .messages .type-class{color:#5F3E8A;font-weight:bold}',R = "DIV",Q = '.qxconsole .messages .level-user{background:#E3EFE9}',P = '<div class="qxconsole">',O = "D",N = '.qxconsole .messages .type-map{color:#CC3E8A;font-weight:bold;}',M = '.qxconsole .messages .type-string{color:black;font-weight:normal;}',r = '.qxconsole .control a{text-decoration:none;color:black;}',s = '<div class="messages">',p = '.qxconsole .messages .type-boolean{color:#15BC91;font-weight:normal;}',q = '<input type="text"/>',n = "clear",o = '.qxconsole .command input{width:100%;border:0 none;font-family:Consolas,Monaco,monospace;font-size:11px;line-height:1.2;}',l = '.qxconsole .messages .type-array{color:#CC3E8A;font-weight:bold;}',m = '.qxconsole{z-index:10000;width:600px;height:300px;top:0px;right:0px;position:absolute;border-left:1px solid black;color:black;border-bottom:1px solid black;color:black;font-family:Consolas,Monaco,monospace;font-size:11px;line-height:1.2;}',t = '.qxconsole .command{background:white;padding:2px 4px;border-top:1px solid black;}',u = '.qxconsole .messages .user-command{color:blue}',B = "F7",z = "qx.log.appender.Console",F = '.qxconsole .messages .level-info{background:#DEEDFA}',D = "block",I = '.qxconsole .messages .level-warn{background:#FFF7D5}',H = '.qxconsole .messages .type-stringify{color:#565656;font-weight:bold}',w = '.qxconsole .messages .user-error{background:#FFE2D5}',L = '.qxconsole .control{background:#cdcdcd;border-bottom:1px solid black;padding:4px 8px;}',K = '<div class="control"><a href="javascript:qx.log.appender.Console.clear()">Clear</a> | <a href="javascript:qx.log.appender.Console.toggle()">Hide</a></div>',J = ">>> ",v = "Down",x = '.qxconsole .messages .type-number{color:#155791;font-weight:normal;}',y = "Up",A = "none",C = "keypress",E = '</div>',G = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.Window)
  #require(qx.event.handler.Keyboard)
  
  ************************************************************************ */
  /**
   * Feature-rich console appender for the qooxdoo logging system.
   *
   * Creates a small inline element which is placed in the top-right corner
   * of the window. Prints all messages with a nice color highlighting.
   *
   * * Allows user command inputs.
   * * Command history enabled by default (Keyboard up/down arrows).
   * * Lazy creation on first open.
   * * Clearing the console using a button.
   * * Display of offset (time after loading) of each message
   * * Supports keyboard shortcuts F7 or Ctrl+D to toggle the visibility
   */
  qx.Class.define(z, {
    statics : {
      /*
      ---------------------------------------------------------------------------
        INITIALIZATION AND SHUTDOWN
      ---------------------------------------------------------------------------
      */
      /**
       * Initializes the console, building HTML and pushing last
       * log messages to the output window.
       *
       * @return {void}
       */
      init : function(){

        // Build style sheet content
        var W = [m, L, r, k, U, u, h, w, T, F, I, g, Q, M, x, p, l, N, a, S, V, H, t, o, b];
        // Include stylesheet
        qx.bom.Stylesheet.createElement(W.join(G));
        // Build markup
        var Y = [P, K, s, E, c, q, E, E];
        // Insert HTML to access DOM node
        var ba = document.createElement(R);
        ba.innerHTML = Y.join(G);
        var X = ba.firstChild;
        document.body.appendChild(ba.firstChild);
        // Make important DOM nodes available
        this.__main = X;
        this.__log = X.childNodes[1];
        this.__cmd = X.childNodes[2].firstChild;
        // Correct height of messages frame
        this.__onResize();
        // Finally register to log engine
        qx.log.Logger.register(this);
        // Register to object manager
        qx.core.ObjectRegistry.register(this);
      },
      /**
       * Used by the object registry to dispose this instance e.g. remove listeners etc.
       *
       * @return {void}
       */
      dispose : function(){

        qx.event.Registration.removeListener(document.documentElement, C, this.__onKeyPress, this);
        qx.log.Logger.unregister(this);
      },
      /*
      ---------------------------------------------------------------------------
        INSERT & CLEAR
      ---------------------------------------------------------------------------
      */
      /**
       * Clears the current console output.
       *
       * @return {void}
       */
      clear : function(){

        // Remove all messages
        this.__log.innerHTML = G;
      },
      /**
       * Processes a single log entry
       *
       * @signature function(entry)
       * @param entry {Map} The entry to process
       * @return {void}
       */
      process : function(bb){

        // Append new content
        this.__log.appendChild(qx.log.appender.Util.toHtml(bb));
        // Scroll down
        this.__scrollDown();
      },
      /**
       * Automatically scroll down to the last line
       */
      __scrollDown : function(){

        this.__log.scrollTop = this.__log.scrollHeight;
      },
      /*
      ---------------------------------------------------------------------------
        VISIBILITY TOGGLING
      ---------------------------------------------------------------------------
      */
      /** {Boolean} Flag to store last visibility status */
      __visible : true,
      /**
       * Toggles the visibility of the console between visible and hidden.
       *
       * @return {void}
       */
      toggle : function(){

        if(!this.__main){

          this.init();
        } else if(this.__main.style.display == A){

          this.show();
        } else {

          this.__main.style.display = A;
        };
      },
      /**
       * Shows the console.
       *
       * @return {void}
       */
      show : function(){

        if(!this.__main){

          this.init();
        } else {

          this.__main.style.display = D;
          this.__log.scrollTop = this.__log.scrollHeight;
        };
      },
      /*
      ---------------------------------------------------------------------------
        COMMAND LINE SUPPORT
      ---------------------------------------------------------------------------
      */
      /** {Array} List of all previous commands. */
      __history : [],
      /**
       * Executes the currently given command
       *
       * @return {void}
       */
      execute : function(){

        var be = this.__cmd.value;
        if(be == G){

          return;
        };
        if(be == n){

          return this.clear();
        };
        var bc = document.createElement(f);
        bc.innerHTML = qx.log.appender.Util.escapeHTML(J + be);
        bc.className = d;
        this.__history.push(be);
        this.__lastCommand = this.__history.length;
        this.__log.appendChild(bc);
        this.__scrollDown();
        try{

          var bd = window.eval(be);
        } catch(bf) {

          qx.log.Logger.error(bf);
        };
        if(bd !== undefined){

          qx.log.Logger.debug(bd);
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler for resize listener
       *
       * @param e {Event} Event object
       * @return {void}
       */
      __onResize : function(e){

        this.__log.style.height = (this.__main.clientHeight - this.__main.firstChild.offsetHeight - this.__main.lastChild.offsetHeight) + i;
      },
      /**
       * Event handler for keydown listener
       *
       * @param e {Event} Event object
       * @return {void}
       */
      __onKeyPress : function(e){

        var bh = e.getKeyIdentifier();
        // Console toggling
        if((bh == B) || (bh == O && e.isCtrlPressed())){

          this.toggle();
          e.preventDefault();
        };
        // Not yet created
        if(!this.__main){

          return;
        };
        // Active element not in console
        if(!qx.dom.Hierarchy.contains(this.__main, e.getTarget())){

          return;
        };
        // Command execution
        if(bh == j && this.__cmd.value != G){

          this.execute();
          this.__cmd.value = G;
        };
        // History managment
        if(bh == y || bh == v){

          this.__lastCommand += bh == y ? -1 : 1;
          this.__lastCommand = Math.min(Math.max(0, this.__lastCommand), this.__history.length);
          var bg = this.__history[this.__lastCommand];
          this.__cmd.value = bg || G;
          this.__cmd.select();
        };
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(bi){

      qx.event.Registration.addListener(document.documentElement, C, bi.__onKeyPress, bi);
    }
  });
})();
(function(){

  var x = "",w = " needs a height when its height size should be used!",v = "px",u = "position",t = "qx.debug",s = " needs a width when its width size should be used!",r = "engine.version",q = "qx.ui.root.Inline",p = "$$widget",o = "appear",f = "hidden",n = "div",k = "left",c = "Please use a DOM element to create an inline root.",b = "mshtml",h = "engine.name",g = "height",l = "The root element ",a = " of ",m = "resize",d = "relative";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Alexander Steitz (aback)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #use(qx.event.handler.ElementResize)
  #ignore(qx.ui)
  #ignore(qx.ui.popup.Manager)
  #ignore(qx.ui.menu.Manager)
  
  ************************************************************************ */
  /**
   * This classes could be used to insert qooxdoo islands into existing
   * web pages. You can use the isles to place any qooxdoo powered widgets
   * inside a layout made using traditional HTML markup and CSS.
   *
   * The size of the widget in each dimension can either be determined by the
   * size hint of the inline's children or by the size of the root DOM element. If
   * <code>dynamicX</code>/<code>dynamicY</code> is true the width/height of the DOM
   * element is used.
   *
   * This class uses {@link qx.ui.layout.Basic} as default layout. The layout
   * can be changed using the {@link #setLayout} method.
   *
   * To position popups and tooltips please have a look at {@link qx.ui.root.Page}.
   */
  qx.Class.define(q, {
    extend : qx.ui.root.Abstract,
    include : [qx.ui.core.MLayoutHandling],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param el {Element} DOM element to use as isle for qooxdoo content. Please
     *    note that existing content gets removed on the first layout flush.
     * @param dynamicX {Boolean} If <code>true</code> the widget's width is
     *    determined by the DOM element's width. Otherwise the children's size hint
     *    is used.
     * @param dynamicY {Boolean} If <code>true</code> the widget's height is
     *    determined by the DOM element's height. Otherwise the children's size hint
     *    is used.
     */
    construct : function(y, z, A){

      // check the parameter
      if(qx.core.Environment.get(t)){

        this.assertElement(y, c);
      };
      // Temporary storage of element to use
      this.__elem = y;
      // Avoid any problems with dynamic resizing
      y.style.overflow = f;
      // Avoid any problems with broken layout
      y.style.textAlign = k;
      this.__dynX = z || false;
      this.__dynY = A || false;
      this.__initDynamicMode();
      qx.ui.root.Abstract.call(this);
      // Use static layout
      this._setLayout(new qx.ui.layout.Basic());
      // Directly schedule layout for root element
      qx.ui.core.queue.Layout.add(this);
      // Register as root
      qx.ui.core.FocusHandler.getInstance().connectTo(this);
      // Avoid the automatically scroll in to view.
      // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3236 for details.
      if((qx.core.Environment.get(h) == b)){

        this.setKeepFocus(true);
      };
      // Resize handling for the window
      var window = qx.dom.Node.getWindow(y);
      qx.event.Registration.addListener(window, m, this._onWindowResize, this);
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __dynX : false,
      __dynY : false,
      __elem : null,
      /**
       * Performs several checks for dynamic mode and adds the "resize" listener
       */
      __initDynamicMode : function(){

        if(this.__dynX || this.__dynY){

          // Check the DOM element for an usable width and height
          var B = qx.bom.element.Dimension.getSize(this.__elem);
          if(this.__dynX && B.width < 1){

            throw new Error(l + this.__elem + a + this + s);
          };
          if(this.__dynY){

            if(B.height < 1){

              throw new Error(l + this.__elem + a + this + w);
            };
            // check for implicit height. Set the height explicit to prevent that
            // the element grows indefinetely
            if(B.height >= 1 && qx.bom.element.Style.get(this.__elem, g, 3) == x){

              qx.bom.element.Style.set(this.__elem, g, B.height + v);
            };
          };
          qx.event.Registration.addListener(this.__elem, m, this._onResize, this);
        };
      },
      // overridden
      _createContainerElement : function(){

        var C = this.__elem;
        if(this.__dynX || this.__dynY){

          var G = document.createElement(n);
          C.appendChild(G);
          // If any of the ancestor elements has a position "relative" it is
          // necessary for IE6 to apply this style also to the root element to
          // avoid any problems when resizing the browser window (see Bug #2035)
          if((qx.core.Environment.get(h) == b) && qx.core.Environment.get(r) == 6){

            var F = qx.dom.Node.getBodyElement(C);
            var E;
            var I;
            var H = false;
            var D = qx.dom.Hierarchy.getAncestors(C);
            for(var i = 0,j = D.length;i < j;i++){

              E = D[i];
              if(E != F){

                I = qx.bom.element.Style.get(E, u);
                if(I == d){

                  H = true;
                  break;
                };
              } else {

                break;
              };
            };
            if(H){

              C.style.position = d;
            };
          };
        } else {

          G = C;
        };
        var J = new qx.html.Root(G);
        // Make relative
        G.style.position = d;
        // Store "weak" reference to the widget in the DOM element.
        J.setAttribute(p, this.toHashCode());
        // fire event asynchronously, otherwise the browser will fire the event
        // too early and no listener will be informed since they're not added
        // at this time
        qx.event.Timer.once(function(e){

          this.fireEvent(o);
        }, this, 0);
        return J;
      },
      /**
       * Listener for the element's resize event
       *
       * @param e {qx.event.type.Event} Event object
       */
      _onResize : function(e){

        var K = e.getData();
        if((K.oldWidth !== K.width) && this.__dynX || (K.oldHeight !== K.height) && this.__dynY){

          qx.ui.core.queue.Layout.add(this);
        };
      },
      /**
       * Listener for the window's resize event.
       */
      _onWindowResize : function(){

        // close all popups
        if(qx.ui.popup && qx.ui.popup.Manager){

          qx.ui.popup.Manager.getInstance().hideAll();
        };
        // close all menus
        if(qx.ui.menu && qx.ui.menu.Manager){

          qx.ui.menu.Manager.getInstance().hideAll();
        };
      },
      // overridden
      _computeSizeHint : function(){

        var P = this.__dynX;
        var M = this.__dynY;
        if(!P || !M){

          var L = qx.ui.root.Abstract.prototype._computeSizeHint.call(this);
        } else {

          L = {
          };
        };
        var Q = qx.bom.element.Dimension;
        if(P){

          var O = Q.getContentWidth(this.__elem);
          L.width = O;
          L.minWidth = O;
          L.maxWidth = O;
        };
        if(M){

          var N = Q.getContentHeight(this.__elem);
          L.height = N;
          L.minHeight = N;
          L.maxHeight = N;
        };
        return L;
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(R, S){

      qx.ui.core.MLayoutHandling.remap(S);
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      qx.event.Registration.removeListener(this.__elem, m, this._onResize, this);
      this.__elem = null;
    }
  });
})();
(function(){

  var f = "resize",d = "interval",c = "__timer",b = "body",a = "qx.event.handler.ElementResize";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This handler fires a <code>resize</code> event if the size of a DOM element
   * changes.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct : function(g){

      qx.core.Object.call(this);
      this.__manager = g;
      this.__elements = {
      };
      this.__timer = new qx.event.Timer(200);
      this.__timer.addListener(d, this._onInterval, this);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        resize : true
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __elements : null,
      __manager : null,
      __timer : null,
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(h, i){

        return h.tagName.toLowerCase() !== b;
      },
      // interface implementation
      registerEvent : function(j, k, l){

        var n = qx.core.ObjectRegistry.toHashCode(j);
        var m = this.__elements;
        if(!m[n]){

          m[n] = {
            element : j,
            width : qx.bom.element.Dimension.getWidth(j),
            height : qx.bom.element.Dimension.getHeight(j)
          };
          this.__timer.start();
        };
      },
      // interface implementation
      unregisterEvent : function(o, p, q){

        var s = qx.core.ObjectRegistry.toHashCode(o);
        var r = this.__elements;
        if(r[s]){

          delete r[s];
          if(qx.lang.Object.isEmpty(r)){

            this.__timer.stop();
          };
        };
      },
      /**
       * Checks elements for width and height changes and fires resize event
       * if needed.
       *
       * @param e {qx.event.type.Data} The incoming data event
       */
      _onInterval : function(e){

        var u = this.__elements;
        for(var x in u){

          var y = u[x];
          var t = y.element;
          var w = qx.bom.element.Dimension.getWidth(t);
          var v = qx.bom.element.Dimension.getHeight(t);
          if(y.height !== v || y.width !== w){

            qx.event.Registration.fireNonBubblingEvent(t, f, qx.event.type.Data, [{
              width : w,
              oldWidth : y.width,
              height : v,
              oldHeight : y.height
            }]);
            y.width = w;
            y.height = v;
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__manager = this.__elements = null;
      this._disposeObjects(c);
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(z){

      qx.event.Registration.addHandler(z);
    }
  });
})();
(function(){

  var v = "tagToggled",u = "http://localhost:8080/xnat/REST/prearchive/experiments?recent=true",s = "selectTag",r = "/archive/projects/",q = "prearchive",p = "?recent=",n = "/REST/",m = "experiments",l = "qx.ui.indicator.ProgressBar",k = "/REST/services/dicomdump?src=",c = "dicomheaderview.DicomHeaderView",j = "/experiments/",f = "&format=csv",b = "Integer",a = "DICOM Headers table cannot load because there are no sessions to view.",e = "completed",d = "GET",g = "archive";
  /**
   * Manage retrieving the recent sessions from XNAT, the headers for each of those sessions and drawing the session table and tag table in a container.
   * 
   * "project","timestamp","lastmod","uploaded","scan_date","scan_time","subject","folderName","name","tag","status","url","autoarchive"
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    /**
     * See properties documentation for an explanation on the constructor arguments
     */
    construct : function(w, y, z, A, B, C){

      qx.core.Object.call(this);
      this.initServerRoot(w);
      this.initArchiveType(B);
      this.initNumDays(C);
      this.initOpenAction(z);
      this.initCloseAction(A);
      this.initContainer(y);
      this.initProgressBar(new qx.ui.indicator.ProgressBar(0));
      this.main();
    },
    properties : {
      /**
       * Container in which to display the archive headers
       */
      container : {
        deferredInit : true
      },
      /**
       * Function that renders the headers in the 'container'  
       */
      openAction : {
        deferredInit : true
      },
      /**
       * Function that manages closing the container
       */
      closeAction : {
        deferredInit : true
      },
      /**
       * Root of the XNAT server
       */
      serverRoot : {
        deferredInit : true
      },
      /**
       * Either "archive" or "prearchive"
       */
      archiveType : {
        deferredInit : true
      },
      /**
       * Number of days worth of headers to retrieve
       */
      numDays : {
        check : b,
        deferredInit : true
      },
      /**
       * As the headers are retrieved notify the user with this progress bar
       */
      progressBar : {
        check : l,
        deferredInit : true
      }
    },
    members : {
      main : function(){

        var F = this;
        var E = this.getServerRoot();
        var I = this.getArchiveType();
        var L = this.getNumDays();
        var G = this.getProgressBar();
        /** 
         * As each header is received update the progress bar
         */
        var H = function(x){

          var M = G.getValue();
          G.setValue(M + x);
        };
        this.getContainer().add(G);
        this.getOpenAction().open(this.getContainer());
        /**
         * Cancel header retrieval
         */
        var D = function(N){

          if(F.getCloseAction().event !== undefined){

            F.getContainer().addListener(F.getCloseAction().event, function(O){

              N();
            });
          } else {

            return N;
          };
        };
        var K = this.createRecentUrl(E, I, L);
        /**
         * The request that retrieves the recent sessions
         */
        var J = new qx.io.remote.Request(K, d);
        /**
         * Once the list of sessions has been retrieved get and render the DICOM headers
         * for each of the them.
         */
        J.addListener(e, function(P){

          var W = P.getContent();
          var S = new csvparser.CSVParser().csvToArray(W);
          var Q = dicomheaderview.ExperimentTable.toObject(S);
          // create the urls for retrieving the DICOM header
          var V;
          if(F.getArchiveType() === g){

            V = Q.map(function(o){

              return r + o.project + j + o.id;
            });
          } else {

            V = Q.map(function(o){

              return o.url;
            });
          };
          // Store the ids of the sessions
          var U;
          if(F.getArchiveType() === g){

            U = Q.map(function(o){

              return o.id;
            });
          } else {

            U = Q.map(function(o){

              return o.name;
            });
          };
          if(Q.length > 0){

            G.setMaximum(V.length);
            // retrieve the headers
            var T = new dicomheaderview.GetHeaders(F.getServerRoot(), V, H, D);
            // Once retrieved render the table
            T.addListener(e, function(X){

              var bb = X.getData();
              F.getContainer().remove(G);
              var Y = [];
              for(var h = 0;h < bb.headers.length;h++){

                Y.push({
                  name : U[h],
                  data : bb.headers[h].data
                });
              };
              var ba = new dicomheaderview.ExperimentTable(Y, null);
              var bc = F.fillMainContainer(ba);
              F.getContainer().add(bc);
              F.getOpenAction().open(F.getContainer());
            });
            T.retrieveHeaders();
          } else {

            F.getContainer().remove(G);
            var R = new qx.ui.basic.Label(a).set({
              rich : true,
              width : 300
            });
            F.getContainer().add(R);
          };
        });
        J.send();
      },
      /**
       * Create the url to retrieve the headers
       * @param serverRoot{String} The root of the XNAT server
       * @param srcUrl{String} The url of the session
       */
      createHeaderUrl : function(bd, be){

        var bf = bd + k + be;
        return bf;
      },
      /**
       * Create the url to retrieve the list of recent sessions
       * @param serverRoot{String} The root of the XNAT server
       * @param archiveType{String} "archive|prearchive"
       * @param numDays{Integer} How far to go back
       */
      createRecentUrl : function(bg, bh, bi){

        var bk;
        if(bh === g){

          bk = m;
        } else {

          bk = q;
        };
        var bj = bg + n + bk + p + bi + f;
        return bj;
      },
      /**
       * Used for testing, unused in production
       */
      createMockExperiments : function(bl){

        var bn = [];
        var bm = dicomheaderview.MockData.experiments(100);
        for(var i = 0;i < bm.length;i++){

          bn.push({
            name : bm[i],
            data : bl
          });
        };
        return bn;
      },
      /**
       * Add the master list of tags and the table of sessions to the container.
       * Scroll the corresponding tag column in the session table if a tag is selected in the master list
       * Hide a column in the session table if the user unchecks it in the master list
       * @param experimentTable{Object} The table of experiments
       */
      fillMainContainer : function(bo){

        var bt = new qx.ui.container.Composite(new qx.ui.layout.HBox());
        var t = new dicomtag.TagTable();
        var bs = bo.createTable(dicomtag.Tags.defaultVisibleTags);
        t.addListener(s, function(bu){

          var bv = bu.getData();
          bo.scrollToColumn(bs, bv.tag);
        });
        t.addListener(v, function(bw){

          var bx = bw.getData();
          bo.setVisibility(bs, bx.tag, bx.visible);
          bo.scrollToColumn(bs, bx.tag);
        });
        var br = bo.getTableTags();
        var bq = t.createModel(br.slice(1));
        var bp = t.createPublicTable(bq);
        bt.setWidth(900);
        bt.add(bp);
        bt.add(bs, {
          flex : 1
        });
        return bt;
      },
      /**
       * Retrieve the most recent sessions from the prearchive. Unused
       */
      serverRequest : function(){

        var by = u;
        var bz = new qx.io.remote.Request(by, d);
        bz.setCrossDomain(true);
        return bz;
      }
    }
  });
})();
(function(){

  var i = "complete",h = "0%",g = "progressbar",f = "change",e = "qx.ui.indicator.ProgressBar",d = "qx.event.type.Event",c = "%",b = "qx.event.type.Data",a = "progress";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  /**
   * The Progress bar is designed to simply display the current % complete
   * for a process.
   *
   * The Value is limited between 0 and Maximum value.
   * It's not allowed to set a Maximum value of 0.  If you set a Maximum value
   * bigger than 0, but smaller than Value, it will be limited to Value.
   *
   * The following example creates and adds a progress bar to the root element.
   * A listener is used to show the user if the value is changed,
   * and another one when the progress is complete.
   *
   * <pre class='javascript'>
   * var pb = new qx.ui.indicator.ProgressBar();
   * this.getRoot().add(pb, { left : 20, top: 20});
   *
   * pb.addListener("change", function(e) {
   *   this.debug(e.getData()); // % complete
   *   this.debug(pb.getValue()); // absolute value
   * });
   *
   * pb.addListener("complete", function(e) {
   *   this.debug("complete");
   * });
   *
   * //set a value
   * pb.setValue(20);
   * </pre>
   */
  qx.Class.define(e, {
    extend : qx.ui.container.Composite,
    /**
     * @param value {Number ? 0} Progress bar value
     * @param maximum {Number ? 100} Progress bar maximum value
     */
    construct : function(j, k){

      qx.ui.container.Composite.call(this);
      this._createChildControl(a);
      this.setLayout(new qx.ui.layout.HBox());
      if(k != null){

        this.setMaximum(k);
      };
      if(j != null){

        this.setValue(j);
      };
    },
    properties : {
      appearance : {
        refine : true,
        init : g
      }
    },
    events : {
      /**
       * Fired when the process is complete (value === maximum value)
       */
      complete : d,
      /**
       * Fired when the % complete value is changed.
       */
      change : b
    },
    members : {
      __value : 0,
      __maximum : 100,
      /**
       * Returns the progress bar value.
       *
       * @return progress bar value.
       */
      getValue : function(){

        return this.__value;
      },
      /**
       * Sets the value of the progress bar.
       *
       * @param value {Number} New value of the progress bar.
       * @return The unmodified incoming value.
       */
      setValue : function(l){

        var m = this.getMaximum();
        //do nothing if is not a number
        if(!qx.lang.Type.isNumber(l) || !isFinite(l)){

          return;
        };
        // limit value to 0
        if(l < 0){

          l = 0;
        };
        // limit value to max
        if(l > m){

          l = m;
        };
        //set value
        this.__value = l;
        //update progress
        this._changeProgress(l / m);
        return l;
      },
      /**
       * Returns the maximum value of progress bar.
       *
       * @return maximum value of progress bar.
       */
      getMaximum : function(){

        return this.__maximum;
      },
      /**
       * Sets the maximum value of the progress bar.
       *
       * @param value {Number} New maximum value progress bar.
       * @return The unmodified incoming value.
       */
      setMaximum : function(n){

        var o = n;
        var p = this.getValue();
        //do nothing if is not a number, is negative or zero
        if(!qx.lang.Type.isNumber(o) || !isFinite(o) || o <= 0){

          return;
        };
        //limit max to a greater than 0 value
        if(o < p){

          o = p;
        };
        //set max
        this.__maximum = o;
        //update progress
        this._changeProgress(p / o);
        return o;
      },
      //overridden
      _createChildControlImpl : function(q, r){

        var s;
        switch(q){case a:
        s = new qx.ui.container.Composite(new qx.ui.layout.Canvas());
        this._add(s, {
          width : h
        });
        break;};
        return s || qx.ui.container.Composite.prototype._createChildControlImpl.call(this, q);
      },
      /**
       * Update the progress bar.
       *
       * @param value {Number} future value of progress bar
       */
      _changeProgress : function(t){

        var v = this.getChildControl(a);
        var u = Math.floor(t * 100);
        var w = parseInt(v.getLayoutProperties().width, 10);
        v.setLayoutProperties({
          width : u + c
        });
        //fire change event
        if(u != w){

          this.fireDataEvent(f, u, w);
        };
        //fire complete event if 100% complete
        if(u === 100){

          this.fireEvent(i);
        };
      }
    }
  });
})();
(function(){

  var s = "Decorator",r = "middle",q = "_applyReversed",p = "qx.debug",o = "bottom",n = "' is not supported by the HBox layout!",m = "Boolean",k = "flex",j = "right",h = "Integer",c = "The property '",g = "qx.ui.layout.HBox",f = "width",b = "center",a = "top",e = "left",d = "_applyLayoutChange";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A horizontal box layout.
   *
   * The horizontal box layout lays out widgets in a horizontal row, from left
   * to right.
   *
   * *Features*
   *
   * * Minimum and maximum dimensions
   * * Prioritized growing/shrinking (flex)
   * * Margins (with horizontal collapsing)
   * * Auto sizing (ignoring percent values)
   * * Percent widths (not relevant for size hint)
   * * Alignment (child property {@link qx.ui.core.LayoutItem#alignX} is ignored)
   * * Horizontal spacing (collapsed with margins)
   * * Reversed children layout (from last to first)
   * * Vertical children stretching (respecting size hints)
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>flex</strong> <em>(Integer)</em>: The flexibility of a layout item determines how the container
   *   distributes remaining empty space among its children. If items are made
   *   flexible, they can grow or shrink accordingly. Their relative flex values
   *   determine how the items are being resized, i.e. the larger the flex ratio
   *   of two items, the larger the resizing of the first item compared to the
   *   second.
   *
   *   If there is only one flex item in a layout container, its actual flex
   *   value is not relevant. To disallow items to become flexible, set the
   *   flex value to zero.
   * </li>
   * <li><strong>width</strong> <em>(String)</em>: Allows to define a percent
   *   width for the item. The width in percent, if specified, is used instead
   *   of the width defined by the size hint. The minimum and maximum width still
   *   takes care of the element's limits. It has no influence on the layout's
   *   size hint. Percent values are mostly useful for widgets which are sized by
   *   the outer hierarchy.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the grid layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.HBox();
   * layout.setSpacing(4); // apply spacing
   *
   * var container = new qx.ui.container.Composite(layout);
   *
   * container.add(new qx.ui.core.Widget());
   * container.add(new qx.ui.core.Widget());
   * container.add(new qx.ui.core.Widget());
   * </pre>
   *
   * *External Documentation*
   *
   * See <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/box.html'>extended documentation</a>
   * and links to demos for this layout.
   *
   */
  qx.Class.define(g, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param spacing {Integer?0} The spacing between child widgets {@link #spacing}.
     * @param alignX {String?"left"} Horizontal alignment of the whole children
     *     block {@link #alignX}.
     * @param separator {Decorator} A separator to render between the items
     */
    construct : function(t, u, v){

      qx.ui.layout.Abstract.call(this);
      if(t){

        this.setSpacing(t);
      };
      if(u){

        this.setAlignX(u);
      };
      if(v){

        this.setSeparator(v);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Horizontal alignment of the whole children block. The horizontal
       * alignment of the child is completely ignored in HBoxes (
       * {@link qx.ui.core.LayoutItem#alignX}).
       */
      alignX : {
        check : [e, b, j],
        init : e,
        apply : d
      },
      /**
       * Vertical alignment of each child. Can be overridden through
       * {@link qx.ui.core.LayoutItem#alignY}.
       */
      alignY : {
        check : [a, r, o],
        init : a,
        apply : d
      },
      /** Horizontal spacing between two children */
      spacing : {
        check : h,
        init : 0,
        apply : d
      },
      /** Separator lines to use between the objects */
      separator : {
        check : s,
        nullable : true,
        apply : d
      },
      /** Whether the actual children list should be laid out in reversed order. */
      reversed : {
        check : m,
        init : false,
        apply : q
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __widths : null,
      __flexs : null,
      __enableFlex : null,
      __children : null,
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyReversed : function(){

        // easiest way is to invalidate the cache
        this._invalidChildrenCache = true;
        // call normal layout change
        this._applyLayoutChange();
      },
      /**
       * Rebuilds caches for flex and percent layout properties
       */
      __rebuildCache : function(){

        var B = this._getLayoutChildren();
        var length = B.length;
        var y = false;
        var w = this.__widths && this.__widths.length != length && this.__flexs && this.__widths;
        var z;
        // Sparse array (keep old one if lengths has not been modified)
        var x = w ? this.__widths : new Array(length);
        var A = w ? this.__flexs : new Array(length);
        // Reverse support
        if(this.getReversed()){

          B = B.concat().reverse();
        };
        // Loop through children to preparse values
        for(var i = 0;i < length;i++){

          z = B[i].getLayoutProperties();
          if(z.width != null){

            x[i] = parseFloat(z.width) / 100;
          };
          if(z.flex != null){

            A[i] = z.flex;
            y = true;
          } else {

            // reset (in case the index of the children changed: BUG #3131)
            A[i] = 0;
          };
        };
        // Store data
        if(!w){

          this.__widths = x;
          this.__flexs = A;
        };
        this.__enableFlex = y;
        this.__children = B;
        // Clear invalidation marker
        delete this._invalidChildrenCache;
      },
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(p, {
        "true" : function(C, name, D){

          this.assert(name === k || name === f, c + name + n);
          if(name == f){

            this.assertMatch(D, qx.ui.layout.Util.PERCENT_VALUE);
          } else {

            // flex
            this.assertNumber(D);
            this.assert(D >= 0);
          };
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(E, F){

        // Rebuild flex/width caches
        if(this._invalidChildrenCache){

          this.__rebuildCache();
        };
        // Cache children
        var L = this.__children;
        var length = L.length;
        var U = qx.ui.layout.Util;
        // Compute gaps
        var T = this.getSpacing();
        var X = this.getSeparator();
        if(X){

          var I = U.computeHorizontalSeparatorGaps(L, T, X);
        } else {

          var I = U.computeHorizontalGaps(L, T, true);
        };
        // First run to cache children data and compute allocated width
        var i,G,R,Q;
        var W = [];
        var M = I;
        for(i = 0;i < length;i += 1){

          Q = this.__widths[i];
          R = Q != null ? Math.floor((E - I) * Q) : L[i].getSizeHint().width;
          W.push(R);
          M += R;
        };
        // Flex support (growing/shrinking)
        if(this.__enableFlex && M != E){

          var O = {
          };
          var S,V;
          for(i = 0;i < length;i += 1){

            S = this.__flexs[i];
            if(S > 0){

              N = L[i].getSizeHint();
              O[i] = {
                min : N.minWidth,
                value : W[i],
                max : N.maxWidth,
                flex : S
              };
            };
          };
          var J = U.computeFlexOffsets(O, E, M);
          for(i in J){

            V = J[i].offset;
            W[i] += V;
            M += V;
          };
        };
        // Start with left coordinate
        var bc = L[0].getMarginLeft();
        // Alignment support
        if(M < E && this.getAlignX() != e){

          bc = E - M;
          if(this.getAlignX() === b){

            bc = Math.round(bc / 2);
          };
        };
        // Layouting children
        var N,top,H,R,K,ba,P;
        var T = this.getSpacing();
        // Pre configure separators
        this._clearSeparators();
        // Compute separator width
        if(X){

          var Y = qx.theme.manager.Decoration.getInstance().resolve(X).getInsets();
          var bb = Y.left + Y.right;
        };
        // Render children and separators
        for(i = 0;i < length;i += 1){

          G = L[i];
          R = W[i];
          N = G.getSizeHint();
          ba = G.getMarginTop();
          P = G.getMarginBottom();
          // Find usable height
          H = Math.max(N.minHeight, Math.min(F - ba - P, N.maxHeight));
          // Respect vertical alignment
          top = U.computeVerticalAlignOffset(G.getAlignY() || this.getAlignY(), H, F, ba, P);
          // Add collapsed margin
          if(i > 0){

            // Whether a separator has been configured
            if(X){

              // add margin of last child and spacing
              bc += K + T;
              // then render the separator at this position
              this._renderSeparator(X, {
                left : bc,
                top : 0,
                width : bb,
                height : F
              });
              // and finally add the size of the separator, the spacing (again) and the left margin
              bc += bb + T + G.getMarginLeft();
            } else {

              // Support margin collapsing when no separator is defined
              bc += U.collapseMargins(T, K, G.getMarginLeft());
            };
          };
          // Layout child
          G.renderLayout(bc, top, R, H);
          // Add width
          bc += R;
          // Remember right margin (for collapsing)
          K = G.getMarginRight();
        };
      },
      // overridden
      _computeSizeHint : function(){

        // Rebuild flex/width caches
        if(this._invalidChildrenCache){

          this.__rebuildCache();
        };
        var bj = qx.ui.layout.Util;
        var br = this.__children;
        // Initialize
        var bd = 0,bk = 0,bh = 0;
        var bg = 0,bi = 0;
        var bo,be,bq;
        // Iterate over children
        for(var i = 0,l = br.length;i < l;i += 1){

          bo = br[i];
          be = bo.getSizeHint();
          // Sum up widths
          bk += be.width;
          // Detect if child is shrinkable or has percent width and update minWidth
          var bn = this.__flexs[i];
          var bf = this.__widths[i];
          if(bn){

            bd += be.minWidth;
          } else if(bf){

            bh = Math.max(bh, Math.round(be.minWidth / bf));
          } else {

            bd += be.width;
          };
          // Build vertical margin sum
          bq = bo.getMarginTop() + bo.getMarginBottom();
          // Find biggest height
          if((be.height + bq) > bi){

            bi = be.height + bq;
          };
          // Find biggest minHeight
          if((be.minHeight + bq) > bg){

            bg = be.minHeight + bq;
          };
        };
        bd += bh;
        // Respect gaps
        var bm = this.getSpacing();
        var bp = this.getSeparator();
        if(bp){

          var bl = bj.computeHorizontalSeparatorGaps(br, bm, bp);
        } else {

          var bl = bj.computeHorizontalGaps(br, bm, true);
        };
        // Return hint
        return {
          minWidth : bd + bl,
          width : bk + bl,
          minHeight : bg,
          height : bi
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__widths = this.__flexs = this.__children = null;
    }
  });
})();
(function(){

  var k = "application/xml",j = "application/json",i = "text/html",h = "application/x-www-form-urlencoded",g = "qx.io.remote.Exchange",f = "Integer",d = "X-Qooxdoo-Response-Type",c = "HEAD",b = "qx.io.remote.Request",a = "qx.debug",T = "_applyResponseType",S = "_applyState",R = "text/javascript",Q = "changeState",P = "_applyProhibitCaching",O = "",N = "_applyMethod",M = "DELETE",L = "qx.debug.io.remote",K = "boolean",r = "Aborting already sent request!",s = "State: ",p = "GET",q = "Pragma",n = "no-url-params-on-post",o = "Content-Type",l = "PUT",m = "no-cache",t = "Cache-Control",u = "text/plain",C = "aborted",A = "failed",E = "nocache",D = "completed",G = "qx.io.remote.Response",F = "POST",x = "configured",J = "timeout",I = "queued",H = "String",w = "sending",y = "receiving",z = "Boolean",B = "qx.event.type.Event";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * This class is used to send HTTP requests to the server.
   *
   * Note: This class will be deprecated in a future release. Instead,
   * please use classes found in {@link qx.io.request}.
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param vUrl {String}
     *   Target url to issue the request to.
     *
     * @param vMethod {String}
     *   Determines http method (GET, POST, PUT, etc.) to use. See "method" property
     *   for valid values and default value.
     *
     * @param vResponseType {String}
     *   The mime type of the response. Default is text/plain.
     */
    construct : function(U, V, W){

      qx.core.Object.call(this);
      this.__requestHeaders = {
      };
      this.__urlParameters = {
      };
      this.__dataParameters = {
      };
      this.__formFields = {
      };
      if(U !== undefined){

        this.setUrl(U);
      };
      if(V !== undefined){

        this.setMethod(V);
      };
      if(W !== undefined){

        this.setResponseType(W);
      };
      this.setProhibitCaching(true);
      // Get the next sequence number for this request
      this.__seqNum = ++qx.io.remote.Request.__seqNum;
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the Request object changes its state to 'created' */
      "created" : B,
      /** Fired when the Request object changes its state to 'configured' */
      "configured" : B,
      /** Fired when the Request object changes its state to 'sending' */
      "sending" : B,
      /** Fired when the Request object changes its state to 'receiving' */
      "receiving" : B,
      /**
       * Fired once the request has finished successfully. The event object
       * can be used to read the transferred data.
       */
      "completed" : G,
      /** Fired when the pending request has been aborted. */
      "aborted" : B,
      /** Fired when the pending request failes. */
      "failed" : G,
      /** Fired when the pending request times out. */
      "timeout" : G
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /*
      ---------------------------------------------------------------------------
        SEQUENCE NUMBER
      ---------------------------------------------------------------------------
      */
      /**
       * Sequence (id) number of a request, used to associate a response or error
       * with its initiating request.
       */
      __seqNum : 0,
      /**
       * Returns true if the given HTTP method allows a request body being transferred to the server.
       * This is currently POST and PUT. Other methods require their data being encoded into
       * the URL
       *
       * @param httpMethod {String} one of the values of the method property
       * @return {Boolean}
       */
      methodAllowsRequestBody : function(X){

        return (X == F) || (X == l);
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Target url to issue the request to.
       */
      url : {
        check : H,
        init : O
      },
      /**
       * Determines what type of request to issue (GET or POST).
       */
      method : {
        check : [p, F, l, c, M],
        apply : N,
        init : p
      },
      /**
       * Set the request to asynchronous.
       */
      asynchronous : {
        check : z,
        init : true
      },
      /**
       * Set the data to be sent via this request
       */
      data : {
        check : H,
        nullable : true
      },
      /**
       * Username to use for HTTP authentication.
       * Set to NULL if HTTP authentication is not used.
       */
      username : {
        check : H,
        nullable : true
      },
      /**
       * Password to use for HTTP authentication.
       * Set to NULL if HTTP authentication is not used.
       */
      password : {
        check : H,
        nullable : true
      },
      /**
       * The state that the request is in, while being processed.
       */
      state : {
        check : [x, I, w, y, D, C, J, A],
        init : x,
        apply : S,
        event : Q
      },
      /**
       * Response type of request.
       *
       * The response type is a MIME type, default is text/plain. Other supported
       * MIME types are text/javascript, text/html, application/json,
       * application/xml.
       */
      responseType : {
        check : [u, R, j, k, i],
        init : u,
        apply : T
      },
      /**
       * Number of milliseconds before the request is being timed out.
       *
       * If this property is null, the timeout for the request comes is the
       * qx.io.remote.RequestQueue's property defaultTimeout.
       */
      timeout : {
        check : f,
        nullable : true
      },
      /**
       * Prohibit request from being cached.
       *
       * Setting the value to <i>true</i> adds a parameter "nocache" to the
       * request URL with a value of the current time, as well as adding request
       * headers Pragma:no-cache and Cache-Control:no-cache.
       *
       * Setting the value to <i>false</i> removes the parameter and request
       * headers.
       *
       * As a special case, this property may be set to the string value
       * "no-url-params-on-post" which will prevent the nocache parameter from
       * being added to the URL if the POST method is used but will still add
       * the Pragma and Cache-Control headers.  This is useful if your backend
       * does nasty things like mixing parameters specified in the URL into
       * form fields in the POST request.  (One example of this nasty behavior
       * is known as "mixed mode" in Oracle, as described here:
       * http://download.oracle.com/docs/cd/B32110_01/web.1013/b28963/concept.htm#i1005684)
       */
      prohibitCaching : {
        check : function(v){

          return typeof v == K || v === n;
        },
        init : true,
        apply : P
      },
      /**
       * Indicate that the request is cross domain.
       *
       * A request is cross domain if the request's URL points to a host other than
       * the local host. This switches the concrete implementation that is used for
       * sending the request from qx.io.remote.transport.XmlHttp to
       * qx.io.remote.transport.Script, because only the latter can handle cross
       * domain requests.
       */
      crossDomain : {
        check : z,
        init : false
      },
      /**
       * Indicate that the request will be used for a file upload.
       *
       * The request will be used for a file upload.  This switches the concrete
       * implementation that is used for sending the request from
       * qx.io.remote.transport.XmlHttp to qx.io.remote.IFrameTransport, because only
       * the latter can handle file uploads.
       */
      fileUpload : {
        check : z,
        init : false
      },
      /**
       * The transport instance used for the request.
       *
       * This is necessary to be able to abort an asynchronous request.
       */
      transport : {
        check : g,
        nullable : true
      },
      /**
       * Use Basic HTTP Authentication.
       */
      useBasicHttpAuth : {
        check : z,
        init : false
      },
      /**
       * If true and the responseType property is set to "application/json", getContent() will
       * return a Javascript map containing the JSON contents, i. e. the result qx.lang.Json.parse().
       * If false, the raw string data will be returned and the parsing must be done manually.
       * This is usefull for special JSON dialects / extensions which are not supported by
       * qx.lang.Json.
       *
       * Note that this is currently only respected by qx.io.remote.transport.XmlHttp, i. e.
       * if the transport used is the one using XMLHttpRequests. The other transports
       * do not support JSON parsing, so this property has no effect.
       */
      parseJson : {
        check : z,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __requestHeaders : null,
      __urlParameters : null,
      __dataParameters : null,
      __formFields : null,
      __seqNum : null,
      /*
      ---------------------------------------------------------------------------
        CORE METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Schedule this request for transport to server.
       *
       * The request is added to the singleton class qx.io.remote.RequestQueue's
       * list of pending requests.
       *
       * @return {void}
       */
      send : function(){

        qx.io.remote.RequestQueue.getInstance().add(this);
      },
      /**
       * Abort sending this request.
       *
       * The request is removed from the singleton class qx.io.remote.RequestQueue's
       * list of pending events. If the request haven't been scheduled this
       * method is a noop.
       *
       * @return {void}
       */
      abort : function(){

        qx.io.remote.RequestQueue.getInstance().abort(this);
      },
      /**
       * Abort sending this request if it has not already been aborted.
       *
       * @return {void}
       */
      reset : function(){

        switch(this.getState()){case w:case y:
        this.error(r);// no break
        case I:
        this.abort();
        break;};
      },
      /*
      ---------------------------------------------------------------------------
        STATE ALIASES
      ---------------------------------------------------------------------------
      */
      /**
       * Determine if this request is in the configured state.
       *
       * @return {Boolean} <true> if the request is in the configured state; <false> otherwise.
       */
      isConfigured : function(){

        return this.getState() === x;
      },
      /**
       * Determine if this request is in the queued state.
       *
       * @return {Boolean} <true> if the request is in the queued state; <false> otherwise.
       */
      isQueued : function(){

        return this.getState() === I;
      },
      /**
       * Determine if this request is in the sending state.
       *
       * @return {Boolean} <true> if the request is in the sending state; <false> otherwise.
       */
      isSending : function(){

        return this.getState() === w;
      },
      /**
       * Determine if this request is in the receiving state.
       *
       * @return {Boolean} <true> if the request is in the receiving state; <false> otherwise.
       */
      isReceiving : function(){

        return this.getState() === y;
      },
      /**
       * Determine if this request is in the completed state.
       *
       * @return {Boolean} <true> if the request is in the completed state; <false> otherwise.
       */
      isCompleted : function(){

        return this.getState() === D;
      },
      /**
       * Determine if this request is in the aborted state.
       *
       * @return {Boolean} <true> if the request is in the aborted state; <false> otherwise.
       */
      isAborted : function(){

        return this.getState() === C;
      },
      /**
       * Determine if this request is in the timeout state.
       *
       * @return {Boolean} <true> if the request is in the timeout state; <false> otherwise.
       */
      isTimeout : function(){

        return this.getState() === J;
      },
      /**
       * Determine if this request is in the failed state.
       *
       * @return {Boolean} <true> if the request is in the failed state; <false> otherwise.
       */
      isFailed : function(){

        return this.getState() === A;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Dispatches a clone of the given event on this instance
       *
       * @param e {qx.event.type.Event} The original event
       */
      __forwardEvent : qx.event.GlobalError.observeMethod(function(e){

        var Y = e.clone();
        Y.setTarget(this);
        this.dispatchEvent(Y);
      }),
      /**
       * Event handler called when the request enters the queued state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _onqueued : function(e){

        // Modify internal state
        this.setState(I);
        // Bubbling up
        this.__forwardEvent(e);
      },
      /**
       * Event handler called when the request enters the sending state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _onsending : function(e){

        // Modify internal state
        this.setState(w);
        // Bubbling up
        this.__forwardEvent(e);
      },
      /**
       * Event handler called when the request enters the receiving state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _onreceiving : function(e){

        // Modify internal state
        this.setState(y);
        // Bubbling up
        this.__forwardEvent(e);
      },
      /**
       * Event handler called when the request enters the completed state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _oncompleted : function(e){

        // Modify internal state
        this.setState(D);
        // Bubbling up
        this.__forwardEvent(e);
        // Automatically dispose after event completion
        this.dispose();
      },
      /**
       * Event handler called when the request enters the aborted state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _onaborted : function(e){

        // Modify internal state
        this.setState(C);
        // Bubbling up
        this.__forwardEvent(e);
        // Automatically dispose after event completion
        this.dispose();
      },
      /**
       * Event handler called when the request enters the timeout state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _ontimeout : function(e){

        /*
          // User's handler can block until timeout.
          switch(this.getState())
          {
            // If we're no longer running...
            case "completed":
            case "timeout":
            case "aborted":
            case "failed":
              // then don't bubble up the timeout event
              return;
          }
        
        
            */
        // Modify internal state
        this.setState(J);
        // Bubbling up
        this.__forwardEvent(e);
        // Automatically dispose after event completion
        this.dispose();
      },
      /**
       * Event handler called when the request enters the failed state.
       *
       * @param e {qx.event.type.Event} Event indicating state change
       * @return {void}
       */
      _onfailed : function(e){

        // Modify internal state
        this.setState(A);
        // Bubbling up
        this.__forwardEvent(e);
        // Automatically dispose after event completion
        this.dispose();
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyState : function(ba, bb){

        if(qx.core.Environment.get(a)){

          if(qx.core.Environment.get(L)){

            this.debug(s + ba);
          };
        };
      },
      // property apply
      _applyProhibitCaching : function(bc, bd){

        if(!bc){

          this.removeParameter(E);
          this.removeRequestHeader(q);
          this.removeRequestHeader(t);
          return;
        };
        // If value isn't "no-url-params-on-post" or this isn't a POST request
        if(bc !== n || this.getMethod() != F){

          // ... then add a parameter to the URL to make it unique on each
          // request.  The actual id, "nocache" is irrelevant; it's the fact
          // that a (usually) different date is added to the URL on each request
          // that prevents caching.
          this.setParameter(E, new Date().valueOf());
        } else {

          // Otherwise, we don't want the nocache parameer in the URL.
          this.removeParameter(E);
        };
        // Add the HTTP 1.0 request to avoid use of a cache
        this.setRequestHeader(q, m);
        // Add the HTTP 1.1 request to avoid use of a cache
        this.setRequestHeader(t, m);
      },
      // property apply
      _applyMethod : function(be, bf){

        if(qx.io.remote.Request.methodAllowsRequestBody(be)){

          this.setRequestHeader(o, h);
        } else {

          this.removeRequestHeader(o);
        };
        // Re-test the prohibit caching property.  We may need to add or remove
        // the "nocache" parameter.  We explicitly call the _apply method since
        // it wouldn't be called normally when setting the value to its already
        // existant value.
        var bg = this.getProhibitCaching();
        this._applyProhibitCaching(bg, bg);
      },
      // property apply
      _applyResponseType : function(bh, bi){

        this.setRequestHeader(d, bh);
      },
      /*
      ---------------------------------------------------------------------------
        REQUEST HEADER
      ---------------------------------------------------------------------------
      */
      /**
       * Add a request header to the request.
       *
       * Example: request.setRequestHeader("Content-Type", "text/html")
       *
       * Please note: Some browsers, such as Safari 3 and 4, will capitalize
       * header field names. This is in accordance with RFC 2616[1], which states
       * that HTTP 1.1 header names are case-insensitive, so your server backend
       * should be case-agnostic when dealing with request headers.
       *
       * [1]<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2">RFC 2616: HTTP Message Headers</a>
       *
       * @param vId {String} The identifier to use for this added header
       * @param vValue {String} The value to use for this added header
       * @return {void}
       */
      setRequestHeader : function(bj, bk){

        this.__requestHeaders[bj] = bk;
      },
      /**
       * Remove a previously-added request header
       *
       * @param vId {String} The id of the header to be removed
       * @return {void}
       */
      removeRequestHeader : function(bl){

        delete this.__requestHeaders[bl];
      },
      /**
       * Retrieve the value of a header which was previously set
       *
       * @param vId {String} The id of the header value being requested
       * @return {String} The value of the header with the specified id
       */
      getRequestHeader : function(bm){

        return this.__requestHeaders[bm] || null;
      },
      /**
       * Return the object containing all of the headers which have been added.
       *
       * @return {Object} The returned object has as its property names each of the ids of headers
       *     which have been added, and as each property value, the value of the
       *     property corresponding to that id.
       */
      getRequestHeaders : function(){

        return this.__requestHeaders;
      },
      /*
      ---------------------------------------------------------------------------
        PARAMETERS
      ---------------------------------------------------------------------------
      */
      /**
       * Add a parameter to the request.
       *
       * @param vId {String}
       *   String identifier of the parameter to add.
       *
       * @param vValue {var}
       *   Value of parameter. May be a string (for one parameter) or an array
       *   of strings (for setting multiple parameter values with the same
       *   parameter name).
       *
       * @param bAsData {Boolean | false}
       *   If <i>false</i>, add the parameter to the URL.  If <i>true</i> then
       *   instead the parameters added by calls to this method will be combined
       *   into a string added as the request data, as if the entire set of
       *   parameters had been pre-build and passed to setData().
       *
       * Note: Parameters requested to be sent as data will be silently dropped
       *       if data is manually added via a call to setData().
       *
       * Note: Some transports, e.g. Script, do not support passing parameters
       *       as data.
       *
       * @return {void}
       */
      setParameter : function(bn, bo, bp){

        if(bp){

          this.__dataParameters[bn] = bo;
        } else {

          this.__urlParameters[bn] = bo;
        };
      },
      /**
       * Remove a parameter from the request.
       *
       * @param vId {String}
       *   Identifier of the parameter to remove.
       *
       * @param bFromData {Boolean}
       *   If <i>false</i> then remove the parameter of the URL parameter list.
       *   If <i>true</i> then remove it from the list of parameters to be sent
       *   as request data.
       *
       * @return {void}
       */
      removeParameter : function(bq, br){

        if(br){

          delete this.__dataParameters[bq];
        } else {

          delete this.__urlParameters[bq];
        };
      },
      /**
       * Get a parameter in the request.
       *
       * @param vId {String}
       *   Identifier of the parameter to get.
       *
       * @param bFromData {Boolean}
       *   If <i>false</i> then retrieve the parameter from the URL parameter
       *   list. If <i>true</i> then retrieve it from the list of parameters to
       *   be sent as request data.
       *
       * @return {var}
       *   The requested parameter value
       *
       */
      getParameter : function(bs, bt){

        if(bt){

          return this.__dataParameters[bs] || null;
        } else {

          return this.__urlParameters[bs] || null;
        };
      },
      /**
       * Returns the object containg all parameters for the request.
       *
       * @param bFromData {Boolean}
       *   If <i>false</i> then retrieve the URL parameter list.
       *   If <i>true</i> then retrieve the data parameter list.
       *
       * @return {Object}
       *   The returned object has as its property names each of the ids of
       *   parameters which have been added, and as each property value, the
       *   value of the property corresponding to that id.
       */
      getParameters : function(bu){

        return (bu ? this.__dataParameters : this.__urlParameters);
      },
      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      /**
       * Add a form field to the POST request.
       *
       * NOTE: Adding any programatic form fields using this method will switch the
       *       Transport implementation to IframeTransport.
       *
       * NOTE: Use of these programatic form fields disallow use of synchronous
       *       requests and cross-domain requests.  Be sure that you do not need
       *       those features when setting these programatic form fields.
       *
       * @param vId {String} String identifier of the form field to add.
       * @param vValue {String} Value of form field
       * @return {void}
       */
      setFormField : function(bv, bw){

        this.__formFields[bv] = bw;
      },
      /**
       * Remove a form field from the POST request.
       *
       * @param vId {String} Identifier of the form field to remove.
       * @return {void}
       */
      removeFormField : function(bx){

        delete this.__formFields[bx];
      },
      /**
       * Get a form field in the POST request.
       *
       * @param vId {String} Identifier of the form field to get.
       * @return {String|null} Value of form field or <code>null</code> if no value
       *    exists for the passed identifier.
       */
      getFormField : function(by){

        return this.__formFields[by] || null;
      },
      /**
       * Returns the object containg all form fields for the POST request.
       *
       * @return {Object} The returned object has as its property names each of the ids of
       *     form fields which have been added, and as each property value, the value
       *     of the property corresponding to that id.
       */
      getFormFields : function(){

        return this.__formFields;
      },
      /**
       * Obtain the sequence (id) number used for this request
       *
       * @return {Integer} The sequence number of this request
       */
      getSequenceNumber : function(){

        return this.__seqNum;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.setTransport(null);
      this.__requestHeaders = this.__urlParameters = this.__dataParameters = this.__formFields = null;
    }
  });
})();
(function(){

  var l = "_on",k = "Boolean",j = "__timer",h = " handler ",g = "ms",f = "Progress: ",d = "singleton",c = "Timeout: transport ",b = "interval",a = "receiving",F = "Request-Queue Progress: ",E = " threw an error: ",D = "__active",C = "io.maxrequests",B = "_applyEnabled",A = "queued",z = "sending",y = "completed",x = "ms > ",w = "failed",s = "Request ",t = "qx.io.remote.RequestQueue",q = "timeout",r = "/",o = "aborted",p = "ActiveCount: ",m = "_onaborted",n = "Integer",u = "qx.debug",v = "qx.debug.io.remote";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * Handles scheduling of requests to be sent to a server.
   *
   * This class is a singleton and is used by qx.io.remote.Request to schedule its
   * requests. It should not be used directly.
   *
   * @internal
   */
  qx.Class.define(t, {
    type : d,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__queue = [];
      this.__active = [];
      this.__totalRequests = 0;
      // timeout handling
      this.__timer = new qx.event.Timer(500);
      this.__timer.addListener(b, this._oninterval, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Indicates whether queue is enabled or not.
       */
      enabled : {
        init : true,
        check : k,
        apply : B
      },
      /**
       * The maximum number of total requests.
       */
      maxTotalRequests : {
        check : n,
        nullable : true
      },
      /**
       * Maximum number of parallel requests.
       */
      maxConcurrentRequests : {
        check : n,
        init : qx.core.Environment.get(C)
      },
      /**
       * Default timeout for remote requests in milliseconds.
       */
      defaultTimeout : {
        check : n,
        init : 5000
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __queue : null,
      __active : null,
      __totalRequests : null,
      __timer : null,
      /*
      ---------------------------------------------------------------------------
        QUEUE HANDLING
      ---------------------------------------------------------------------------
      */
      /**
       * Get a list of queued requests
       *
       * @return {Request[]} The list of queued requests
       */
      getRequestQueue : function(){

        return this.__queue;
      },
      /**
       * Get a list of active queued requests, each one wrapped in an instance of
       * {@link qx.io.remote.Exchange}
       *
       * @return {Exchange[]} The list of active queued requests, each one
       *   wrapped in an instance of {@link qx.io.remote.Exchange}
       */
      getActiveQueue : function(){

        return this.__active;
      },
      /**
       * Generates debug output
       */
      _debug : function(){

        if(qx.core.Environment.get(u)){

          if(qx.core.Environment.get(v)){

            // Debug output
            var G = this.__active.length + r + (this.__queue.length + this.__active.length);
            this.debug(f + G);
            window.status = F + G;
          };
        };
      },
      /**
       * Checks the queue if any request is left to send and uses the transport
       * layer to send the open requests.
       * This method calls itself until every request in the queue is send.
       *
       * @return {void}
       */
      _check : function(){

        // Debug output
        this._debug();
        // Check queues and stop timer if not needed anymore
        if(this.__active.length == 0 && this.__queue.length == 0){

          this.__timer.stop();
        };
        // Checking if enabled
        if(!this.getEnabled()){

          return;
        };
        // Checking active queue fill
        if(this.__queue.length == 0 || (this.__queue[0].isAsynchronous() && this.__active.length >= this.getMaxConcurrentRequests())){

          return;
        };
        // Checking number of total requests
        if(this.getMaxTotalRequests() != null && this.__totalRequests >= this.getMaxTotalRequests()){

          return;
        };
        var H = this.__queue.shift();
        var I = new qx.io.remote.Exchange(H);
        // Increment counter
        this.__totalRequests++;
        // Add to active queue
        this.__active.push(I);
        // Debug output
        this._debug();
        // Establish event connection between qx.io.remote.Exchange and me.
        I.addListener(z, this._onsending, this);
        I.addListener(a, this._onreceiving, this);
        I.addListener(y, this._oncompleted, this);
        I.addListener(o, this._oncompleted, this);
        I.addListener(q, this._oncompleted, this);
        I.addListener(w, this._oncompleted, this);
        // Store send timestamp
        I._start = (new Date).valueOf();
        // Send
        I.send();
        // Retry
        if(this.__queue.length > 0){

          this._check();
        };
      },
      /**
       * Removes a transport object from the active queue and disposes the
       * transport object in order stop the request.
       *
       * @param vTransport {qx.io.remote.Exchange} Transport object
       * @return {void}
       */
      _remove : function(J){

        // Remove from active transports
        qx.lang.Array.remove(this.__active, J);
        // Dispose transport object
        J.dispose();
        // Check again
        this._check();
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLING
      ---------------------------------------------------------------------------
      */
      __activeCount : 0,
      /**
       * Listens for the "sending" event of the transport object and increases
       * the counter for active requests.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onsending : function(e){

        if(qx.core.Environment.get(u)){

          if(qx.core.Environment.get(v)){

            this.__activeCount++;
            e.getTarget()._counted = true;
            this.debug(p + this.__activeCount);
          };
        };
        e.getTarget().getRequest()._onsending(e);
      },
      /**
       * Listens for the "receiving" event of the transport object and delegate
       * the event to the current request object.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onreceiving : function(e){

        e.getTarget().getRequest()._onreceiving(e);
      },
      /**
       * Listens for the "completed" event of the transport object and decreases
       * the counter for active requests.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _oncompleted : function(e){

        if(qx.core.Environment.get(u)){

          if(qx.core.Environment.get(v)){

            if(e.getTarget()._counted){

              this.__activeCount--;
              this.debug(p + this.__activeCount);
            };
          };
        };
        // delegate the event to the handler method of the request depending
        // on the current type of the event ( completed|aborted|timeout|failed )
        var L = e.getTarget().getRequest();
        var K = l + e.getType();
        // remove the request from the queue,
        // keep local reference, see [BUG #4422]
        this._remove(e.getTarget());
        // It's possible that the request handler can fail, possibly due to
        // being sent garbage data. We want to prevent that from crashing
        // the program, but instead display an error.
        try{

          if(L[K]){

            L[K](e);
          };
        } catch(M) {

          this.error(s + L + h + K + E, M);
          // Issue an "aborted" event so the application gets notified.
          // If that too fails, or if there's no "aborted" handler, ignore it.
          try{

            if(L[m]){

              var event = qx.event.Registration.createEvent(o, qx.event.type.Event);
              L[m](event);
            };
          } catch(N) {
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        TIMEOUT HANDLING
      ---------------------------------------------------------------------------
      */
      /**
       * Listens for the "interval" event of the transport object and checks
       * if the active requests are timed out.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _oninterval : function(e){

        var U = this.__active;
        if(U.length == 0){

          this.__timer.stop();
          return;
        };
        var P = (new Date).valueOf();
        var S;
        var Q;
        var T = this.getDefaultTimeout();
        var R;
        var O;
        for(var i = U.length - 1;i >= 0;i--){

          S = U[i];
          Q = S.getRequest();
          if(Q.isAsynchronous()){

            R = Q.getTimeout();
            // if timer is disabled...
            if(R == 0){

              // then ignore it.
              continue;
            };
            if(R == null){

              R = T;
            };
            O = P - S._start;
            if(O > R){

              this.warn(c + S.toHashCode());
              this.warn(O + x + R + g);
              S.timeout();
            };
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        MODIFIERS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyEnabled : function(V, W){

        if(V){

          this._check();
        };
        this.__timer.setEnabled(V);
      },
      /*
      ---------------------------------------------------------------------------
        CORE METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Add the request to the pending requests queue.
       *
       * @param vRequest {var} The request
       * @return {void}
       */
      add : function(X){

        X.setState(A);
        if(X.isAsynchronous()){

          this.__queue.push(X);
        } else {

          this.__queue.unshift(X);
        };
        this._check();
        if(this.getEnabled()){

          this.__timer.start();
        };
      },
      /**
       * Remove the request from the pending requests queue.
       *
       *  The underlying transport of the request is forced into the aborted
       *  state ("aborted") and listeners of the "aborted"
       *  signal are notified about the event. If the request isn't in the
       *  pending requests queue, this method is a noop.
       *
       * @param vRequest {var} The request
       * @return {void}
       */
      abort : function(Y){

        var ba = Y.getTransport();
        if(ba){

          ba.abort();
        } else if(qx.lang.Array.contains(this.__queue, Y)){

          qx.lang.Array.remove(this.__queue, Y);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeArray(D);
      this._disposeObjects(j);
      this.__queue = null;
    }
  });
})();
(function(){

  var bu = "Precondition failed",bt = "Moved temporarily",bs = "qx.io.remote.Exchange",br = "Bad gateway",bq = "Gone",bp = "qx.io.remote.transport.Script",bo = "No supported transport types were found!",bn = "Unauthorized",bm = "Possibly due to application URL using 'file:' protocol?",bl = "Altered State: ",ba = "_applyState",Y = "Failed with typical HTTP statuscode: ",X = "Abort: implementation ",W = "Use proxy",V = "Conflict",U = "Connection closed by server",T = "Gateway time-out",S = "qx.io.remote.Request",R = "], ",Q = "qx.io.remote.transport.XmlHttp",bB = "qx.io.remote.transport.Abstract",bC = "There is no transport implementation available to handle this request: ",bz = "Server timeout",bA = "Multiple choices",bx = "Request handler throws error",by = "Not implemented",bv = "Failed with MSHTML specific HTTP statuscode: ",bw = "Unknown status code: ",bD = "Failed with statuscode: 206 (Partial content while being complete!)",bE = "Moved permanently",be = "Not modified",bd = "Timeout: forcing state to timeout",bg = "State: ",bf = "created",bi = "Bad request",bh = "_applyImplementation",bk = ")",bj = " => ",bc = "Abort: forcing state to be aborted",bb = "Payment required",a = "Length required",b = "changeState",c = "MSHTML-specific HTTP status code",d = " (",f = "Timeout: implementation ",g = "Forbidden",h = " => failed",j = ", ",k = "file:",m = "Unknown status code",bI = "Out of resources",bH = "Possibly due to a cross-domain request?",bG = "Not available",bF = "See other",bM = "Partial content",bL = "HTTP version not supported",bK = "Using implementation: ",bJ = "Failed with statuscode: -1 at readyState ",bO = "Proxy authentication required",bN = "",B = "Request-URL too large",C = "Method not allowed",z = "Ok",A = "Server error",F = "Not found",G = "Not acceptable",D = "Request time-out",E = "No content",x = "qx.io.remote.transport.Iframe",y = "Request entity too large",u = "Unsupported media type",t = "undefined",w = "Please attach a request object first",v = " [",q = "&",p = "Unknown status code. ",s = "=",r = "qx.event.type.Event",o = "configured",n = "Connection dropped",L = "qx.io.remote.Response",M = "aborted",N = "timeout",O = "completed",H = "failed",I = "sending",J = "receiving",K = "qx.debug.io.remote",P = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Andreas Junghans (lucidcake)
  
  ************************************************************************ */
  /* ************************************************************************
  
  *#use(qx.io.remote.transport.XmlHttp)
  #use(qx.io.remote.transport.Iframe)
  #use(qx.io.remote.transport.Script)
  
  ************************************************************************ */
  /**
   * Transport layer to control which transport class (XmlHttp, Iframe or Script)
   * can be used.
   *
   * @internal
   */
  qx.Class.define(bs, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Constructor method.
     *
     * @param vRequest {qx.io.remote.Request} request object
     */
    construct : function(bP){

      qx.core.Object.call(this);
      this.setRequest(bP);
      bP.setTransport(this);
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired whenever a request is send */
      "sending" : r,
      /** Fired whenever a request is received */
      "receiving" : r,
      /** Fired whenever a request is completed */
      "completed" : L,
      /** Fired whenever a request is aborted */
      "aborted" : r,
      /** Fired whenever a request has failed */
      "failed" : L,
      /** Fired whenever a request has timed out */
      "timeout" : L
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /* ************************************************************************
         Class data, properties and methods
      ************************************************************************ */
      /*
      ---------------------------------------------------------------------------
        TRANSPORT TYPE HANDLING
      ---------------------------------------------------------------------------
      */
      /**
       * Predefined order of types.
       *
       * @internal
       */
      typesOrder : [Q, x, bp],
      /**
       * Marker for initialized types.
       *
       * @internal
       */
      typesReady : false,
      /**
       * Map of all available types.
       *
       * @internal
       */
      typesAvailable : {
      },
      /**
       * Map of all supported types.
       *
       * @internal
       */
      typesSupported : {
      },
      /**
       * Registers a transport type.
       * At the moment one out of XmlHttp, Iframe or Script.
       *
       * @param vClass {Object} transport class
       * @param vId {String} unique id
       * @return {void}
       */
      registerType : function(bQ, bR){

        qx.io.remote.Exchange.typesAvailable[bR] = bQ;
      },
      /**
       * Initializes the available type of transport classes and
       * checks for the supported ones.
       *
       * @return {void}
       * @throws {Error} an error if no supported transport type is available
       */
      initTypes : function(){

        if(qx.io.remote.Exchange.typesReady){

          return;
        };
        for(var bT in qx.io.remote.Exchange.typesAvailable){

          var bS = qx.io.remote.Exchange.typesAvailable[bT];
          if(bS.isSupported()){

            qx.io.remote.Exchange.typesSupported[bT] = bS;
          };
        };
        qx.io.remote.Exchange.typesReady = true;
        if(qx.lang.Object.isEmpty(qx.io.remote.Exchange.typesSupported)){

          throw new Error(bo);
        };
      },
      /**
       * Checks which supported transport class can handle the request with the
       * given content type.
       *
       * @param vImpl {Object} transport implementation
       * @param vNeeds {Map} requirements for the request like e.g. "cross-domain"
       * @param vResponseType {String} content type
       */
      canHandle : function(bU, bV, bW){

        if(!qx.lang.Array.contains(bU.handles.responseTypes, bW)){

          return false;
        };
        for(var bX in bV){

          if(!bU.handles[bX]){

            return false;
          };
        };
        return true;
      },
      /*
      ---------------------------------------------------------------------------
        MAPPING
      ---------------------------------------------------------------------------
      */
      /**
       *http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/0e6a34e4-f90c-489d-acff-cb44242fafc6.asp
       *
       * 0: UNINITIALIZED
       * The object has been created, but not initialized (the open method has not been called).
       *
       * 1: LOADING
       * The object has been created, but the send method has not been called.
       *
       * 2: LOADED
       * The send method has been called, but the status and headers are not yet available.
       *
       * 3: INTERACTIVE
       * Some data has been received. Calling the responseBody and responseText properties at this state to obtain partial results will return an error, because status and response headers are not fully available.
       *
       * 4: COMPLETED
       * All the data has been received, and the complete data is available in the
       *
       * @internal
       */
      _nativeMap : {
        '0' : bf,
        '1' : o,
        '2' : I,
        '3' : J,
        '4' : O
      },
      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */
      /**
       * Called from the transport class when a request was completed.
       *
       * @param vStatusCode {Integer} status code of the request
       * @param vReadyState {String} readystate of the request
       * @param vIsLocal {Boolean} whether the request is a local one
       * @return {Boolean | var} Returns boolean value depending on the status code
       */
      wasSuccessful : function(bY, ca, cb){

        if(cb){

          switch(bY){case null:case 0:
          return true;case -1:
          // Not Available (OK for readystates: MSXML<4=1-3, MSXML>3=1-2, Gecko=1)
          return ca < 4;default:
          // at least older versions of Safari don't set the status code for local file access
          return typeof bY === t;};
        } else {

          switch(bY){case -1:
          // Not Available (OK for readystates: MSXML<4=1-3, MSXML>3=1-2, Gecko=1)
          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K) && ca > 3){

              qx.log.Logger.debug(this, bJ + ca);
            };
          };
          return ca < 4;case 200:// OK
          case 304:
          // Not Modified
          return true;case 201:// Created
          case 202:// Accepted
          case 203:// Non-Authoritative Information
          case 204:// No Content
          case 205:
          // Reset Content
          return true;case 206:
          // Partial Content
          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K) && ca === 4){

              qx.log.Logger.debug(this, bD);
            };
          };
          return ca !== 4;case 300:// Multiple Choices
          case 301:// Moved Permanently
          case 302:// Moved Temporarily
          case 303:// See Other
          case 305:// Use Proxy
          case 400:// Bad Request
          case 401:// Unauthorized
          case 402:// Payment Required
          case 403:// Forbidden
          case 404:// Not Found
          case 405:// Method Not Allowed
          case 406:// Not Acceptable
          case 407:// Proxy Authentication Required
          case 408:// Request Time-Out
          case 409:// Conflict
          case 410:// Gone
          case 411:// Length Required
          case 412:// Precondition Failed
          case 413:// Request Entity Too Large
          case 414:// Request-URL Too Large
          case 415:// Unsupported Media Type
          case 500:// Server Error
          case 501:// Not Implemented
          case 502:// Bad Gateway
          case 503:// Out of Resources
          case 504:// Gateway Time-Out
          case 505:
          // HTTP Version not supported
          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K)){

              qx.log.Logger.debug(this, Y + bY);
            };
          };
          return false;// The following case labels are wininet.dll error codes that may
          // be encountered.
          // Server timeout
          case 12002:// Internet Name Not Resolved
          case 12007:// 12029 to 12031 correspond to dropped connections.
          case 12029:case 12030:case 12031:// Connection closed by server.
          case 12152:// See above comments for variable status.
          case 13030:
          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K)){

              qx.log.Logger.debug(this, bv + bY);
            };
          };
          return false;default:
          // Handle all 20x status codes as OK as defined in the corresponding RFC
          // http://www.w3.org/Protocols/rfc2616/rfc2616.html
          if(bY > 206 && bY < 300){

            return true;
          };
          qx.log.Logger.debug(this, bw + bY + d + ca + bk);
          return false;};
        };
      },
      /**
       * Status code to string conversion
       *
       * @param vStatusCode {Integer} request status code
       * @return {string} String presentation of status code
       */
      statusCodeToString : function(cc){

        switch(cc){case -1:
        return bG;case 0:
        // Attempt to generate a potentially meaningful error.
        // Get the current URL
        var cd = window.location.href;
        // Are we on a local page obtained via file: protocol?
        if(qx.lang.String.startsWith(cd.toLowerCase(), k)){

          // Yup. Can't issue remote requests from here.
          return (p + bm);
        } else {

          return (p + bH);
        };
        break;case 200:
        return z;case 304:
        return be;case 206:
        return bM;case 204:
        return E;case 300:
        return bA;case 301:
        return bE;case 302:
        return bt;case 303:
        return bF;case 305:
        return W;case 400:
        return bi;case 401:
        return bn;case 402:
        return bb;case 403:
        return g;case 404:
        return F;case 405:
        return C;case 406:
        return G;case 407:
        return bO;case 408:
        return D;case 409:
        return V;case 410:
        return bq;case 411:
        return a;case 412:
        return bu;case 413:
        return y;case 414:
        return B;case 415:
        return u;case 500:
        return A;case 501:
        return by;case 502:
        return br;case 503:
        return bI;case 504:
        return T;case 505:
        return bL;case 12002:
        return bz;case 12029:
        return n;case 12030:
        return n;case 12031:
        return n;case 12152:
        return U;case 13030:
        return c;default:
        return m;};
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Set the request to send with this transport. */
      request : {
        check : S,
        nullable : true
      },
      /**
       * Set the implementation to use to send the request with.
       *
       *  The implementation should be a subclass of qx.io.remote.transport.Abstract and
       *  must implement all methods in the transport API.
       */
      implementation : {
        check : bB,
        nullable : true,
        apply : bh
      },
      /** Current state of the transport layer. */
      state : {
        check : [o, I, J, O, M, N, H],
        init : o,
        event : b,
        apply : ba
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        CORE METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Sends the request.
       *
       * @return {var | Boolean} Returns true if the request was sent.
       */
      send : function(){

        var ch = this.getRequest();
        if(!ch){

          return this.error(w);
        };
        qx.io.remote.Exchange.initTypes();
        var cf = qx.io.remote.Exchange.typesOrder;
        var ce = qx.io.remote.Exchange.typesSupported;
        // Mapping settings to contenttype and needs to check later
        // if the selected transport implementation can handle
        // fulfill these requirements.
        var cj = ch.getResponseType();
        var ck = {
        };
        if(ch.getAsynchronous()){

          ck.asynchronous = true;
        } else {

          ck.synchronous = true;
        };
        if(ch.getCrossDomain()){

          ck.crossDomain = true;
        };
        if(ch.getFileUpload()){

          ck.fileUpload = true;
        };
        // See if there are any programtic form fields requested
        for(var ci in ch.getFormFields()){

          // There are.
          ck.programaticFormFields = true;
          // No need to search further
          break;
        };
        var cl,cg;
        for(var i = 0,l = cf.length;i < l;i++){

          cl = ce[cf[i]];
          if(cl){

            if(!qx.io.remote.Exchange.canHandle(cl, ck, cj)){

              continue;
            };
            try{

              if(qx.core.Environment.get(P)){

                if(qx.core.Environment.get(K)){

                  this.debug(bK + cl.classname);
                };
              };
              cg = new cl;
              this.setImplementation(cg);
              cg.setUseBasicHttpAuth(ch.getUseBasicHttpAuth());
              cg.send();
              return true;
            } catch(cm) {

              this.error(bx);
              this.error(cm);
              return;
            };
          };
        };
        this.error(bC + ch);
      },
      /**
       * Force the transport into the aborted ("aborted")
       *  state.
       *
       * @return {void}
       */
      abort : function(){

        var cn = this.getImplementation();
        if(cn){

          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K)){

              this.debug(X + cn.toHashCode());
            };
          };
          cn.abort();
        } else {

          if(qx.core.Environment.get(P)){

            if(qx.core.Environment.get(K)){

              this.debug(bc);
            };
          };
          this.setState(M);
        };
      },
      /**
       * Force the transport into the timeout state.
       *
       * @return {void}
       */
      timeout : function(){

        var cq = this.getImplementation();
        if(cq){

          var cp = bN;
          for(var co in cq.getParameters()){

            cp += q + co + s + cq.getParameters()[co];
          };
          this.warn(f + cq.toHashCode() + j + cq.getUrl() + v + cq.getMethod() + R + cp);
          cq.timeout();
        } else {

          this.warn(bd);
          this.setState(N);
        };
        // Disable future timeouts in case user handler blocks
        this.__disableRequestTimeout();
      },
      /*
      ---------------------------------------------------------------------------
        PRIVATES
      ---------------------------------------------------------------------------
      */
      /**
       * Disables the timer of the request to prevent that the timer is expiring
       * even if the user handler (e.g. "completed") was already called.
       *
       * @return {void}
       */
      __disableRequestTimeout : function(){

        var cr = this.getRequest();
        if(cr){

          cr.setTimeout(0);
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for "sending" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onsending : function(e){

        this.setState(I);
      },
      /**
       * Event listener for "receiving" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onreceiving : function(e){

        this.setState(J);
      },
      /**
       * Event listener for "completed" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _oncompleted : function(e){

        this.setState(O);
      },
      /**
       * Event listener for "abort" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onabort : function(e){

        this.setState(M);
      },
      /**
       * Event listener for "failed" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _onfailed : function(e){

        this.setState(H);
      },
      /**
       * Event listener for "timeout" event.
       *
       * @param e {qx.event.type.Event} event object
       * @return {void}
       */
      _ontimeout : function(e){

        this.setState(N);
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      /**
       * Apply method for the implementation property.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyImplementation : function(cs, ct){

        if(ct){

          ct.removeListener(I, this._onsending, this);
          ct.removeListener(J, this._onreceiving, this);
          ct.removeListener(O, this._oncompleted, this);
          ct.removeListener(M, this._onabort, this);
          ct.removeListener(N, this._ontimeout, this);
          ct.removeListener(H, this._onfailed, this);
        };
        if(cs){

          var cv = this.getRequest();
          cs.setUrl(cv.getUrl());
          cs.setMethod(cv.getMethod());
          cs.setAsynchronous(cv.getAsynchronous());
          cs.setUsername(cv.getUsername());
          cs.setPassword(cv.getPassword());
          cs.setParameters(cv.getParameters(false));
          cs.setFormFields(cv.getFormFields());
          cs.setRequestHeaders(cv.getRequestHeaders());
          // Set the parseJson property which is currently only supported for XmlHttp transport
          // (which is the only transport supporting JSON parsing so far).
          if(cs instanceof qx.io.remote.transport.XmlHttp){

            cs.setParseJson(cv.getParseJson());
          };
          var cy = cv.getData();
          if(cy === null){

            var cz = cv.getParameters(true);
            var cx = [];
            for(var cu in cz){

              var cw = cz[cu];
              if(cw instanceof Array){

                for(var i = 0;i < cw.length;i++){

                  cx.push(encodeURIComponent(cu) + s + encodeURIComponent(cw[i]));
                };
              } else {

                cx.push(encodeURIComponent(cu) + s + encodeURIComponent(cw));
              };
            };
            if(cx.length > 0){

              cs.setData(cx.join(q));
            };
          } else {

            cs.setData(cy);
          };
          cs.setResponseType(cv.getResponseType());
          cs.addListener(I, this._onsending, this);
          cs.addListener(J, this._onreceiving, this);
          cs.addListener(O, this._oncompleted, this);
          cs.addListener(M, this._onabort, this);
          cs.addListener(N, this._ontimeout, this);
          cs.addListener(H, this._onfailed, this);
        };
      },
      /**
       * Apply method for the state property.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyState : function(cA, cB){

        if(qx.core.Environment.get(P)){

          if(qx.core.Environment.get(K)){

            this.debug(bg + cB + bj + cA);
          };
        };
        switch(cA){case I:
        this.fireEvent(I);
        break;case J:
        this.fireEvent(J);
        break;case O:case M:case N:case H:
        var cD = this.getImplementation();
        if(!cD){

          // implementation has already been disposed
          break;
        };
        // Disable future timeouts in case user handler blocks
        this.__disableRequestTimeout();
        if(this.hasListener(cA)){

          var cE = qx.event.Registration.createEvent(cA, qx.io.remote.Response);
          if(cA == O){

            var cC = cD.getResponseContent();
            cE.setContent(cC);
            /*
             * Was there acceptable content?  This might occur, for example, if
             * the web server was shut down unexpectedly and thus the connection
             * closed with no data having been sent.
             */
            if(cC === null){

              // Nope.  Change COMPLETED to FAILED.
              if(qx.core.Environment.get(P)){

                if(qx.core.Environment.get(K)){

                  this.debug(bl + cA + h);
                };
              };
              cA = H;
            };
          } else if(cA == H){

            cE.setContent(cD.getResponseContent());
          };
          cE.setStatusCode(cD.getStatusCode());
          cE.setResponseHeaders(cD.getResponseHeaders());
          this.dispatchEvent(cE);
        };
        // Disconnect and dispose implementation
        this.setImplementation(null);
        cD.dispose();
        // Fire event to listeners
        //this.fireDataEvent(vEventType, vResponse);
        break;};
      }
    },
    /*
    *****************************************************************************
       ENVIRONMENT SETTINGS
    *****************************************************************************
    */
    environment : {
      "qx.debug.io.remote" : false,
      "qx.debug.io.remote.data" : false
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      var cF = this.getImplementation();
      if(cF){

        this.setImplementation(null);
        cF.dispose();
      };
      this.setRequest(null);
    }
  });
})();
(function(){

  var j = "setRequestHeader is abstract",i = "getFetchedLength is abstract",h = "Timeout...",g = "getStatusText is abstract",f = "getStatusCode is abstract",e = "GET",d = "Aborting...",c = "_applyState",b = "changeState",a = "getResponseHeader is abstract",F = "getResponseHeaders is abstract",E = "Failed...",D = "getResponseText is abstract",C = "abstract",B = "qx.io.remote.transport.Abstract",A = "State: ",z = "getResponseXml is abstract",y = "send is abstract",x = "Boolean",w = "Object",q = "receiving",r = "sending",o = "completed",p = "configured",m = "aborted",n = "qx.debug",k = "failed",l = "qx.debug.io.remote",s = "created",t = "timeout",v = "String",u = "qx.event.type.Event";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Abstract for all transport implementations
   */
  qx.Class.define(B, {
    type : C,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.setRequestHeaders({
      });
      this.setParameters({
      });
      this.setFormFields({
      });
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Event when a request is created */
      "created" : u,
      /** Event when a request is configured */
      "configured" : u,
      /** Event when a request is send */
      "sending" : u,
      /** Event when a request is received */
      "receiving" : u,
      /** Event when a request is completed */
      "completed" : u,
      /** Event when a request is aborted */
      "aborted" : u,
      /** Event when a request has failed */
      "failed" : u,
      /** Event when a request has timed out */
      "timeout" : u
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Target url to issue the request to */
      url : {
        check : v,
        nullable : true
      },
      /** Determines what type of request to issue */
      method : {
        check : v,
        nullable : true,
        init : e
      },
      /** Set the request to asynchronous */
      asynchronous : {
        check : x,
        nullable : true,
        init : true
      },
      /** Set the data to be sent via this request */
      data : {
        check : v,
        nullable : true
      },
      /** Username to use for HTTP authentication */
      username : {
        check : v,
        nullable : true
      },
      /** Password to use for HTTP authentication */
      password : {
        check : v,
        nullable : true
      },
      /** The state of the current request */
      state : {
        check : [s, p, r, q, o, m, t, k],
        init : s,
        event : b,
        apply : c
      },
      /** Request headers */
      requestHeaders : {
        check : w,
        nullable : true
      },
      /** Request parameters to send. */
      parameters : {
        check : w,
        nullable : true
      },
      /** Request form fields to send. */
      formFields : {
        check : w,
        nullable : true
      },
      /** Response Type */
      responseType : {
        check : v,
        nullable : true
      },
      /** Use Basic HTTP Authentication */
      useBasicHttpAuth : {
        check : x,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Sending a request.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {void}
       * @throws the abstract function warning.
       */
      send : function(){

        throw new Error(y);
      },
      /**
       * Force the transport into the aborted state ("aborted").
       *
       * Listeners of the "aborted" signal are notified about the event.
       *
       * @return {void}
       */
      abort : function(){

        if(qx.core.Environment.get(n)){

          if(qx.core.Environment.get(l)){

            this.warn(d);
          };
        };
        this.setState(m);
      },
      /**
       * Force the transport into the timeout state ("timeout").
       *
       * Listeners of the "timeout" signal are notified about the event.
       *
       * @return {void}
       */
      timeout : function(){

        if(qx.core.Environment.get(n)){

          if(qx.core.Environment.get(l)){

            this.warn(h);
          };
        };
        this.setState(t);
      },
      /**
       * Force the transport into the failed state ("failed").
       *
       * Listeners of the "failed" signal are notified about the event.
       *
       * @return {void}
       */
      failed : function(){

        if(qx.core.Environment.get(n)){

          if(qx.core.Environment.get(l)){

            this.warn(E);
          };
        };
        this.setState(k);
      },
      /*
      ---------------------------------------------------------------------------
        REQUEST HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Add a request header to this transports qx.io.remote.Request.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @param vLabel {String} Request header name
       * @param vValue {var} Value for the header
       * @return {void}
       * @throws the abstract function warning.
       */
      setRequestHeader : function(G, H){

        throw new Error(j);
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the request header of the request.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @param vLabel {String} Response header name
       * @return {Object}
       * @throws the abstract function warning.
       */
      getResponseHeader : function(I){

        throw new Error(a);
      },
      /**
       * Provides an hash of all response headers.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {Object}
       * @throws the abstract function warning.
       */
      getResponseHeaders : function(){

        throw new Error(F);
      },
      /*
      ---------------------------------------------------------------------------
        STATUS SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current status code of the request if available or -1 if not.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {Integer}
       * @throws the abstract function warning.
       */
      getStatusCode : function(){

        throw new Error(f);
      },
      /**
       * Provides the status text for the current request if available and null otherwise.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {String}
       * @throws the abstract function warning.
       */
      getStatusText : function(){

        throw new Error(g);
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE DATA SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Provides the response text from the request when available and null otherwise.
       * By passing true as the "partial" parameter of this method, incomplete data will
       * be made available to the caller.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {String}
       * @throws the abstract function warning.
       */
      getResponseText : function(){

        throw new Error(D);
      },
      /**
       * Provides the XML provided by the response if any and null otherwise.
       * By passing true as the "partial" parameter of this method, incomplete data will
       * be made available to the caller.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {Object}
       * @throws the abstract function warning.
       */
      getResponseXml : function(){

        throw new Error(z);
      },
      /**
       * Returns the length of the content as fetched thus far.
       *
       * This method is virtual and concrete subclasses are supposed to
       * implement it.
       *
       * @abstract
       * @return {Integer}
       * @throws the abstract function warning.
       */
      getFetchedLength : function(){

        throw new Error(i);
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      /**
       * Apply method for "state" property. For each state value a corresponding
       * event is fired to inform the listeners.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyState : function(J, K){

        if(qx.core.Environment.get(n)){

          if(qx.core.Environment.get(l)){

            this.debug(A + J);
          };
        };
        switch(J){case s:
        this.fireEvent(s);
        break;case p:
        this.fireEvent(p);
        break;case r:
        this.fireEvent(r);
        break;case q:
        this.fireEvent(q);
        break;case o:
        this.fireEvent(o);
        break;case m:
        this.fireEvent(m);
        break;case k:
        this.fireEvent(k);
        break;case t:
        this.fireEvent(t);
        break;};
        return true;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.setRequestHeaders(null);
      this.setParameters(null);
      this.setFormFields(null);
    }
  });
})();
(function(){

  var l = ")!",k = "gecko",j = "frame_",h = "Could not execute json: (",g = "aborted",f = "No valid responseType specified (",d = "Returning content for responseType: ",c = "pre",b = "javascript:void(0)",a = "sending",S = "Transfer not complete, ignoring content!",R = "form",Q = "Could not execute javascript: (",P = "failed",O = "mshtml",N = "Ignore Ready State Change",M = "form_",L = "opera",K = "timeout",J = "qx/static/blank.gif",s = "application/xml",t = "application/json",q = "text/html",r = ")",o = "textarea",p = "_data_",m = "load",n = "text/plain",u = "text/javascript",v = "readystatechange",B = "completed",A = "qx.debug.io.remote",D = "?",C = "qx.io.remote.transport.Iframe",F = "none",E = "display",x = "",I = "engine.name",H = "&",G = "=",w = "Response: ",y = "qx.debug.io.remote.data",z = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Andreas Junghans (lucidcake)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #asset(qx/static/blank.gif)
  
  ************************************************************************ */
  /**
   * Transports requests to a server using an IFRAME.
   *
   * This class should not be used directly by client programmers.
   */
  qx.Class.define(C, {
    extend : qx.io.remote.transport.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.io.remote.transport.Abstract.call(this);
      // Unique identifiers for iframe and form
      var T = (new Date).valueOf();
      var U = j + T;
      var V = M + T;
      // This is to prevent the "mixed secure and insecure content" warning in IE with https
      var W;
      if((qx.core.Environment.get(I) == O)){

        W = b;
      };
      // Create a hidden iframe.
      // The purpose of the iframe is to receive data coming back from the server (see below).
      this.__frame = qx.bom.Iframe.create({
        id : U,
        name : U,
        src : W
      });
      qx.bom.element.Style.set(this.__frame, E, F);
      // Create form element with textarea as conduit for request data.
      // The target of the form is the hidden iframe, which means the response
      // coming back from the server is written into the iframe.
      this.__form = qx.dom.Element.create(R, {
        id : V,
        name : V,
        target : U
      });
      qx.bom.element.Style.set(this.__form, E, F);
      qx.dom.Element.insertEnd(this.__form, qx.dom.Node.getBodyElement(document));
      this.__data = qx.dom.Element.create(o, {
        id : p,
        name : p
      });
      qx.dom.Element.insertEnd(this.__data, this.__form);
      // Finally, attach iframe to DOM and add listeners
      qx.dom.Element.insertEnd(this.__frame, qx.dom.Node.getBodyElement(document));
      qx.event.Registration.addListener(this.__frame, m, this._onload, this);
      // qx.event.handler.Iframe does not yet support the readystatechange event
      this.__onreadystatechangeWrapper = qx.lang.Function.listener(this._onreadystatechange, this);
      qx.bom.Event.addNativeListener(this.__frame, v, this.__onreadystatechangeWrapper);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Capabilities of this transport type.
       *
       * @internal
       */
      handles : {
        synchronous : false,
        asynchronous : true,
        crossDomain : false,
        fileUpload : true,
        programaticFormFields : true,
        responseTypes : [n, u, t, s, q]
      },
      /**
       * Returns always true, because iframe transport is supported by all browsers.
       *
       * @return {Boolean}
       */
      isSupported : function(){

        return true;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */
      /**
       * For reference:
       * http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/readyState_1.asp
       *
       * @internal
       */
      _numericMap : {
        "uninitialized" : 1,
        "loading" : 2,
        "loaded" : 2,
        "interactive" : 3,
        "complete" : 4
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __data : null,
      __lastReadyState : 0,
      __form : null,
      __frame : null,
      __onreadystatechangeWrapper : null,
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Sends a request with the use of a form.
       *
       * @return {void}
       */
      send : function(){

        var Y = this.getMethod();
        var bb = this.getUrl();
        // --------------------------------------
        //   Adding parameters
        // --------------------------------------
        var bf = this.getParameters(false);
        var be = [];
        for(var ba in bf){

          var bc = bf[ba];
          if(bc instanceof Array){

            for(var i = 0;i < bc.length;i++){

              be.push(encodeURIComponent(ba) + G + encodeURIComponent(bc[i]));
            };
          } else {

            be.push(encodeURIComponent(ba) + G + encodeURIComponent(bc));
          };
        };
        if(be.length > 0){

          bb += (bb.indexOf(D) >= 0 ? H : D) + be.join(H);
        };
        // --------------------------------------------------------
        //   Adding data parameters (if no data is already present)
        // --------------------------------------------------------
        if(this.getData() === null){

          var bf = this.getParameters(true);
          var be = [];
          for(var ba in bf){

            var bc = bf[ba];
            if(bc instanceof Array){

              for(var i = 0;i < bc.length;i++){

                be.push(encodeURIComponent(ba) + G + encodeURIComponent(bc[i]));
              };
            } else {

              be.push(encodeURIComponent(ba) + G + encodeURIComponent(bc));
            };
          };
          if(be.length > 0){

            this.setData(be.join(H));
          };
        };
        // --------------------------------------
        //   Adding form fields
        // --------------------------------------
        var X = this.getFormFields();
        for(var ba in X){

          var bd = document.createElement(o);
          bd.name = ba;
          bd.appendChild(document.createTextNode(X[ba]));
          this.__form.appendChild(bd);
        };
        // --------------------------------------
        //   Preparing form
        // --------------------------------------
        this.__form.action = bb;
        this.__form.method = Y;
        // --------------------------------------
        //   Sending data
        // --------------------------------------
        this.__data.appendChild(document.createTextNode(this.getData()));
        this.__form.submit();
        this.setState(a);
      },
      /**
       * Converting complete state to numeric value and update state property
       *
       * @signature function(e)
       * @param e {qx.event.type.Event} event object
       */
      _onload : qx.event.GlobalError.observeMethod(function(e){

        // Timing-issue in Opera
        // Do not switch state to complete in case load event fires before content
        // of iframe was updated
        if(qx.core.Environment.get(I) == L && this.getIframeHtmlContent() == x){

          return;
        };
        if(this.__form.src){

          return;
        };
        this._switchReadyState(qx.io.remote.transport.Iframe._numericMap.complete);
      }),
      /**
       * Converting named readyState to numeric value and update state property
       *
       * @signature function(e)
       * @param e {qx.event.type.Event} event object
       */
      _onreadystatechange : qx.event.GlobalError.observeMethod(function(e){

        this._switchReadyState(qx.io.remote.transport.Iframe._numericMap[this.__frame.readyState]);
      }),
      /**
       * Switches the readystate by setting the internal state.
       *
       * @param vReadyState {String} readystate value
       */
      _switchReadyState : function(bg){

        // Ignoring already stopped requests
        switch(this.getState()){case B:case g:case P:case K:
        this.warn(N);
        return;};
        // Updating internal state
        while(this.__lastReadyState < bg){

          this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
        };
      },
      /*
      ---------------------------------------------------------------------------
        REQUEST HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Sets a request header with the given value.
       *
       * This method is not implemented at the moment.
       *
       * @param vLabel {String} request header name
       * @param vValue {var} request header value
       * @return {void}
       */
      setRequestHeader : function(bh, bi){
      },
      // TODO
      // throw new Error("setRequestHeader is abstract");
      /*
      ---------------------------------------------------------------------------
        RESPONSE HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the value of the given response header.
       *
       * This method is not implemented at the moment and returns always "null".
       *
       * @param vLabel {String} Response header name
       * @return {null} Returns null
       */
      getResponseHeader : function(bj){

        return null;
      },
      /**
       * Provides an hash of all response headers.
       *
       * This method is not implemented at the moment and returns an empty map.
       *
       * @return {Map} empty map
       */
      getResponseHeaders : function(){

        return {
        };
      },
      /*
      ---------------------------------------------------------------------------
        STATUS SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current status code of the request if available or -1 if not.
       * This method needs implementation (returns always 200).
       *
       * @return {Integer} status code
       */
      getStatusCode : function(){

        return 200;
      },
      /**
       * Provides the status text for the current request if available and null otherwise.
       * This method needs implementation (returns always an empty string)
       *
       * @return {String} status code text
       */
      getStatusText : function(){

        return x;
      },
      /*
      ---------------------------------------------------------------------------
        FRAME UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the DOM window object of the used iframe.
       *
       * @return {Object} DOM window object
       */
      getIframeWindow : function(){

        return qx.bom.Iframe.getWindow(this.__frame);
      },
      /**
       * Returns the document node of the used iframe.
       *
       * @return {Object} document node
       */
      getIframeDocument : function(){

        return qx.bom.Iframe.getDocument(this.__frame);
      },
      /**
       * Returns the body node of the used iframe.
       *
       * @return {Object} body node
       */
      getIframeBody : function(){

        return qx.bom.Iframe.getBody(this.__frame);
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE DATA SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the iframe content (innerHTML) as text.
       *
       * @return {String} iframe content as text
       */
      getIframeTextContent : function(){

        var bk = this.getIframeBody();
        if(!bk){

          return null;
        };
        if(!bk.firstChild){

          return x;
        };
        // Mshtml returns the content inside a PRE
        // element if we use plain text
        if(bk.firstChild.tagName && bk.firstChild.tagName.toLowerCase() == c){

          return bk.firstChild.innerHTML;
        } else {

          return bk.innerHTML;
        };
      },
      /**
       * Returns the iframe content as HTML.
       *
       * @return {String} iframe content as HTML
       */
      getIframeHtmlContent : function(){

        var bl = this.getIframeBody();
        return bl ? bl.innerHTML : null;
      },
      /**
       * Returns the length of the content as fetched thus far.
       * This method needs implementation (returns always 0).
       *
       * @return {Integer} Returns 0
       */
      getFetchedLength : function(){

        return 0;
      },
      /**
       * Returns the content of the response
       *
       * @return {null | String} null or text of the response (=iframe content).
       */
      getResponseContent : function(){

        if(this.getState() !== B){

          if(qx.core.Environment.get(z)){

            if(qx.core.Environment.get(A)){

              this.warn(S);
            };
          };
          return null;
        };
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(A)){

            this.debug(d + this.getResponseType());
          };
        };
        var bm = this.getIframeTextContent();
        switch(this.getResponseType()){case n:
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(y)){

            this.debug(w + this._responseContent);
          };
        };
        return bm;
        break;case q:
        bm = this.getIframeHtmlContent();
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(y)){

            this.debug(w + this._responseContent);
          };
        };
        return bm;
        break;case t:
        bm = this.getIframeHtmlContent();
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(y)){

            this.debug(w + this._responseContent);
          };
        };
        try{

          return bm && bm.length > 0 ? qx.lang.Json.parse(bm) : null;
        } catch(bn) {

          return this.error(h + bm + r, bn);
        };case u:
        bm = this.getIframeHtmlContent();
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(y)){

            this.debug(w + this._responseContent);
          };
        };
        try{

          return bm && bm.length > 0 ? window.eval(bm) : null;
        } catch(bo) {

          return this.error(Q + bm + r, bo);
        };case s:
        bm = this.getIframeDocument();
        if(qx.core.Environment.get(z)){

          if(qx.core.Environment.get(y)){

            this.debug(w + this._responseContent);
          };
        };
        return bm;default:
        this.warn(f + this.getResponseType() + l);
        return null;};
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(){

      // basic registration to qx.io.remote.Exchange
      // the real availability check (activeX stuff and so on) follows at the first real request
      qx.io.remote.Exchange.registerType(qx.io.remote.transport.Iframe, C);
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__frame){

        qx.event.Registration.removeListener(this.__frame, m, this._onload, this);
        qx.bom.Event.removeNativeListener(this.__frame, v, this.__onreadystatechangeWrapper);
        // Reset source to a blank image for gecko
        // Otherwise it will switch into a load-without-end behaviour
        if((qx.core.Environment.get(I) == k)){

          this.__frame.src = qx.util.ResourceManager.getInstance().toUri(J);
        };
        // Finally, remove element node
        qx.dom.Element.remove(this.__frame);
      };
      if(this.__form){

        qx.dom.Element.remove(this.__form);
      };
      this.__frame = this.__form = this.__data = null;
    }
  });
})();
(function(){

  var d = "qx.event.handler.Iframe",c = "load",b = "iframe",a = "navigate";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This handler provides a "load" event for iframes
   */
  qx.Class.define(d, {
    extend : qx.core.Object,
    implement : qx.event.IEventHandler,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} Priority of this handler */
      PRIORITY : qx.event.Registration.PRIORITY_NORMAL,
      /** {Map} Supported event types */
      SUPPORTED_TYPES : {
        load : 1,
        navigate : 1
      },
      /** {Integer} Which target check to use */
      TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,
      /** {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE : false,
      /**
       * Internal function called by iframes created using {@link qx.bom.Iframe}.
       *
       * @signature function(target)
       * @internal
       * @param target {Element} DOM element which is the target of this event
       */
      onevent : qx.event.GlobalError.observeMethod(function(e){

        // Fire navigate event when actual URL diverges from stored URL
        var f = qx.bom.Iframe.queryCurrentUrl(e);
        if(f !== e.$$url){

          qx.event.Registration.fireEvent(e, a, qx.event.type.Data, [f]);
          e.$$url = f;
        };
        // Always fire load event
        qx.event.Registration.fireEvent(e, c);
      })
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent : function(g, h){

        return g.tagName.toLowerCase() === b;
      },
      // interface implementation
      registerEvent : function(i, j, k){
      },
      // interface implementation
      unregisterEvent : function(l, m, n){
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(o){

      qx.event.Registration.addHandler(o);
    }
  });
})();
(function(){

  var k = "Iframe source could not be set!",j = "contentDocument",i = "engine.name",h = "",g = "qx.bom.Iframe",f = "osx",e = "os.name",d = "webkit",c = "iframe",b = "body",a = "load";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
       * Christian Hagendorn (Chris_schmidt)
  
  ************************************************************************ */
  /* ************************************************************************
  
  #require(qx.event.handler.Iframe)
  
  ************************************************************************ */
  /**
   * Cross browser abstractions to work with iframes.
   */
  qx.Class.define(g, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * {Map} Default attributes for creation {@link #create}.
       */
      DEFAULT_ATTRIBUTES : {
        onload : "qx.event.handler.Iframe.onevent(this)",
        frameBorder : 0,
        frameSpacing : 0,
        marginWidth : 0,
        marginHeight : 0,
        hspace : 0,
        vspace : 0,
        border : 0,
        allowTransparency : true
      },
      /**
       * Creates an DOM element.
       *
       * Attributes may be given directly with this call. This is critical
       * for some attributes e.g. name, type, ... in many clients.
       *
       * @param attributes {Map?null} Map of attributes to apply
       * @param win {Window?null} Window to create the element for
       * @return {Element} The created iframe node
       */
      create : function(l, m){

        // Work on a copy to not modify given attributes map
        var l = l ? qx.lang.Object.clone(l) : {
        };
        var n = qx.bom.Iframe.DEFAULT_ATTRIBUTES;
        for(var o in n){

          if(l[o] == null){

            l[o] = n[o];
          };
        };
        return qx.dom.Element.create(c, l, m);
      },
      /**
       * Get the DOM window object of an iframe.
       *
       * @param iframe {Element} DOM element of the iframe.
       * @return {Window?null} The DOM window object of the iframe or null.
       * @signature function(iframe)
       */
      getWindow : function(p){

        try{

          return p.contentWindow;
        } catch(q) {

          return null;
        };
      },
      /**
       * Get the DOM document object of an iframe.
       *
       * @param iframe {Element} DOM element of the iframe.
       * @return {Document} The DOM document object of the iframe.
       */
      getDocument : function(r){

        if(j in r){

          try{

            return r.contentDocument;
          } catch(t) {

            return null;
          };
        };
        try{

          var s = this.getWindow(r);
          return s ? s.document : null;
        } catch(u) {

          return null;
        };
      },
      /**
       * Get the HTML body element of the iframe.
       *
       * @param iframe {Element} DOM element of the iframe.
       * @return {Element} The DOM node of the <code>body</code> element of the iframe.
       */
      getBody : function(v){

        try{

          var w = this.getDocument(v);
          return w ? w.getElementsByTagName(b)[0] : null;
        } catch(x) {

          return null;
        };
      },
      /**
       * Sets iframe's source attribute to given value
       *
       * @param iframe {Element} DOM element of the iframe.
       * @param source {String} URL to be set.
       * @signature function(iframe, source)
       */
      setSource : function(y, z){

        try{

          // the guru says ...
          // it is better to use 'replace' than 'src'-attribute, since 'replace'
          // does not interfere with the history (which is taken care of by the
          // history manager), but there has to be a loaded document
          if(this.getWindow(y) && qx.dom.Hierarchy.isRendered(y)){

            /*
              Some gecko users might have an exception here:
              Exception... "Component returned failure code: 0x805e000a
              [nsIDOMLocation.replace]"  nsresult: "0x805e000a (<unknown>)"
            */
            try{

              // Webkit on Mac can't set the source when the iframe is still
              // loading its current page
              if((qx.core.Environment.get(i) == d) && qx.core.Environment.get(e) == f){

                var A = this.getWindow(y);
                if(A){

                  A.stop();
                };
              };
              this.getWindow(y).location.replace(z);
            } catch(B) {

              y.src = z;
            };
          } else {

            y.src = z;
          };
          // This is a programmer provided source. Remember URL for this source
          // for later comparison with current URL. The current URL can diverge
          // if the end-user navigates in the Iframe.
          this.__rememberUrl(y);
        } catch(C) {

          qx.log.Logger.warn(k);
        };
      },
      /**
       * Returns the current (served) URL inside the iframe
       *
       * @param iframe {Element} DOM element of the iframe.
       * @return {String} Returns the location href or null (if a query is not possible/allowed)
       */
      queryCurrentUrl : function(D){

        var E = this.getDocument(D);
        try{

          if(E && E.location){

            return E.location.href;
          };
        } catch(F) {
        };
        return h;
      },
      /**
      * Remember actual URL of iframe.
      *
      * @param iframe {Element} DOM element of the iframe.
      * @return {void}
      */
      __rememberUrl : function(G){

        // URL can only be detected after load. Retrieve and store URL once.
        var H = function(){

          qx.bom.Event.removeNativeListener(G, a, H);
          G.$$url = qx.bom.Iframe.queryCurrentUrl(G);
        };
        qx.bom.Event.addNativeListener(G, a, H);
      }
    }
  });
})();
(function(){

  var k = "Ignore Ready State Change",j = "Illegal parameter name. The following prefix is used internally by qooxdoo): ",h = ")!",g = "aborted",f = "Response: ",e = "script",d = "Request: ",c = "No valid responseType specified (",b = "_ScriptTransport_",a = "Returning content for responseType: ",D = "",C = "Transfer not complete, ignoring content!",B = "_ScriptTransport_id",A = "failed",z = "_ScriptTransport_data",y = "Request finished for an unknown instance (probably aborted or timed out before)",x = "utf-8",w = "timeout",v = "application/json",u = "qx.io.remote.transport.Script",r = "text/plain",s = "text/javascript",p = "qx.debug.io.remote.data",q = "completed",n = "?",o = "qx.debug.io.remote",l = "&",m = "=",t = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
       * Andreas Junghans (lucidcake)
  
  ************************************************************************ */
  /**
   * Transports requests to a server using dynamic script tags.
   *
   * This class should not be used directly by client programmers.
   */
  qx.Class.define(u, {
    extend : qx.io.remote.transport.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.io.remote.transport.Abstract.call(this);
      var E = ++qx.io.remote.transport.Script.__uniqueId;
      if(E >= 2000000000){

        qx.io.remote.transport.Script.__uniqueId = E = 1;
      };
      this.__element = null;
      this.__uniqueId = E;
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Unique identifier for each instance.
       *
       * @internal
       */
      __uniqueId : 0,
      /**
       * Registry for all script transport instances.
       *
       * @internal
       */
      _instanceRegistry : {
      },
      /**
       * Internal URL parameter prefix.
       *
       * @internal
       */
      ScriptTransport_PREFIX : b,
      /**
       * Internal URL parameter ID.
       *
       * @internal
       */
      ScriptTransport_ID_PARAM : B,
      /**
       * Internal URL parameter data prefix.
       *
       * @internal
       */
      ScriptTransport_DATA_PARAM : z,
      /**
       * Capabilities of this transport type.
       *
       * @internal
       */
      handles : {
        synchronous : false,
        asynchronous : true,
        crossDomain : true,
        fileUpload : false,
        programaticFormFields : false,
        responseTypes : [r, s, v]
      },
      /**
       * Returns always true, because script transport is supported by all browsers.
       *
       */
      isSupported : function(){

        return true;
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */
      /**
       * For reference:
       * http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/readyState_1.asp
       *
       * @internal
       */
      _numericMap : {
        "uninitialized" : 1,
        "loading" : 2,
        "loaded" : 2,
        "interactive" : 3,
        "complete" : 4
      },
      /**
       * This method can be called by the script loaded by the ScriptTransport
       * class.
       *
       * @signature function(id, content)
       * @param id {String} Id of the corresponding transport object,
       *     which is passed as an URL parameter to the server an
       * @param content {String} This string is passed to the content property
       *     of the {@link qx.io.remote.Response} object.
       */
      _requestFinished : qx.event.GlobalError.observeMethod(function(F, content){

        var G = qx.io.remote.transport.Script._instanceRegistry[F];
        if(G == null){

          if(qx.core.Environment.get(t)){

            if(qx.core.Environment.get(o)){

              this.warn(y);
            };
          };
        } else {

          G._responseContent = content;
          G._switchReadyState(qx.io.remote.transport.Script._numericMap.complete);
        };
      })
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lastReadyState : 0,
      __element : null,
      __uniqueId : null,
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Sends the request using "script" elements
       *
       * @return {void}
       */
      send : function(){

        var J = this.getUrl();
        // --------------------------------------
        //   Adding parameters
        // --------------------------------------
        J += (J.indexOf(n) >= 0 ? l : n) + qx.io.remote.transport.Script.ScriptTransport_ID_PARAM + m + this.__uniqueId;
        var M = this.getParameters();
        var L = [];
        for(var I in M){

          if(I.indexOf(qx.io.remote.transport.Script.ScriptTransport_PREFIX) == 0){

            this.error(j + qx.io.remote.transport.Script.ScriptTransport_PREFIX);
          };
          var K = M[I];
          if(K instanceof Array){

            for(var i = 0;i < K.length;i++){

              L.push(encodeURIComponent(I) + m + encodeURIComponent(K[i]));
            };
          } else {

            L.push(encodeURIComponent(I) + m + encodeURIComponent(K));
          };
        };
        if(L.length > 0){

          J += l + L.join(l);
        };
        // --------------------------------------
        //   Sending data
        // --------------------------------------
        var H = this.getData();
        if(H != null){

          J += l + qx.io.remote.transport.Script.ScriptTransport_DATA_PARAM + m + encodeURIComponent(H);
        };
        qx.io.remote.transport.Script._instanceRegistry[this.__uniqueId] = this;
        this.__element = document.createElement(e);
        // IE needs this (it ignores the
        // encoding from the header sent by the
        // server for dynamic script tags)
        this.__element.charset = x;
        this.__element.src = J;
        if(qx.core.Environment.get(t)){

          if(qx.core.Environment.get(p)){

            this.debug(d + J);
          };
        };
        document.body.appendChild(this.__element);
      },
      /**
       * Switches the readystate by setting the internal state.
       *
       * @param vReadyState {String} readystate value
       * @return {void}
       */
      _switchReadyState : function(N){

        // Ignoring already stopped requests
        switch(this.getState()){case q:case g:case A:case w:
        this.warn(k);
        return;};
        // Updating internal state
        while(this.__lastReadyState < N){

          this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
        };
      },
      /*
      ---------------------------------------------------------------------------
        REQUEST HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Sets a request header with the given value.
       *
       * This method is not implemented at the moment.
       *
       * @param vLabel {String} Request header name
       * @param vValue {var} Request header value
       * @return {void}
       */
      setRequestHeader : function(O, P){
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the value of the given response header.
       *
       * This method is not implemented at the moment and returns always "null".
       *
       * @param vLabel {String} Response header name
       * @return {null} Returns null
       */
      getResponseHeader : function(Q){

        return null;
      },
      /**
       * Provides an hash of all response headers.
       *
       * This method is not implemented at the moment and returns an empty map.
       *
       * @return {Map} empty map
       */
      getResponseHeaders : function(){

        return {
        };
      },
      /*
      ---------------------------------------------------------------------------
        STATUS SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current status code of the request if available or -1 if not.
       * This method needs implementation (returns always 200).
       *
       * @return {Integer} status code
       */
      getStatusCode : function(){

        return 200;
      },
      /**
       * Provides the status text for the current request if available and null otherwise.
       * This method needs implementation (returns always an empty string)
       *
       * @return {String} always an empty string.
       */
      getStatusText : function(){

        return D;
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE DATA SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the length of the content as fetched thus far.
       * This method needs implementation (returns always 0).
       *
       * @return {Integer} Returns 0
       */
      getFetchedLength : function(){

        return 0;
      },
      /**
       * Returns the content of the response.
       *
       * @return {null | String} If successful content of response as string.
       */
      getResponseContent : function(){

        if(this.getState() !== q){

          if(qx.core.Environment.get(t)){

            if(qx.core.Environment.get(o)){

              this.warn(C);
            };
          };
          return null;
        };
        if(qx.core.Environment.get(t)){

          if(qx.core.Environment.get(o)){

            this.debug(a + this.getResponseType());
          };
        };
        switch(this.getResponseType()){case r:// server is responsible for using a string as the response
        case v:case s:
        if(qx.core.Environment.get(t)){

          if(qx.core.Environment.get(p)){

            this.debug(f + this._responseContent);
          };
        };
        var R = this._responseContent;
        return (R === 0 ? 0 : (R || null));default:
        this.warn(c + this.getResponseType() + h);
        return null;};
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(){

      // basic registration to qx.io.remote.Exchange
      // the real availability check (activeX stuff and so on) follows at the first real request
      qx.io.remote.Exchange.registerType(qx.io.remote.transport.Script, u);
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__element){

        delete qx.io.remote.transport.Script._instanceRegistry[this.__uniqueId];
        document.body.removeChild(this.__element);
      };
      this.__element = this._responseContent = null;
    }
  });
})();
(function(){

  var m = ")!",k = "Boolean",j = 'Referer',h = "Could not execute json: [",g = "engine.version",f = 'Basic ',d = "Failed to send data: ",c = "\n</pre>",b = "string",a = "Response was not a valid xml document [",bi = "Failed with exception: ",bh = 'Authorization',bg = "Missing Document Element!",bf = "send",be = "XML-File is not well-formed!",bd = "Failed: ",bc = "Request: ",bb = "No valid responseType specified (",ba = "<pre>Could not execute json: \n",Y = "Returning content for responseType: ",u = "Could not load from file: ",v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",r = "Could not execute javascript: [",t = "Transfer not complete or failed, ignoring content!",p = "mshtml",q = ':',n = "parseerror",o = "Ignore Ready State Change",y = "file:",z = "webkit",H = "State: ",F = "object",O = "application/xml",J = "qx.io.remote.transport.XmlHttp",U = "application/json",S = "text/html",B = "text/plain",X = "text/javascript",W = "receiving",V = "?",A = "created",D = "aborted",E = "sending",G = "",I = "]",K = "&",P = "engine.name",T = "configured",w = "timeout",x = "completed",C = "qx.debug.io.remote",N = "Response: ",M = "=",L = "qx.debug.io.remote.data",R = "failed",Q = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * Transports requests to a server using the native XmlHttpRequest object.
   *
   * This class should not be used directly by client programmers.
   */
  qx.Class.define(J, {
    extend : qx.io.remote.transport.Abstract,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Capabilities of this transport type.
       *
       * @internal
       */
      handles : {
        synchronous : true,
        asynchronous : true,
        crossDomain : false,
        fileUpload : false,
        programaticFormFields : false,
        responseTypes : [B, X, U, O, S]
      },
      /**
       * Return a new XMLHttpRequest object suitable for the client browser.
       *
       * @return {Object} native XMLHttpRequest object
       * @signature function()
       */
      createRequestObject : qx.core.Environment.select(P, {
        "default" : function(){

          return new XMLHttpRequest;
        },
        // IE7's native XmlHttp does not care about trusted zones. To make this
        // work in the localhost scenario, you can use the following registry setting:
        //
        // [HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main\
        // FeatureControl\FEATURE_XMLHTTP_RESPECT_ZONEPOLICY]
        // "Iexplore.exe"=dword:00000001
        //
        // Generally it seems that the ActiveXObject is more stable. jQuery
        // seems to use it always. We prefer the ActiveXObject for the moment, but allow
        // fallback to XMLHTTP if ActiveX is disabled.
        "mshtml" : function(){

          if(window.ActiveXObject && qx.xml.Document.XMLHTTP){

            return new ActiveXObject(qx.xml.Document.XMLHTTP);
          };
          if(window.XMLHttpRequest){

            return new XMLHttpRequest;
          };
        }
      }),
      /**
       * Whether the transport type is supported by the client.
       *
       * @return {Boolean} supported or not
       */
      isSupported : function(){

        return !!this.createRequestObject();
      }
    },
    /*
     *****************************************************************************
        PROPERTIES
     *****************************************************************************
     */
    properties : {
      /**
       * If true and the responseType property is set to "application/json", getResponseContent() will
       * return a Javascript map containing the JSON contents, i. e. the result qx.lang.Json.parse().
       * If false, the raw string data will be returned and the parsing must be done manually.
       * This is usefull for special JSON dialects / extensions which are not supported by
       * qx.lang.Json.
       */
      parseJson : {
        check : k,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        CORE METHODS
      ---------------------------------------------------------------------------
      */
      __localRequest : false,
      __lastReadyState : 0,
      __request : null,
      /**
       * Returns the native request object
       *
       * @return {Object} native XmlHTTPRequest object
       */
      getRequest : function(){

        if(this.__request === null){

          this.__request = qx.io.remote.transport.XmlHttp.createRequestObject();
          this.__request.onreadystatechange = qx.lang.Function.bind(this._onreadystatechange, this);
        };
        return this.__request;
      },
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Implementation for sending the request
       *
       * @return {void}
       */
      send : function(){

        this.__lastReadyState = 0;
        var bn = this.getRequest();
        var bj = this.getMethod();
        var bq = this.getAsynchronous();
        var bp = this.getUrl();
        // --------------------------------------
        //   Local handling
        // --------------------------------------
        var bl = (window.location.protocol === y && !(/^http(s){0,1}\:/.test(bp)));
        this.__localRequest = bl;
        // --------------------------------------
        //   Adding URL parameters
        // --------------------------------------
        var bt = this.getParameters(false);
        var br = [];
        for(var bk in bt){

          var bo = bt[bk];
          if(bo instanceof Array){

            for(var i = 0;i < bo.length;i++){

              br.push(encodeURIComponent(bk) + M + encodeURIComponent(bo[i]));
            };
          } else {

            br.push(encodeURIComponent(bk) + M + encodeURIComponent(bo));
          };
        };
        if(br.length > 0){

          bp += (bp.indexOf(V) >= 0 ? K : V) + br.join(K);
        };
        // --------------------------------------------------------
        //   Adding data parameters (if no data is already present)
        // --------------------------------------------------------
        if(this.getData() === null){

          var bt = this.getParameters(true);
          var br = [];
          for(var bk in bt){

            var bo = bt[bk];
            if(bo instanceof Array){

              for(var i = 0;i < bo.length;i++){

                br.push(encodeURIComponent(bk) + M + encodeURIComponent(bo[i]));
              };
            } else {

              br.push(encodeURIComponent(bk) + M + encodeURIComponent(bo));
            };
          };
          if(br.length > 0){

            this.setData(br.join(K));
          };
        };
        var bs = function(bu){

          var bz = v;
          var bD = G;
          var bx,bw,bv;
          var bA,bB,bC,by;
          var i = 0;
          do {

            bx = bu.charCodeAt(i++);
            bw = bu.charCodeAt(i++);
            bv = bu.charCodeAt(i++);
            bA = bx >> 2;
            bB = ((bx & 3) << 4) | (bw >> 4);
            bC = ((bw & 15) << 2) | (bv >> 6);
            by = bv & 63;
            if(isNaN(bw)){

              bC = by = 64;
            } else if(isNaN(bv)){

              by = 64;
            };
            bD += bz.charAt(bA) + bz.charAt(bB) + bz.charAt(bC) + bz.charAt(by);
          }while(i < bu.length);
          return bD;
        };
        // --------------------------------------
        //   Opening connection
        // --------------------------------------
        try{

          if(this.getUsername()){

            if(this.getUseBasicHttpAuth()){

              bn.open(bj, bp, bq);
              bn.setRequestHeader(bh, f + bs(this.getUsername() + q + this.getPassword()));
            } else {

              bn.open(bj, bp, bq, this.getUsername(), this.getPassword());
            };
          } else {

            bn.open(bj, bp, bq);
          };
        } catch(bE) {

          this.error(bi + bE);
          this.failed();
          return;
        };
        // --------------------------------------
        //   Applying request header
        // --------------------------------------
        // Add a Referer header
        // The Java backend uses the referer header, and Firefox doesn't send one by
        // default (see here:
        // http://www.mercurytide.co.uk/whitepapers/issues-working-with-ajax/ ). Even when
        // not using a backend that evaluates the referrer, it's still useful to have it
        // set correctly, e.g. when looking at server log files.
        if(!(qx.core.Environment.get(P) == z)){

          // avoid "Refused to set unsafe header Referer" in Safari and other Webkit-based browsers
          bn.setRequestHeader(j, window.location.href);
        };
        var bm = this.getRequestHeaders();
        for(var bk in bm){

          bn.setRequestHeader(bk, bm[bk]);
        };
        // --------------------------------------
        //   Sending data
        // --------------------------------------
        try{

          if(qx.core.Environment.get(Q)){

            if(qx.core.Environment.get(L)){

              this.debug(bc + this.getData());
            };
          };
          // IE9 executes the call synchronous when the call is to file protocol
          // See [BUG #4762] for details
          if(bl && bq && qx.core.Environment.get(P) == p && qx.core.Environment.get(g) == 9){

            qx.event.Timer.once(function(){

              bn.send(this.getData());
            }, this, 0);
          } else {

            bn.send(this.getData());
          };
        } catch(bF) {

          if(bl){

            this.failedLocally();
          } else {

            this.error(d + bF, bf);
            this.failed();
          };
          return;
        };
        // --------------------------------------
        //   Readystate for sync reqeusts
        // --------------------------------------
        if(!bq){

          this._onreadystatechange();
        };
      },
      /**
       * Force the transport into the failed state ("failed").
       *
       * This method should be used only if the requests URI was local
       * access. I.e. it started with "file://".
       *
       * @return {void}
       */
      failedLocally : function(){

        if(this.getState() === R){

          return;
        };
        // should only occur on "file://" access
        this.warn(u + this.getUrl());
        this.failed();
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Listener method for change of the "readystate".
       * Sets the internal state and informs the transport layer.
       *
       * @signature function(e)
       * @param e {Event} native event
       */
      _onreadystatechange : qx.event.GlobalError.observeMethod(function(e){

        // Ignoring already stopped requests
        switch(this.getState()){case x:case D:case R:case w:
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(C)){

            this.warn(o);
          };
        };
        return;};
        // Checking status code
        var bG = this.getReadyState();
        if(bG == 4){

          // The status code is only meaningful when we reach ready state 4.
          // (Important for Opera since it goes through other states before
          // reaching 4, and the status code is not valid before 4 is reached.)
          if(!qx.io.remote.Exchange.wasSuccessful(this.getStatusCode(), bG, this.__localRequest)){

            // Fix for bug #2272
            // The IE doesn't set the state to 'sending' even though the send method
            // is called. This only occurs if the server (which is called) goes
            // down or a network failure occurs.
            if(this.getState() === T){

              this.setState(E);
            };
            this.failed();
            return;
          };
        };
        // Sometimes the xhr call skips the send state
        if(bG == 3 && this.__lastReadyState == 1){

          this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
        };
        // Updating internal state
        while(this.__lastReadyState < bG){

          this.setState(qx.io.remote.Exchange._nativeMap[++this.__lastReadyState]);
        };
      }),
      /*
      ---------------------------------------------------------------------------
        READY STATE
      ---------------------------------------------------------------------------
      */
      /**
       * Get the ready state of this transports request.
       *
       * For qx.io.remote.transport.XmlHttp, ready state is a number between 1 to 4.
       *
       * @return {Integer} ready state number
       */
      getReadyState : function(){

        var bH = null;
        try{

          bH = this.getRequest().readyState;
        } catch(bI) {
        };
        return bH;
      },
      /*
      ---------------------------------------------------------------------------
        REQUEST HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Set a request header to this transports request.
       *
       * @param vLabel {String} Request header name
       * @param vValue {var} Request header value
       * @return {void}
       */
      setRequestHeader : function(bJ, bK){

        this.getRequestHeaders()[bJ] = bK;
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE HEADER SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns a specific header provided by the server upon sending a request,
       * with header name determined by the argument headerName.
       *
       * Only available at readyState 3 and 4 universally and in readyState 2
       * in Gecko.
       *
       * Please note: Some servers/proxies (such as Selenium RC) will capitalize
       * response header names. This is in accordance with RFC 2616[1], which
       * states that HTTP 1.1 header names are case-insensitive, so your
       * application should be case-agnostic when dealing with response headers.
       *
       * [1]<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2">RFC 2616: HTTP Message Headers</a>
       *
       * @param vLabel {String} Response header name
       * @return {String|null} Response header value
       */
      getResponseHeader : function(bL){

        var bM = null;
        try{

          bM = this.getRequest().getResponseHeader(bL) || null;
        } catch(bN) {
        };
        return bM;
      },
      /**
       * Returns all response headers of the request.
       *
       * @return {var} response headers
       */
      getStringResponseHeaders : function(){

        var bP = null;
        try{

          var bO = this.getRequest().getAllResponseHeaders();
          if(bO){

            bP = bO;
          };
        } catch(bQ) {
        };
        return bP;
      },
      /**
       * Provides a hash of all response headers.
       *
       * @return {var} hash of all response headers
       */
      getResponseHeaders : function(){

        var bT = this.getStringResponseHeaders();
        var bU = {
        };
        if(bT){

          var bR = bT.split(/[\r\n]+/g);
          for(var i = 0,l = bR.length;i < l;i++){

            var bS = bR[i].match(/^([^:]+)\s*:\s*(.+)$/i);
            if(bS){

              bU[bS[1]] = bS[2];
            };
          };
        };
        return bU;
      },
      /*
      ---------------------------------------------------------------------------
        STATUS SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current status code of the request if available or -1 if not.
       *
       * @return {Integer} current status code
       */
      getStatusCode : function(){

        var bV = -1;
        try{

          bV = this.getRequest().status;
          // [BUG #4476]
          // IE sometimes tells 1223 when it should be 204
          if(bV === 1223){

            bV = 204;
          };
        } catch(bW) {
        };
        return bV;
      },
      /**
       * Provides the status text for the current request if available and null
       * otherwise.
       *
       * @return {String} current status code text
       */
      getStatusText : function(){

        var bX = G;
        try{

          bX = this.getRequest().statusText;
        } catch(bY) {
        };
        return bX;
      },
      /*
      ---------------------------------------------------------------------------
        RESPONSE DATA SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Provides the response text from the request when available and null
       * otherwise.  By passing true as the "partial" parameter of this method,
       * incomplete data will be made available to the caller.
       *
       * @return {String} Content of the response as string
       */
      getResponseText : function(){

        var ca = null;
        try{

          ca = this.getRequest().responseText;
        } catch(cb) {

          ca = null;
        };
        return ca;
      },
      /**
       * Provides the XML provided by the response if any and null otherwise.  By
       * passing true as the "partial" parameter of this method, incomplete data will
       * be made available to the caller.
       *
       * @return {String} Content of the response as XML
       * @throws {Error} If an error within the response occurs.
       */
      getResponseXml : function(){

        var ce = null;
        var cc = this.getStatusCode();
        var cd = this.getReadyState();
        if(qx.io.remote.Exchange.wasSuccessful(cc, cd, this.__localRequest)){

          try{

            ce = this.getRequest().responseXML;
          } catch(cf) {
          };
        };
        // Typical behaviour on file:// on mshtml
        // Could we check this with something like: /^file\:/.test(path); ?
        // No browser check here, because it doesn't seem to break other browsers
        //    * test for this.req.responseXML's objecthood added by *
        //    * FRM, 20050816                                       *
        if(typeof ce == F && ce != null){

          if(!ce.documentElement){

            // Clear xml file declaration, this breaks non unicode files (like ones with Umlauts)
            var s = String(this.getRequest().responseText).replace(/<\?xml[^\?]*\?>/, G);
            ce.loadXML(s);
          };
          // Re-check if fixed...
          if(!ce.documentElement){

            throw new Error(bg);
          };
          if(ce.documentElement.tagName == n){

            throw new Error(be);
          };
        } else {

          throw new Error(a + this.getRequest().responseText + I);
        };
        return ce;
      },
      /**
       * Returns the length of the content as fetched thus far
       *
       * @return {Integer} Length of the response text.
       */
      getFetchedLength : function(){

        var cg = this.getResponseText();
        return typeof cg == b ? cg.length : 0;
      },
      /**
       * Returns the content of the response
       *
       * @return {null | String} Response content if available
       */
      getResponseContent : function(){

        var ch = this.getState();
        if(ch !== x && ch != R){

          if(qx.core.Environment.get(Q)){

            if(qx.core.Environment.get(C)){

              this.warn(t);
            };
          };
          return null;
        };
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(C)){

            this.debug(Y + this.getResponseType());
          };
        };
        var cj = this.getResponseText();
        if(ch == R){

          if(qx.core.Environment.get(Q)){

            if(qx.core.Environment.get(L)){

              this.debug(bd + cj);
            };
          };
          return cj;
        };
        switch(this.getResponseType()){case B:case S:
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(L)){

            this.debug(N + cj);
          };
        };
        return cj;case U:
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(L)){

            this.debug(N + cj);
          };
        };
        try{

          if(cj && cj.length > 0){

            var ci;
            if(this.getParseJson()){

              ci = qx.lang.Json.parse(cj);
              ci = (ci === 0 ? 0 : (ci || null));
            } else {

              ci = cj;
            };
            return ci;
          } else {

            return null;
          };
        } catch(ck) {

          this.error(h + cj + I, ck);
          return ba + cj + c;
        };case X:
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(L)){

            this.debug(N + cj);
          };
        };
        try{

          if(cj && cj.length > 0){

            var ci = window.eval(cj);
            return (ci === 0 ? 0 : (ci || null));
          } else {

            return null;
          };
        } catch(cl) {

          this.error(r + cj + I, cl);
          return null;
        };case O:
        cj = this.getResponseXml();
        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(L)){

            this.debug(N + cj);
          };
        };
        return (cj === 0 ? 0 : (cj || null));default:
        this.warn(bb + this.getResponseType() + m);
        return null;};
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      /**
       * Apply method for the "state" property.
       * Fires an event for each state value to inform the listeners.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       * @return {void}
       */
      _applyState : function(cm, cn){

        if(qx.core.Environment.get(Q)){

          if(qx.core.Environment.get(C)){

            this.debug(H + cm);
          };
        };
        switch(cm){case A:
        this.fireEvent(A);
        break;case T:
        this.fireEvent(T);
        break;case E:
        this.fireEvent(E);
        break;case W:
        this.fireEvent(W);
        break;case x:
        this.fireEvent(x);
        break;case R:
        this.fireEvent(R);
        break;case D:
        this.getRequest().abort();
        this.fireEvent(D);
        break;case w:
        this.getRequest().abort();
        this.fireEvent(w);
        break;};
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(){

      // basic registration to qx.io.remote.Exchange
      // the real availability check (activeX stuff and so on) follows at the first real request
      qx.io.remote.Exchange.registerType(qx.io.remote.transport.XmlHttp, J);
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      var co = this.getRequest();
      if(co){

        // Clean up state change handler
        // Note that for IE the proper way to do this is to set it to a
        // dummy function, not null (Google on "onreadystatechange dummy IE unhook")
        // http://groups.google.com/group/Google-Web-Toolkit-Contributors/browse_thread/thread/7e7ee67c191a6324
        co.onreadystatechange = qx.lang.Function.empty;
        // Aborting
        switch(co.readyState){case 1:case 2:case 3:
        co.abort();};
      };
      this.__request = null;
    }
  });
})();
(function(){

  var d = "Object",c = "_applyResponseHeaders",b = "qx.io.remote.Response",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This class is used to work with the result of a HTTP request.
   */
  qx.Class.define(b, {
    extend : qx.event.type.Event,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        PROPERTIES
      ---------------------------------------------------------------------------
      */
      /** State of the response. */
      state : {
        check : a,
        nullable : true
      },
      /** Status code of the response. */
      statusCode : {
        check : a,
        nullable : true
      },
      /** Content of the response. */
      content : {
        nullable : true
      },
      /** The headers of the response. */
      responseHeaders : {
        check : d,
        nullable : true,
        apply : c
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lowerHeaders : null,
      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */
      // overridden
      clone : function(e){

        var f = qx.event.type.Event.prototype.clone.call(this, e);
        f.setType(this.getType());
        f.setState(this.getState());
        f.setStatusCode(this.getStatusCode());
        f.setContent(this.getContent());
        f.setResponseHeaders(this.getResponseHeaders());
        return f;
      },
      /**
       * Returns a specific response header
       * @param vHeader {String} Response header name
       * @return {Object | null} The header value or null;
       */
      getResponseHeader : function(g){

        if(this.__lowerHeaders){

          return this.__lowerHeaders[g.toLowerCase()] || null;
        };
        return null;
      },
      /**
       * Keep lower-cased shadow of response headers for later
       * case-insensitive matching.
       *
       * @param value {var} Current value
       * @param old {var} Previous value
       */
      _applyResponseHeaders : function(h, i){

        var j = {
        };
        if(h !== null){

          qx.lang.Object.getKeys(h).forEach(function(k){

            j[k.toLowerCase()] = h[k];
          });
          this.__lowerHeaders = j;
        };
      }
    }
  });
})();
(function(){

  var l = 'CSV content is probably invalid: odd number of quotes',k = "(\\r?\\n)",j = "g",h = "",g = "test\ntest2\r\ntest3",f = "csvparser.CSVParser",e = "\"test\",1234,,\"test,\"\"\"",d = "test\",1234\n,\r\n,\"test,\"\"\"",c = ",",b = '',a = "\"";
  /**
   * This class implements parsing CSV data. For better browsers it can run straight through the
   * data in a single blocking loop. For slow browsers there is a progressive version of the parser
   * which gives back control to the browser after each record. 
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    construct : function(){

      this.setEolRegExp(new RegExp(k, j));
    },
    properties : {
      /**
       * A regular expression object that looks for the end of a line.
       */
      eolRegExp : {
        deferredInit : true
      }
    },
    statics : {
      /**
       * Converts a CSV separated line into a list of records
       *
       * @param row {Array} Row to parse
       */
      fields : function(m){

        var t = {
          data : m,
          ret : []
        };
        var q = function(v){

          var w = v.indexOf(a);
          var x = false;
          while(!x){

            if(w != -1 && v[w + 1] != undefined && v[w + 1] == a){

              w = v.indexOf(a, w + 1 + 1);
            } else {

              x = true;
            };
          };
          return w;
        };
        var s = function(y){

          return y.indexOf(c);
        };
        var n = function(z){

          return z.replace(/^\s+/g, b);
        };
        var u = function(A){

          return A.replace(/\"\"/g, a);
        };
        var r = false;
        while(!r){

          if(t.data.substring(0, 1) == a){

            t.data = t.data.substring(1);
            var closed = q(t.data);
            if(closed != -1){

              t.ret.push(t.data.substring(0, closed));
              t.data = n(t.data.substring(closed + 1));
              var o = s(t.data);
              if(o != -1){

                t.data = n(t.data.substring(o + 1));
              } else {

                r = true;
              };
            } else {

              t.ret.push(t.data);
              r = true;
            };
          } else {

            var p = s(t.data);
            if(p != -1){

              t.ret.push(t.data.substring(0, p));
              t.data = n(t.data.substring(p + 1));
            } else {

              t.ret.push(t.data);
              r = true;
            };
          };
        };
        for(var i = 0;i < t.ret.length;i++){

          t.ret[i] = u(t.ret[i]);
        };
        return t.ret;
      },
      /**
       * Remove leading and trailing spaces from the given string
       *
       * @param str {String} 
       */
      trim : function(B){

        return B.replace(/^\s+|\s+$/g, b);
      },
      /**
       * Parse the given data into an array of lines
       * @param regExp {RegExp} A regular expression object that looks for new lines
       * @param data {String} String containing the CSV data.
       * 
       */
      lines : function(C, D){

        var F = D.split(C);
        var i = 0;
        while(i < F.length){

          // Remove leading newline rows
          if(b == F[i].replace(C, b)){

            F.splice(i, 1);
            continue;
          };
          // If the leading line has an odd number of quotes,
          // it must be continued onto the next line.
          var E = F[i].match(/\"/g);
          if(E && 1 == E.length % 2){

            if(i + 2 >= F.length){

              alert(l);
              return F;
            };
            F[i] += F[i + 1] + F[i + 2];
            F.splice(i + 1, 2);
          } else {

            i++;
          };
        };
        return F;
      },
      /**
       * The default way of determining where there are more subtasks
       */
      defaultContinueCase : function(G){

        return G.context.keepGoing;
      },
      /**
       * A subtask that breaks up the given string in lines and parses the fields one line at a time. 
       *
       * @param runRegExp {Function} A function that runs a regular expression object on the given data
       * @param returnArray {Array} The array that will contain the parsed lines                          
       * @param data {String} The CSV data to be parsed.
       */
      linesProgressive : function(H, I, J){

        return function(K){

          K.regexp = H(J);
          if(K.regexp != null){

            var L = csvparser.CSVParser.fields(K.regexp.input.substring(K.curr, K.regexp.index));
            I.push(L);
            K.curr = K.regexp.index + K.regexp[0].length;
          } else {

            K.keepGoing = false;
            if(K.curr != J.length){

              var L = csvparser.CSVParser.fields(J.substring(K.curr));
              I.push(L);
            };
          };
        };
      },
      /**
       * Parse out the fields in each of the given lines.
       * @param lines {[Array]} A list of lines in the CSV dataset
       */
      linesToRows : function(M){

        for(var i = 0;i < M.length;i++){

          M[i] = csvparser.CSVParser.fields(M[i]);
        };
        return M;
      }
    },
    members : {
      /**
       * Parse the given CSV dataset in one record at a time, giving control back to the browser
       * after each one has been parsed.
       * @param returnArray {[Array]} The array that will contain the result.
       * @param data {String} The CSV dataset
       */
      csvToArrayProgressive : function(N, O){

        var R = this;
        var P = function(S){

          return R.getEolRegExp().exec(S);
        };
        var Q = {
          curr : 0,
          regexp : null,
          keepGoing : true
        };
        return {
          context : Q,
          func : csvparser.CSVParser.linesProgressive(P, N, O),
          continueCase : csvparser.CSVParser.defaultContinueCase
        };
      },
      /**
       * Parse the given CSV dataset.
       * @param data {String} The CSV dataset
       */
      csvToArray : function(T){

        return csvparser.CSVParser.linesToRows(csvparser.CSVParser.lines(this.getEolRegExp(), T));
      },
      tests : function(){

        var W = g;
        var U = e;
        var V = d;
        this.debug(this.lines(W, h));
        this.debug(csvparser.CSVParser.fields(U));
        this.debug(csvparser.CSVParser.csvToArray(V));
      }
    }
  });
})();
(function(){

  var h = "",g = "N/A",f = "dicomheaderview.ExperimentTable",e = "<nested>",d = "\"",c = "nested",b = "single",a = "Name";
  /**
   * The model for the table that displays the dicom tags
   * 
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    construct : function(k, l){

      qx.core.Object.call(this);
      this.setModel(this.initModel(k));
    },
    properties : {
      /**
       * The table model 
       */
      model : {
        deferredInit : true
      }
    },
    statics : {
      /**
       * Unquote a string
       * @param str{String} 
       */
      unQuote : function(m){

        var n = m;
        if(qx.lang.String.startsWith(m, d) && qx.lang.String.endsWith(m, d)){

          n = m.substring(1, m.length - 1);
        };
        return n;
      },
      /**
       * Turn a parsed CSV table into an array of objects
       * Example input:
       * [["Col1", "Col2" "Col3"], 
       *  ['"a"', '"b"', '"c"'], 
       *  ['"d"', '"e"', '"f"']]
       * Example Output:
       * [
       *   { "Col1": "a", "Col2": "b", "Col3": "c" },
       *   { "Col1": "d", "Col2": "e", "Col3": "f" }
       * ]
       * @param lines{[[String]]} Each row of the CSV output
       */
      toObject : function(o){

        // Build the column names map from the first line.
        var q = {
        };
        if(o[0]){

          for(var j = 0;j < o[0].length;j++){

            if(o[0][j] != undefined){

              q[j.toString()] = dicomheaderview.ExperimentTable.unQuote(o[0][j]);
            };
          };
        };
        var r = [];
        for(var i = 1;i < o.length;i++){

          var s = o[i];
          var p = {
          };
          for(var j = 0;j < s.length;j++){

            if(s[j] != undefined){

              p[q[j]] = dicomheaderview.ExperimentTable.unQuote(s[j]);
            };
          };
          r.push(p);
        };
        return r;
      }
    },
    members : {
      /**
       * Create the model for the table that displays the headers as columns and their values as rows
       * @param experiments {Object} {@link dicomheaderview.GetHeaders#headers}
       */
      initModel : function(u){

        var D = new qx.ui.table.model.Simple();
        var E = [[], []];
        E[0].push(a);
        E[1].push(a);
        var w = [];
        var x = {
        };
        for(var i = 0;i < u.length;i++){

          for(var j = 0;j < u[i].data.length;j++){

            var A = u[i].data[j].tag1;
            var y = u[i].data[j].tag2;
            var z = u[i].data[j].desc;
            var B = u[i].data[j].vr;
            var v = {
            };
            if(!(A in x)){

              x[A] = {
              };
            };
            if(y === h){

              x[A].type = b;
              v = x[A];
            } else {

              x[A].type = c;
              x[A][u[i].name] = true;
              if(!(y in x[A])){

                x[A][y] = {
                };
              };
              v = x[A][y];
              if(A === y){

                x[A].vr = B;
                x[A].desc = z;
              };
            };
            v.vr = B;
            v[u[i].name] = u[i].data[j].value;
            v.desc = z;
          };
        };
        for(var C in x){

          E[0].push(x[C].desc);
          E[1].push(C);
          for(var i = 0;i < u.length;i++){

            var name = u[i].name;
            if(w[i] === undefined){

              w[i] = [];
              w[i].push(name);
            };
            if((name in x[C]) && x[C].type === b){

              w[i].push(x[C][name]);
            } else if((name in x[C]) && x[C].type === c){

              w[i].push(e);
            } else if(!(name in x[C])){

              w[i].push(g);
            };;
          };
        };
        D.setColumns(E[0], E[1]);
        D.setData(w);
        return D;
      },
      /**
       * Create the table showing only the default visible tags.
       * @param defaultVisibleTags{@link dicomtag.Tags#defaultVisibleTags}
       */
      createTable : function(F){

        var H = this.getModel();
        var J = this.getTableTags();
        var K = J.filter(function(t){

          return !(F.indexOf(t) > -1);
        });
        var I = K.filter(function(t){

          return !(t === a);
        }).map(function(t){

          return H.getColumnIndexById(t);
        });
        var G = new qx.ui.table.Table(H, {
          initiallyHiddenColumns : I
        });
        G.setMetaColumnCounts([1, -1]);
        G.setColumnVisibilityButtonVisible(false);
        return G;
      },
      /**
       * Unused ...
       */
      setVisibleTags : function(L, M, N){

        var O = L.getColumnCount();
        for(var i = 0;i < O;i++){

          var P = L.getColumnId(i);
          if(!N.indexOf(P) > -1){

            var Q = L.getColumnIndexById(P);
            M.setColumnVisible(Q, false);
          };
        };
      },
      /** 
       * Get the header fields shown by this table
       */
      getTableTags : function(){

        var S = this.getModel();
        var R = S.getColumnCount();
        var T = [];
        for(var i = 0;i < R;i++){

          T.push(S.getColumnId(i));
        };
        return T;
      },
      /**
       * Set the visibility of a header field.
       * @param table{Object} The header table
       * @param tag{String} The Dicom tag
       * @param visible{Boolean} If true, show this header field 
       */
      setVisibility : function(U, V, W){

        var X = this.getModel();
        var Y = X.getColumnIndexById(V);
        var ba = U.getTableColumnModel();
        ba.setColumnVisible(Y, W);
      },
      /**
       * Move to the column that shows the given DICOM tag
       * @param table{Object} The header table
       * @param tag{String} DICOM tag
       */
      scrollToColumn : function(bb, bc){

        var bd = this.getModel();
        var be = bd.getColumnIndexById(bc);
        bb.scrollCellVisible(be, 0);
      }
    }
  });
})();
(function(){

  var c = "qx.event.type.Event",b = "qx.ui.table.ITableModel",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * The data model of a table.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event may be null or a map having the following attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       */
      "dataChanged" : a,
      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged" : c,
      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Returns the number of rows in the model.
       *
       * @abstract
       * @return {Integer} the number of rows.
       */
      getRowCount : function(){
      },
      /**
       *
       * Returns the data of one row. This function may be overridden by models which hold
       * all data of a row in one object. By using this function, clients have a way of
       * quickly retrieving the entire row data.
       *
       * <b>Important:</b>Models which do not have their row data accessible in one object
       * may return null.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Object} the row data as an object or null if the model does not support row data
       *                    objects. The details on the object returned are determined by the model
       *                    implementation only.
       */
      getRowData : function(d){
      },
      /**
       * Returns the number of columns in the model.
       *
       * @abstract
       * @return {Integer} the number of columns.
       */
      getColumnCount : function(){
      },
      /**
       * Returns the ID of column. The ID may be used to identify columns
       * independent from their index in the model. E.g. for being aware of added
       * columns when saving the width of a column.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the ID of the column.
       */
      getColumnId : function(e){
      },
      /**
       * Returns the index of a column.
       *
       * @abstract
       * @param columnId {String} the ID of the column.
       * @return {Integer} the index of the column.
       */
      getColumnIndexById : function(f){
      },
      /**
       * Returns the name of a column. This name will be shown to the user in the
       * table header.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @return {String} the name of the column.
       */
      getColumnName : function(g){
      },
      /**
       * Returns whether a column is editable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is editable.
       */
      isColumnEditable : function(h){
      },
      /**
       * Returns whether a column is sortable.
       *
       * @param columnIndex {Integer} the column to check.
       * @return {Boolean} whether the column is sortable.
       */
      isColumnSortable : function(i){
      },
      /**
       * Sorts the model by a column.
       *
       * @param columnIndex {Integer} the column to sort by.
       * @param ascending {Boolean} whether to sort ascending.
       * @return {void}
       */
      sortByColumn : function(j, k){
      },
      /**
       * Returns the column index the model is sorted by. If the model is not sorted
       * -1 is returned.
       *
       * @return {Integer} the column index the model is sorted by.
       */
      getSortColumnIndex : function(){
      },
      /**
       * Returns whether the model is sorted ascending.
       *
       * @return {Boolean} whether the model is sorted ascending.
       */
      isSortAscending : function(){
      },
      /**
       * Prefetches some rows. This is a hint to the model that the specified rows
       * will be read soon.
       *
       * @param firstRowIndex {Integer} the index of first row.
       * @param lastRowIndex {Integer} the index of last row.
       * @return {void}
       */
      prefetchRows : function(l, m){
      },
      /**
       * Returns a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} the index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} The value of the cell.
       * @see #getValueById
       */
      getValue : function(n, o){
      },
      /**
       * Returns a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #getValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} the ID of the column.
       * @param rowIndex {Integer} the index of the row.
       * @return {var} the value of the cell.
       */
      getValueById : function(p, q){
      },
      /**
       * Sets a cell value by column index.
       *
       * @abstract
       * @param columnIndex {Integer} The index of the column.
       * @param rowIndex {Integer} the index of the row.
       * @param value {var} The new value.
       * @return {void}
       * @see #setValueById
       */
      setValue : function(r, s, t){
      },
      /**
       * Sets a cell value by column ID.
       *
       * Whenever you have the choice, use {@link #setValue()} instead,
       * because this should be faster.
       *
       * @param columnId {String} The ID of the column.
       * @param rowIndex {Integer} The index of the row.
       * @param value {var} The new value.
       */
      setValueById : function(u, v, w){
      }
    }
  });
})();
(function(){

  var l = "abstract",k = "columnIdArr and columnNameArr have different length: ",j = "getValue is abstract",h = "qx.ui.table.model.Abstract",g = "qx.event.type.Event",f = "this.__columnIdArr and columnNameArr have different length: ",e = "setValue is abstract",d = "getRowCount is abstract",c = " != ",b = "metaDataChanged",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * An abstract table model that performs the column handling, so subclasses only
   * need to care for row handling.
   */
  qx.Class.define(h, {
    type : l,
    extend : qx.core.Object,
    implement : qx.ui.table.ITableModel,
    events : {
      /**
       * Fired when the table data changed (the stuff shown in the table body).
       * The data property of the event will be a map having the following
       * attributes:
       * <ul>
       *   <li>firstRow: The index of the first row that has changed.</li>
       *   <li>lastRow: The index of the last row that has changed.</li>
       *   <li>firstColumn: The model index of the first column that has changed.</li>
       *   <li>lastColumn: The model index of the last column that has changed.</li>
       * </ul>
       *
       * Additionally, if the data changed as a result of rows being removed
       * from the data model, then these additional attributes will be in the
       * data:
       * <ul>
       *   <li>removeStart: The model index of the first row that was removed.</li>
       *   <li>removeCount: The number of rows that were removed.</li>
       * </ul>
       */
      "dataChanged" : a,
      /**
       * Fired when the meta data changed (the stuff shown in the table header).
       */
      "metaDataChanged" : g,
      /**
       * Fired after the table is sorted (but before the metaDataChanged event)
       */
      "sorted" : a
    },
    construct : function(){

      qx.core.Object.call(this);
      this.__columnIdArr = [];
      this.__columnNameArr = [];
      this.__columnIndexMap = {
      };
    },
    members : {
      __columnIdArr : null,
      __columnNameArr : null,
      __columnIndexMap : null,
      __internalChange : null,
      /**
       * Initialize the table model <--> table interaction. The table model is
       * passed to the table constructor, but the table model doesn't otherwise
       * know anything about the table nor can it operate on table
       * properties. This function provides the capability for the table model
       * to specify characteristics of the table. It is called when the table
       * model is applied to the table.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this model is attached
       */
      init : function(m){
      },
      /**
       * Abstract method
       * @throws {Error} An error if this method is called.
       */
      getRowCount : function(){

        throw new Error(d);
      },
      getRowData : function(n){

        return null;
      },
      isColumnEditable : function(o){

        return false;
      },
      isColumnSortable : function(p){

        return false;
      },
      sortByColumn : function(q, r){
      },
      getSortColumnIndex : function(){

        return -1;
      },
      isSortAscending : function(){

        return true;
      },
      prefetchRows : function(s, t){
      },
      /**
       * Abstract method
       *
       * @param columnIndex {Integer} the index of the column
       * @param rowIndex {Integer} the index of the row
       *
       * @throws {Error} An error if this method is called.
       */
      getValue : function(u, v){

        throw new Error(j);
      },
      getValueById : function(w, x){

        return this.getValue(this.getColumnIndexById(w), x);
      },
      /**
       * Abstract method
       *
       * @param columnIndex {Integer} index of the column
       * @param rowIndex {Integer} index of the row
       * @param value {Var} Value to be set
       *
       * @throws {Error} An error if this method is called.
       */
      setValue : function(y, z, A){

        throw new Error(e);
      },
      setValueById : function(B, C, D){

        this.setValue(this.getColumnIndexById(B), C, D);
      },
      // overridden
      getColumnCount : function(){

        return this.__columnIdArr.length;
      },
      // overridden
      getColumnIndexById : function(E){

        return this.__columnIndexMap[E];
      },
      // overridden
      getColumnId : function(F){

        return this.__columnIdArr[F];
      },
      // overridden
      getColumnName : function(G){

        return this.__columnNameArr[G];
      },
      /**
       * Sets the column IDs. These IDs may be used internally to identify a
       * column.
       *
       * Note: This will clear previously set column names.
       *
       *
       * @param columnIdArr {String[]} the IDs of the columns.
       * @return {void}
       * @see #setColumns
       */
      setColumnIds : function(H){

        this.__columnIdArr = H;
        // Create the reverse map
        this.__columnIndexMap = {
        };
        for(var i = 0;i < H.length;i++){

          this.__columnIndexMap[H[i]] = i;
        };
        this.__columnNameArr = new Array(H.length);
        // Inform the listeners
        if(!this.__internalChange){

          this.fireEvent(b);
        };
      },
      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameArr {String[]} the names of the columns.
       * @return {void}
       * @throws {Error} If the amount of given columns is different from the table.
       * @see #setColumnIds
       */
      setColumnNamesByIndex : function(I){

        if(this.__columnIdArr.length != I.length){

          throw new Error(f + this.__columnIdArr.length + c + I.length);
        };
        this.__columnNameArr = I;
        // Inform the listeners
        this.fireEvent(b);
      },
      /**
       * Sets the column names. These names will be shown to the user.
       *
       * Note: The column IDs have to be defined before.
       *
       *
       * @param columnNameMap {Map} a map containing the column IDs as keys and the
       *          column name as values.
       * @return {void}
       * @see #setColumnIds
       */
      setColumnNamesById : function(J){

        this.__columnNameArr = new Array(this.__columnIdArr.length);
        for(var i = 0;i < this.__columnIdArr.length;++i){

          this.__columnNameArr[i] = J[this.__columnIdArr[i]];
        };
      },
      /**
       * Sets the column names (and optionally IDs)
       *
       * Note: You can not change the _number_ of columns this way.  The number
       *       of columns is highly intertwined in the entire table operation,
       *       and dynamically changing it would require as much work as just
       *       recreating your table.  If you must change the number of columns
       *       in a table then you should remove the table and add a new one.
       *
       * @param columnNameArr {String[]}
       *   The column names. These names will be shown to the user.
       *
       * @param columnIdArr {String[] ? null}
       *   The column IDs. These IDs may be used internally to identify a
       *   column. If null, the column names are used as IDs unless ID values
       *   have already been set. If ID values have already been set, they will
       *   continue to be used if no ID values are explicitly provided here.
       *
       * @throws {Error} If the amount of given columns is different from the table.
       *
       * @return {void}
       */
      setColumns : function(K, L){

        var M = this.__columnIdArr.length == 0 || L;
        if(L == null){

          if(this.__columnIdArr.length == 0){

            L = K;
          } else {

            L = this.__columnIdArr;
          };
        };
        if(L.length != K.length){

          throw new Error(k + L.length + c + K.length);
        };
        if(M){

          this.__internalChange = true;
          this.setColumnIds(L);
          this.__internalChange = false;
        };
        this.setColumnNamesByIndex(K);
      }
    },
    destruct : function(){

      this.__columnIdArr = this.__columnNameArr = this.__columnIndexMap = null;
    }
  });
})();
(function(){

  var h = "qx.ui.table.model.Simple",g = "Boolean",f = "this.__rowArr out of bounds: ",e = ")",d = " (0..",c = "sorted",b = "metaDataChanged",a = "dataChanged";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A simple table model that provides an API for changing the model data.
   */
  qx.Class.define(h, {
    extend : qx.ui.table.model.Abstract,
    construct : function(){

      qx.ui.table.model.Abstract.call(this);
      this.__rowArr = [];
      this.__sortColumnIndex = -1;
      // Array of objects, each with property "ascending" and "descending"
      this.__sortMethods = [];
      this.__editableColArr = null;
    },
    properties : {
      /**
       * Whether sorting should be case sensitive
       */
      caseSensitiveSorting : {
        check : g,
        init : true
      }
    },
    statics : {
      /**
       * Default ascendeing sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorAscending : function(k, l){

        var m = k[arguments.callee.columnIndex];
        var n = l[arguments.callee.columnIndex];
        if(qx.lang.Type.isNumber(m) && qx.lang.Type.isNumber(n)){

          var o = isNaN(m) ? isNaN(n) ? 0 : 1 : isNaN(n) ? -1 : null;
          if(o != null){

            return o;
          };
        };
        return (m > n) ? 1 : ((m == n) ? 0 : -1);
      },
      /**
       * Same as the Default ascending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveAscending : function(p, q){

        var r = (p[arguments.callee.columnIndex].toLowerCase ? p[arguments.callee.columnIndex].toLowerCase() : p[arguments.callee.columnIndex]);
        var s = (q[arguments.callee.columnIndex].toLowerCase ? q[arguments.callee.columnIndex].toLowerCase() : q[arguments.callee.columnIndex]);
        if(qx.lang.Type.isNumber(r) && qx.lang.Type.isNumber(s)){

          var t = isNaN(r) ? isNaN(s) ? 0 : 1 : isNaN(s) ? -1 : null;
          if(t != null){

            return t;
          };
        };
        return (r > s) ? 1 : ((r == s) ? 0 : -1);
      },
      /**
       * Default descending sort method to use if no custom method has been
       * provided.
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorDescending : function(u, v){

        var w = u[arguments.callee.columnIndex];
        var x = v[arguments.callee.columnIndex];
        if(qx.lang.Type.isNumber(w) && qx.lang.Type.isNumber(x)){

          var y = isNaN(w) ? isNaN(x) ? 0 : 1 : isNaN(x) ? -1 : null;
          if(y != null){

            return y;
          };
        };
        return (w < x) ? 1 : ((w == x) ? 0 : -1);
      },
      /**
       * Same as the Default descending sort method but using case insensitivity
       *
       * @param row1 {var} first row
       * @param row2 {var} second row
       * @return {Integer} 1 of row1 is > row2, -1 if row1 is < row2, 0 if row1 == row2
       */
      _defaultSortComparatorInsensitiveDescending : function(z, A){

        var B = (z[arguments.callee.columnIndex].toLowerCase ? z[arguments.callee.columnIndex].toLowerCase() : z[arguments.callee.columnIndex]);
        var C = (A[arguments.callee.columnIndex].toLowerCase ? A[arguments.callee.columnIndex].toLowerCase() : A[arguments.callee.columnIndex]);
        if(qx.lang.Type.isNumber(B) && qx.lang.Type.isNumber(C)){

          var D = isNaN(B) ? isNaN(C) ? 0 : 1 : isNaN(C) ? -1 : null;
          if(D != null){

            return D;
          };
        };
        return (B < C) ? 1 : ((B == C) ? 0 : -1);
      }
    },
    members : {
      __rowArr : null,
      __editableColArr : null,
      __sortableColArr : null,
      __sortMethods : null,
      __sortColumnIndex : null,
      __sortAscending : null,
      // overridden
      getRowData : function(E){

        var F = this.__rowArr[E];
        if(F == null || F.originalData == null){

          return F;
        } else {

          return F.originalData;
        };
      },
      /**
       * Returns the data of one row as map containing the column IDs as key and
       * the cell values as value. Also the meta data is included.
       *
       * @param rowIndex {Integer} the model index of the row.
       * @return {Map} a Map containing the column values.
       */
      getRowDataAsMap : function(G){

        var I = this.__rowArr[G];
        if(I != null){

          var H = {
          };
          // get the current set data
          for(var J = 0;J < this.getColumnCount();J++){

            H[this.getColumnId(J)] = I[J];
          };
          if(I.originalData != null){

            // merge in the meta data
            for(var K in I.originalData){

              if(H[K] == undefined){

                H[K] = I.originalData[K];
              };
            };
          };
          return H;
        };
        // may be null, which is ok
        return (I && I.originalData) ? I.originalData : null;
      },
      /**
       * Gets the whole data as an array of maps.
       *
       * Note: Individual items are retrieved by {@link #getRowDataAsMap}.
       */
      getDataAsMapArray : function(){

        var M = this.getRowCount();
        var L = [];
        for(var i = 0;i < M;i++){

          L.push(this.getRowDataAsMap(i));
        };
        return L;
      },
      /**
       * Sets all columns editable or not editable.
       *
       * @param editable {Boolean} whether all columns are editable.
       * @return {void}
       */
      setEditable : function(N){

        this.__editableColArr = [];
        for(var O = 0;O < this.getColumnCount();O++){

          this.__editableColArr[O] = N;
        };
        this.fireEvent(b);
      },
      /**
       * Sets whether a column is editable.
       *
       * @param columnIndex {Integer} the column of which to set the editable state.
       * @param editable {Boolean} whether the column should be editable.
       * @return {void}
       */
      setColumnEditable : function(P, Q){

        if(Q != this.isColumnEditable(P)){

          if(this.__editableColArr == null){

            this.__editableColArr = [];
          };
          this.__editableColArr[P] = Q;
          this.fireEvent(b);
        };
      },
      // overridden
      isColumnEditable : function(R){

        return this.__editableColArr ? (this.__editableColArr[R] == true) : false;
      },
      /**
       * Sets whether a column is sortable.
       *
       * @param columnIndex {Integer} the column of which to set the sortable state.
       * @param sortable {Boolean} whether the column should be sortable.
       */
      setColumnSortable : function(S, T){

        if(T != this.isColumnSortable(S)){

          if(this.__sortableColArr == null){

            this.__sortableColArr = [];
          };
          this.__sortableColArr[S] = T;
          this.fireEvent(b);
        };
      },
      // overridden
      isColumnSortable : function(U){

        return (this.__sortableColArr ? (this.__sortableColArr[U] !== false) : true);
      },
      // overridden
      sortByColumn : function(V, W){

        // NOTE: We use different comparators for ascending and descending,
        //     because comparators should be really fast.
        var ba;
        var Y = this.__sortMethods[V];
        if(Y){

          ba = (W ? Y.ascending : Y.descending);
        } else {

          if(this.getCaseSensitiveSorting()){

            ba = (W ? qx.ui.table.model.Simple._defaultSortComparatorAscending : qx.ui.table.model.Simple._defaultSortComparatorDescending);
          } else {

            ba = (W ? qx.ui.table.model.Simple._defaultSortComparatorInsensitiveAscending : qx.ui.table.model.Simple._defaultSortComparatorInsensitiveDescending);
          };
        };
        ba.columnIndex = V;
        this.__rowArr.sort(ba);
        this.__sortColumnIndex = V;
        this.__sortAscending = W;
        var X = {
          columnIndex : V,
          ascending : W
        };
        this.fireDataEvent(c, X);
        this.fireEvent(b);
      },
      /**
       * Specify the methods to use for ascending and descending sorts of a
       * particular column.
       *
       * @param columnIndex {Integer}
       *   The index of the column for which the sort methods are being
       *   provided.
       *
       * @param compare {Function|Map}
       *   If provided as a Function, this is the comparator function to sort in
       *   ascending order. It takes two parameters: the two arrays of row data,
       *   row1 and row2, being compared. It may determine which column of the
       *   row data to sort on by accessing arguments.callee.columnIndex.  The
       *   comparator function must return 1, 0 or -1, when the column in row1
       *   is greater than, equal to, or less than, respectively, the column in
       *   row2.
       *
       *   If this parameter is a Map, it shall have two properties: "ascending"
       *   and "descending". The property value of each is a comparator
       *   function, as described above.
       *
       *   If only the "ascending" function is provided (i.e. this parameter is
       *   a Function, not a Map), then the "descending" function is built
       *   dynamically by passing the two parameters to the "ascending" function
       *   in reversed order. <i>Use of a dynamically-built "descending" function
       *   generates at least one extra function call for each row in the table,
       *   and possibly many more. If the table is expected to have more than
       *   about 1000 rows, you will likely want to provide a map with a custom
       *   "descending" sort function as well as the "ascending" one.</i>
       *
       * @return {void}
       */
      setSortMethods : function(bb, bc){

        var bd;
        if(qx.lang.Type.isFunction(bc)){

          bd = {
            ascending : bc,
            descending : function(be, bf){

              return bc(bf, be);
            }
          };
        } else {

          bd = bc;
        };
        this.__sortMethods[bb] = bd;
      },
      /**
       * Returns the sortMethod(s) for a table column.
       *
       * @param columnIndex {Integer} The index of the column for which the sort
       *   methods are being  provided.
       *
       * @return {Map} a map with the two properties "ascending"
       *   and "descending" for the specified column.
       *   The property value of each is a comparator function, as described
       *   in {@link #setSortMethods}.
       */
      getSortMethods : function(bg){

        return this.__sortMethods[bg];
      },
      /**
       * Clears the sorting.
       */
      clearSorting : function(){

        if(this.__sortColumnIndex != -1){

          this.__sortColumnIndex = -1;
          this.__sortAscending = true;
          this.fireEvent(b);
        };
      },
      // overridden
      getSortColumnIndex : function(){

        return this.__sortColumnIndex;
      },
      /**
       * Set the sort column index
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param columnIndex {Integer} index of the column
       */
      _setSortColumnIndex : function(bh){

        this.__sortColumnIndex = bh;
      },
      // overridden
      isSortAscending : function(){

        return this.__sortAscending;
      },
      /**
       * Set whether to sort in ascending order or not.
       *
       * WARNING: This should be called only by subclasses with intimate
       *          knowledge of what they are doing!
       *
       * @param ascending {Boolean}
       *   <i>true</i> for an ascending sort;
       *   <i> false</i> for a descending sort.
       */
      _setSortAscending : function(bi){

        this.__sortAscending = bi;
      },
      // overridden
      getRowCount : function(){

        return this.__rowArr.length;
      },
      // overridden
      getValue : function(bj, bk){

        if(bk < 0 || bk >= this.__rowArr.length){

          throw new Error(f + bk + d + this.__rowArr.length + e);
        };
        return this.__rowArr[bk][bj];
      },
      // overridden
      setValue : function(bl, bm, bn){

        if(this.__rowArr[bm][bl] != bn){

          this.__rowArr[bm][bl] = bn;
          // Inform the listeners
          if(this.hasListener(a)){

            var bo = {
              firstRow : bm,
              lastRow : bm,
              firstColumn : bl,
              lastColumn : bl
            };
            this.fireDataEvent(a, bo);
          };
          if(bl == this.__sortColumnIndex){

            this.clearSorting();
          };
        };
      },
      /**
       * Sets the whole data in a bulk.
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       * @return {void}
       */
      setData : function(bp, bq){

        this.__rowArr = bp;
        // Inform the listeners
        if(this.hasListener(a)){

          var br = {
            firstRow : 0,
            lastRow : bp.length - 1,
            firstColumn : 0,
            lastColumn : this.getColumnCount() - 1
          };
          this.fireDataEvent(a, br);
        };
        if(bq !== false){

          this.clearSorting();
        };
      },
      /**
       * Returns the data of this model.
       *
       * Warning: Do not alter this array! If you want to change the data use
       * {@link #setData}, {@link #setDataAsMapArray} or {@link #setValue} instead.
       *
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      getData : function(){

        return this.__rowArr;
      },
      /**
       * Sets the whole data in a bulk.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setDataAsMapArray : function(bs, bt, bu){

        this.setData(this._mapArray2RowArr(bs, bt), bu);
      },
      /**
       * Adds some rows to the model.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are appended to the end.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       * @return {void}
       */
      addRows : function(bv, bw, bx){

        if(bw == null){

          bw = this.__rowArr.length;
        };
        // Prepare the rowArr so it can be used for apply
        bv.splice(0, 0, bw, 0);
        // Insert the new rows
        Array.prototype.splice.apply(this.__rowArr, bv);
        // Inform the listeners
        var by = {
          firstRow : bw,
          lastRow : this.__rowArr.length - 1,
          firstColumn : 0,
          lastColumn : this.getColumnCount() - 1
        };
        this.fireDataEvent(a, by);
        if(bx !== false){

          this.clearSorting();
        };
      },
      /**
       * Adds some rows to the model.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      addRowsAsMapArray : function(bz, bA, bB, bC){

        this.addRows(this._mapArray2RowArr(bz, bB), bA, bC);
      },
      /**
       * Sets rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array will be altered!
       *
       * @param rowArr {var[][]} An array containing an array for each row. Each
       *          row-array contains the values in that row in the order of the columns
       *          in this model.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *          the rows are set from the beginning (0).
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       * @return {void}
       */
      setRows : function(bD, bE, bF){

        if(bE == null){

          bE = 0;
        };
        // Prepare the rowArr so it can be used for apply
        bD.splice(0, 0, bE, bD.length);
        // Replace rows
        Array.prototype.splice.apply(this.__rowArr, bD);
        // Inform the listeners
        var bG = {
          firstRow : bE,
          lastRow : this.__rowArr.length - 1,
          firstColumn : 0,
          lastColumn : this.getColumnCount() - 1
        };
        this.fireDataEvent(a, bG);
        if(bF !== false){

          this.clearSorting();
        };
      },
      /**
       * Set rows in the model. The rows overwrite the old rows starting at
       * <code>startIndex</code> to <code>startIndex+rowArr.length</code>.
       *
       * Warning: The given array (mapArr) will be altered!
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *        row-map contains the column IDs as key and the cell values as value.
       * @param startIndex {Integer ? null} The index where to insert the new rows. If null,
       *        the rows are appended to the end.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       */
      setRowsAsMapArray : function(bH, bI, bJ, bK){

        this.setRows(this._mapArray2RowArr(bH, bJ), bI, bK);
      },
      /**
       * Removes some rows from the model.
       *
       * @param startIndex {Integer} the index of the first row to remove.
       * @param howMany {Integer} the number of rows to remove.
       * @param clearSorting {Boolean ? true} Whether to clear the sort state.
       * @return {void}
       */
      removeRows : function(bL, bM, bN){

        this.__rowArr.splice(bL, bM);
        // Inform the listeners
        var bO = {
          firstRow : bL,
          lastRow : this.__rowArr.length - 1,
          firstColumn : 0,
          lastColumn : this.getColumnCount() - 1,
          removeStart : bL,
          removeCount : bM
        };
        this.fireDataEvent(a, bO);
        if(bN !== false){

          this.clearSorting();
        };
      },
      /**
       * Creates an array of maps to an array of arrays.
       *
       * @param mapArr {Map[]} An array containing a map for each row. Each
       *          row-map contains the column IDs as key and the cell values as value.
       * @param rememberMaps {Boolean ? false} Whether to remember the original maps.
       *        If true {@link #getRowData} will return the original map.
       * @return {var[][]} An array containing an array for each row. Each
       *           row-array contains the values in that row in the order of the columns
       *           in this model.
       */
      _mapArray2RowArr : function(bP, bQ){

        var bU = bP.length;
        var bR = this.getColumnCount();
        var bT = new Array(bU);
        var bS;
        for(var i = 0;i < bU;++i){

          bS = [];
          if(bQ){

            bS.originalData = bP[i];
          };
          for(var j = 0;j < bR;++j){

            bS[j] = bP[i][this.getColumnId(j)];
          };
          bT[i] = bS;
        };
        return bT;
      }
    },
    destruct : function(){

      this.__rowArr = this.__editableColArr = this.__sortMethods = this.__sortableColArr = null;
    }
  });
})();
(function(){

  var p = "_applyStatusBarVisible",o = "columnVisibilityMenuCreateStart",n = "blur",m = "qx.ui.table.Table",k = "columnVisibilityMenuCreateEnd",h = "changeVisible",g = "_applyResetSelectionOnHeaderClick",f = "_applyMetaColumnCounts",e = "focus",d = "changeDataRowRenderer",bH = "changeHeaderCellHeight",bG = "Escape",bF = "A",bE = "changeSelectionModel",bD = "Left",bC = "Down",bB = "Integer",bA = "_applyHeaderCellHeight",bz = "visibilityChanged",by = "qx.ui.table.ITableModel",w = "orderChanged",y = "_applySelectionModel",u = "menu-button",v = "menu",s = "_applyAdditionalStatusBarText",t = "_applyFocusCellOnMouseMove",q = "table",r = "_applyColumnVisibilityButtonVisible",F = "changeTableModel",G = "qx.event.type.Event",ba = "__columnMenuButtons",V = "tableWidthChanged",bi = "_applyHeaderCellsVisible",bd = "Object",bu = "_applyShowCellFocusIndicator",bo = "resize",O = "verticalScrollBarChanged",bx = "changeScrollY",bw = "_applyTableModel",bv = "__columnModel",M = "End",R = "_applyKeepFirstVisibleRowComplete",T = "widthChanged",X = "one of one row",bb = "Home",be = "_applyRowHeight",bk = "F2",bq = "Up",z = "%1 rows",A = "qx.ui.table.selection.Model",Q = "one row",bh = "__selectionManager",bg = "__timer",bf = "PageDown",bm = "%1 of %2 rows",bl = "keypress",bc = "changeRowHeight",bj = "Number",a = "_applyContextMenuFromDataCellsOnly",bp = "__scrollerParent",B = "qx.ui.table.IRowRenderer",C = "Right",W = "Space",b = "function",c = "PageUp",L = "dataChanged",D = "changeLocale",E = "changeSelection",K = "appear",Y = "qx.dynlocale",bs = '"',br = "Enter",S = "metaDataChanged",bt = "header",N = "__emptyTableModel",bn = "qx.ui.table.pane.CellEvent",H = "qx.event.type.Data",J = "statusbar",P = "column-button",U = "Function",I = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * Table
   *
   * A detailed description can be found in the package description
   * {@link qx.ui.table}.
   *
   * @childControl statusbar {qx.ui.basic.Label} label to show the status of the table
   * @childControl column-button {qx.ui.table.columnmenu.Button} button to open the column menu
   */
  qx.Class.define(m, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param tableModel {qx.ui.table.ITableModel ? null}
     *   The table model to read the data from.
     *
     * @param custom {Map ? null}
     *   A map provided to override the various supplemental classes allocated
     *   within this constructor.  Each property must be a function which
     *   returns an object instance, as indicated by shown the defaults listed
     *   here:
     *
     *   <dl>
     *     <dt>initiallyHiddenColumns</dt>
     *       <dd>
     *         {Array?}
     *         A list of column numbers that should be initially invisible. Any
     *         column not mentioned will be initially visible, and if no array
     *         is provided, all columns will be initially visible.
     *       </dd>
     *     <dt>selectionManager</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Manager(obj);
     *         }
     *       </pre></dd>
     *     <dt>selectionModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.selection.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tableColumnModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.columnmodel.Basic(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePane</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Pane(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneHeader</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Header(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneScroller</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Scroller(obj);
     *         }
     *       </pre></dd>
     *     <dt>tablePaneModel</dt>
     *       <dd><pre class='javascript'>
     *         function(obj)
     *         {
     *           return new qx.ui.table.pane.Model(obj);
     *         }
     *       </pre></dd>
     *     <dt>columnMenu</dt>
     *       <dd><pre class='javascript'>
     *         function()
     *         {
     *           return new qx.ui.table.columnmenu.Button();
     *         }
     *       </pre></dd>
     *   </dl>
     */
    construct : function(bI, bJ){

      qx.ui.core.Widget.call(this);
      //
      // Use default objects if custom objects are not specified
      //
      if(!bJ){

        bJ = {
        };
      };
      if(bJ.initiallyHiddenColumns){

        this.setInitiallyHiddenColumns(bJ.initiallyHiddenColumns);
      };
      if(bJ.selectionManager){

        this.setNewSelectionManager(bJ.selectionManager);
      };
      if(bJ.selectionModel){

        this.setNewSelectionModel(bJ.selectionModel);
      };
      if(bJ.tableColumnModel){

        this.setNewTableColumnModel(bJ.tableColumnModel);
      };
      if(bJ.tablePane){

        this.setNewTablePane(bJ.tablePane);
      };
      if(bJ.tablePaneHeader){

        this.setNewTablePaneHeader(bJ.tablePaneHeader);
      };
      if(bJ.tablePaneScroller){

        this.setNewTablePaneScroller(bJ.tablePaneScroller);
      };
      if(bJ.tablePaneModel){

        this.setNewTablePaneModel(bJ.tablePaneModel);
      };
      if(bJ.columnMenu){

        this.setNewColumnMenu(bJ.columnMenu);
      };
      this._setLayout(new qx.ui.layout.VBox());
      // Create the child widgets
      this.__scrollerParent = new qx.ui.container.Composite(new qx.ui.layout.HBox());
      this._add(this.__scrollerParent, {
        flex : 1
      });
      // Allocate a default data row renderer
      this.setDataRowRenderer(new qx.ui.table.rowrenderer.Default(this));
      // Create the models
      this.__selectionManager = this.getNewSelectionManager()(this);
      this.setSelectionModel(this.getNewSelectionModel()(this));
      this.setTableModel(bI || this.getEmptyTableModel());
      // create the main meta column
      this.setMetaColumnCounts([-1]);
      // Make focusable
      this.setTabIndex(1);
      this.addListener(bl, this._onKeyPress);
      this.addListener(e, this._onFocusChanged);
      this.addListener(n, this._onFocusChanged);
      // attach the resize listener to the last child of the layout. This
      // ensures that all other children are laid out before
      var bK = new qx.ui.core.Widget().set({
        height : 0
      });
      this._add(bK);
      bK.addListener(bo, this._onResize, this);
      this.__focusedCol = null;
      this.__focusedRow = null;
      // add an event listener which updates the table content on locale change
      if(qx.core.Environment.get(Y)){

        qx.locale.Manager.getInstance().addListener(D, this._onChangeLocale, this);
      };
      this.initStatusBarVisible();
      // If the table model has an init() method...
      bI = this.getTableModel();
      if(bI.init && typeof (bI.init) == b){

        // ... then call it now to allow the table model to affect table
        // properties.
        bI.init(this);
      };
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Dispatched before adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the top of the
       * menu.
       */
      "columnVisibilityMenuCreateStart" : H,
      /**
       * Dispatched after adding the column list to the column visibility menu.
       * The event data is a map with two properties: table and menu.  Listeners
       * may add additional items to the menu, which appear at the bottom of the
       * menu.
       */
      "columnVisibilityMenuCreateEnd" : H,
      /**
       * Dispatched when the width of the table has changed.
       */
      "tableWidthChanged" : G,
      /**
       * Dispatched when updating scrollbars discovers that a vertical scrollbar
       * is needed when it previously was not, or vice versa.  The data is a
       * boolean indicating whether a vertical scrollbar is now being used.
       */
      "verticalScrollBarChanged" : H,
      /**
       * Dispatched when a data cell has been clicked.
       */
      "cellClick" : bn,
      /**
       * Dispatched when a data cell has been clicked.
       */
      "cellDblclick" : bn,
      /**
       * Dispatched when the context menu is needed in a data cell
       */
      "cellContextmenu" : bn,
      /**
       * Dispatched after a cell editor is flushed.
       *
       * The data is a map containing this properties:
       * <ul>
       *   <li>row</li>
       *   <li>col</li>
       *   <li>value</li>
       *   <li>oldValue</li>
       * </ul>
       */
      "dataEdited" : H
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Events that must be redirected to the scrollers. */
      __redirectEvents : {
        cellClick : 1,
        cellDblclick : 1,
        cellContextmenu : 1
      }
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      appearance : {
        refine : true,
        init : q
      },
      focusable : {
        refine : true,
        init : true
      },
      minWidth : {
        refine : true,
        init : 50
      },
      /**
       * The list of columns that are initially hidden. This property is set by
       * the constructor, from the value received in
       * custom.initiallyHiddenColumns, and is only used when a column model is
       * initialized. It can be of great benefit in tables with numerous columns
       * where most are not initially visible. The process of creating the
       * headers for all of the columns, only to have those columns discarded
       * shortly thereafter when setColumnVisibility(false) is called, is a
       * waste of (significant, in some browsers) time. Specifying the
       * non-visible columns at constructor time can therefore avoid the initial
       * creation of all of those superfluous widgets.
       */
      initiallyHiddenColumns : {
        init : null
      },
      /**
       * Whether the widget contains content which may be selected by the user.
       *
       * If the value set to <code>true</code> the native browser selection can
       * be used for text selection. But it is normally useful for
       * forms fields, longer texts/documents, editors, etc.
       *
       * Note: This has no effect on Table!
       */
      selectable : {
        refine : true,
        init : false
      },
      /** The selection model. */
      selectionModel : {
        check : A,
        apply : y,
        event : bE
      },
      /** The table model. */
      tableModel : {
        check : by,
        apply : bw,
        event : F
      },
      /** The height of the table rows. */
      rowHeight : {
        check : bj,
        init : 20,
        apply : be,
        event : bc,
        themeable : true
      },
      /**
       * Force line height to match row height.  May be disabled if cell
       * renderers being used wish to render multiple lines of data within a
       * cell.  (With the default setting, all but the first of multiple lines
       * of data will not be visible.)
       */
      forceLineHeight : {
        check : I,
        init : true
      },
      /**
       *  Whether the header cells are visible. When setting this to false,
       *  you'll likely also want to set the {#columnVisibilityButtonVisible}
       *  property to false as well, to entirely remove the header row.
       */
      headerCellsVisible : {
        check : I,
        init : true,
        apply : bi,
        themeable : true
      },
      /** The height of the header cells. */
      headerCellHeight : {
        check : bB,
        init : 16,
        apply : bA,
        event : bH,
        nullable : true,
        themeable : true
      },
      /** Whether to show the status bar */
      statusBarVisible : {
        check : I,
        init : true,
        apply : p
      },
      /** The Statusbartext, set it, if you want some more Information */
      additionalStatusBarText : {
        nullable : true,
        init : null,
        apply : s
      },
      /** Whether to show the column visibility button */
      columnVisibilityButtonVisible : {
        check : I,
        init : true,
        apply : r,
        themeable : true
      },
      /**
       * {Integer[]} The number of columns per meta column. If the last array entry is -1,
       * this meta column will get the remaining columns.
       */
      metaColumnCounts : {
        check : bd,
        apply : f
      },
      /**
       * Whether the focus should moved when the mouse is moved over a cell. If false
       * the focus is only moved on mouse clicks.
       */
      focusCellOnMouseMove : {
        check : I,
        init : false,
        apply : t
      },
      /**
       * Whether row focus change by keyboard also modifies selection
       */
      rowFocusChangeModifiesSelection : {
        check : I,
        init : true
      },
      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator : {
        check : I,
        init : true,
        apply : bu
      },
      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly : {
        check : I,
        init : true,
        apply : a
      },
      /**
       * Whether the table should keep the first visible row complete. If set to false,
       * the first row may be rendered partial, depending on the vertical scroll value.
       */
      keepFirstVisibleRowComplete : {
        check : I,
        init : true,
        apply : R
      },
      /**
       * Whether the table cells should be updated when only the selection or the
       * focus changed. This slows down the table update but allows to react on a
       * changed selection or a changed focus in a cell renderer.
       */
      alwaysUpdateCells : {
        check : I,
        init : false
      },
      /**
       * Whether to reset the selection when a header cell is clicked. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderClick : {
        check : I,
        init : true,
        apply : g
      },
      /** The renderer to use for styling the rows. */
      dataRowRenderer : {
        check : B,
        init : null,
        nullable : true,
        event : d
      },
      /**
       * A function to call when before modal cell editor is opened.
       *
       * @signature function(cellEditor, cellInfo)
       *
       * @param cellEditor {qx.ui.window.Window}
       *   The modal window which has been created for this cell editor
       *
       * @param cellInfo {Map}
       *   Information about the cell for which this cell editor was created.
       *   It contains the following properties:
       *       col, row, xPos, value
       *
       * @return {void}
       */
      modalCellEditorPreOpenFunction : {
        check : U,
        init : null,
        nullable : true
      },
      /**
       * A function to instantiate a new column menu button.
       */
      newColumnMenu : {
        check : U,
        init : function(){

          return new qx.ui.table.columnmenu.Button();
        }
      },
      /**
       * A function to instantiate a selection manager.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionManager : {
        check : U,
        init : function(bL){

          return new qx.ui.table.selection.Manager(bL);
        }
      },
      /**
       * A function to instantiate a selection model.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property must
       * be set before calling the Table constructor.
       */
      newSelectionModel : {
        check : U,
        init : function(bM){

          return new qx.ui.table.selection.Model(bM);
        }
      },
      /**
       * A function to instantiate a table column model.  This allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTableColumnModel : {
        check : U,
        init : function(bN){

          return new qx.ui.table.columnmodel.Basic(bN);
        }
      },
      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePane : {
        check : U,
        init : function(bO){

          return new qx.ui.table.pane.Pane(bO);
        }
      },
      /**
       * A function to instantiate a table pane.  this allows subclasses of
       * Table to subclass this internal class.  To take effect, this property
       * must be set before calling the Table constructor.
       */
      newTablePaneHeader : {
        check : U,
        init : function(bP){

          return new qx.ui.table.pane.Header(bP);
        }
      },
      /**
       * A function to instantiate a table pane scroller.  this allows
       * subclasses of Table to subclass this internal class.  To take effect,
       * this property must be set before calling the Table constructor.
       */
      newTablePaneScroller : {
        check : U,
        init : function(bQ){

          return new qx.ui.table.pane.Scroller(bQ);
        }
      },
      /**
       * A function to instantiate a table pane model.  this allows subclasses
       * of Table to subclass this internal class.  To take effect, this
       * property must be set before calling the Table constructor.
       */
      newTablePaneModel : {
        check : U,
        init : function(bR){

          return new qx.ui.table.pane.Model(bR);
        }
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __focusedCol : null,
      __focusedRow : null,
      __scrollerParent : null,
      __selectionManager : null,
      __additionalStatusBarText : null,
      __lastRowCount : null,
      __internalChange : null,
      __columnMenuButtons : null,
      __columnModel : null,
      __emptyTableModel : null,
      __hadVerticalScrollBar : null,
      __timer : null,
      // overridden
      _createChildControlImpl : function(bS, bT){

        var bU;
        switch(bS){case J:
        bU = new qx.ui.basic.Label();
        bU.set({
          allowGrowX : true
        });
        this._add(bU);
        break;case P:
        bU = this.getNewColumnMenu()();
        bU.set({
          focusable : false
        });
        // Create the initial menu too
        var bV = bU.factory(v, {
          table : this
        });
        // Add a listener to initialize the column menu when it becomes visible
        bV.addListener(K, this._initColumnMenu, this);
        break;};
        return bU || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, bS);
      },
      // property modifier
      _applySelectionModel : function(bW, bX){

        this.__selectionManager.setSelectionModel(bW);
        if(bX != null){

          bX.removeListener(E, this._onSelectionChanged, this);
        };
        bW.addListener(E, this._onSelectionChanged, this);
      },
      // property modifier
      _applyRowHeight : function(bY, ca){

        var cb = this._getPaneScrollerArr();
        for(var i = 0;i < cb.length;i++){

          cb[i].updateVerScrollBarMaximum();
        };
      },
      // property modifier
      _applyHeaderCellsVisible : function(cc, cd){

        var ce = this._getPaneScrollerArr();
        for(var i = 0;i < ce.length;i++){

          if(cc){

            ce[i]._showChildControl(bt);
          } else {

            ce[i]._excludeChildControl(bt);
          };
        };
        // also hide the column visibility button
        if(this.getColumnVisibilityButtonVisible()){

          this._applyColumnVisibilityButtonVisible(cc);
        };
      },
      // property modifier
      _applyHeaderCellHeight : function(cf, cg){

        var ch = this._getPaneScrollerArr();
        for(var i = 0;i < ch.length;i++){

          ch[i].getHeader().setHeight(cf);
        };
      },
      /**
       * Get an empty table model instance to use for this table. Use this table
       * to configure the table with no table model.
       *
       * @return {qx.ui.table.ITableModel} The empty table model
       */
      getEmptyTableModel : function(){

        if(!this.__emptyTableModel){

          this.__emptyTableModel = new qx.ui.table.model.Simple();
          this.__emptyTableModel.setColumns([]);
          this.__emptyTableModel.setData([]);
        };
        return this.__emptyTableModel;
      },
      // property modifier
      _applyTableModel : function(ci, cj){

        this.getTableColumnModel().init(ci.getColumnCount(), this);
        if(cj != null){

          cj.removeListener(S, this._onTableModelMetaDataChanged, this);
          cj.removeListener(L, this._onTableModelDataChanged, this);
        };
        ci.addListener(S, this._onTableModelMetaDataChanged, this);
        ci.addListener(L, this._onTableModelDataChanged, this);
        // Update the status bar
        this._updateStatusBar();
        this._updateTableData(0, ci.getRowCount(), 0, ci.getColumnCount());
        this._onTableModelMetaDataChanged();
        // If the table model has an init() method, call it. We don't, however,
        // call it if this is the initial setting of the table model, as the
        // scrollers are not yet initialized. In that case, the init method is
        // called explicitly by the Table constructor.
        if(cj && ci.init && typeof (ci.init) == b){

          ci.init(this);
        };
      },
      /**
       * Get the The table column model.
       *
       * @return {qx.ui.table.columnmodel.Basic} The table's column model
       */
      getTableColumnModel : function(){

        if(!this.__columnModel){

          var cn = this.__columnModel = this.getNewTableColumnModel()(this);
          cn.addListener(bz, this._onColVisibilityChanged, this);
          cn.addListener(T, this._onColWidthChanged, this);
          cn.addListener(w, this._onColOrderChanged, this);
          // Get the current table model
          var cm = this.getTableModel();
          cn.init(cm.getColumnCount(), this);
          // Reset the table column model in each table pane model
          var ck = this._getPaneScrollerArr();
          for(var i = 0;i < ck.length;i++){

            var cl = ck[i];
            var co = cl.getTablePaneModel();
            co.setTableColumnModel(cn);
          };
        };
        return this.__columnModel;
      },
      // property modifier
      _applyStatusBarVisible : function(cp, cq){

        if(cp){

          this._showChildControl(J);
        } else {

          this._excludeChildControl(J);
        };
        if(cp){

          this._updateStatusBar();
        };
      },
      // property modifier
      _applyAdditionalStatusBarText : function(cr, cs){

        this.__additionalStatusBarText = cr;
        this._updateStatusBar();
      },
      // property modifier
      _applyColumnVisibilityButtonVisible : function(ct, cu){

        if(ct){

          this._showChildControl(P);
        } else {

          this._excludeChildControl(P);
        };
      },
      // property modifier
      _applyMetaColumnCounts : function(cv, cw){

        var cD = cv;
        var cx = this._getPaneScrollerArr();
        var cB = {
        };
        if(cv > cw){

          // Save event listeners on the redirected events so we can re-apply
          // them to new scrollers.
          var cF = qx.event.Registration.getManager(cx[0]);
          for(var cG in qx.ui.table.Table.__redirectEvents){

            cB[cG] = {
            };
            cB[cG].capture = cF.getListeners(cx[0], cG, true);
            cB[cG].bubble = cF.getListeners(cx[0], cG, false);
          };
        };
        // Remove the panes not needed any more
        this._cleanUpMetaColumns(cD.length);
        // Update the old panes
        var cC = 0;
        for(var i = 0;i < cx.length;i++){

          var cH = cx[i];
          var cE = cH.getTablePaneModel();
          cE.setFirstColumnX(cC);
          cE.setMaxColumnCount(cD[i]);
          cC += cD[i];
        };
        // Add the new panes
        if(cD.length > cx.length){

          var cA = this.getTableColumnModel();
          for(var i = cx.length;i < cD.length;i++){

            var cE = this.getNewTablePaneModel()(cA);
            cE.setFirstColumnX(cC);
            cE.setMaxColumnCount(cD[i]);
            cC += cD[i];
            var cH = this.getNewTablePaneScroller()(this);
            cH.setTablePaneModel(cE);
            // Register event listener for vertical scrolling
            cH.addListener(bx, this._onScrollY, this);
            // Apply redirected events to this new scroller
            for(cG in qx.ui.table.Table.__redirectEvents){

              // On first setting of meta columns (constructing phase), there
              // are no handlers to deal with yet.
              if(!cB[cG]){

                break;
              };
              if(cB[cG].capture && cB[cG].capture.length > 0){

                var cy = cB[cG].capture;
                for(var j = 0;j < cy.length;j++){

                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var cz = cy[j].context;
                  if(!cz){

                    cz = this;
                  } else if(cz == cx[0]){

                    cz = cH;
                  };
                  cH.addListener(cG, cy[j].handler, cz, true);
                };
              };
              if(cB[cG].bubble && cB[cG].bubble.length > 0){

                var cJ = cB[cG].bubble;
                for(var j = 0;j < cJ.length;j++){

                  // Determine what context to use.  If the context does not
                  // exist, we assume that the context is this table.  If it
                  // does exist and it equals the first pane scroller (from
                  // which we retrieved the listeners) then set the context
                  // to be this new pane scroller.  Otherwise leave the context
                  // as it was set.
                  var cz = cJ[j].context;
                  if(!cz){

                    cz = this;
                  } else if(cz == cx[0]){

                    cz = cH;
                  };
                  cH.addListener(cG, cJ[j].handler, cz, false);
                };
              };
            };
            // last meta column is flexible
            var cI = (i == cD.length - 1) ? 1 : 0;
            this.__scrollerParent.add(cH, {
              flex : cI
            });
            cx = this._getPaneScrollerArr();
          };
        };
        // Update all meta columns
        for(var i = 0;i < cx.length;i++){

          var cH = cx[i];
          var cK = (i == (cx.length - 1));
          // Set the right header height
          cH.getHeader().setHeight(this.getHeaderCellHeight());
          // Put the column visibility button in the top right corner of the last meta column
          cH.setTopRightWidget(cK ? this.getChildControl(P) : null);
        };
        if(!this.isColumnVisibilityButtonVisible()){

          this._excludeChildControl(P);
        };
        this._updateScrollerWidths();
        this._updateScrollBarVisibility();
      },
      // property modifier
      _applyFocusCellOnMouseMove : function(cL, cM){

        var cN = this._getPaneScrollerArr();
        for(var i = 0;i < cN.length;i++){

          cN[i].setFocusCellOnMouseMove(cL);
        };
      },
      // property modifier
      _applyShowCellFocusIndicator : function(cO, cP){

        var cQ = this._getPaneScrollerArr();
        for(var i = 0;i < cQ.length;i++){

          cQ[i].setShowCellFocusIndicator(cO);
        };
      },
      // property modifier
      _applyContextMenuFromDataCellsOnly : function(cR, cS){

        var cT = this._getPaneScrollerArr();
        for(var i = 0;i < cT.length;i++){

          cT[i].setContextMenuFromDataCellsOnly(cR);
        };
      },
      // property modifier
      _applyKeepFirstVisibleRowComplete : function(cU, cV){

        var cW = this._getPaneScrollerArr();
        for(var i = 0;i < cW.length;i++){

          cW[i].onKeepFirstVisibleRowCompleteChanged();
        };
      },
      // property modifier
      _applyResetSelectionOnHeaderClick : function(cX, cY){

        var da = this._getPaneScrollerArr();
        for(var i = 0;i < da.length;i++){

          da[i].setResetSelectionOnHeaderClick(cX);
        };
      },
      /**
       * Returns the selection manager.
       *
       * @return {qx.ui.table.selection.Manager} the selection manager.
       */
      getSelectionManager : function(){

        return this.__selectionManager;
      },
      /**
       * Returns an array containing all TablePaneScrollers in this table.
       *
       * @return {qx.ui.table.pane.Scroller[]} all TablePaneScrollers in this table.
       */
      _getPaneScrollerArr : function(){

        return this.__scrollerParent.getChildren();
      },
      /**
       * Returns a TablePaneScroller of this table.
       *
       * @param metaColumn {Integer} the meta column to get the TablePaneScroller for.
       * @return {qx.ui.table.pane.Scroller} the qx.ui.table.pane.Scroller.
       */
      getPaneScroller : function(db){

        return this._getPaneScrollerArr()[db];
      },
      /**
       * Cleans up the meta columns.
       *
       * @param fromMetaColumn {Integer} the first meta column to clean up. All following
       *      meta columns will be cleaned up, too. All previous meta columns will
       *      stay unchanged. If 0 all meta columns will be cleaned up.
       * @return {void}
       */
      _cleanUpMetaColumns : function(dc){

        var dd = this._getPaneScrollerArr();
        if(dd != null){

          for(var i = dd.length - 1;i >= dc;i--){

            dd[i].destroy();
          };
        };
      },
      /**
       * Event handler. Called when the locale has changed.
       *
       * @param evt {Event} the event.
       * @return {void}
       */
      _onChangeLocale : function(de){

        this.updateContent();
        this._updateStatusBar();
      },
      /**
       * Event handler. Called when the selection has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onSelectionChanged : function(df){

        var dg = this._getPaneScrollerArr();
        for(var i = 0;i < dg.length;i++){

          dg[i].onSelectionChanged();
        };
        this._updateStatusBar();
      },
      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onTableModelMetaDataChanged : function(dh){

        var di = this._getPaneScrollerArr();
        for(var i = 0;i < di.length;i++){

          di[i].onTableModelMetaDataChanged();
        };
        this._updateStatusBar();
      },
      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onTableModelDataChanged : function(dj){

        var dk = dj.getData();
        this._updateTableData(dk.firstRow, dk.lastRow, dk.firstColumn, dk.lastColumn, dk.removeStart, dk.removeCount);
      },
      /**
       * To update the table if the table model has changed and remove selection.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       * @param removeStart {Integer ? null} The first index of the interval (including), to remove selection.
       * @param removeCount {Integer ? null} The count of the interval, to remove selection.
       * @return {void}
       */
      _updateTableData : function(dl, dm, dn, dp, dq, dr){

        var ds = this._getPaneScrollerArr();
        // update selection if rows were removed
        if(dr){

          this.getSelectionModel().removeSelectionInterval(dq, dq + dr);
          // remove focus if the focused row has been removed
          if(this.__focusedRow >= dq && this.__focusedRow < (dq + dr)){

            this.setFocusedCell();
          };
        };
        for(var i = 0;i < ds.length;i++){

          ds[i].onTableModelDataChanged(dl, dm, dn, dp);
        };
        var dt = this.getTableModel().getRowCount();
        if(dt != this.__lastRowCount){

          this.__lastRowCount = dt;
          this._updateScrollBarVisibility();
          this._updateStatusBar();
        };
      },
      /**
       * Event handler. Called when a TablePaneScroller has been scrolled vertically.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onScrollY : function(du){

        if(!this.__internalChange){

          this.__internalChange = true;
          // Set the same scroll position to all meta columns
          var dv = this._getPaneScrollerArr();
          for(var i = 0;i < dv.length;i++){

            dv[i].setScrollY(du.getData());
          };
          this.__internalChange = false;
        };
      },
      /**
       * Event handler. Called when a key was pressed.
       *
       * @param evt {qx.event.type.KeySequence} the event.
       * @return {void}
       */
      _onKeyPress : function(dw){

        if(!this.getEnabled()){

          return;
        };
        // No editing mode
        var dD = this.__focusedRow;
        var dA = true;
        // Handle keys that are independent from the modifiers
        var dE = dw.getKeyIdentifier();
        if(this.isEditing()){

          // Editing mode
          if(dw.getModifiers() == 0){

            switch(dE){case br:
            this.stopEditing();
            var dD = this.__focusedRow;
            this.moveFocusedCell(0, 1);
            if(this.__focusedRow != dD){

              dA = this.startEditing();
            };
            break;case bG:
            this.cancelEditing();
            this.focus();
            break;default:
            dA = false;
            break;};
          };
        } else {

          // No editing mode
          if(dw.isCtrlPressed()){

            // Handle keys that depend on modifiers
            dA = true;
            switch(dE){case bF:
            // Ctrl + A
            var dB = this.getTableModel().getRowCount();
            if(dB > 0){

              this.getSelectionModel().setSelectionInterval(0, dB - 1);
            };
            break;default:
            dA = false;
            break;};
          } else {

            // Handle keys that are independent from the modifiers
            switch(dE){case W:
            this.__selectionManager.handleSelectKeyDown(this.__focusedRow, dw);
            break;case bk:case br:
            this.startEditing();
            dA = true;
            break;case bb:
            this.setFocusedCell(this.__focusedCol, 0, true);
            break;case M:
            var dB = this.getTableModel().getRowCount();
            this.setFocusedCell(this.__focusedCol, dB - 1, true);
            break;case bD:
            this.moveFocusedCell(-1, 0);
            break;case C:
            this.moveFocusedCell(1, 0);
            break;case bq:
            this.moveFocusedCell(0, -1);
            break;case bC:
            this.moveFocusedCell(0, 1);
            break;case c:case bf:
            var dz = this.getPaneScroller(0);
            var dC = dz.getTablePane();
            var dy = this.getRowHeight();
            var dx = (dE == c) ? -1 : 1;
            dB = dC.getVisibleRowCount() - 1;
            dz.setScrollY(dz.getScrollY() + dx * dB * dy);
            this.moveFocusedCell(0, dx * dB);
            break;default:
            dA = false;};
          };
        };
        if(dD != this.__focusedRow && this.getRowFocusChangeModifiesSelection()){

          // The focus moved -> Let the selection manager handle this event
          this.__selectionManager.handleMoveKeyDown(this.__focusedRow, dw);
        };
        if(dA){

          dw.preventDefault();
          dw.stopPropagation();
        };
      },
      /**
       * Event handler. Called when the table gets the focus.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onFocusChanged : function(dF){

        var dG = this._getPaneScrollerArr();
        for(var i = 0;i < dG.length;i++){

          dG[i].onFocusChanged();
        };
      },
      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onColVisibilityChanged : function(dH){

        var dI = this._getPaneScrollerArr();
        for(var i = 0;i < dI.length;i++){

          dI[i].onColVisibilityChanged();
        };
        var dJ = dH.getData();
        if(this.__columnMenuButtons != null && dJ.col != null && dJ.visible != null){

          this.__columnMenuButtons[dJ.col].setVisible(dJ.visible);
        };
        this._updateScrollerWidths();
        this._updateScrollBarVisibility();
      },
      /**
       * Event handler. Called when the width of a column has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onColWidthChanged : function(dK){

        var dL = this._getPaneScrollerArr();
        for(var i = 0;i < dL.length;i++){

          var dM = dK.getData();
          dL[i].setColumnWidth(dM.col, dM.newWidth);
        };
        this._updateScrollerWidths();
        this._updateScrollBarVisibility();
      },
      /**
       * Event handler. Called when the column order has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onColOrderChanged : function(dN){

        var dO = this._getPaneScrollerArr();
        for(var i = 0;i < dO.length;i++){

          dO[i].onColOrderChanged();
        };
        // A column may have been moved between meta columns
        this._updateScrollerWidths();
        this._updateScrollBarVisibility();
      },
      /**
       * Gets the TablePaneScroller at a certain x position in the page. If there is
       * no TablePaneScroller at this position, null is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller or null.
       */
      getTablePaneScrollerAtPageX : function(dP){

        var dQ = this._getMetaColumnAtPageX(dP);
        return (dQ != -1) ? this.getPaneScroller(dQ) : null;
      },
      /**
       * Sets the currently focused cell. A value of <code>null</code> hides the
       * focus cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param scrollVisible {Boolean ? false} whether to scroll the new focused cell
       *          visible.
       * @return {void}
       */
      setFocusedCell : function(dR, dS, dT){

        if(!this.isEditing() && (dR != this.__focusedCol || dS != this.__focusedRow)){

          if(dR === null){

            dR = 0;
          };
          this.__focusedCol = dR;
          this.__focusedRow = dS;
          var dU = this._getPaneScrollerArr();
          for(var i = 0;i < dU.length;i++){

            dU[i].setFocusedCell(dR, dS);
          };
          if(dR !== null && dT){

            this.scrollCellVisible(dR, dS);
          };
        };
      },
      /**
       * Resets (clears) the current selection
       */
      resetSelection : function(){

        this.getSelectionModel().resetSelection();
      },
      /**
       * Resets the focused cell.
       */
      resetCellFocus : function(){

        this.setFocusedCell(null, null, false);
      },
      /**
       * Returns the column of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn : function(){

        return this.__focusedCol;
      },
      /**
       * Returns the row of the currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow : function(){

        return this.__focusedRow;
      },
      /**
       * Select whether the focused row is highlighted
       *
       * @param bHighlight {Boolean}
       *   Flag indicating whether the focused row should be highlighted.
       *
       * @return {void}
       */
      highlightFocusedRow : function(dV){

        this.getDataRowRenderer().setHighlightFocusRow(dV);
      },
      /**
       * Remove the highlighting of the current focus row.
       *
       * This is used to temporarily remove the highlighting of the currently
       * focused row, and is expected to be used most typically by adding a
       * listener on the "mouseout" event, so that the focus highlighting is
       * suspended when the mouse leaves the table:
       *
       *     table.addListener("mouseout", table.clearFocusedRowHighlight);
       *
       * @param evt {qx.event.type.Mouse} Incoming mouse event
       * @return {void}
       */
      clearFocusedRowHighlight : function(dW){

        if(dW){

          var dY = dW.getRelatedTarget();
          if(dY instanceof qx.ui.table.pane.Pane || dY instanceof qx.ui.table.pane.FocusIndicator){

            return;
          };
        };
        // Remove focus from any cell that has it
        this.resetCellFocus();
        // Now, for each pane scroller...
        var dX = this._getPaneScrollerArr();
        for(var i = 0;i < dX.length;i++){

          // ... repaint without focus.
          dX[i].onFocusChanged();
        };
      },
      /**
       * Moves the focus.
       *
       * @param deltaX {Integer} The delta by which the focus should be moved on the x axis.
       * @param deltaY {Integer} The delta by which the focus should be moved on the y axis.
       * @return {void}
       */
      moveFocusedCell : function(ea, eb){

        var ef = this.__focusedCol;
        var eg = this.__focusedRow;
        // could also be undefined [BUG #4676]
        if(ef == null || eg == null){

          return;
        };
        if(ea != 0){

          var ee = this.getTableColumnModel();
          var x = ee.getVisibleX(ef);
          var ed = ee.getVisibleColumnCount();
          x = qx.lang.Number.limit(x + ea, 0, ed - 1);
          ef = ee.getVisibleColumnAtX(x);
        };
        if(eb != 0){

          var ec = this.getTableModel();
          eg = qx.lang.Number.limit(eg + eb, 0, ec.getRowCount() - 1);
        };
        this.setFocusedCell(ef, eg, true);
      },
      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       * @return {void}
       */
      scrollCellVisible : function(eh, ei){

        // get the dom element
        var ej = this.getContentElement().getDomElement();
        // if the dom element is not available, the table hasn't been rendered
        if(!ej){

          // postpone the scroll until the table has appeared
          this.addListenerOnce(K, function(){

            this.scrollCellVisible(eh, ei);
          }, this);
        };
        var ek = this.getTableColumnModel();
        var x = ek.getVisibleX(eh);
        var el = this._getMetaColumnAtColumnX(x);
        if(el != -1){

          this.getPaneScroller(el).scrollCellVisible(eh, ei);
        };
      },
      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing : function(){

        if(this.__focusedCol != null){

          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);
          var em = this._getMetaColumnAtColumnX(x);
          return this.getPaneScroller(em).isEditing();
        };
        return false;
      },
      /**
       * Starts editing the currently focused cell. Does nothing if already editing
       * or if the column is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing : function(){

        if(this.__focusedCol != null){

          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);
          var eo = this._getMetaColumnAtColumnX(x);
          var en = this.getPaneScroller(eo).startEditing();
          return en;
        };
        return false;
      },
      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing : function(){

        if(this.__focusedCol != null){

          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);
          var ep = this._getMetaColumnAtColumnX(x);
          this.getPaneScroller(ep).stopEditing();
        };
      },
      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing : function(){

        if(this.__focusedCol != null){

          var x = this.getTableColumnModel().getVisibleX(this.__focusedCol);
          var eq = this._getMetaColumnAtColumnX(x);
          this.getPaneScroller(eq).cancelEditing();
        };
      },
      /**
       * Update the table content of every attached table pane.
       */
      updateContent : function(){

        var er = this._getPaneScrollerArr();
        for(var i = 0;i < er.length;i++){

          er[i].getTablePane().updateContent(true);
        };
      },
      /**
       * Activates the blocker widgets on all column headers and the
       * column button
       */
      blockHeaderElements : function(){

        var es = this._getPaneScrollerArr();
        for(var i = 0;i < es.length;i++){

          es[i].getHeader().getBlocker().blockContent(20);
        };
        this.getChildControl(P).getBlocker().blockContent(20);
      },
      /**
       * Deactivates the blocker widgets on all column headers and the
       * column button
       */
      unblockHeaderElements : function(){

        var et = this._getPaneScrollerArr();
        for(var i = 0;i < et.length;i++){

          et[i].getHeader().getBlocker().unblockContent();
        };
        this.getChildControl(P).getBlocker().unblockContent();
      },
      /**
       * Gets the meta column at a certain x position in the page. If there is no
       * meta column at this position, -1 is returned.
       *
       * @param pageX {Integer} the position in the page to check (in pixels).
       * @return {Integer} the index of the meta column or -1.
       */
      _getMetaColumnAtPageX : function(eu){

        var ev = this._getPaneScrollerArr();
        for(var i = 0;i < ev.length;i++){

          var ew = ev[i].getContainerLocation();
          if(eu >= ew.left && eu <= ew.right){

            return i;
          };
        };
        return -1;
      },
      /**
       * Returns the meta column a column is shown in. If the column is not shown at
       * all, -1 is returned.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the meta column the column is shown in.
       */
      _getMetaColumnAtColumnX : function(ex){

        var ez = this.getMetaColumnCounts();
        var eA = 0;
        for(var i = 0;i < ez.length;i++){

          var ey = ez[i];
          eA += ey;
          if(ey == -1 || ex < eA){

            return i;
          };
        };
        return -1;
      },
      /**
       * Updates the text shown in the status bar.
       */
      _updateStatusBar : function(){

        var eB = this.getTableModel();
        if(this.getStatusBarVisible()){

          var eC = this.getSelectionModel().getSelectedCount();
          var eE = eB.getRowCount();
          var eD;
          if(eE >= 0){

            if(eC == 0){

              eD = this.trn(Q, z, eE, eE);
            } else {

              eD = this.trn(X, bm, eE, eC, eE);
            };
          };
          if(this.__additionalStatusBarText){

            if(eD){

              eD += this.__additionalStatusBarText;
            } else {

              eD = this.__additionalStatusBarText;
            };
          };
          if(eD){

            this.getChildControl(J).setValue(eD);
          };
        };
      },
      /**
       * Updates the widths of all scrollers.
       */
      _updateScrollerWidths : function(){

        // Give all scrollers except for the last one the wanted width
        // (The last one has a flex with)
        var eF = this._getPaneScrollerArr();
        for(var i = 0;i < eF.length;i++){

          var eH = (i == (eF.length - 1));
          var eI = eF[i].getTablePaneModel().getTotalWidth();
          eF[i].setPaneWidth(eI);
          var eG = eH ? 1 : 0;
          eF[i].setLayoutProperties({
            flex : eG
          });
        };
      },
      /**
       * Updates the visibility of the scrollbars in the meta columns.
       */
      _updateScrollBarVisibility : function(){

        if(!this.getBounds()){

          return;
        };
        var eM = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var eO = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;
        var eJ = this._getPaneScrollerArr();
        // Check which scroll bars are needed
        var eL = false;
        var eN = false;
        for(var i = 0;i < eJ.length;i++){

          var eP = (i == (eJ.length - 1));
          // Only show the last vertical scrollbar
          var eK = eJ[i].getNeededScrollBars(eL, !eP);
          if(eK & eM){

            eL = true;
          };
          if(eP && (eK & eO)){

            eN = true;
          };
        };
        // Set the needed scrollbars
        for(var i = 0;i < eJ.length;i++){

          var eP = (i == (eJ.length - 1));
          // Only show the last vertical scrollbar
          eJ[i].setHorizontalScrollBarVisible(eL);
          // If this is the last meta-column...
          if(eP){

            // ... then get the current (old) use of vertical scroll bar
            if(this.__hadVerticalScrollBar == null){

              this.__hadVerticalScrollBar = eJ[i].getVerticalScrollBarVisible();
              this.__timer = qx.event.Timer.once(function(){

                // reset the last visible state of the vertical scroll bar
                // in a timeout to prevent infinite loops.
                this.__hadVerticalScrollBar = null;
                this.__timer = null;
              }, this, 0);
            };
          };
          eJ[i].setVerticalScrollBarVisible(eP && eN);
          // If this is the last meta-column and the use of a vertical scroll bar
          // has changed...
          if(eP && eN != this.__hadVerticalScrollBar){

            // ... then dispatch an event to any awaiting listeners
            this.fireDataEvent(O, eN);
          };
        };
      },
      /**
       * Initialize the column menu
       */
      _initColumnMenu : function(){

        var eS = this.getTableModel();
        var eT = this.getTableColumnModel();
        var eU = this.getChildControl(P);
        // Remove all items from the menu. We'll rebuild it here.
        eU.empty();
        // Inform listeners who may want to insert menu items at the beginning
        var eR = eU.getMenu();
        var eV = {
          table : this,
          menu : eR,
          columnButton : eU
        };
        this.fireDataEvent(o, eV);
        this.__columnMenuButtons = {
        };
        for(var eW = 0,l = eS.getColumnCount();eW < l;eW++){

          var eQ = eU.factory(u, {
            text : eS.getColumnName(eW),
            column : eW,
            bVisible : eT.isColumnVisible(eW)
          });
          qx.core.Assert.assertInterface(eQ, qx.ui.table.IColumnMenuItem);
          eQ.addListener(h, this._createColumnVisibilityCheckBoxHandler(eW), this);
          this.__columnMenuButtons[eW] = eQ;
        };
        // Inform listeners who may want to insert menu items at the end
        eV = {
          table : this,
          menu : eR,
          columnButton : eU
        };
        this.fireDataEvent(k, eV);
      },
      /**
       * Creates a handler for a check box of the column visibility menu.
       *
       * @param col {Integer} the model index of column to create the handler for.
       * @return {Function} The created event handler.
       */
      _createColumnVisibilityCheckBoxHandler : function(eX){

        return function(eY){

          var fa = this.getTableColumnModel();
          fa.setColumnVisible(eX, eY.getData());
        };
      },
      /**
       * Sets the width of a column.
       *
       * @param col {Integer} the model index of column.
       * @param width {Integer} the new width in pixels.
       * @return {void}
       */
      setColumnWidth : function(fb, fc){

        this.getTableColumnModel().setColumnWidth(fb, fc);
      },
      /**
       * Resize event handler
       */
      _onResize : function(){

        this.fireEvent(V);
        this._updateScrollerWidths();
        this._updateScrollBarVisibility();
      },
      // overridden
      addListener : function(fd, fe, self, ff){

        if(this.self(arguments).__redirectEvents[fd]){

          // start the id with the type (needed for removing)
          var fh = [fd];
          for(var i = 0,fg = this._getPaneScrollerArr();i < fg.length;i++){

            fh.push(fg[i].addListener.apply(fg[i], arguments));
          };
          // join the id's of every event with "
          return fh.join(bs);
        } else {

          return qx.ui.core.Widget.prototype.addListener.call(this, fd, fe, self, ff);
        };
      },
      // overridden
      removeListener : function(fi, fj, self, fk){

        if(this.self(arguments).__redirectEvents[fi]){

          for(var i = 0,fl = this._getPaneScrollerArr();i < fl.length;i++){

            fl[i].removeListener.apply(fl[i], arguments);
          };
        } else {

          qx.ui.core.Widget.prototype.removeListener.call(this, fi, fj, self, fk);
        };
      },
      // overridden
      removeListenerById : function(fm){

        var fq = fm.split(bs);
        // type is the first entry of the connected id
        var fp = fq.shift();
        if(this.self(arguments).__redirectEvents[fp]){

          var fo = true;
          for(var i = 0,fn = this._getPaneScrollerArr();i < fn.length;i++){

            fo = fn[i].removeListenerById.call(fn[i], fq[i]) && fo;
          };
          return fo;
        } else {

          return qx.ui.core.Widget.prototype.removeListenerById.call(this, fm);
        };
      },
      destroy : function(){

        this.getChildControl(P).getMenu().destroy();
        qx.ui.core.Widget.prototype.destroy.call(this);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      // remove the event listener which handled the locale change
      if(qx.core.Environment.get(Y)){

        qx.locale.Manager.getInstance().removeListener(D, this._onChangeLocale, this);
      };
      // we allocated these objects on init so we have to clean them up.
      var fs = this.getSelectionModel();
      if(fs){

        fs.dispose();
      };
      var fr = this.getDataRowRenderer();
      if(fr){

        fr.dispose();
      };
      this._cleanUpMetaColumns(0);
      this.getTableColumnModel().dispose();
      this._disposeObjects(bh, bp, N, N, bv, bg);
      this._disposeMap(ba);
    }
  });
})();
(function(){

  var s = "Decorator",r = "center",q = "_applyReversed",p = "qx.debug",o = "bottom",n = "' is not supported by the VBox layout!",m = "qx.ui.layout.VBox",k = "flex",j = "Integer",h = "The property '",c = "right",g = "Boolean",f = "left",b = "height",a = "middle",e = "top",d = "_applyLayoutChange";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A vertical box layout.
   *
   * The vertical box layout lays out widgets in a vertical column, from top
   * to bottom.
   *
   * *Features*
   *
   * * Minimum and maximum dimensions
   * * Prioritized growing/shrinking (flex)
   * * Margins (with vertical collapsing)
   * * Auto sizing (ignoring percent values)
   * * Percent heights (not relevant for size hint)
   * * Alignment (child property {@link qx.ui.core.LayoutItem#alignY} is ignored)
   * * Vertical spacing (collapsed with margins)
   * * Reversed children layout (from last to first)
   * * Horizontal children stretching (respecting size hints)
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>flex</strong> <em>(Integer)</em>: The flexibility of a layout item determines how the container
   *   distributes remaining empty space among its children. If items are made
   *   flexible, they can grow or shrink accordingly. Their relative flex values
   *   determine how the items are being resized, i.e. the larger the flex ratio
   *   of two items, the larger the resizing of the first item compared to the
   *   second.
   *
   *   If there is only one flex item in a layout container, its actual flex
   *   value is not relevant. To disallow items to become flexible, set the
   *   flex value to zero.
   * </li>
   * <li><strong>height</strong> <em>(String)</em>: Allows to define a percent
   *   height for the item. The height in percent, if specified, is used instead
   *   of the height defined by the size hint. The minimum and maximum height still
   *   takes care of the element's limits. It has no influence on the layout's
   *   size hint. Percent values are mostly useful for widgets which are sized by
   *   the outer hierarchy.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the grid layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.VBox();
   * layout.setSpacing(4); // apply spacing
   *
   * var container = new qx.ui.container.Composite(layout);
   *
   * container.add(new qx.ui.core.Widget());
   * container.add(new qx.ui.core.Widget());
   * container.add(new qx.ui.core.Widget());
   * </pre>
   *
   * *External Documentation*
   *
   * See <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/box.html'>extended documentation</a>
   * and links to demos for this layout.
   *
   */
  qx.Class.define(m, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param spacing {Integer?0} The spacing between child widgets {@link #spacing}.
     * @param alignY {String?"top"} Vertical alignment of the whole children
     *     block {@link #alignY}.
     * @param separator {Decorator} A separator to render between the items
     */
    construct : function(t, u, v){

      qx.ui.layout.Abstract.call(this);
      if(t){

        this.setSpacing(t);
      };
      if(u){

        this.setAlignY(u);
      };
      if(v){

        this.setSeparator(v);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Vertical alignment of the whole children block. The vertical
       * alignment of the child is completely ignored in VBoxes (
       * {@link qx.ui.core.LayoutItem#alignY}).
       */
      alignY : {
        check : [e, a, o],
        init : e,
        apply : d
      },
      /**
       * Horizontal alignment of each child. Can be overridden through
       * {@link qx.ui.core.LayoutItem#alignX}.
       */
      alignX : {
        check : [f, r, c],
        init : f,
        apply : d
      },
      /** Vertical spacing between two children */
      spacing : {
        check : j,
        init : 0,
        apply : d
      },
      /** Separator lines to use between the objects */
      separator : {
        check : s,
        nullable : true,
        apply : d
      },
      /** Whether the actual children list should be laid out in reversed order. */
      reversed : {
        check : g,
        init : false,
        apply : q
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __heights : null,
      __flexs : null,
      __enableFlex : null,
      __children : null,
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyReversed : function(){

        // easiest way is to invalidate the cache
        this._invalidChildrenCache = true;
        // call normal layout change
        this._applyLayoutChange();
      },
      /**
       * Rebuilds caches for flex and percent layout properties
       */
      __rebuildCache : function(){

        var B = this._getLayoutChildren();
        var length = B.length;
        var x = false;
        var w = this.__heights && this.__heights.length != length && this.__flexs && this.__heights;
        var z;
        // Sparse array (keep old one if lengths has not been modified)
        var y = w ? this.__heights : new Array(length);
        var A = w ? this.__flexs : new Array(length);
        // Reverse support
        if(this.getReversed()){

          B = B.concat().reverse();
        };
        // Loop through children to preparse values
        for(var i = 0;i < length;i++){

          z = B[i].getLayoutProperties();
          if(z.height != null){

            y[i] = parseFloat(z.height) / 100;
          };
          if(z.flex != null){

            A[i] = z.flex;
            x = true;
          } else {

            // reset (in case the index of the children changed: BUG #3131)
            A[i] = 0;
          };
        };
        // Store data
        if(!w){

          this.__heights = y;
          this.__flexs = A;
        };
        this.__enableFlex = x;
        this.__children = B;
        // Clear invalidation marker
        delete this._invalidChildrenCache;
      },
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(p, {
        "true" : function(C, name, D){

          this.assert(name === k || name === b, h + name + n);
          if(name == b){

            this.assertMatch(D, qx.ui.layout.Util.PERCENT_VALUE);
          } else {

            // flex
            this.assertNumber(D);
            this.assert(D >= 0);
          };
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(E, F){

        // Rebuild flex/height caches
        if(this._invalidChildrenCache){

          this.__rebuildCache();
        };
        // Cache children
        var M = this.__children;
        var length = M.length;
        var W = qx.ui.layout.Util;
        // Compute gaps
        var V = this.getSpacing();
        var ba = this.getSeparator();
        if(ba){

          var J = W.computeVerticalSeparatorGaps(M, V, ba);
        } else {

          var J = W.computeVerticalGaps(M, V, true);
        };
        // First run to cache children data and compute allocated height
        var i,H,I,Q;
        var R = [];
        var X = J;
        for(i = 0;i < length;i += 1){

          Q = this.__heights[i];
          I = Q != null ? Math.floor((F - J) * Q) : M[i].getSizeHint().height;
          R.push(I);
          X += I;
        };
        // Flex support (growing/shrinking)
        if(this.__enableFlex && X != F){

          var O = {
          };
          var U,Y;
          for(i = 0;i < length;i += 1){

            U = this.__flexs[i];
            if(U > 0){

              N = M[i].getSizeHint();
              O[i] = {
                min : N.minHeight,
                value : R[i],
                max : N.maxHeight,
                flex : U
              };
            };
          };
          var K = W.computeFlexOffsets(O, F, X);
          for(i in K){

            Y = K[i].offset;
            R[i] += Y;
            X += Y;
          };
        };
        // Start with top coordinate
        var top = M[0].getMarginTop();
        // Alignment support
        if(X < F && this.getAlignY() != e){

          top = F - X;
          if(this.getAlignY() === a){

            top = Math.round(top / 2);
          };
        };
        // Layouting children
        var N,bc,S,I,P,T,L;
        // Pre configure separators
        this._clearSeparators();
        // Compute separator height
        if(ba){

          var bb = qx.theme.manager.Decoration.getInstance().resolve(ba).getInsets();
          var G = bb.top + bb.bottom;
        };
        // Render children and separators
        for(i = 0;i < length;i += 1){

          H = M[i];
          I = R[i];
          N = H.getSizeHint();
          T = H.getMarginLeft();
          L = H.getMarginRight();
          // Find usable width
          S = Math.max(N.minWidth, Math.min(E - T - L, N.maxWidth));
          // Respect horizontal alignment
          bc = W.computeHorizontalAlignOffset(H.getAlignX() || this.getAlignX(), S, E, T, L);
          // Add collapsed margin
          if(i > 0){

            // Whether a separator has been configured
            if(ba){

              // add margin of last child and spacing
              top += P + V;
              // then render the separator at this position
              this._renderSeparator(ba, {
                top : top,
                left : 0,
                height : G,
                width : E
              });
              // and finally add the size of the separator, the spacing (again) and the top margin
              top += G + V + H.getMarginTop();
            } else {

              // Support margin collapsing when no separator is defined
              top += W.collapseMargins(V, P, H.getMarginTop());
            };
          };
          // Layout child
          H.renderLayout(bc, top, S, I);
          // Add height
          top += I;
          // Remember bottom margin (for collapsing)
          P = H.getMarginBottom();
        };
      },
      // overridden
      _computeSizeHint : function(){

        // Rebuild flex/height caches
        if(this._invalidChildrenCache){

          this.__rebuildCache();
        };
        var bj = qx.ui.layout.Util;
        var br = this.__children;
        // Initialize
        var bf = 0,bi = 0,bh = 0;
        var bd = 0,bk = 0;
        var bo,be,bq;
        // Iterate over children
        for(var i = 0,l = br.length;i < l;i += 1){

          bo = br[i];
          be = bo.getSizeHint();
          // Sum up heights
          bi += be.height;
          // Detect if child is shrinkable or has percent height and update minHeight
          var bn = this.__flexs[i];
          var bg = this.__heights[i];
          if(bn){

            bf += be.minHeight;
          } else if(bg){

            bh = Math.max(bh, Math.round(be.minHeight / bg));
          } else {

            bf += be.height;
          };
          // Build horizontal margin sum
          bq = bo.getMarginLeft() + bo.getMarginRight();
          // Find biggest width
          if((be.width + bq) > bk){

            bk = be.width + bq;
          };
          // Find biggest minWidth
          if((be.minWidth + bq) > bd){

            bd = be.minWidth + bq;
          };
        };
        bf += bh;
        // Respect gaps
        var bm = this.getSpacing();
        var bp = this.getSeparator();
        if(bp){

          var bl = bj.computeVerticalSeparatorGaps(br, bm, bp);
        } else {

          var bl = bj.computeVerticalGaps(br, bm, true);
        };
        // Return hint
        return {
          minHeight : bf + bl,
          height : bi + bl,
          minWidth : bd,
          width : bk
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__heights = this.__flexs = this.__children = null;
    }
  });
})();
(function(){

  var a = "qx.ui.table.IRowRenderer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * Interface for a row renderer.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Updates a data row.
       *
       * The rowInfo map contains the following properties:
       * <ul>
       * <li>rowData (var): contains the row data for the row.
       *   The kind of this object depends on the table model, see
       *   {@link ITableModel#getRowData()}</li>
       * <li>row (int): the model index of the row.</li>
       * <li>selected (boolean): whether a cell in this row is selected.</li>
       * <li>focusedRow (boolean): whether the focused cell is in this row.</li>
       * <li>table (qx.ui.table.Table): the table the row belongs to.</li>
       * </ul>
       *
       * @abstract
       * @param rowInfo {Map} A map containing the information about the row to
       *      update.
       * @param rowElement {element} the DOM element that renders the data row.
       */
      updateDataRowElement : function(b, c){
      },
      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       */
      getRowHeightStyle : function(d){
      },
      /**
       * Create a style string, which will be set as the style property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      createRowStyle : function(e){
      },
      /**
       * Create a HTML class string, which will be set as the class property of the row.
       *
       * @param rowInfo {Map} A map containing the information about the row to
       *      update. See {@link #updateDataRowElement} for more information.
       */
      getRowClass : function(f){
      }
    }
  });
})();
(function(){

  var j = "table-row-background-even",i = "Boolean",h = "content",g = "default",f = "height:",e = "'",d = "table-row",c = "table-row-background-focused",b = "css.boxmodel",a = ';color:',v = "table-row-background-odd",u = "1px solid ",t = "table-row-line",s = "table-row-background-selected",r = "background-color:",q = ';border-bottom: 1px solid ',p = "table-row-selected",o = "table-row-background-focused-selected",n = "px;",m = "qx.ui.table.rowrenderer.Default",k = ";",l = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2007 Visionet GmbH, http://www.visionet.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132) STZ-IDA
       * Dietrich Streifert (level420) Visionet
  
  ************************************************************************ */
  /**
   * The default data row renderer.
   */
  qx.Class.define(m, {
    extend : qx.core.Object,
    implement : qx.ui.table.IRowRenderer,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__fontStyleString = l;
      this.__fontStyleString = {
      };
      this._colors = {
      };
      // link to font theme
      this._renderFont(qx.theme.manager.Font.getInstance().resolve(g));
      // link to color theme
      var w = qx.theme.manager.Color.getInstance();
      this._colors.bgcolFocusedSelected = w.resolve(o);
      this._colors.bgcolFocused = w.resolve(c);
      this._colors.bgcolSelected = w.resolve(s);
      this._colors.bgcolEven = w.resolve(j);
      this._colors.bgcolOdd = w.resolve(v);
      this._colors.colSelected = w.resolve(p);
      this._colors.colNormal = w.resolve(d);
      this._colors.horLine = w.resolve(t);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Whether the focused row should be highlighted. */
      highlightFocusRow : {
        check : i,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _colors : null,
      __fontStyle : null,
      __fontStyleString : null,
      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY : 1,
      // borderBottom
      /**
       * Render the new font and update the table pane content
       * to reflect the font change.
       *
       * @param font {qx.bom.Font} The font to use for the table row
       */
      _renderFont : function(x){

        if(x){

          this.__fontStyle = x.getStyles();
          this.__fontStyleString = qx.bom.element.Style.compile(this.__fontStyle);
          this.__fontStyleString = this.__fontStyleString.replace(/"/g, e);
        } else {

          this.__fontStyleString = l;
          this.__fontStyle = qx.bom.Font.getDefaultStyles();
        };
      },
      // interface implementation
      updateDataRowElement : function(y, z){

        var B = this.__fontStyle;
        var A = z.style;
        // set font styles
        qx.bom.element.Style.setStyles(z, B);
        if(y.focusedRow && this.getHighlightFocusRow()){

          A.backgroundColor = y.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused;
        } else {

          if(y.selected){

            A.backgroundColor = this._colors.bgcolSelected;
          } else {

            A.backgroundColor = (y.row % 2 == 0) ? this._colors.bgcolEven : this._colors.bgcolOdd;
          };
        };
        A.color = y.selected ? this._colors.colSelected : this._colors.colNormal;
        A.borderBottom = u + this._colors.horLine;
      },
      /**
       * Get the row's height CSS style taking the box model into account
       *
       * @param height {Integer} The row's (border-box) height in pixel
       */
      getRowHeightStyle : function(C){

        if(qx.core.Environment.get(b) == h){

          C -= this._insetY;
        };
        return f + C + n;
      },
      // interface implementation
      createRowStyle : function(D){

        var E = [];
        E.push(k);
        E.push(this.__fontStyleString);
        E.push(r);
        if(D.focusedRow && this.getHighlightFocusRow()){

          E.push(D.selected ? this._colors.bgcolFocusedSelected : this._colors.bgcolFocused);
        } else {

          if(D.selected){

            E.push(this._colors.bgcolSelected);
          } else {

            E.push((D.row % 2 == 0) ? this._colors.bgcolEven : this._colors.bgcolOdd);
          };
        };
        E.push(a);
        E.push(D.selected ? this._colors.colSelected : this._colors.colNormal);
        E.push(q, this._colors.horLine);
        return E.join(l);
      },
      getRowClass : function(F){

        return l;
      },
      /**
       * Add extra attributes to each row.
       *
       * @param rowInfo {Object}
       *   The following members are available in rowInfo:
       *   <dl>
       *     <dt>table {qx.ui.table.Table}</dt>
       *     <dd>The table object</dd>
       *
       *     <dt>styleHeight {Integer}</dt>
       *     <dd>The height of this (and every) row</dd>
       *
       *     <dt>row {Integer}</dt>
       *     <dd>The number of the row being added</dd>
       *
       *     <dt>selected {Boolean}</dt>
       *     <dd>Whether the row being added is currently selected</dd>
       *
       *     <dt>focusedRow {Boolean}</dt>
       *     <dd>Whether the row being added is currently focused</dd>
       *
       *     <dt>rowData {Array}</dt>
       *     <dd>The array row from the data model of the row being added</dd>
       *   </dl>
       *
       * @return {String}
       *   Any additional attributes and their values that should be added to the
       *   div tag for the row.
       */
      getRowAttributes : function(G){

        return l;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._colors = this.__fontStyle = this.__fontStyleString = null;
    }
  });
})();
(function(){

  var a = "qx.ui.table.IColumnMenuButton";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * Interface for creating the column visibility menu
   */
  qx.Interface.define(a, {
    properties : {
      /**
       * The menu which is displayed when this button is pressed.
       */
      menu : {
      }
    },
    members : {
      /**
       * Instantiate a sub-widget.
       *
       * @param item {String}
       *   One of the following strings, indicating what type of
       *   column-menu-specific object to instantiate:
       *   <dl>
       *     <dt>menu</dt>
       *     <dd>
       *       Instantiate a menu which will appear when the column visibility
       *       button is pressed. No options are provided in this case.
       *     </dd>
       *     <dt>menu-button</dt>
       *     <dd>
       *       Instantiate a button to correspond to a column within the
       *       table. The options are a map containing <i>text</i>, the name of
       *       the column; <i>column</i>, the column number; and
       *       <i>bVisible</i>, a boolean indicating whether this column is
       *       currently visible. The instantiated return object must implement
       *       interface {@link qx.ui.table.IColumnMenuItem}
       *     </dd>
       *     <dt>user-button</dt>
       *     <dd>
       *       Instantiate a button for other than a column name. This is used,
       *       for example, to add the "Reset column widths" button when the
       *       Resize column model is requested. The options is a map containing
       *       <i>text</i>, the text to present in the button.
       *     </dd>
       *     <dt>separator</dt>
       *     <dd>
       *       Instantiate a separator object to added to the menu. This is
       *       used, for example, to separate the table column name list from
       *       the "Reset column widths" button when the Resize column model is
       *       requested. No options are provided in this case.
       *     </dd>
       *   </dl>
       *
       * @param options {Map}
       *   Options specific to the <i>item</i> being requested.
       *
       * @return {qx.ui.core.Widget}
       *   The instantiated object as specified by <i>item</i>.
       */
      factory : function(b, c){

        return true;
      },
      /**
       * Empty the menu of all items, in preparation for building a new column
       * visibility menu.
       *
       * @return {void}
       */
      empty : function(){

        return true;
      }
    }
  });
})();
(function(){

  var n = "toolTipText",m = "icon",l = "label",k = "qx.ui.core.MExecutable",j = "value",h = "qx.event.type.Event",g = "_applyCommand",f = "enabled",d = "menu",c = "changeCommand",a = "qx.ui.core.Command",b = "execute";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This mixin is included by all widgets, which support an 'execute' like
   * buttons or menu entries.
   */
  qx.Mixin.define(k, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired if the {@link #execute} method is invoked.*/
      "execute" : h
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * A command called if the {@link #execute} method is called, e.g. on a
       * button click.
       */
      command : {
        check : a,
        apply : g,
        event : c,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __executableBindingIds : null,
      __semaphore : false,
      __executeListenerId : null,
      /**
       * {Map} Set of properties, which will by synced from the command to the
       *    including widget
       *
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties : [f, l, m, n, j, d],
      /**
       * Initiate the execute action.
       */
      execute : function(){

        var o = this.getCommand();
        if(o){

          if(this.__semaphore){

            this.__semaphore = false;
          } else {

            this.__semaphore = true;
            o.execute(this);
          };
        };
        this.fireEvent(b);
      },
      /**
       * Handler for the execute event of the command.
       *
       * @param e {qx.event.type.Event} The execute event of the command.
       */
      __onCommandExecute : function(e){

        if(this.__semaphore){

          this.__semaphore = false;
          return;
        };
        this.__semaphore = true;
        this.execute();
      },
      // property apply
      _applyCommand : function(p, q){

        // execute forwarding
        if(q != null){

          q.removeListenerById(this.__executeListenerId);
        };
        if(p != null){

          this.__executeListenerId = p.addListener(b, this.__onCommandExecute, this);
        };
        // binding stuff
        var t = this.__executableBindingIds;
        if(t == null){

          this.__executableBindingIds = t = {
          };
        };
        var u;
        for(var i = 0;i < this._bindableProperties.length;i++){

          var s = this._bindableProperties[i];
          // remove the old binding
          if(q != null && !q.isDisposed() && t[s] != null){

            q.removeBinding(t[s]);
            t[s] = null;
          };
          // add the new binding
          if(p != null && qx.Class.hasProperty(this.constructor, s)){

            // handle the init value (dont sync the initial null)
            var r = p.get(s);
            if(r == null){

              u = this.get(s);
              // check also for themed values [BUG #5906]
              if(u == null){

                // update the appearance to make sure every themed property is up to date
                this.syncAppearance();
                u = qx.util.PropertyUtil.getThemeValue(this, s);
              };
            } else {

              // Reset the self property value [BUG #4534]
              u = null;
            };
            // set up the binding
            t[s] = p.bind(s, this, s);
            // reapply the former value
            if(u){

              this.set(s, u);
            };
          };
        };
      }
    },
    destruct : function(){

      this._applyCommand(null, this.getCommand());
      this.__executableBindingIds = null;
    }
  });
})();
(function(){

  var d = "qx.util.PropertyUtil",c = "$$theme_",b = "$$user_",a = "$$init_";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A helper class for accessing the property system directly.
   *
   * This class is rather to be used internally. For all regular usage of the
   * property system the default API should be sufficient.
   */
  qx.Class.define(d, {
    statics : {
      /**
       * Get the property map of the given class
       *
       * @param clazz {Class} a qooxdoo class
       * @return {Map} A properties map as defined in {@link qx.Class#define}
       *   including the properties of included mixins and not including refined
       *   properties.
       */
      getProperties : function(e){

        return e.$$properties;
      },
      /**
       * Get the property map of the given class including the properties of all
       * superclasses!
       *
       * @param clazz {Class} a qooxdoo class
       * @return {Map} The properties map as defined in {@link qx.Class#define}
       *   including the properties of included mixins of the current class and
       *   all superclasses.
       */
      getAllProperties : function(f){

        var i = {
        };
        var j = f;
        // go threw the class hierarchy
        while(j != qx.core.Object){

          var h = this.getProperties(j);
          for(var g in h){

            i[g] = h[g];
          };
          j = j.superclass;
        };
        return i;
      },
      /*
      -------------------------------------------------------------------------
        USER VALUES
      -------------------------------------------------------------------------
      */
      /**
       * Returns the user value of the given property
       *
       * @param object {Object} The object to access
       * @param propertyName {String} The name of the property
       * @return {var} The user value
       */
      getUserValue : function(k, l){

        return k[b + l];
      },
      /**
      * Sets the user value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @param value {var} The value to set
      * @return {void}
      */
      setUserValue : function(m, n, o){

        m[b + n] = o;
      },
      /**
      * Deletes the user value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @return {void}
      */
      deleteUserValue : function(p, q){

        delete (p[b + q]);
      },
      /*
      -------------------------------------------------------------------------
        INIT VALUES
      -------------------------------------------------------------------------
      */
      /**
       * Returns the init value of the given property
       *
       * @param object {Object} The object to access
       * @param propertyName {String} The name of the property
       * @return {var} The init value
       */
      getInitValue : function(r, s){

        return r[a + s];
      },
      /**
      * Sets the init value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @param value {var} The value to set
      * @return {void}
      */
      setInitValue : function(t, u, v){

        t[a + u] = v;
      },
      /**
      * Deletes the init value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @return {void}
      */
      deleteInitValue : function(w, x){

        delete (w[a + x]);
      },
      /*
      -------------------------------------------------------------------------
        THEME VALUES
      -------------------------------------------------------------------------
      */
      /**
       * Returns the theme value of the given property
       *
       * @param object {Object} The object to access
       * @param propertyName {String} The name of the property
       * @return {var} The theme value
       */
      getThemeValue : function(y, z){

        return y[c + z];
      },
      /**
      * Sets the theme value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @param value {var} The value to set
      * @return {void}
      */
      setThemeValue : function(A, B, C){

        A[c + B] = C;
      },
      /**
      * Deletes the theme value of the given property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @return {void}
      */
      deleteThemeValue : function(D, E){

        delete (D[c + E]);
      },
      /*
      -------------------------------------------------------------------------
        THEMED PROPERTY
      -------------------------------------------------------------------------
      */
      /**
       * Sets a themed property
       *
       * @param object {Object} The object to access
       * @param propertyName {String} The name of the property
      * @param value {var} The value to set
       * @return {void}
       */
      setThemed : function(F, G, H){

        var I = qx.core.Property.$$method.setThemed;
        F[I[G]](H);
      },
      /**
      * Resets a themed property
      *
      * @param object {Object} The object to access
      * @param propertyName {String} The name of the property
      * @return {void}
      */
      resetThemed : function(J, K){

        var L = qx.core.Property.$$method.resetThemed;
        J[L[K]]();
      }
    }
  });
})();
(function(){

  var b = "qx.ui.form.IExecutable",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all form widgets which are executable in some way. This
   * could be a button for example.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired when the widget is executed. Sets the "data" property of the
       * event to the object that issued the command.
       */
      "execute" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        COMMAND PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Set the command of this executable.
       *
       * @param command {qx.ui.core.Command} The command.
       */
      setCommand : function(c){

        return arguments.length == 1;
      },
      /**
       * Return the current set command of this executable.
       *
       * @return {qx.ui.core.Command} The current set command.
       */
      getCommand : function(){
      },
      /**
       * Fire the "execute" event on the command.
       */
      execute : function(){
      }
    }
  });
})();
(function(){

  var o = "dblclick",n = "qx.ui.form.Button",m = "mouseup",l = "mousedown",k = "mouseover",j = "mouseout",i = "keydown",h = "button",g = "keyup",f = "Enter",b = "Space",d = "hovered",c = "abandoned",a = "pressed";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A Button widget which supports various states and allows it to be used
   * via the mouse and the keyboard.
   *
   * If the user presses the button by clicking on it, or the <code>Enter</code> or
   * <code>Space</code> keys, the button fires an {@link qx.ui.core.MExecutable#execute} event.
   *
   * If the {@link qx.ui.core.MExecutable#command} property is set, the
   * command is executed as well.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.Button("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button was clicked");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/button.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(n, {
    extend : qx.ui.basic.Atom,
    include : [qx.ui.core.MExecutable],
    implement : [qx.ui.form.IExecutable],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} label of the atom
     * @param icon {String?null} Icon URL of the atom
     * @param command {qx.ui.core.Command?null} Command instance to connect with
     */
    construct : function(p, q, r){

      qx.ui.basic.Atom.call(this, p, q);
      if(r != null){

        this.setCommand(r);
      };
      // Add listeners
      this.addListener(k, this._onMouseOver);
      this.addListener(j, this._onMouseOut);
      this.addListener(l, this._onMouseDown);
      this.addListener(m, this._onMouseUp);
      this.addListener(i, this._onKeyDown);
      this.addListener(g, this._onKeyUp);
      // Stop events
      this.addListener(o, this._onStopEvent);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : h
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        focused : true,
        hovered : true,
        pressed : true,
        disabled : true
      },
      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */
      /**
       * Manually press the button
       */
      press : function(){

        if(this.hasState(c)){

          return;
        };
        this.addState(a);
      },
      /**
       * Manually release the button
       */
      release : function(){

        if(this.hasState(a)){

          this.removeState(a);
        };
      },
      /**
       * Completely reset the button (remove all states)
       */
      reset : function(){

        this.removeState(a);
        this.removeState(c);
        this.removeState(d);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Listener method for "mouseover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOver : function(e){

        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
        if(this.hasState(c)){

          this.removeState(c);
          this.addState(a);
        };
        this.addState(d);
      },
      /**
       * Listener method for "mouseout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOut : function(e){

        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
        this.removeState(d);
        if(this.hasState(a)){

          this.removeState(a);
          this.addState(c);
        };
      },
      /**
       * Listener method for "mousedown" event
       * <ul>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseDown : function(e){

        if(!e.isLeftPressed()){

          return;
        };
        e.stopPropagation();
        // Activate capturing if the button get a mouseout while
        // the button is pressed.
        this.capture();
        this.removeState(c);
        this.addState(a);
      },
      /**
       * Listener method for "mouseup" event
       * <ul>
       * <li>Removes "pressed" state (if set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Adds "hovered" state (if "abandoned" state is not set)</li>
       *</ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseUp : function(e){

        this.releaseCapture();
        // We must remove the states before executing the command
        // because in cases were the window lost the focus while
        // executing we get the capture phase back (mouseout).
        var s = this.hasState(a);
        var t = this.hasState(c);
        if(s){

          this.removeState(a);
        };
        if(t){

          this.removeState(c);
        } else {

          this.addState(d);
          if(s){

            this.execute();
          };
        };
        e.stopPropagation();
      },
      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyDown : function(e){

        switch(e.getKeyIdentifier()){case f:case b:
        this.removeState(c);
        this.addState(a);
        e.stopPropagation();};
      },
      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyUp : function(e){

        switch(e.getKeyIdentifier()){case f:case b:
        if(this.hasState(a)){

          this.removeState(c);
          this.removeState(a);
          this.execute();
          e.stopPropagation();
        };};
      }
    }
  });
})();
(function(){

  var n = "qx.ui.menu.Menu",m = "submenu",l = "Enter",k = "abandoned",j = "contextmenu",i = "changeMenu",h = "qx.ui.form.MenuButton",g = "visible",f = "left",d = "_applyMenu",a = "hovered",c = "changeVisibility",b = "pressed";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * A button which opens the connected menu when clicking on it.
   */
  qx.Class.define(h, {
    extend : qx.ui.form.Button,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} Initial label
     * @param icon {String?null} Initial icon
     * @param menu {qx.ui.menu.Menu} Connect to menu instance
     */
    construct : function(o, p, q){

      qx.ui.form.Button.call(this, o, p);
      // Initialize properties
      if(q != null){

        this.setMenu(q);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The menu instance to show when clicking on the button */
      menu : {
        check : n,
        nullable : true,
        apply : d,
        event : i
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyVisibility : function(r, s){

        qx.ui.form.Button.prototype._applyVisibility.call(this, r, s);
        // hide the menu too
        var t = this.getMenu();
        if(r != g && t){

          t.hide();
        };
      },
      // property apply
      _applyMenu : function(u, v){

        if(v){

          v.removeListener(c, this._onMenuChange, this);
          v.resetOpener();
        };
        if(u){

          u.addListener(c, this._onMenuChange, this);
          u.setOpener(this);
          u.removeState(m);
          u.removeState(j);
        };
      },
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Positions and shows the attached menu widget.
       *
       * @param selectFirst {Boolean?false} Whether the first menu button should be selected
       */
      open : function(w){

        var x = this.getMenu();
        if(x){

          // Hide all menus first
          qx.ui.menu.Manager.getInstance().hideAll();
          // Open the attached menu
          x.setOpener(this);
          x.open();
          // Select first item
          if(w){

            var y = x.getSelectables()[0];
            if(y){

              x.setSelectedButton(y);
            };
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange : function(e){

        var z = this.getMenu();
        if(z.isVisible()){

          this.addState(b);
        } else {

          this.removeState(b);
        };
      },
      // overridden
      _onMouseDown : function(e){

        qx.ui.form.Button.prototype._onMouseDown.call(this, e);
        // only open on left clicks [BUG #5125]
        if(e.getButton() != f){

          return;
        };
        var A = this.getMenu();
        if(A){

          // Toggle sub menu visibility
          if(!A.isVisible()){

            this.open();
          } else {

            A.exclude();
          };
          // Event is processed, stop it for others
          e.stopPropagation();
        };
      },
      // overridden
      _onMouseUp : function(e){

        qx.ui.form.Button.prototype._onMouseUp.call(this, e);
        // Just stop propagation to stop menu manager
        // from getting the event
        e.stopPropagation();
      },
      // overridden
      _onMouseOver : function(e){

        // Add hovered state
        this.addState(a);
      },
      // overridden
      _onMouseOut : function(e){

        // Just remove the hover state
        this.removeState(a);
      },
      // overridden
      _onKeyDown : function(e){

        switch(e.getKeyIdentifier()){case l:
        this.removeState(k);
        this.addState(b);
        var B = this.getMenu();
        if(B){

          // Toggle sub menu visibility
          if(!B.isVisible()){

            this.open();
          } else {

            B.exclude();
          };
        };
        e.stopPropagation();};
      },
      // overridden
      _onKeyUp : function(e){
      }
    }
  });
})();
(function(){

  var w = "__openTimer",v = "blur",u = "Enter",t = "Up",s = "__closeTimer",r = "__objects",q = "Escape",p = "event.touch",o = "qx.ui.menu.Manager",n = "Left",f = "Down",m = "Right",j = "singleton",c = "Space",b = "Object is no menu: ",h = "qx.debug",g = "interval",k = "keydown",a = "mousedown",l = "keyup",d = "keypress";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * This singleton manages visible menu instances and supports some
   * core features to schedule menu open/close with timeout support.
   *
   * It also manages the whole keyboard support for the currently
   * registered widgets.
   *
   * The zIndex order is also managed by this class.
   */
  qx.Class.define(o, {
    type : j,
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      // Create data structure
      this.__objects = [];
      var x = document.body;
      var y = qx.event.Registration;
      // React on mousedown/mouseup events, but on native, to support inline applications
      y.addListener(window.document.documentElement, a, this._onMouseDown, this, true);
      // React on keypress events
      y.addListener(x, k, this._onKeyUpDown, this, true);
      y.addListener(x, l, this._onKeyUpDown, this, true);
      y.addListener(x, d, this._onKeyPress, this, true);
      // only use the blur event to hide windows on non touch devices [BUG #4033]
      // When the menu is locaed on top of an iFrame, the select will fail
      if(!qx.core.Environment.get(p)){

        // Hide all when the window is blurred
        qx.bom.Element.addListener(window, v, this.hideAll, this);
      };
      // Create open timer
      this.__openTimer = new qx.event.Timer;
      this.__openTimer.addListener(g, this._onOpenInterval, this);
      // Create close timer
      this.__closeTimer = new qx.event.Timer;
      this.__closeTimer.addListener(g, this._onCloseInterval, this);
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __scheduleOpen : null,
      __scheduleClose : null,
      __openTimer : null,
      __closeTimer : null,
      __objects : null,
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Query engine for menu children.
       *
       * @param menu {qx.ui.menu.Menu} Any menu instance
       * @param start {Integer} Child index to start with
       * @param iter {Integer} Iteration count, normally <code>+1</code> or <code>-1</code>
       * @param loop {Boolean?false} Whether to wrap when reaching the begin/end of the list
       * @return {qx.ui.menu.Button} Any menu button or <code>null</code>
       */
      _getChild : function(z, A, B, C){

        var D = z.getChildren();
        var length = D.length;
        var E;
        for(var i = A;i < length && i >= 0;i += B){

          E = D[i];
          if(E.isEnabled() && !E.isAnonymous() && E.isVisible()){

            return E;
          };
        };
        if(C){

          i = i == length ? 0 : length - 1;
          for(;i != A;i += B){

            E = D[i];
            if(E.isEnabled() && !E.isAnonymous() && E.isVisible()){

              return E;
            };
          };
        };
        return null;
      },
      /**
       * Whether the given widget is inside any Menu instance.
       *
       * @param widget {qx.ui.core.Widget} Any widget
       * @return {Boolean} <code>true</code> when the widget is part of any menu
       */
      _isInMenu : function(F){

        while(F){

          if(F instanceof qx.ui.menu.Menu){

            return true;
          };
          F = F.getLayoutParent();
        };
        return false;
      },
      /**
       * Returns an instance of a menu button if the given widget is a child
       *
       * @param widget {qx.ui.core.Widget} any widget
       * @return {qx.ui.menu.Button} Any menu button instance or <code>null</code>
       */
      _getMenuButton : function(G){

        while(G){

          if(G instanceof qx.ui.menu.AbstractButton){

            return G;
          };
          G = G.getLayoutParent();
        };
        return null;
      },
      /*
      ---------------------------------------------------------------------------
        PUBLIC METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Adds a menu to the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      add : function(H){

        if(qx.core.Environment.get(h)){

          if(!(H instanceof qx.ui.menu.Menu)){

            throw new Error(b + H);
          };
        };
        var I = this.__objects;
        I.push(H);
        H.setZIndex(1e6 + I.length);
      },
      /**
       * Remove a menu from the list of visible menus.
       *
       * @param obj {qx.ui.menu.Menu} Any menu instance.
       */
      remove : function(J){

        if(qx.core.Environment.get(h)){

          if(!(J instanceof qx.ui.menu.Menu)){

            throw new Error(b + J);
          };
        };
        var K = this.__objects;
        if(K){

          qx.lang.Array.remove(K, J);
        };
      },
      /**
       * Hides all currently opened menus.
       */
      hideAll : function(){

        var L = this.__objects;
        if(L){

          for(var i = L.length - 1;i >= 0;i--){

            L[i].exclude();
          };
        };
      },
      /**
       * Returns the menu which was opened at last (which
       * is the active one this way)
       *
       * @return {qx.ui.menu.Menu} The current active menu or <code>null</code>
       */
      getActiveMenu : function(){

        var M = this.__objects;
        return M.length > 0 ? M[M.length - 1] : null;
      },
      /*
      ---------------------------------------------------------------------------
        SCHEDULED OPEN/CLOSE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Schedules the given menu to be opened after the
       * {@link qx.ui.menu.Menu#openInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for open
       */
      scheduleOpen : function(N){

        // Cancel close of given menu first
        this.cancelClose(N);
        // When the menu is already visible
        if(N.isVisible()){

          // Cancel all other open requests
          if(this.__scheduleOpen){

            this.cancelOpen(this.__scheduleOpen);
          };
        } else if(this.__scheduleOpen != N){

          // menu.debug("Schedule open");
          this.__scheduleOpen = N;
          this.__openTimer.restartWith(N.getOpenInterval());
        };
      },
      /**
       * Schedules the given menu to be closed after the
       * {@link qx.ui.menu.Menu#closeInterval} configured by the
       * menu instance itself.
       *
       * @param menu {qx.ui.menu.Menu} The menu to schedule for close
       */
      scheduleClose : function(O){

        // Cancel open of the menu first
        this.cancelOpen(O);
        // When the menu is already invisible
        if(!O.isVisible()){

          // Cancel all other close requests
          if(this.__scheduleClose){

            this.cancelClose(this.__scheduleClose);
          };
        } else if(this.__scheduleClose != O){

          // menu.debug("Schedule close");
          this.__scheduleClose = O;
          this.__closeTimer.restartWith(O.getCloseInterval());
        };
      },
      /**
       * When the given menu is scheduled for open this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for open
       */
      cancelOpen : function(P){

        if(this.__scheduleOpen == P){

          // menu.debug("Cancel open");
          this.__openTimer.stop();
          this.__scheduleOpen = null;
        };
      },
      /**
       * When the given menu is scheduled for close this pending
       * request is canceled.
       *
       * @param menu {qx.ui.menu.Menu} The menu to cancel for close
       */
      cancelClose : function(Q){

        if(this.__scheduleClose == Q){

          // menu.debug("Cancel close");
          this.__closeTimer.stop();
          this.__scheduleClose = null;
        };
      },
      /*
      ---------------------------------------------------------------------------
        TIMER EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for a pending open request. Configured to the interval
       * of the current menu to open.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onOpenInterval : function(e){

        // Stop timer
        this.__openTimer.stop();
        // Open menu and reset flag
        this.__scheduleOpen.open();
        this.__scheduleOpen = null;
      },
      /**
       * Event listener for a pending close request. Configured to the interval
       * of the current menu to close.
       *
       * @param e {qx.event.type.Event} Interval event
       */
      _onCloseInterval : function(e){

        // Stop timer, reset scheduling flag
        this.__closeTimer.stop();
        // Close menu and reset flag
        this.__scheduleClose.exclude();
        this.__scheduleClose = null;
      },
      /*
      ---------------------------------------------------------------------------
        MOUSE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler for mousedown events
       *
       * @param e {qx.event.type.Mouse} mousedown event
       */
      _onMouseDown : function(e){

        var R = e.getTarget();
        R = qx.ui.core.Widget.getWidgetByElement(R, true);
        // If the target is 'null' the click appears on a DOM element witch is not
        // a widget. This happens normally with an inline application, when the user
        // clicks not in the inline application. In this case all all currently
        // open menus should be closed.
        if(R == null){

          this.hideAll();
          return;
        };
        // If the target is the one which has opened the current menu
        // we ignore the mousedown to let the button process the event
        // further with toggling or ignoring the click.
        if(R.getMenu && R.getMenu() && R.getMenu().isVisible()){

          return;
        };
        // All clicks not inside a menu will hide all currently open menus
        if(this.__objects.length > 0 && !this._isInMenu(R)){

          this.hideAll();
        };
      },
      /*
      ---------------------------------------------------------------------------
        KEY EVENT HANDLING
      ---------------------------------------------------------------------------
      */
      /**
       * {Map} Map of all keys working on an active menu selection
       * @lint ignoreReferenceField(__selectionKeys)
       */
      __selectionKeys : {
        "Enter" : 1,
        "Space" : 1
      },
      /**
       * {Map} Map of all keys working without a selection
       * @lint ignoreReferenceField(__navigationKeys)
       */
      __navigationKeys : {
        "Escape" : 1,
        "Up" : 1,
        "Down" : 1,
        "Left" : 1,
        "Right" : 1
      },
      /**
       * Event handler for all keyup/keydown events. Stops all events
       * when any menu is opened.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       * @return {void}
       */
      _onKeyUpDown : function(e){

        var S = this.getActiveMenu();
        if(!S){

          return;
        };
        // Stop for all supported key combos
        var T = e.getKeyIdentifier();
        if(this.__navigationKeys[T] || (this.__selectionKeys[T] && S.getSelectedButton())){

          e.stopPropagation();
        };
      },
      /**
       * Event handler for all keypress events. Delegates the event to the more
       * specific methods defined in this class.
       *
       * Currently processes the keys: <code>Up</code>, <code>Down</code>,
       * <code>Left</code>, <code>Right</code> and <code>Enter</code>.
       *
       * @param e {qx.event.type.KeySequence} Keyboard event
       * @return {void}
       */
      _onKeyPress : function(e){

        var U = this.getActiveMenu();
        if(!U){

          return;
        };
        var V = e.getKeyIdentifier();
        var X = this.__navigationKeys[V];
        var W = this.__selectionKeys[V];
        if(X){

          switch(V){case t:
          this._onKeyPressUp(U);
          break;case f:
          this._onKeyPressDown(U);
          break;case n:
          this._onKeyPressLeft(U);
          break;case m:
          this._onKeyPressRight(U);
          break;case q:
          this.hideAll();
          break;};
          e.stopPropagation();
          e.preventDefault();
        } else if(W){

          // Do not process these events when no item is hovered
          var Y = U.getSelectedButton();
          if(Y){

            switch(V){case u:
            this._onKeyPressEnter(U, Y, e);
            break;case c:
            this._onKeyPressSpace(U, Y, e);
            break;};
            e.stopPropagation();
            e.preventDefault();
          };
        };
      },
      /**
       * Event handler for <code>Up</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @return {void}
       */
      _onKeyPressUp : function(ba){

        // Query for previous child
        var bb = ba.getSelectedButton();
        var bc = ba.getChildren();
        var be = bb ? ba.indexOf(bb) - 1 : bc.length - 1;
        var bd = this._getChild(ba, be, -1, true);
        // Reconfigure property
        if(bd){

          ba.setSelectedButton(bd);
        } else {

          ba.resetSelectedButton();
        };
      },
      /**
       * Event handler for <code>Down</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @return {void}
       */
      _onKeyPressDown : function(bf){

        // Query for next child
        var bg = bf.getSelectedButton();
        var bi = bg ? bf.indexOf(bg) + 1 : 0;
        var bh = this._getChild(bf, bi, 1, true);
        // Reconfigure property
        if(bh){

          bf.setSelectedButton(bh);
        } else {

          bf.resetSelectedButton();
        };
      },
      /**
       * Event handler for <code>Left</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @return {void}
       */
      _onKeyPressLeft : function(bj){

        var bo = bj.getOpener();
        if(!bo){

          return;
        };
        // Back to the "parent" menu
        if(bo instanceof qx.ui.menu.AbstractButton){

          var bl = bo.getLayoutParent();
          bl.resetOpenedButton();
          bl.setSelectedButton(bo);
        } else if(bo instanceof qx.ui.menubar.Button){

          var bn = bo.getMenuBar().getMenuButtons();
          var bk = bn.indexOf(bo);
          // This should not happen, definitely!
          if(bk === -1){

            return;
          };
          // Get previous button, fallback to end if first arrived
          var bp = null;
          var length = bn.length;
          for(var i = 1;i <= length;i++){

            var bm = bn[(bk - i + length) % length];
            if(bm.isEnabled() && bm.isVisible()){

              bp = bm;
              break;
            };
          };
          if(bp && bp != bo){

            bp.open(true);
          };
        };
      },
      /**
       * Event handler for <code>Right</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @return {void}
       */
      _onKeyPressRight : function(bq){

        var bs = bq.getSelectedButton();
        // Open sub-menu of hovered item and select first child
        if(bs){

          var br = bs.getMenu();
          if(br){

            // Open previously hovered item
            bq.setOpenedButton(bs);
            // Hover first item in new submenu
            var by = this._getChild(br, 0, 1);
            if(by){

              br.setSelectedButton(by);
            };
            return;
          };
        } else if(!bq.getOpenedButton()){

          var by = this._getChild(bq, 0, 1);
          if(by){

            bq.setSelectedButton(by);
            if(by.getMenu()){

              bq.setOpenedButton(by);
            };
            return;
          };
        };
        // Jump to the next toolbar button
        var bw = bq.getOpener();
        // Look up opener hierarchy for menu button
        if(bw instanceof qx.ui.menu.Button && bs){

          // From one inner selected button try to find the top level
          // menu button which has opened the whole menu chain.
          while(bw){

            bw = bw.getLayoutParent();
            if(bw instanceof qx.ui.menu.Menu){

              bw = bw.getOpener();
              if(bw instanceof qx.ui.menubar.Button){

                break;
              };
            } else {

              break;
            };
          };
          if(!bw){

            return;
          };
        };
        // Ask the toolbar for the next menu button
        if(bw instanceof qx.ui.menubar.Button){

          var bv = bw.getMenuBar().getMenuButtons();
          var bt = bv.indexOf(bw);
          // This should not happen, definitely!
          if(bt === -1){

            return;
          };
          // Get next button, fallback to first if end arrived
          var bx = null;
          var length = bv.length;
          for(var i = 1;i <= length;i++){

            var bu = bv[(bt + i) % length];
            if(bu.isEnabled() && bu.isVisible()){

              bx = bu;
              break;
            };
          };
          if(bx && bx != bw){

            bx.open(true);
          };
        };
      },
      /**
       * Event handler for <code>Enter</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       * @return {void}
       */
      _onKeyPressEnter : function(bz, bA, e){

        // Route keypress event to the selected button
        if(bA.hasListener(d)){

          // Clone and reconfigure event
          var bB = e.clone();
          bB.setBubbles(false);
          bB.setTarget(bA);
          // Finally dispatch the clone
          bA.dispatchEvent(bB);
        };
        // Hide all open menus
        this.hideAll();
      },
      /**
       * Event handler for <code>Space</code> key
       *
       * @param menu {qx.ui.menu.Menu} The active menu
       * @param button {qx.ui.menu.AbstractButton} The selected button
       * @param e {qx.event.type.KeySequence} The keypress event
       * @return {void}
       */
      _onKeyPressSpace : function(bC, bD, e){

        // Route keypress event to the selected button
        if(bD.hasListener(d)){

          // Clone and reconfigure event
          var bE = e.clone();
          bE.setBubbles(false);
          bE.setTarget(bD);
          // Finally dispatch the clone
          bD.dispatchEvent(bE);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      var bG = qx.event.Registration;
      var bF = document.body;
      // React on mousedown/mouseup events
      bG.removeListener(window.document.documentElement, a, this._onMouseDown, this, true);
      // React on keypress events
      bG.removeListener(bF, k, this._onKeyUpDown, this, true);
      bG.removeListener(bF, l, this._onKeyUpDown, this, true);
      bG.removeListener(bF, d, this._onKeyPress, this, true);
      this._disposeObjects(w, s);
      this._disposeArray(r);
    }
  });
})();
(function(){

  var l = "indexOf",k = "addAfter",j = "add",i = "addBefore",h = "_",g = "addAt",f = "hasChildren",e = "removeAt",d = "removeAll",c = "getChildren",a = "remove",b = "qx.ui.core.MRemoteChildrenHandling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin redirects all children handling methods to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to add
   * child widgets directly to the window pane.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the child widgets should be added.
   */
  qx.Mixin.define(b, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Forward the call with the given function name to the children container
       *
       * @param functionName {String} name of the method to forward
       * @param a1 {var} first argument of the method to call
       * @param a2 {var} second argument of the method to call
       * @param a3 {var} third argument of the method to call
       * @return {var} The return value of the forward method
       */
      __forward : function(m, n, o, p){

        var q = this.getChildrenContainer();
        if(q === this){

          m = h + m;
        };
        return (q[m])(n, o, p);
      },
      /**
       * Returns the children list
       *
       * @return {LayoutItem[]} The children array (Arrays are
       *   reference types, please to not modify them in-place)
       */
      getChildren : function(){

        return this.__forward(c);
      },
      /**
       * Whether the widget contains children.
       *
       * @return {Boolean} Returns <code>true</code> when the widget has children.
       */
      hasChildren : function(){

        return this.__forward(f);
      },
      /**
       * Adds a new child widget.
       *
       * The supported keys of the layout options map depend on the layout manager
       * used to position the widget. The options are documented in the class
       * documentation of each layout manager {@link qx.ui.layout}.
       *
       * @param child {LayoutItem} the item to add.
       * @param options {Map?null} Optional layout data for item.
       * @return {Widget} This object (for chaining support)
       */
      add : function(r, s){

        return this.__forward(j, r, s);
      },
      /**
       * Remove the given child item.
       *
       * @param child {LayoutItem} the item to remove
       * @return {Widget} This object (for chaining support)
       */
      remove : function(t){

        return this.__forward(a, t);
      },
      /**
       * Remove all children.
       *
       * @return {void}
       */
      removeAll : function(){

        return this.__forward(d);
      },
      /**
       * Returns the index position of the given item if it is
       * a child item. Otherwise it returns <code>-1</code>.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} the item to query for
       * @return {Integer} The index position or <code>-1</code> when
       *   the given item is no child of this layout.
       */
      indexOf : function(u){

        return this.__forward(l, u);
      },
      /**
       * Add a child at the specified index
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} item to add
       * @param index {Integer} Index, at which the item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAt : function(v, w, x){

        this.__forward(g, v, w, x);
      },
      /**
       * Add an item before another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} item to add
       * @param before {LayoutItem} item before the new item will be inserted.
       * @param options {Map?null} Optional layout data for item.
       */
      addBefore : function(y, z, A){

        this.__forward(i, y, z, A);
      },
      /**
       * Add an item after another already inserted item
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param child {LayoutItem} item to add
       * @param after {LayoutItem} item, after which the new item will be inserted
       * @param options {Map?null} Optional layout data for item.
       */
      addAfter : function(B, C, D){

        this.__forward(k, B, C, D);
      },
      /**
       * Remove the item at the specified index.
       *
       * This method works on the widget's children list. Some layout managers
       * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
       * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
       * ignore the children order for the layout process.
       *
       * @param index {Integer} Index of the item to remove.
       * @return {qx.ui.core.LayoutItem} The removed item
       */
      removeAt : function(E){

        return this.__forward(e, E);
      }
    }
  });
})();
(function(){

  var l = "Boolean",k = "mouseout",j = "excluded",h = "menu",g = "_applySelectedButton",f = "_applySpacingY",d = "_blocker",c = "_applyCloseInterval",b = "_applyBlockerColor",a = "The menu instance needs a configured 'opener' widget!",D = "_applyIconColumnWidth",C = "mouseover",B = "_applyArrowColumnWidth",A = "qx.ui.menu.Menu",z = "Color",y = "Number",x = "_applyOpenInterval",w = "Unknown target: ",v = "_applySpacingX",u = "_applyBlockerOpacity",s = "Could not open menu instance because 'opener' widget is not visible",t = "_applyOpenedButton",q = "selected",r = "visible",o = "qx.ui.core.Widget",p = "Integer",m = "resize",n = "slidebar";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The menu is a popup like control which supports buttons. It comes
   * with full keyboard navigation and an improved timeout based mouse
   * control behavior.
   *
   * This class is the container for all derived instances of
   * {@link qx.ui.menu.AbstractButton}.
   *
   * @childControl slidebar {qx.ui.menu.MenuSlideBar} shows a slidebar to easily navigate inside the menu (if too little space is left)
   */
  qx.Class.define(A, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MPlacement, qx.ui.core.MRemoteChildrenHandling],
    construct : function(){

      qx.ui.core.Widget.call(this);
      // Use hard coded layout
      this._setLayout(new qx.ui.menu.Layout);
      // Automatically add to application's root
      var E = this.getApplicationRoot();
      E.add(this);
      // Register mouse listeners
      this.addListener(C, this._onMouseOver);
      this.addListener(k, this._onMouseOut);
      // add resize listener
      this.addListener(m, this._onResize, this);
      E.addListener(m, this._onResize, this);
      this._blocker = new qx.ui.core.Blocker(E);
      // Initialize properties
      this.initVisibility();
      this.initKeepFocus();
      this.initKeepActive();
    },
    properties : {
      /*
      ---------------------------------------------------------------------------
        WIDGET PROPERTIES
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance : {
        refine : true,
        init : h
      },
      // overridden
      allowGrowX : {
        refine : true,
        init : false
      },
      // overridden
      allowGrowY : {
        refine : true,
        init : false
      },
      // overridden
      visibility : {
        refine : true,
        init : j
      },
      // overridden
      keepFocus : {
        refine : true,
        init : true
      },
      // overridden
      keepActive : {
        refine : true,
        init : true
      },
      /*
      ---------------------------------------------------------------------------
        STYLE OPTIONS
      ---------------------------------------------------------------------------
      */
      /** The spacing between each cell of the menu buttons */
      spacingX : {
        check : p,
        apply : v,
        init : 0,
        themeable : true
      },
      /** The spacing between each menu button */
      spacingY : {
        check : p,
        apply : f,
        init : 0,
        themeable : true
      },
      /**
      * Default icon column width if no icons are rendered.
      * This property is ignored as soon as an icon is present.
      */
      iconColumnWidth : {
        check : p,
        init : 0,
        themeable : true,
        apply : D
      },
      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth : {
        check : p,
        init : 0,
        themeable : true,
        apply : B
      },
      /**
       * Color of the blocker
       */
      blockerColor : {
        check : z,
        init : null,
        nullable : true,
        apply : b,
        themeable : true
      },
      /**
       * Opacity of the blocker
       */
      blockerOpacity : {
        check : y,
        init : 1,
        apply : u,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        FUNCTIONALITY PROPERTIES
      ---------------------------------------------------------------------------
      */
      /** The currently selected button */
      selectedButton : {
        check : o,
        nullable : true,
        apply : g
      },
      /** The currently opened button (sub menu is visible) */
      openedButton : {
        check : o,
        nullable : true,
        apply : t
      },
      /** Widget that opened the menu */
      opener : {
        check : o,
        nullable : true
      },
      /*
      ---------------------------------------------------------------------------
        BEHAVIOR PROPERTIES
      ---------------------------------------------------------------------------
      */
      /** Interval in ms after which sub menus should be opened */
      openInterval : {
        check : p,
        themeable : true,
        init : 250,
        apply : x
      },
      /** Interval in ms after which sub menus should be closed  */
      closeInterval : {
        check : p,
        themeable : true,
        init : 250,
        apply : c
      },
      /** Blocks the background if value is <code>true<code> */
      blockBackground : {
        check : l,
        themeable : true,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __scheduledOpen : null,
      __onAfterSlideBarAdd : null,
      /** {qx.ui.core.Blocker} blocker for background blocking */
      _blocker : null,
      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Opens the menu and configures the opener
       */
      open : function(){

        if(this.getOpener() != null){

          var F = this.placeToWidget(this.getOpener());
          if(F){

            this.__updateSlideBar();
            this.show();
            this._placementTarget = this.getOpener();
          } else {

            this.warn(s);
          };
        } else {

          this.warn(a);
        };
      },
      /**
       * Opens the menu at the mouse cursor position
       *
       * @param e {qx.event.type.Mouse}  Mouse event to align to
       */
      openAtMouse : function(e){

        this.placeToMouse(e);
        this.__updateSlideBar();
        this.show();
        this._placementTarget = {
          left : e.getDocumentLeft(),
          top : e.getDocumentTop()
        };
      },
      /**
       * Opens the menu in relation to the given point
       *
       * @param point {Map} Coordinate of any point with the keys <code>left</code>
       *   and <code>top</code>.
       */
      openAtPoint : function(G){

        this.placeToPoint(G);
        this.__updateSlideBar();
        this.show();
        this._placementTarget = G;
      },
      /**
       * Convenience method to add a separator to the menu
       */
      addSeparator : function(){

        this.add(new qx.ui.menu.Separator);
      },
      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes : function(){

        return this._getMenuLayout().getColumnSizes();
      },
      /**
       * Return all selectable menu items.
       *
       * @return {qx.ui.core.Widget[]} selectable widgets
       */
      getSelectables : function(){

        var H = [];
        var I = this.getChildren();
        for(var i = 0;i < I.length;i++){

          if(I[i].isEnabled()){

            H.push(I[i]);
          };
        };
        return H;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIconColumnWidth : function(J, K){

        this._getMenuLayout().setIconColumnWidth(J);
      },
      // property apply
      _applyArrowColumnWidth : function(L, M){

        this._getMenuLayout().setArrowColumnWidth(L);
      },
      // property apply
      _applySpacingX : function(N, O){

        this._getMenuLayout().setColumnSpacing(N);
      },
      // property apply
      _applySpacingY : function(P, Q){

        this._getMenuLayout().setSpacing(P);
      },
      // overridden
      _applyVisibility : function(R, S){

        qx.ui.core.Widget.prototype._applyVisibility.call(this, R, S);
        var T = qx.ui.menu.Manager.getInstance();
        if(R === r){

          // Register to manager (zIndex handling etc.)
          T.add(this);
          // Mark opened in parent menu
          var U = this.getParentMenu();
          if(U){

            U.setOpenedButton(this.getOpener());
          };
        } else if(S === r){

          // Deregister from manager (zIndex handling etc.)
          T.remove(this);
          // Unmark opened in parent menu
          var U = this.getParentMenu();
          if(U && U.getOpenedButton() == this.getOpener()){

            U.resetOpenedButton();
          };
          // Clear properties
          this.resetOpenedButton();
          this.resetSelectedButton();
        };
        this.__updateBlockerVisibility();
      },
      /**
       * Updates the blocker's visibility
       */
      __updateBlockerVisibility : function(){

        if(this.isVisible()){

          if(this.getBlockBackground()){

            var V = this.getZIndex();
            this._blocker.blockContent(V - 1);
          };
        } else {

          if(this._blocker.isContentBlocked()){

            this._blocker.unblockContent();
          };
        };
      },
      /**
       * Get the parent menu. Returns <code>null</code> if the menu doesn't have a
       * parent menu.
       *
       * @return {Menu|null} The parent menu.
       */
      getParentMenu : function(){

        var W = this.getOpener();
        if(!W || !(W instanceof qx.ui.menu.AbstractButton)){

          return null;
        };
        if(W && W.getContextMenu() === this){

          return null;
        };
        while(W && !(W instanceof qx.ui.menu.Menu)){

          W = W.getLayoutParent();
        };
        return W;
      },
      // property apply
      _applySelectedButton : function(X, Y){

        if(Y){

          Y.removeState(q);
        };
        if(X){

          X.addState(q);
        };
      },
      // property apply
      _applyOpenedButton : function(ba, bb){

        if(bb && bb.getMenu()){

          bb.getMenu().exclude();
        };
        if(ba){

          ba.getMenu().open();
        };
      },
      // property apply
      _applyBlockerColor : function(bc, bd){

        this._blocker.setColor(bc);
      },
      // property apply
      _applyBlockerOpacity : function(be, bf){

        this._blocker.setOpacity(be);
      },
      /*
      ---------------------------------------------------------------------------
      SCROLLING SUPPORT
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer : function(){

        return this.getChildControl(n, true) || this;
      },
      // overridden
      _createChildControlImpl : function(bg, bh){

        var bi;
        switch(bg){case n:
        var bi = new qx.ui.menu.MenuSlideBar();
        var bk = this._getLayout();
        this._setLayout(new qx.ui.layout.Grow());
        var bj = bi.getLayout();
        bi.setLayout(bk);
        bj.dispose();
        var bl = qx.lang.Array.clone(this.getChildren());
        for(var i = 0;i < bl.length;i++){

          bi.add(bl[i]);
        };
        this.removeListener(m, this._onResize, this);
        bi.getChildrenContainer().addListener(m, this._onResize, this);
        this._add(bi);
        break;};
        return bi || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, bg);
      },
      /**
       * Get the menu layout manager
       *
       * @return {Layout} The menu layout manager
       */
      _getMenuLayout : function(){

        if(this.hasChildControl(n)){

          return this.getChildControl(n).getChildrenContainer().getLayout();
        } else {

          return this._getLayout();
        };
      },
      /**
       * Get the menu bounds
       *
       * @return {Map} The menu bounds
       */
      _getMenuBounds : function(){

        if(this.hasChildControl(n)){

          return this.getChildControl(n).getChildrenContainer().getBounds();
        } else {

          return this.getBounds();
        };
      },
      /**
       * Computes the size of the menu. This method is used by the
       * {@link qx.ui.core.MPlacement} mixin.
       */
      _computePlacementSize : function(){

        return this._getMenuBounds();
      },
      /**
       * Updates the visibility of the slidebar based on the menu's current size
       * and position.
       */
      __updateSlideBar : function(){

        var bn = this._getMenuBounds();
        if(!bn){

          this.addListenerOnce(m, this.__updateSlideBar, this);
          return;
        };
        var bm = this.getLayoutParent().getBounds().height;
        var top = this.getLayoutProperties().top;
        var bo = this.getLayoutProperties().left;
        // Adding the slidebar must be deferred because this call can happen
        // during the layout flush, which make it impossible to move existing
        // layout to the slidebar
        if(top < 0){

          this._assertSlideBar(function(){

            this.setHeight(bn.height + top);
            this.moveTo(bo, 0);
          });
        } else if(top + bn.height > bm){

          this._assertSlideBar(function(){

            this.setHeight(bm - top);
          });
        } else {

          this.setHeight(null);
        };
      },
      /**
       * Schedules the addition of the slidebar and calls the given callback
       * after the slidebar has been added.
       *
       * @param callback {Function} the callback to call
       */
      _assertSlideBar : function(bp){

        if(this.hasChildControl(n)){

          return bp.call(this);
        };
        this.__onAfterSlideBarAdd = bp;
        qx.ui.core.queue.Widget.add(this);
      },
      // overridden
      syncWidget : function(bq){

        this.getChildControl(n);
        if(this.__onAfterSlideBarAdd){

          this.__onAfterSlideBarAdd.call(this);
          delete this.__onAfterSlideBarAdd;
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLING
      ---------------------------------------------------------------------------
      */
      /**
       * Update position if the menu or the root is resized
       */
      _onResize : function(){

        if(this.isVisible()){

          var br = this._placementTarget;
          if(!br){

            return;
          } else if(br instanceof qx.ui.core.Widget){

            this.placeToWidget(br);
          } else if(br.top !== undefined){

            this.placeToPoint(br);
          } else {

            throw new Error(w + br);
          };;
          this.__updateSlideBar();
        };
      },
      /**
       * Event listener for mouseover event.
       *
       * @param e {qx.event.type.Mouse} mouseover event
       * @return {void}
       */
      _onMouseOver : function(e){

        // Cache manager
        var bt = qx.ui.menu.Manager.getInstance();
        // Be sure this menu is kept
        bt.cancelClose(this);
        // Change selection
        var bu = e.getTarget();
        if(bu.isEnabled() && bu instanceof qx.ui.menu.AbstractButton){

          // Select button directly
          this.setSelectedButton(bu);
          var bs = bu.getMenu && bu.getMenu();
          if(bs){

            bs.setOpener(bu);
            // Finally schedule for opening
            bt.scheduleOpen(bs);
            // Remember scheduled menu for opening
            this.__scheduledOpen = bs;
          } else {

            var bv = this.getOpenedButton();
            if(bv){

              bt.scheduleClose(bv.getMenu());
            };
            if(this.__scheduledOpen){

              bt.cancelOpen(this.__scheduledOpen);
              this.__scheduledOpen = null;
            };
          };
        } else if(!this.getOpenedButton()){

          // When no button is opened reset the selection
          // Otherwise keep it
          this.resetSelectedButton();
        };
      },
      /**
       * Event listener for mouseout event.
       *
       * @param e {qx.event.type.Mouse} mouseout event
       * @return {void}
       */
      _onMouseOut : function(e){

        // Cache manager
        var bw = qx.ui.menu.Manager.getInstance();
        // Detect whether the related target is out of the menu
        if(!qx.ui.core.Widget.contains(this, e.getRelatedTarget())){

          // Update selected property
          // Force it to the open sub menu in cases where that is opened
          // Otherwise reset it. Menus which are left by the cursor should
          // not show any selection.
          var bx = this.getOpenedButton();
          bx ? this.setSelectedButton(bx) : this.resetSelectedButton();
          // Cancel a pending close request for the currently
          // opened sub menu
          if(bx){

            bw.cancelClose(bx.getMenu());
          };
          // When leaving this menu to the outside, stop
          // all pending requests to open any other sub menu
          if(this.__scheduledOpen){

            bw.cancelOpen(this.__scheduledOpen);
          };
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(!qx.core.ObjectRegistry.inShutDown){

        qx.ui.menu.Manager.getInstance().remove(this);
      };
      this.getApplicationRoot().removeListener(m, this._onResize, this);
      this._placementTarget = null;
      this._disposeObjects(d);
    }
  });
})();
(function(){

  var c = "qx.ui.menu.Layout",b = "Integer",a = "_applyLayoutChange";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Layouter used by the qooxdoo menu's to render their buttons
   *
   * @internal
   */
  qx.Class.define(c, {
    extend : qx.ui.layout.VBox,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Spacing between each cell on the menu buttons */
      columnSpacing : {
        check : b,
        init : 0,
        apply : a
      },
      /**
       * Whether a column and which column should automatically span
       * when the following cell is empty. Spanning may be disabled
       * through setting this property to <code>null</code>.
       */
      spanColumn : {
        check : b,
        init : 1,
        nullable : true,
        apply : a
      },
      /** Default icon column width if no icons are rendered */
      iconColumnWidth : {
        check : b,
        init : 0,
        themeable : true,
        apply : a
      },
      /** Default arrow column width if no sub menus are rendered */
      arrowColumnWidth : {
        check : b,
        init : 0,
        themeable : true,
        apply : a
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __columnSizes : null,
      /*
      ---------------------------------------------------------------------------
        LAYOUT INTERFACE
      ---------------------------------------------------------------------------
      */
      // overridden
      _computeSizeHint : function(){

        var q = this._getLayoutChildren();
        var o,g,j;
        var e = this.getSpanColumn();
        var h = this.__columnSizes = [0, 0, 0, 0];
        var m = this.getColumnSpacing();
        var k = 0;
        var f = 0;
        // Compute column sizes and insets
        for(var i = 0,l = q.length;i < l;i++){

          o = q[i];
          if(o.isAnonymous()){

            continue;
          };
          g = o.getChildrenSizes();
          for(var n = 0;n < g.length;n++){

            if(e != null && n == e && g[e + 1] == 0){

              k = Math.max(k, g[n]);
            } else {

              h[n] = Math.max(h[n], g[n]);
            };
          };
          var d = q[i].getInsets();
          f = Math.max(f, d.left + d.right);
        };
        // Fix label column width is cases where the maximum button with no shortcut
        // is larger than the maximum button with a shortcut
        if(e != null && h[e] + m + h[e + 1] < k){

          h[e] = k - h[e + 1] - m;
        };
        // When merging the cells for label and shortcut
        // ignore the spacing between them
        if(k == 0){

          j = m * 2;
        } else {

          j = m * 3;
        };
        // Fix zero size icon column
        if(h[0] == 0){

          h[0] = this.getIconColumnWidth();
        };
        // Fix zero size arrow column
        if(h[3] == 0){

          h[3] = this.getArrowColumnWidth();
        };
        var p = qx.ui.layout.VBox.prototype._computeSizeHint.call(this).height;
        // Build hint
        return {
          minHeight : p,
          height : p,
          width : qx.lang.Array.sum(h) + f + j
        };
      },
      /*
      ---------------------------------------------------------------------------
        CUSTOM ADDONS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the column sizes detected during the pre-layout phase
       *
       * @return {Array} List of all column widths
       */
      getColumnSizes : function(){

        return this.__columnSizes || null;
      }
    },
    /*
     *****************************************************************************
        DESTRUCT
     *****************************************************************************
     */
    destruct : function(){

      this.__columnSizes = null;
    }
  });
})();
(function(){

  var b = "menu-separator",a = "qx.ui.menu.Separator";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This widget draws a separator line between two instances of
   * {@link qx.ui.menu.AbstractButton} and is inserted into the
   * {@link qx.ui.menu.Menu}.
   *
   * For convenience reasons there is also
   * a method {@link qx.ui.menu.Menu#addSeparator} to append instances
   * of this class to the menu.
   */
  qx.Class.define(a, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : b
      },
      // overridden
      anonymous : {
        refine : true,
        init : true
      }
    }
  });
})();
(function(){

  var v = "qx.ui.menu.Menu",u = "qx.ui.menu.AbstractButton",t = "keypress",s = "",r = "_applyIcon",q = "changeMenu",p = "changeIcon",o = "click",n = "changeLabel",m = "abstract",f = "_applyLabel",l = "_applyMenu",i = "submenu",c = "String",b = "changeCommand",h = "changeLocale",g = "qx.dynlocale",j = "icon",a = "label",k = "arrow",d = "shortcut";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The abstract menu button class is used for all type of menu content
   * for example normal buttons, checkboxes or radiobuttons.
   *
   * @childControl icon {qx.ui.basic.Image} icon of the button
   * @childControl label {qx.ui.basic.Label} label of the button
   * @childControl shortcut {qx.ui.basic.Label} shows if specified the shortcut
   * @childControl arrow {qx.ui.basic.Image} shows the arrow to show an additional widget (e.g. popup or submenu)
   */
  qx.Class.define(u, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MExecutable],
    implement : [qx.ui.form.IExecutable],
    type : m,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.Widget.call(this);
      // Use hard coded layout
      this._setLayout(new qx.ui.menu.ButtonLayout);
      // Add listeners
      this.addListener(o, this._onClick);
      this.addListener(t, this._onKeyPress);
      // Add command listener
      this.addListener(b, this._onChangeCommand, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      blockToolTip : {
        refine : true,
        init : true
      },
      /** The label text of the button */
      label : {
        check : c,
        apply : f,
        nullable : true,
        event : n
      },
      /** Whether a sub menu should be shown and which one */
      menu : {
        check : v,
        apply : l,
        nullable : true,
        dereference : true,
        event : q
      },
      /** The icon to use */
      icon : {
        check : c,
        apply : r,
        themeable : true,
        nullable : true,
        event : p
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl : function(w, x){

        var y;
        switch(w){case j:
        y = new qx.ui.basic.Image;
        y.setAnonymous(true);
        this._add(y, {
          column : 0
        });
        break;case a:
        y = new qx.ui.basic.Label;
        y.setAnonymous(true);
        this._add(y, {
          column : 1
        });
        break;case d:
        y = new qx.ui.basic.Label;
        y.setAnonymous(true);
        this._add(y, {
          column : 2
        });
        break;case k:
        y = new qx.ui.basic.Image;
        y.setAnonymous(true);
        this._add(y, {
          column : 3
        });
        break;};
        return y || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, w);
      },
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        selected : 1
      },
      /*
      ---------------------------------------------------------------------------
        LAYOUT UTILS
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the dimensions of all children
       *
       * @return {Array} Preferred width of each child
       */
      getChildrenSizes : function(){

        var z = 0,A = 0,B = 0,F = 0;
        if(this._isChildControlVisible(j)){

          var G = this.getChildControl(j);
          z = G.getMarginLeft() + G.getSizeHint().width + G.getMarginRight();
        };
        if(this._isChildControlVisible(a)){

          var D = this.getChildControl(a);
          A = D.getMarginLeft() + D.getSizeHint().width + D.getMarginRight();
        };
        if(this._isChildControlVisible(d)){

          var C = this.getChildControl(d);
          B = C.getMarginLeft() + C.getSizeHint().width + C.getMarginRight();
        };
        if(this._isChildControlVisible(k)){

          var E = this.getChildControl(k);
          F = E.getMarginLeft() + E.getSizeHint().width + E.getMarginRight();
        };
        return [z, A, B, F];
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for click
       *
       * @param e {qx.event.type.Mouse} mouseup event
       */
      _onClick : function(e){
      },
      /**
       * Event listener for mouseup event
       *
       * @param e {qx.event.type.KeySequence} keypress event
       */
      _onKeyPress : function(e){
      },
      /**
       * Event listener for command changes. Updates the text of the shortcut.
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onChangeCommand : function(e){

        var J = e.getData();
        // do nothing if no command is set
        if(J == null){

          return;
        };
        if(qx.core.Environment.get(g)){

          var H = e.getOldData();
          if(!H){

            qx.locale.Manager.getInstance().addListener(h, this._onChangeLocale, this);
          };
          if(!J){

            qx.locale.Manager.getInstance().removeListener(h, this._onChangeLocale, this);
          };
        };
        var I = J != null ? J.toString() : s;
        this.getChildControl(d).setValue(I);
      },
      /**
       * Update command string on locale changes
       */
      _onChangeLocale : qx.core.Environment.select(g, {
        "true" : function(e){

          var K = this.getCommand();
          if(K != null){

            this.getChildControl(d).setValue(K.toString());
          };
        },
        "false" : null
      }),
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyIcon : function(L, M){

        if(L){

          this._showChildControl(j).setSource(L);
        } else {

          this._excludeChildControl(j);
        };
      },
      // property apply
      _applyLabel : function(N, O){

        if(N){

          this._showChildControl(a).setValue(N);
        } else {

          this._excludeChildControl(a);
        };
      },
      // property apply
      _applyMenu : function(P, Q){

        if(Q){

          Q.resetOpener();
          Q.removeState(i);
        };
        if(P){

          this._showChildControl(k);
          P.setOpener(this);
          P.addState(i);
        } else {

          this._excludeChildControl(k);
        };
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct : function(){

      this.removeListener(b, this._onChangeCommand, this);
      if(this.getMenu()){

        if(!qx.core.ObjectRegistry.inShutDown){

          this.getMenu().destroy();
        };
      };
      if(qx.core.Environment.get(g)){

        qx.locale.Manager.getInstance().removeListener(h, this._onChangeLocale, this);
      };
    }
  });
})();
(function(){

  var g = "qx.ui.menu.ButtonLayout",f = "qx.debug",e = "column",d = "left",c = "middle",b = "' is not supported by the MenuButton layout!",a = "The property '";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Layout used for the menu buttons which may contain four elements. A icon,
   * a label, a shortcut text and an arrow (for a sub menu)
   *
   * @internal
   */
  qx.Class.define(g, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(f, {
        "true" : function(h, name, j){

          this.assert(name == e, a + name + b);
        },
        "false" : null
      }),
      // overridden
      renderLayout : function(k, m){

        var w = this._getLayoutChildren();
        var v;
        var o;
        var p = [];
        for(var i = 0,l = w.length;i < l;i++){

          v = w[i];
          o = v.getLayoutProperties().column;
          p[o] = v;
        };
        var u = this.__getMenu(w[0]);
        var x = u.getColumnSizes();
        var r = u.getSpacingX();
        // stretch label column
        var q = qx.lang.Array.sum(x) + r * (x.length - 1);
        if(q < k){

          x[1] += k - q;
        };
        var y = 0,top = 0;
        var s = qx.ui.layout.Util;
        for(var i = 0,l = x.length;i < l;i++){

          v = p[i];
          if(v){

            var n = v.getSizeHint();
            var top = s.computeVerticalAlignOffset(v.getAlignY() || c, n.height, m, 0, 0);
            var t = s.computeHorizontalAlignOffset(v.getAlignX() || d, n.width, x[i], v.getMarginLeft(), v.getMarginRight());
            v.renderLayout(y + t, top, n.width, n.height);
          };
          if(x[i] > 0){

            y += x[i] + r;
          };
        };
      },
      /**
       * Get the widget's menu
       *
       * @param widget {qx.ui.core.Widget} the widget to get the menu for
       * @return {qx.ui.menu.Menu} the menu
       */
      __getMenu : function(z){

        while(!(z instanceof qx.ui.menu.Menu)){

          z = z.getLayoutParent();
        };
        return z;
      },
      // overridden
      _computeSizeHint : function(){

        var C = this._getLayoutChildren();
        var B = 0;
        var D = 0;
        for(var i = 0,l = C.length;i < l;i++){

          var A = C[i].getSizeHint();
          D += A.width;
          B = Math.max(B, A.height);
        };
        return {
          width : D,
          height : B
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.core.MRemoteLayoutHandling";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin redirects the layout manager to a child widget of the
   * including class. This is e.g. used in {@link qx.ui.window.Window} to configure
   * the layout manager of the window pane instead of the window directly.
   *
   * The including class must implement the method <code>getChildrenContainer</code>,
   * which has to return the widget, to which the layout should be set.
   */
  qx.Mixin.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Set a layout manager for the widget. A a layout manager can only be connected
       * with one widget. Reset the connection with a previous widget first, if you
       * like to use it in another widget instead.
       *
       * @param layout {qx.ui.layout.Abstract} The new layout or
       *     <code>null</code> to reset the layout.
       * @return {void}
       */
      setLayout : function(b){

        return this.getChildrenContainer().setLayout(b);
      },
      /**
       * Get the widget's layout manager.
       *
       * @return {qx.ui.layout.Abstract} The widget's layout manager
       */
      getLayout : function(){

        return this.getChildrenContainer().getLayout();
      }
    }
  });
})();
(function(){

  var v = "qx.ui.container.SlideBar",u = "engine.version",t = "engine.name",s = "removeChildWidget",r = "scrollX",q = "scrollY",p = "_applyOrientation",o = "mousewheel",n = "gecko",m = "x",f = "y",l = "Integer",i = "slidebar",c = "update",b = "content",h = "execute",g = "button-backward",j = "button-forward",a = "vertical",k = "scrollpane",d = "horizontal";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * Container, which provides scrolling in one dimension (vertical or horizontal).
   *
   * @childControl button-forward {qx.ui.form.RepeatButton} button to step forward
   * @childControl button-backward {qx.ui.form.RepeatButton} button to step backward
   * @childControl content {qx.ui.container.Composite} container to hold the content
   * @childControl scrollpane {qx.ui.core.scroll.ScrollPane} the scroll pane holds the content to enable scrolling
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   // create slide bar container
   *   slideBar = new qx.ui.container.SlideBar().set({
   *     width: 300
   *   });
   *
   *   // set layout
   *   slideBar.setLayout(new qx.ui.layout.HBox());
   *
   *   // add some widgets
   *   for (var i=0; i<10; i++)
   *   {
   *     slideBar.add((new qx.ui.core.Widget()).set({
   *       backgroundColor : (i % 2 == 0) ? "red" : "blue",
   *       width : 60
   *     }));
   *   }
   *
   *   this.getRoot().add(slideBar);
   * </pre>
   *
   * This example creates a SlideBar and add some widgets with alternating
   * background colors. Since the content is larger than the container, two
   * scroll buttons at the left and the right edge are shown.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/slidebar.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(v, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param orientation {String?"horizontal"} The slide bar orientation
     */
    construct : function(w){

      qx.ui.core.Widget.call(this);
      var x = this.getChildControl(k);
      this._add(x, {
        flex : 1
      });
      if(w != null){

        this.setOrientation(w);
      } else {

        this.initOrientation();
      };
      this.addListener(o, this._onMouseWheel, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : i
      },
      /** Orientation of the bar */
      orientation : {
        check : [d, a],
        init : d,
        apply : p
      },
      /** The number of pixels to scroll if the buttons are pressed */
      scrollStep : {
        check : l,
        init : 15,
        themeable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getChildrenContainer : function(){

        return this.getChildControl(b);
      },
      // overridden
      _createChildControlImpl : function(y, z){

        var A;
        switch(y){case j:
        A = new qx.ui.form.RepeatButton;
        A.addListener(h, this._onExecuteForward, this);
        A.setFocusable(false);
        this._addAt(A, 2);
        break;case g:
        A = new qx.ui.form.RepeatButton;
        A.addListener(h, this._onExecuteBackward, this);
        A.setFocusable(false);
        this._addAt(A, 0);
        break;case b:
        A = new qx.ui.container.Composite();
        /*
         * Gecko < 2 does not update the scroll position after removing an
         * element. So we have to do this by hand.
         */
        if(qx.core.Environment.get(t) == n && parseInt(qx.core.Environment.get(u)) < 2){

          A.addListener(s, this._onRemoveChild, this);
        };
        this.getChildControl(k).add(A);
        break;case k:
        A = new qx.ui.core.scroll.ScrollPane();
        A.addListener(c, this._onResize, this);
        A.addListener(r, this._onScroll, this);
        A.addListener(q, this._onScroll, this);
        break;};
        return A || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, y);
      },
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        barLeft : true,
        barTop : true,
        barRight : true,
        barBottom : true
      },
      /*
      ---------------------------------------------------------------------------
        PUBLIC SCROLL API
      ---------------------------------------------------------------------------
      */
      /**
       * Scrolls the element's content by the given amount.
       *
       * @param offset {Integer?0} Amount to scroll
       * @return {void}
       */
      scrollBy : function(B){

        var C = this.getChildControl(k);
        if(this.getOrientation() === d){

          C.scrollByX(B);
        } else {

          C.scrollByY(B);
        };
      },
      /**
       * Scrolls the element's content to the given coordinate
       *
       * @param value {Integer} The position to scroll to.
       * @return {void}
       */
      scrollTo : function(D){

        var E = this.getChildControl(k);
        if(this.getOrientation() === d){

          E.scrollToX(D);
        } else {

          E.scrollToY(D);
        };
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled : function(F, G, name){

        qx.ui.core.Widget.prototype._applyEnabled.call(this, F, G, name);
        this._updateArrowsEnabled();
      },
      // property apply
      _applyOrientation : function(H, I){

        var L = [this.getLayout(), this._getLayout()];
        var K = this.getChildControl(j);
        var J = this.getChildControl(g);
        // old can also be null, so we have to check both explicitly to set
        // the states correctly.
        if(I == a && H == d){

          K.removeState(a);
          J.removeState(a);
          K.addState(d);
          J.addState(d);
        } else if(I == d && H == a){

          K.removeState(d);
          J.removeState(d);
          K.addState(a);
          J.addState(a);
        };
        if(H == d){

          this._setLayout(new qx.ui.layout.HBox());
          this.setLayout(new qx.ui.layout.HBox());
        } else {

          this._setLayout(new qx.ui.layout.VBox());
          this.setLayout(new qx.ui.layout.VBox());
        };
        if(L[0]){

          L[0].dispose();
        };
        if(L[1]){

          L[1].dispose();
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Scrolls pane on mousewheel events
       *
       * @param e {qx.event.type.Mouse} the mouse event
       */
      _onMouseWheel : function(e){

        var Q = 0;
        var P = this.getChildControl(k);
        if(this.getOrientation() === d){

          Q = e.getWheelDelta(m);
          var M = P.getScrollX();
          var N = P.getScrollMaxX();
          var O = parseInt(Q);
          // pass the event to the parent if both scrollbars are at the end
          if(!(O < 0 && M <= 0 || O > 0 && M >= N || Q == 0)){

            e.stop();
          };
        } else {

          Q = e.getWheelDelta(f);
          var M = P.getScrollY();
          var N = P.getScrollMaxY();
          var O = parseInt(Q);
          // pass the event to the parent if both scrollbars are at the end
          if(!(O < 0 && M <= 0 || O > 0 && M >= N || Q == 0)){

            e.stop();
          };
        };
        this.scrollBy(Q * this.getScrollStep());
      },
      /**
       * Update arrow enabled state after scrolling
       */
      _onScroll : function(){

        this._updateArrowsEnabled();
      },
      /**
       * Listener for resize event. This event is fired after the
       * first flush of the element which leads to another queuing
       * when the changes modify the visibility of the scroll buttons.
       *
       * @param e {Event} Event object
       * @return {void}
       */
      _onResize : function(e){

        var content = this.getChildControl(k).getChildren()[0];
        if(!content){

          return;
        };
        var R = this.getInnerSize();
        var T = content.getBounds();
        var S = (this.getOrientation() === d) ? T.width > R.width : T.height > R.height;
        if(S){

          this._showArrows();
          this._updateArrowsEnabled();
        } else {

          this._hideArrows();
        };
      },
      /**
       * Scroll handler for left scrolling
       *
       * @return {void}
       */
      _onExecuteBackward : function(){

        this.scrollBy(-this.getScrollStep());
      },
      /**
       * Scroll handler for right scrolling
       *
       * @return {void}
       */
      _onExecuteForward : function(){

        this.scrollBy(this.getScrollStep());
      },
      /**
       * Helper function for Gecko. Modifies the scroll offset when a child is
       * removed.
       */
      _onRemoveChild : function(){

        qx.event.Timer.once(function(){

          // It might happen that the child control is already disposed in very
          // seldom cases - anyway check against that (Bug #5339)
          var U = this.getChildControl(k);
          if(!U.isDisposed()){

            this.scrollBy(U.getScrollX());
          };
        }, this, 50);
      },
      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Update arrow enabled state
       */
      _updateArrowsEnabled : function(){

        // set the disables state directly because we are overriding the
        // inheritance
        if(!this.getEnabled()){

          this.getChildControl(g).setEnabled(false);
          this.getChildControl(j).setEnabled(false);
          return;
        };
        var W = this.getChildControl(k);
        if(this.getOrientation() === d){

          var V = W.getScrollX();
          var X = W.getScrollMaxX();
        } else {

          var V = W.getScrollY();
          var X = W.getScrollMaxY();
        };
        this.getChildControl(g).setEnabled(V > 0);
        this.getChildControl(j).setEnabled(V < X);
      },
      /**
       * Show the arrows (Called from resize event)
       *
       * @return {void}
       */
      _showArrows : function(){

        this._showChildControl(j);
        this._showChildControl(g);
      },
      /**
       * Hide the arrows (Called from resize event)
       *
       * @return {void}
       */
      _hideArrows : function(){

        this._excludeChildControl(j);
        this._excludeChildControl(g);
        this.scrollTo(0);
      }
    }
  });
})();
(function(){

  var n = "press",m = "qx.ui.form.RepeatButton",l = "release",k = "__timer",j = "interval",i = "execute",h = "Enter",g = "Space",f = "hovered",d = "qx.event.type.Event",a = "Integer",c = "abandoned",b = "pressed";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The RepeatButton is a special button, which fires repeatedly {@link #execute}
   * events, while the mouse button is pressed on the button. The initial delay
   * and the interval time can be set using the properties {@link #firstInterval}
   * and {@link #interval}. The {@link #execute} events will be fired in a shorter
   * amount of time if the mouse button is hold, until the min {@link #minTimer}
   * is reached. The {@link #timerDecrease} property sets the amount of milliseconds
   * which will decreased after every firing.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.RepeatButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is executed");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/repeatbutton.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(m, {
    extend : qx.ui.form.Button,
    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct : function(o, p){

      qx.ui.form.Button.call(this, o, p);
      // create the timer and add the listener
      this.__timer = new qx.event.AcceleratingTimer();
      this.__timer.addListener(j, this._onInterval, this);
    },
    events : {
      /**
       * This event gets dispatched with every interval. The timer gets executed
       * as long as the user holds down the mouse button.
       */
      "execute" : d,
      /**
       * This event gets dispatched when the button is pressed.
       */
      "press" : d,
      /**
       * This event gets dispatched when the button is released.
       */
      "release" : d
    },
    properties : {
      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval : {
        check : a,
        init : 100
      },
      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval : {
        check : a,
        init : 500
      },
      /** This configures the minimum value for the timer interval. */
      minTimer : {
        check : a,
        init : 20
      },
      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease : {
        check : a,
        init : 2
      }
    },
    members : {
      __executed : null,
      __timer : null,
      /**
       * Calling this function is like a click from the user on the
       * button with all consequences.
       * <span style='color: red'>Be sure to call the {@link #release} function.</span>
       *
       * @return {void}
       */
      press : function(){

        // only if the button is enabled
        if(this.isEnabled()){

          // if the state pressed must be applied (first call)
          if(!this.hasState(b)){

            // start the timer
            this.__startInternalTimer();
          };
          // set the states
          this.removeState(c);
          this.addState(b);
        };
      },
      /**
       * Calling this function is like a release from the user on the
       * button with all consequences.
       * Usually the {@link #release} function will be called before the call of
       * this function.
       *
       * @param fireExecuteEvent {Boolean?true} flag which signals, if an event should be fired
       * @return {void}
       */
      release : function(q){

        // only if the button is enabled
        if(!this.isEnabled()){

          return;
        };
        // only if the button is pressed
        if(this.hasState(b)){

          // if the button has not been executed
          if(!this.__executed){

            this.execute();
          };
        };
        // remove button states
        this.removeState(b);
        this.removeState(c);
        // stop the repeat timer and therefore the execution
        this.__stopInternalTimer();
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // overridden
      _applyEnabled : function(r, s){

        qx.ui.form.Button.prototype._applyEnabled.call(this, r, s);
        if(!r){

          // remove button states
          this.removeState(b);
          this.removeState(c);
          // stop the repeat timer and therefore the execution
          this.__stopInternalTimer();
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Listener method for "mouseover" event
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOver : function(e){

        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
        if(this.hasState(c)){

          this.removeState(c);
          this.addState(b);
          this.__timer.start();
        };
        this.addState(f);
      },
      /**
       * Listener method for "mouseout" event
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOut : function(e){

        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
        this.removeState(f);
        if(this.hasState(b)){

          this.removeState(b);
          this.addState(c);
          this.__timer.stop();
        };
      },
      /**
       * Callback method for the "mouseDown" method.
       *
       * Sets the interval of the timer (value of firstInterval property) and
       * starts the timer. Additionally removes the state "abandoned" and adds the
       * state "pressed".
       *
       * @param e {qx.event.type.Mouse} mouseDown event
       * @return {void}
       */
      _onMouseDown : function(e){

        if(!e.isLeftPressed()){

          return;
        };
        // Activate capturing if the button get a mouseout while
        // the button is pressed.
        this.capture();
        this.__startInternalTimer();
        e.stopPropagation();
      },
      /**
       * Callback method for the "mouseUp" event.
       *
       * Handles the case that the user is releasing the mouse button
       * before the timer interval method got executed. This way the
       * "execute" method get executed at least one time.
       *
       * @param e {qx.event.type.Mouse} mouseUp event
       * @return {void}
       */
      _onMouseUp : function(e){

        this.releaseCapture();
        if(!this.hasState(c)){

          this.addState(f);
          if(this.hasState(b) && !this.__executed){

            this.execute();
          };
        };
        this.__stopInternalTimer();
        e.stopPropagation();
      },
      /**
       * Listener method for "keyup" event.
       *
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space" and stopps the internal timer
       * (same like mouse up).
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyUp : function(e){

        switch(e.getKeyIdentifier()){case h:case g:
        if(this.hasState(b)){

          if(!this.__executed){

            this.execute();
          };
          this.removeState(b);
          this.removeState(c);
          e.stopPropagation();
          this.__stopInternalTimer();
        };};
      },
      /**
       * Listener method for "keydown" event.
       *
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space". It also starts
       * the internal timer (same like mousedown).
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyDown : function(e){

        switch(e.getKeyIdentifier()){case h:case g:
        this.removeState(c);
        this.addState(b);
        e.stopPropagation();
        this.__startInternalTimer();};
      },
      /**
       * Callback for the interval event.
       *
       * Stops the timer and starts it with a new interval
       * (value of the "interval" property - value of the "timerDecrease" property).
       * Dispatches the "execute" event.
       *
       * @param e {qx.event.type.Event} interval event
       * @return {void}
       */
      _onInterval : function(e){

        this.__executed = true;
        this.fireEvent(i);
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL TIMER
      ---------------------------------------------------------------------------
      */
      /**
       * Starts the internal timer which causes firing of execution
       * events in an interval. It also presses the button.
       *
       * @return {void}
       */
      __startInternalTimer : function(){

        this.fireEvent(n);
        this.__executed = false;
        this.__timer.set({
          interval : this.getInterval(),
          firstInterval : this.getFirstInterval(),
          minimum : this.getMinTimer(),
          decrease : this.getTimerDecrease()
        }).start();
        this.removeState(c);
        this.addState(b);
      },
      /**
       * Stops the internal timer and releases the button.
       *
       * @return {void}
       */
      __stopInternalTimer : function(){

        this.fireEvent(l);
        this.__timer.stop();
        this.removeState(c);
        this.removeState(b);
      }
    },
    /*
      *****************************************************************************
         DESTRUCTOR
      *****************************************************************************
      */
    destruct : function(){

      this._disposeObjects(k);
    }
  });
})();
(function(){

  var e = "qx.event.type.Event",d = "__timer",c = "qx.event.AcceleratingTimer",b = "interval",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Timer, which accelerates after each interval. The initial delay and the
   * interval time can be set using the properties {@link #firstInterval}
   * and {@link #interval}. The {@link #interval} events will be fired with
   * decreasing interval times while the timer is running, until the {@link #minimum}
   * is reached. The {@link #decrease} property sets the amount of milliseconds
   * which will decreased after every firing.
   *
   * This class is e.g. used in the {@link qx.ui.form.RepeatButton} and
   * {@link qx.ui.form.HoverButton} widgets.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    construct : function(){

      qx.core.Object.call(this);
      this.__timer = new qx.event.Timer(this.getInterval());
      this.__timer.addListener(b, this._onInterval, this);
    },
    events : {
      /** This event if fired each time the interval time has elapsed */
      "interval" : e
    },
    properties : {
      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval : {
        check : a,
        init : 100
      },
      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval : {
        check : a,
        init : 500
      },
      /** This configures the minimum value for the timer interval. */
      minimum : {
        check : a,
        init : 20
      },
      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      decrease : {
        check : a,
        init : 2
      }
    },
    members : {
      __timer : null,
      __currentInterval : null,
      /**
       * Reset and start the timer.
       */
      start : function(){

        this.__timer.setInterval(this.getFirstInterval());
        this.__timer.start();
      },
      /**
       * Stop the timer
       */
      stop : function(){

        this.__timer.stop();
        this.__currentInterval = null;
      },
      /**
       * Interval event handler
       */
      _onInterval : function(){

        this.__timer.stop();
        if(this.__currentInterval == null){

          this.__currentInterval = this.getInterval();
        };
        this.__currentInterval = Math.max(this.getMinimum(), this.__currentInterval - this.getDecrease());
        this.__timer.setInterval(this.__currentInterval);
        this.__timer.start();
        this.fireEvent(b);
      }
    },
    destruct : function(){

      this._disposeObjects(d);
    }
  });
})();
(function(){

  var m = "scrollY",l = "update",k = "scrollX",j = "_applyScrollX",i = "_applyScrollY",h = "qx.lang.Type.isNumber(value)&&value>=0&&value<=this.getScrollMaxX()",g = "appear",f = "qx.lang.Type.isNumber(value)&&value>=0&&value<=this.getScrollMaxY()",d = "qx.event.type.Event",c = "qx.ui.core.scroll.ScrollPane",a = "scroll",b = "resize";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This class represents a scroll able pane. This means that this widget
   * may contain content which is bigger than the available (inner)
   * dimensions of this widget. The widget also offer methods to control
   * the scrolling position. It can only have exactly one child.
   */
  qx.Class.define(c, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.Widget.call(this);
      this.set({
        minWidth : 0,
        minHeight : 0
      });
      // Automatically configure a "fixed" grow layout.
      this._setLayout(new qx.ui.layout.Grow());
      // Add resize listener to "translate" event
      this.addListener(b, this._onUpdate);
      var n = this.getContentElement();
      // Synchronizes the DOM scroll position with the properties
      n.addListener(a, this._onScroll, this);
      // Fixed some browser quirks e.g. correcting scroll position
      // to the previous value on re-display of a pane
      n.addListener(g, this._onAppear, this);
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired on resize of both the container or the content. */
      update : d
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The horizontal scroll position */
      scrollX : {
        check : h,
        apply : j,
        event : k,
        init : 0
      },
      /** The vertical scroll position */
      scrollY : {
        check : f,
        apply : i,
        event : m,
        init : 0
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        CONTENT MANAGEMENT
      ---------------------------------------------------------------------------
      */
      /**
       * Configures the content of the scroll pane. Replaces any existing child
       * with the newly given one.
       *
       * @param widget {qx.ui.core.Widget?null} The content widget of the pane
       * @return {void}
       */
      add : function(o){

        var p = this._getChildren()[0];
        if(p){

          this._remove(p);
          p.removeListener(b, this._onUpdate, this);
        };
        if(o){

          this._add(o);
          o.addListener(b, this._onUpdate, this);
        };
      },
      /**
       * Removes the given widget from the content. The pane is empty
       * afterwards as only one child is supported by the pane.
       *
       * @param widget {qx.ui.core.Widget?null} The content widget of the pane
       * @return {void}
       */
      remove : function(q){

        if(q){

          this._remove(q);
          q.removeListener(b, this._onUpdate, this);
        };
      },
      /**
       * Returns an array containing the current content.
       *
       * @return {Object[]} The content array
       */
      getChildren : function(){

        return this._getChildren();
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for resize event of content and container
       *
       * @param e {Event} Resize event object
       */
      _onUpdate : function(e){

        this.fireEvent(l);
      },
      /**
       * Event listener for scroll event of content
       *
       * @param e {qx.event.type.Event} Scroll event object
       */
      _onScroll : function(e){

        var r = this.getContentElement();
        this.setScrollX(r.getScrollX());
        this.setScrollY(r.getScrollY());
      },
      /**
       * Event listener for appear event of content
       *
       * @param e {qx.event.type.Event} Appear event object
       */
      _onAppear : function(e){

        var v = this.getContentElement();
        var s = this.getScrollX();
        var t = v.getScrollX();
        if(s != t){

          v.scrollToX(s);
        };
        var w = this.getScrollY();
        var u = v.getScrollY();
        if(w != u){

          v.scrollToY(w);
        };
      },
      /*
      ---------------------------------------------------------------------------
        ITEM LOCATION SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the top offset of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemTop : function(z){

        var top = 0;
        do {

          top += z.getBounds().top;
          z = z.getLayoutParent();
        }while(z && z !== this);
        return top;
      },
      /**
       * Returns the top offset of the end of the given item in relation to the
       * inner height of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemBottom : function(A){

        return this.getItemTop(A) + A.getBounds().height;
      },
      /**
       * Returns the left offset of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Top offset
       */
      getItemLeft : function(B){

        var C = 0;
        var parent;
        do {

          C += B.getBounds().left;
          parent = B.getLayoutParent();
          if(parent){

            C += parent.getInsets().left;
          };
          B = parent;
        }while(B && B !== this);
        return C;
      },
      /**
       * Returns the left offset of the end of the given item in relation to the
       * inner width of this widget.
       *
       * @param item {qx.ui.core.Widget} Item to query
       * @return {Integer} Right offset
       */
      getItemRight : function(D){

        return this.getItemLeft(D) + D.getBounds().width;
      },
      /*
      ---------------------------------------------------------------------------
        DIMENSIONS
      ---------------------------------------------------------------------------
      */
      /**
       * The size (identical with the preferred size) of the content.
       *
       * @return {Map} Size of the content (keys: <code>width</code> and <code>height</code>)
       */
      getScrollSize : function(){

        return this.getChildren()[0].getBounds();
      },
      /*
      ---------------------------------------------------------------------------
        SCROLL SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * The maximum horizontal scroll position.
       *
       * @return {Integer} Maximum horizontal scroll position.
       */
      getScrollMaxX : function(){

        var F = this.getInnerSize();
        var E = this.getScrollSize();
        if(F && E){

          return Math.max(0, E.width - F.width);
        };
        return 0;
      },
      /**
       * The maximum vertical scroll position.
       *
       * @return {Integer} Maximum vertical scroll position.
       */
      getScrollMaxY : function(){

        var H = this.getInnerSize();
        var G = this.getScrollSize();
        if(H && G){

          return Math.max(0, G.height - H.height);
        };
        return 0;
      },
      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       * @return {void}
       */
      scrollToX : function(I){

        var J = this.getScrollMaxX();
        if(I < 0){

          I = 0;
        } else if(I > J){

          I = J;
        };
        this.setScrollX(I);
      },
      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @return {void}
       */
      scrollToY : function(K){

        var L = this.getScrollMaxY();
        if(K < 0){

          K = 0;
        } else if(K > L){

          K = L;
        };
        this.setScrollY(K);
      },
      /**
       * Scrolls the element's content horizontally by the given amount.
       *
       * @param x {Integer?0} Amount to scroll
       * @return {void}
       */
      scrollByX : function(x){

        this.scrollToX(this.getScrollX() + x);
      },
      /**
       * Scrolls the element's content vertically by the given amount.
       *
       * @param y {Integer?0} Amount to scroll
       * @return {void}
       */
      scrollByY : function(y){

        this.scrollToY(this.getScrollY() + y);
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyScrollX : function(M){

        this.getContentElement().scrollToX(M);
      },
      // property apply
      _applyScrollY : function(N){

        this.getContentElement().scrollToY(N);
      }
    }
  });
})();
(function(){

  var f = "button-backward",e = "vertical",d = "button-forward",c = "menu-slidebar",b = "qx.ui.menu.MenuSlideBar",a = "execute";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The MenuSlideBar is used to scroll menus if they don't fit on the screen.
   *
   * @childControl button-forward {qx.ui.form.HoverButton} scrolls forward of hovered
   * @childControl button-backward {qx.ui.form.HoverButton} scrolls backward if hovered
   *
   * @internal
   */
  qx.Class.define(b, {
    extend : qx.ui.container.SlideBar,
    construct : function(){

      qx.ui.container.SlideBar.call(this, e);
    },
    properties : {
      appearance : {
        refine : true,
        init : c
      }
    },
    members : {
      // overridden
      _createChildControlImpl : function(g, h){

        var i;
        switch(g){case d:
        i = new qx.ui.form.HoverButton();
        i.addListener(a, this._onExecuteForward, this);
        this._addAt(i, 2);
        break;case f:
        i = new qx.ui.form.HoverButton();
        i.addListener(a, this._onExecuteBackward, this);
        this._addAt(i, 0);
        break;};
        return i || qx.ui.container.SlideBar.prototype._createChildControlImpl.call(this, g);
      }
    }
  });
})();
(function(){

  var i = "hover-button",h = "__timer",g = "interval",f = "mouseover",d = "mouseout",c = "qx.ui.form.HoverButton",b = "hovered",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The HoverButton is an {@link qx.ui.basic.Atom}, which fires repeatedly
   * execute events while the mouse is over the widget.
   *
   * The rate at which the execute event is fired accelerates is the mouse keeps
   * inside of the widget. The initial delay and the interval time can be set using
   * the properties {@link #firstInterval} and {@link #interval}. The
   * {@link #execute} events will be fired in a shorter amount of time if the mouse
   * remains over the widget, until the min {@link #minTimer} is reached.
   * The {@link #timerDecrease} property sets the amount of milliseconds which will
   * decreased after every firing.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var button = new qx.ui.form.HoverButton("Hello World");
   *
   *   button.addListener("execute", function(e) {
   *     alert("Button is hovered");
   *   }, this);
   *
   *   this.getRoot.add(button);
   * </pre>
   *
   * This example creates a button with the label "Hello World" and attaches an
   * event listener to the {@link #execute} event.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/hoverbutton.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(c, {
    extend : qx.ui.basic.Atom,
    include : [qx.ui.core.MExecutable],
    implement : [qx.ui.form.IExecutable],
    /**
     * @param label {String} Label to use
     * @param icon {String?null} Icon to use
     */
    construct : function(j, k){

      qx.ui.basic.Atom.call(this, j, k);
      this.addListener(f, this._onMouseOver, this);
      this.addListener(d, this._onMouseOut, this);
      this.__timer = new qx.event.AcceleratingTimer();
      this.__timer.addListener(g, this._onInterval, this);
    },
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : i
      },
      /**
       * Interval used after the first run of the timer. Usually a smaller value
       * than the "firstInterval" property value to get a faster reaction.
       */
      interval : {
        check : a,
        init : 80
      },
      /**
       * Interval used for the first run of the timer. Usually a greater value
       * than the "interval" property value to a little delayed reaction at the first
       * time.
       */
      firstInterval : {
        check : a,
        init : 200
      },
      /** This configures the minimum value for the timer interval. */
      minTimer : {
        check : a,
        init : 20
      },
      /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
      timerDecrease : {
        check : a,
        init : 2
      }
    },
    members : {
      __timer : null,
      /**
       * Start timer on mouse over
       *
       * @param e {qx.event.type.Mouse} The mouse event
       */
      _onMouseOver : function(e){

        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
        this.__timer.set({
          interval : this.getInterval(),
          firstInterval : this.getFirstInterval(),
          minimum : this.getMinTimer(),
          decrease : this.getTimerDecrease()
        }).start();
        this.addState(b);
      },
      /**
       * Stop timer on mouse out
       *
       * @param e {qx.event.type.Mouse} The mouse event
       */
      _onMouseOut : function(e){

        this.__timer.stop();
        this.removeState(b);
        if(!this.isEnabled() || e.getTarget() !== this){

          return;
        };
      },
      /**
       * Fire execute event on timer interval event
       */
      _onInterval : function(){

        if(this.isEnabled()){

          this.execute();
        } else {

          this.__timer.stop();
        };
      }
    },
    destruct : function(){

      this._disposeObjects(h);
    }
  });
})();
(function(){

  var h = "hovered",g = "inherit",f = "qx.ui.menubar.Button",d = "keydown",c = "menubar-button",b = "keyup",a = "pressed";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * A menubar button
   */
  qx.Class.define(f, {
    extend : qx.ui.form.MenuButton,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(i, j, k){

      qx.ui.form.MenuButton.call(this, i, j, k);
      this.removeListener(d, this._onKeyDown);
      this.removeListener(b, this._onKeyUp);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      appearance : {
        refine : true,
        init : c
      },
      show : {
        refine : true,
        init : g
      },
      focusable : {
        refine : true,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Inspects the parent chain to find the MenuBar
       *
       * @return {qx.ui.menubar.MenuBar} MenuBar instance or <code>null</code>.
       */
      getMenuBar : function(){

        var parent = this;
        while(parent){

          /* this method is also used by toolbar.MenuButton, so we need to check
             for a ToolBar instance. */
          if(parent instanceof qx.ui.toolbar.ToolBar){

            return parent;
          };
          parent = parent.getLayoutParent();
        };
        return null;
      },
      // overridden
      open : function(l){

        qx.ui.form.MenuButton.prototype.open.call(this, l);
        var menubar = this.getMenuBar();
        menubar._setAllowMenuOpenHover(true);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENERS
      ---------------------------------------------------------------------------
      */
      /**
       * Listener for visibility property changes of the attached menu
       *
       * @param e {qx.event.type.Data} Property change event
       */
      _onMenuChange : function(e){

        var m = this.getMenu();
        var menubar = this.getMenuBar();
        if(m.isVisible()){

          this.addState(a);
          // Sync with open menu property
          if(menubar){

            menubar.setOpenMenu(m);
          };
        } else {

          this.removeState(a);
          // Sync with open menu property
          if(menubar && menubar.getOpenMenu() == m){

            menubar.resetOpenMenu();
            menubar._setAllowMenuOpenHover(false);
          };
        };
      },
      // overridden
      _onMouseUp : function(e){

        qx.ui.form.MenuButton.prototype._onMouseUp.call(this, e);
        // Set state 'pressed' to visualize that the menu is open.
        var n = this.getMenu();
        if(n && n.isVisible() && !this.hasState(a)){

          this.addState(a);
        };
      },
      /**
       * Event listener for mouseover event
       *
       * @param e {qx.event.type.Mouse} mouseover event object
       */
      _onMouseOver : function(e){

        // Add hovered state
        this.addState(h);
        // Open submenu
        if(this.getMenu()){

          var menubar = this.getMenuBar();
          if(menubar._isAllowMenuOpenHover()){

            // Hide all open menus
            qx.ui.menu.Manager.getInstance().hideAll();
            // Set it again, because hideAll remove it.
            menubar._setAllowMenuOpenHover(true);
            // Then show the attached menu
            if(this.isEnabled()){

              this.open();
            };
          };
        };
      }
    }
  });
})();
(function(){

  var m = "Boolean",k = "changeShow",j = "qx.ui.core.Widget",h = "_applyOverflowHandling",g = "_applySpacing",f = "qx.ui.toolbar.ToolBar",d = "Integer",c = "showItem",b = "Widget must be child of the toolbar.",a = "changeOpenMenu",z = "icon",y = "_applyOverflowIndicator",x = "toolbar",w = "qx.ui.menu.Menu",v = "Priority already in use!",u = "label",t = "_applyShow",s = "hideItem",r = "both",q = "qx.event.type.Data",o = "resize",p = "excluded",n = "visible";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * The Toolbar class is the main part of the toolbar widget.
   *
   * It can handle added {@link Button}s, {@link CheckBox}es, {@link RadioButton}s
   * and {@link Separator}s in its {@link #add} method. The {@link #addSpacer} method
   * adds a spacer at the current toolbar position. This means that the widgets
   * added after the method call of {@link #addSpacer} are aligned to the right of
   * the toolbar.
   *
   * For more details on the documentation of the toolbar widget, take a look at the
   * documentation of the {@link qx.ui.toolbar}-Package.
   */
  qx.Class.define(f, {
    extend : qx.ui.core.Widget,
    include : qx.ui.core.MChildrenHandling,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.Widget.call(this);
      // add needed layout
      this._setLayout(new qx.ui.layout.HBox());
      // initialize the overflow handling
      this.__removedItems = [];
      this.__removePriority = [];
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Appearance of the widget */
      appearance : {
        refine : true,
        init : x
      },
      /** Holds the currently open menu (when the toolbar is used for menus) */
      openMenu : {
        check : w,
        event : a,
        nullable : true
      },
      /** Whether icons, labels, both or none should be shown. */
      show : {
        init : r,
        check : [r, u, z],
        inheritable : true,
        apply : t,
        event : k
      },
      /** The spacing between every child of the toolbar */
      spacing : {
        nullable : true,
        check : d,
        themeable : true,
        apply : g
      },
      /**
       * Widget which will be shown if at least one toolbar item is hidden.
       * Keep in mind to add this widget to the toolbar before you set it as
       * indicator!
       */
      overflowIndicator : {
        check : j,
        nullable : true,
        apply : y
      },
      /** Enables the overflow handling which automatically removes items.*/
      overflowHandling : {
        init : false,
        check : m,
        apply : h
      }
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired if an item will be hidden by the {@link #overflowHandling}.*/
      "hideItem" : q,
      /** Fired if an item will be show by the {@link #overflowHandling}.*/
      "showItem" : q
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        OVERFLOW HANDLING
      ---------------------------------------------------------------------------
      */
      __removedItems : null,
      __removePriority : null,
      // overridden
      _computeSizeHint : function(){

        // get the original hint
        var C = qx.ui.core.Widget.prototype._computeSizeHint.call(this);
        if(true && this.getOverflowHandling()){

          var A = 0;
          // if an overflow widget is given, use its width + spacing as min width
          var B = this.getOverflowIndicator();
          if(B){

            A = B.getSizeHint().width + this.getSpacing();
          };
          // reset the minWidth because we reduce the count of elements
          C.minWidth = A;
        };
        return C;
      },
      /**
       * Resize event handler.
       *
       * @param e {qx.event.type.Data} The resize event.
       */
      _onResize : function(e){

        this._recalculateOverflow(e.getData().width);
      },
      /**
       * Responsible for calculation the overflow based on the available width.
       *
       * @param width {Integer?null} The available width.
       * @param requiredWidth {Integer?null} The required width for the widget
       *   if available.
       */
      _recalculateOverflow : function(D, E){

        // do nothing if overflow handling is not enabled
        if(!this.getOverflowHandling()){

          return;
        };
        // get all required sizes
        E = E || this.getSizeHint().width;
        var F = this.getOverflowIndicator();
        var L = 0;
        if(F){

          L = F.getSizeHint().width;
        };
        if(D == undefined && this.getBounds() != null){

          D = this.getBounds().width;
        };
        // if we still don't have a width, than we are not added to a parrent
        if(D == undefined){

          // we should ignore it in that case
          return;
        };
        // if we have not enough space
        if(D < E){

          do {

            // get the next child
            var M = this._getNextToHide();
            // if there is no child to hide, just do nothing
            if(!M){

              return;
            };
            // get margins or spacing
            var O = M.getMarginLeft() + M.getMarginRight();
            O = Math.max(O, this.getSpacing());
            var J = M.getSizeHint().width + O;
            this.__hideChild(M);
            // new width is the requiredWidth - the removed childs width
            E -= J;
            // show the overflowWidgetWidth
            if(F && F.getVisibility() != n){

              F.setVisibility(n);
              // if we need to add the overflow indicator, we need to add its width
              E += L;
              // add spacing or margins
              var H = F.getMarginLeft() + F.getMarginRight();
              E += Math.max(H, this.getSpacing());
            };
          }while(E > D);
        } else if(this.__removedItems.length > 0){

          do {

            var P = this.__removedItems[0];
            // if we have something we can show
            if(P){

              // get the margins or spacing
              var O = P.getMarginLeft() + P.getMarginRight();
              O = Math.max(O, this.getSpacing());
              // check if the element has been rendered before [BUG #4542]
              if(P.getDecoratorElement() == null){

                // if not, apply the decorator element because it can change the
                // width of the child with padding e.g.
                P.syncAppearance();
                // also invalidate the layout cache to trigger size hint
                // recalculation
                P.invalidateLayoutCache();
              };
              var I = P.getSizeHint().width;
              // check if it fits in in case its the last child to replace
              var N = false;
              // if we can remove the overflow widget if its available
              if(this.__removedItems.length == 1 && L > 0){

                var G = O - this.getSpacing();
                var K = E - L + I + G;
                N = D > K;
              };
              // if it just fits in || it fits in when we remove the overflow widget
              if(D > E + I + O || N){

                this.__showChild(P);
                E += I;
                // check if we need to remove the overflow widget
                if(F && this.__removedItems.length == 0){

                  F.setVisibility(p);
                };
              } else {

                return;
              };
            };
          }while(D >= E && this.__removedItems.length > 0);
        };
      },
      /**
       * Helper to show a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to show.
       */
      __showChild : function(Q){

        Q.setVisibility(n);
        this.__removedItems.shift();
        this.fireDataEvent(c, Q);
      },
      /**
       * Helper to exclude a toolbar item.
       *
       * @param child {qx.ui.core.Widget} The widget to exclude.
       */
      __hideChild : function(R){

        // ignore the call if no child is given
        if(!R){

          return;
        };
        this.__removedItems.unshift(R);
        R.setVisibility(p);
        this.fireDataEvent(s, R);
      },
      /**
       * Responsible for returning the next item to remove. In It checks the
       * priorities added by {@link #setRemovePriority}. If all priorized widgets
       * already excluded, it takes the widget added at last.
       *
       * @return {qx.ui.core.Widget|null} The widget which should be removed next.
       *   If null is returned, no widget is availablew to remove.
       */
      _getNextToHide : function(){

        // get the elements by priority
        for(var i = this.__removePriority.length - 1;i >= 0;i--){

          var S = this.__removePriority[i];
          // maybe a priority is left out and spacers don't have the visibility
          if(S && S.getVisibility && S.getVisibility() == n){

            return S;
          };
        };
        // if there is non found by priority, check all available widgets
        var T = this._getChildren();
        for(var i = T.length - 1;i >= 0;i--){

          var U = T[i];
          // ignore the overflow widget
          if(U == this.getOverflowIndicator()){

            continue;
          };
          // spacer don't have the visibility
          if(U.getVisibility && U.getVisibility() == n){

            return U;
          };
        };
      },
      /**
       * The removal of the toolbar items is priority based. You can change these
       * priorities with this method. The higher a priority, the earlier it will
       * be excluded. Remmeber to use every priority only once! If you want
       * override an already set priority, use the override parameter.
       * Keep in mind to only use already added items.
       *
       * @param item {qx.ui.core.Widget} The item to give the priority.
       * @param priority {Integer} The priority, higher means removed earlier.
       * @param override {Boolean} true, if the priority should be overridden.
       */
      setRemovePriority : function(V, W, X){

        // security check for overriding priorities
        if(!X && this.__removePriority[W] != undefined){

          throw new Error(v);
        };
        this.__removePriority[W] = V;
      },
      // property apply
      _applyOverflowHandling : function(Y, ba){

        // invalidate the own and the parrents layout cach because the size hint changes
        this.invalidateLayoutCache();
        var parent = this.getLayoutParent();
        if(parent){

          parent.invalidateLayoutCache();
        };
        // recalculate if possible
        var bc = this.getBounds();
        if(bc && bc.width){

          this._recalculateOverflow(bc.width);
        };
        // if the handling has been enabled
        if(Y){

          // add the resize listener
          this.addListener(o, this._onResize, this);
        } else {

          this.removeListener(o, this._onResize, this);
          // set the overflow indicator to excluded
          var bb = this.getOverflowIndicator();
          if(bb){

            bb.setVisibility(p);
          };
          // set all buttons back to visible
          for(var i = 0;i < this.__removedItems.length;i++){

            this.__removedItems[i].setVisibility(n);
          };
          // reset the removed items
          this.__removedItems = [];
        };
      },
      // property apply
      _applyOverflowIndicator : function(bd, be){

        if(be){

          this._remove(be);
        };
        if(bd){

          // check if its a child of the toolbar
          if(this._indexOf(bd) == -1){

            throw new Error(b);
          };
          // hide the widget
          bd.setVisibility(p);
        };
      },
      /*
      ---------------------------------------------------------------------------
        MENU OPEN
      ---------------------------------------------------------------------------
      */
      __allowMenuOpenHover : false,
      /**
       * Indicate if a menu could be opened on hover or not.
       *
       * @internal
       * @param value {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _setAllowMenuOpenHover : function(bf){

        this.__allowMenuOpenHover = bf;
      },
      /**
       * Return if a menu could be opened on hover or not.
       *
       * @internal
       * @return {Boolean} <code>true</code> if a menu could be opened,
       *    <code>false</code> otherwise.
       */
      _isAllowMenuOpenHover : function(){

        return this.__allowMenuOpenHover;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applySpacing : function(bg, bh){

        var bi = this._getLayout();
        bg == null ? bi.resetSpacing() : bi.setSpacing(bg);
      },
      // property apply
      _applyShow : function(bj){

        var bk = this._getChildren();
        for(var i = 0;i < bk.length;i++){

          if(bk[i].setShow){

            bk[i].setShow(bj);
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        CHILD HANDLING
      ---------------------------------------------------------------------------
      */
      // overridden
      _add : function(bl, bm){

        qx.ui.core.Widget.prototype._add.call(this, bl, bm);
        // sync the show property
        if(bl.setShow){

          bl.setShow(this.getShow());
        };
        var bn = this.getSizeHint().width + bl.getSizeHint().width + 2 * this.getSpacing();
        this._recalculateOverflow(null, bn);
      },
      // overridden
      _addAt : function(bo, bp, bq){

        qx.ui.core.Widget.prototype._addAt.call(this, bo, bp, bq);
        // sync the show property
        if(bo.setShow){

          bo.setShow(this.getShow());
        };
        var br = this.getSizeHint().width + bo.getSizeHint().width + 2 * this.getSpacing();
        this._recalculateOverflow(null, br);
      },
      // overridden
      _addBefore : function(bs, bt, bu){

        qx.ui.core.Widget.prototype._addBefore.call(this, bs, bt, bu);
        // sync the show property
        if(bs.setShow){

          bs.setShow(this.getShow());
        };
        var bv = this.getSizeHint().width + bs.getSizeHint().width + 2 * this.getSpacing();
        this._recalculateOverflow(null, bv);
      },
      // overridden
      _addAfter : function(bw, bx, by){

        qx.ui.core.Widget.prototype._addAfter.call(this, bw, bx, by);
        // sync the show property
        if(bw.setShow){

          bw.setShow(this.getShow());
        };
        var bz = this.getSizeHint().width + bw.getSizeHint().width + 2 * this.getSpacing();
        this._recalculateOverflow(null, bz);
      },
      // overridden
      _remove : function(bA){

        qx.ui.core.Widget.prototype._remove.call(this, bA);
        var bB = this.getSizeHint().width - bA.getSizeHint().width - 2 * this.getSpacing();
        this._recalculateOverflow(null, bB);
      },
      // overridden
      _removeAt : function(bC){

        var bE = this._getChildren()[bC];
        qx.ui.core.Widget.prototype._removeAt.call(this, bC);
        var bD = this.getSizeHint().width - bE.getSizeHint().width - 2 * this.getSpacing();
        this._recalculateOverflow(null, bD);
      },
      // overridden
      _removeAll : function(){

        qx.ui.core.Widget.prototype._removeAll.call(this);
        this._recalculateOverflow(null, 0);
      },
      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Add a spacer to the toolbar. The spacer has a flex
       * value of one and will stretch to the available space.
       *
       * @return {qx.ui.core.Spacer} The newly added spacer object. A reference
       *   to the spacer is needed to remove this spacer from the layout.
       */
      addSpacer : function(){

        var bF = new qx.ui.core.Spacer;
        this._add(bF, {
          flex : 1
        });
        return bF;
      },
      /**
       * Adds a separator to the toolbar.
       */
      addSeparator : function(){

        this.add(new qx.ui.toolbar.Separator);
      },
      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons : function(){

        var bH = this.getChildren();
        var bG = [];
        var bI;
        for(var i = 0,l = bH.length;i < l;i++){

          bI = bH[i];
          if(bI instanceof qx.ui.menubar.Button){

            bG.push(bI);
          } else if(bI instanceof qx.ui.toolbar.Part){

            bG.push.apply(bG, bI.getMenuButtons());
          };
        };
        return bG;
      }
    },
    destruct : function(){

      if(this.hasListener(o)){

        this.removeListener(o, this._onResize, this);
      };
    }
  });
})();
(function(){

  var a = "qx.ui.core.Spacer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A Spacer is a "virtual" widget, which can be placed into any layout and takes
   * the space a normal widget of the same size would take.
   *
   * Spacers are invisible and very light weight because they don't require any
   * DOM modifications.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var container = new qx.ui.container.Composite(new qx.ui.layout.HBox());
   *   container.add(new qx.ui.core.Widget());
   *   container.add(new qx.ui.core.Spacer(50));
   *   container.add(new qx.ui.core.Widget());
   * </pre>
   *
   * This example places two widgets and a spacer into a container with a
   * horizontal box layout. In this scenario the spacer creates an empty area of
   * 50 pixel width between the two widgets.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/spacer.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(a, {
    extend : qx.ui.core.LayoutItem,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param width {Integer?null} the initial width
     * @param height {Integer?null} the initial height
     */
    construct : function(b, c){

      qx.ui.core.LayoutItem.call(this);
      // Initialize dimensions
      this.setWidth(b != null ? b : 0);
      this.setHeight(c != null ? c : 0);
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Helper method called from the visibility queue to detect outstanding changes
       * to the appearance.
       *
       * @internal
       */
      checkAppearanceNeeds : function(){
      },
      /**
       * Recursively adds all children to the given queue
       *
       * @param queue {Map} The queue to add widgets to
       */
      addChildrenToQueue : function(d){
      },
      /**
       * Removes this widget from its parent and dispose it.
       *
       * Please note that the widget is not disposed synchronously. The
       * real dispose happens after the next queue flush.
       *
       * @return {void}
       */
      destroy : function(){

        if(this.$$disposed){

          return;
        };
        var parent = this.$$parent;
        if(parent){

          parent._remove(this);
        };
        qx.ui.core.queue.Dispose.add(this);
      }
    }
  });
})();
(function(){

  var b = "toolbar-separator",a = "qx.ui.toolbar.Separator";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * A widget used for decoration proposes to structure a toolbar. Each
   * Separator renders a line between the buttons around.
   */
  qx.Class.define(a, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : b
      },
      // overridden
      anonymous : {
        refine : true,
        init : true
      },
      // overridden
      width : {
        refine : true,
        init : 0
      },
      // overridden
      height : {
        refine : true,
        init : 0
      }
    }
  });
})();
(function(){

  var q = "Integer",p = "qx.ui.toolbar.Part",o = "icon",n = "label",m = "syncAppearance",k = "visible",j = "changeShow",h = "_applySpacing",g = "toolbar/part",f = "handle",c = "both",e = "container",d = "left",b = "right",a = "middle";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * A part is a container for multiple toolbar buttons. Each part comes
   * with a handle which may be used in later versions to drag the part
   * around and move it to another position. Currently mainly used
   * for structuring large toolbars beyond the capabilities of the
   * {@link Separator}.
   *
   * @childControl handle {qx.ui.basic.Image} prat handle to visualize the separation
   * @childControl container {qx.ui.toolbar.PartContainer} holds the content of the toolbar part
   */
  qx.Class.define(p, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MRemoteChildrenHandling],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.core.Widget.call(this);
      // Hard coded HBox layout
      this._setLayout(new qx.ui.layout.HBox);
      // Force creation of the handle
      this._createChildControl(f);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      appearance : {
        refine : true,
        init : g
      },
      /** Whether icons, labels, both or none should be shown. */
      show : {
        init : c,
        check : [c, n, o],
        inheritable : true,
        event : j
      },
      /** The spacing between every child of the toolbar */
      spacing : {
        nullable : true,
        check : q,
        themeable : true,
        apply : h
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      _createChildControlImpl : function(r, s){

        var t;
        switch(r){case f:
        t = new qx.ui.basic.Image();
        t.setAlignY(a);
        this._add(t);
        break;case e:
        t = new qx.ui.toolbar.PartContainer();
        t.addListener(m, this.__onSyncAppearance, this);
        this._add(t);
        break;};
        return t || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, r);
      },
      // overridden
      getChildrenContainer : function(){

        return this.getChildControl(e);
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      _applySpacing : function(u, v){

        var w = this.getChildControl(e).getLayout();
        u == null ? w.resetSpacing() : w.setSpacing(u);
      },
      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Helper which applies the left, right and middle states.
       */
      __onSyncAppearance : function(){

        // check every child
        var x = this.getChildrenContainer().getChildren();
        x = x.filter(function(y){

          return y.getVisibility() == k;
        });
        for(var i = 0;i < x.length;i++){

          // if its the first child
          if(i == 0 && i != x.length - 1){

            x[i].addState(d);
            x[i].removeState(b);
            x[i].removeState(a);
          } else if(i == x.length - 1 && i != 0){

            x[i].addState(b);
            x[i].removeState(d);
            x[i].removeState(a);
          } else if(i == 0 && i == x.length - 1){

            x[i].removeState(d);
            x[i].removeState(a);
            x[i].removeState(b);
          } else {

            x[i].addState(a);
            x[i].removeState(b);
            x[i].removeState(d);
          };;
        };
      },
      /**
       * Adds a separator to the toolbar part.
       */
      addSeparator : function(){

        this.add(new qx.ui.toolbar.Separator);
      },
      /**
       * Returns all nested buttons which contains a menu to show. This is mainly
       * used for keyboard support.
       *
       * @return {Array} List of all menu buttons
       */
      getMenuButtons : function(){

        var A = this.getChildren();
        var z = [];
        var B;
        for(var i = 0,l = A.length;i < l;i++){

          B = A[i];
          if(B instanceof qx.ui.menubar.Button){

            z.push(B);
          };
        };
        return z;
      }
    }
  });
})();
(function(){

  var f = "toolbar/part/container",e = "icon",d = "changeShow",c = "qx.ui.toolbar.PartContainer",b = "label",a = "both";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * The container used by {@link Part} to insert the buttons.
   *
   * @internal
   */
  qx.Class.define(c, {
    extend : qx.ui.container.Composite,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.container.Composite.call(this);
      this._setLayout(new qx.ui.layout.HBox);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      appearance : {
        refine : true,
        init : f
      },
      /** Whether icons, labels, both or none should be shown. */
      show : {
        init : a,
        check : [a, b, e],
        inheritable : true,
        event : d
      }
    }
  });
})();
(function(){

  var b = "qx.ui.menu.Button",a = "menu-button";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The real menu button class which supports a command and an icon. All
   * other features are inherited from the {@link qx.ui.menu.AbstractButton}
   * class.
   */
  qx.Class.define(b, {
    extend : qx.ui.menu.AbstractButton,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} Initial label
     * @param icon {String} Initial icon
     * @param command {qx.ui.core.Command} Initial command (shortcut)
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct : function(c, d, f, g){

      qx.ui.menu.AbstractButton.call(this);
      // Initialize with incoming arguments
      if(c != null){

        this.setLabel(c);
      };
      if(d != null){

        this.setIcon(d);
      };
      if(f != null){

        this.setCommand(f);
      };
      if(g != null){

        this.setMenu(g);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : a
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      // overridden
      _onClick : function(e){

        if(e.isLeftPressed()){

          this.execute();
          // don't close menus if the button is a sub menu button
          if(this.getMenu()){

            return;
          };
        } else {

          // don't close menus if the button has a context menu
          if(this.getContextMenu()){

            return;
          };
        };
        qx.ui.menu.Manager.getInstance().hideAll();
      },
      // overridden
      _onKeyPress : function(e){

        this.execute();
      }
    }
  });
})();
(function(){

  var g = "Unrecognized factory request: ",f = "menu-button",e = "table-column-reset-button",d = "separator",c = "user-button",b = "qx.ui.table.columnmenu.Button",a = "menu";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * The traditional qx.ui.menu.MenuButton to access the column visibility menu.
   */
  qx.Class.define(b, {
    extend : qx.ui.form.MenuButton,
    implement : qx.ui.table.IColumnMenuButton,
    /**
     * Create a new instance of a column visibility menu button. This button
     * also contains the factory for creating each of the sub-widgets.
     */
    construct : function(){

      qx.ui.form.MenuButton.call(this);
      // add blocker
      this.__blocker = new qx.ui.core.Blocker(this);
    },
    members : {
      __columnMenuButtons : null,
      __blocker : null,
      // Documented in qx.ui.table.IColumnMenu
      factory : function(h, j){

        switch(h){case a:
        var k = new qx.ui.menu.Menu();
        this.setMenu(k);
        return k;case f:
        var n = new qx.ui.table.columnmenu.MenuItem(j.text);
        n.setVisible(j.bVisible);
        this.getMenu().add(n);
        return n;case c:
        var m = new qx.ui.menu.Button(j.text);
        m.set({
          appearance : e
        });
        return m;case d:
        return new qx.ui.menu.Separator();default:
        throw new Error(g + h);};
      },
      /**
       * Returns the blocker of the columnmenu button.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker : function(){

        return this.__blocker;
      },
      // Documented in qx.ui.table.IColumnMenu
      empty : function(){

        var o = this.getMenu();
        var p = o.getChildren();
        for(var i = 0,l = p.length;i < l;i++){

          p[0].destroy();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__blocker.dispose();
    }
  });
})();
(function(){

  var b = "qx.ui.table.IColumnMenuItem",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * Interface for a column menu item corresponding to a table column.
   */
  qx.Interface.define(b, {
    properties : {
      /**
       * Whether the table column associated with this menu item is visible
       */
      visible : {
      }
    },
    events : {
      /**
       * Dispatched when a column changes visibility state. The event data is a
       * boolean indicating whether the table column associated with this menu
       * item is now visible.
       */
      changeVisible : a
    }
  });
})();
(function(){

  var b = "qx.ui.form.IBooleanForm",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all form widgets which have boolean as their primary
   * data type like a checkbox.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the value was modified */
      "changeValue" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the element's value.
       *
       * @param value {Boolean|null} The new value of the element.
       */
      setValue : function(c){

        return arguments.length == 1;
      },
      /**
       * Resets the element's value to its initial value.
       */
      resetValue : function(){
      },
      /**
       * The element's user set value.
       *
       * @return {Boolean|null} The value.
       */
      getValue : function(){
      }
    }
  });
})();
(function(){

  var m = "menu-checkbox",l = "Boolean",k = "label",j = "_applyValue",i = "value",h = "changeValue",g = "toolTipText",f = "enabled",d = "qx.ui.menu.CheckBox",c = "menu",a = "execute",b = "checked";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Renders a special checkbox button inside a menu. The button behaves like
   * a normal {@link qx.ui.form.CheckBox} and shows a check icon when
   * checked; normally shows no icon when not checked (depends on the theme).
   */
  qx.Class.define(d, {
    extend : qx.ui.menu.AbstractButton,
    implement : [qx.ui.form.IBooleanForm],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String} Initial label
     * @param menu {qx.ui.menu.Menu} Initial sub menu
     */
    construct : function(n, o){

      qx.ui.menu.AbstractButton.call(this);
      // Initialize with incoming arguments
      if(n != null){

        // try to translate every time you create a checkbox [BUG #2699]
        if(n.translate){

          this.setLabel(n.translate());
        } else {

          this.setLabel(n);
        };
      };
      if(o != null){

        this.setMenu(o);
      };
      this.addListener(a, this._onExecute, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : m
      },
      /** Whether the button is checked */
      value : {
        check : l,
        init : false,
        apply : j,
        event : h,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden (from MExecutable to keet the icon out of the binding)
      /**
       * @lint ignoreReferenceField(_bindableProperties)
       */
      _bindableProperties : [f, k, g, i, c],
      // property apply
      _applyValue : function(p, q){

        p ? this.addState(b) : this.removeState(b);
      },
      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute : function(e){

        this.toggleValue();
      },
      // overridden
      _onClick : function(e){

        if(e.isLeftPressed()){

          this.execute();
        } else {

          // don't close menus if the button has a context menu
          if(this.getContextMenu()){

            return;
          };
        };
        qx.ui.menu.Manager.getInstance().hideAll();
      },
      // overridden
      _onKeyPress : function(e){

        this.execute();
      }
    }
  });
})();
(function(){

  var f = "changeVisible",d = "qx.ui.table.columnmenu.MenuItem",c = "_applyVisible",b = "Boolean",a = "changeValue";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 Derrell Lipman
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Derrell Lipman (derrell)
  
  ************************************************************************ */
  /**
   * A menu item.
   */
  qx.Class.define(d, {
    extend : qx.ui.menu.CheckBox,
    implement : qx.ui.table.IColumnMenuItem,
    properties : {
      /**
       * Whether the table column associated with this menu item is visible.
       */
      visible : {
        check : b,
        init : true,
        apply : c,
        event : f
      }
    },
    /**
     * Create a new instance of an item for insertion into the table column
     * visibility menu.
     *
     * @param text {String}
     *   Text for the menu item, most typically the name of the column in the
     *   table.
     */
    construct : function(g){

      qx.ui.menu.CheckBox.call(this, g);
      // Mirror native "value" property in our "visible" property
      this.addListener(a, function(e){

        this.bInListener = true;
        this.setVisible(e.getData());
        this.bInListener = false;
      });
    },
    members : {
      __bInListener : false,
      /**
       * Keep menu in sync with programmatic changes of visibility
       *
       * @param value {Boolean}
       *   New visibility value
       *
       * @param old {Boolean}
       *   Previous visibility value
       */
      _applyVisible : function(h, i){

        // avoid recursion if called from listener on "changeValue" property
        if(!this.bInListener){

          this.setValue(h);
        };
      }
    }
  });
})();
(function(){

  var b = "qx.ui.table.selection.Model",a = "qx.ui.table.selection.Manager";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A selection manager. This is a helper class that handles all selection
   * related events and updates a SelectionModel.
   * <p>
   * Widgets that support selection should use this manager. This way the only
   * thing the widget has to do is mapping mouse or key events to indexes and
   * call the corresponding handler method.
   *
   * @see SelectionModel
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The selection model where to set the selection changes.
       */
      selectionModel : {
        check : b
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lastMouseDownHandled : null,
      /**
       * Handles the mouse down event.
       *
       * @param index {Integer} the index the mouse is pointing at.
       * @param evt {Map} the mouse event.
       * @return {void}
       */
      handleMouseDown : function(c, d){

        if(d.isLeftPressed()){

          var e = this.getSelectionModel();
          if(!e.isSelectedIndex(c)){

            // This index is not selected -> We react when the mouse is pressed (because of drag and drop)
            this._handleSelectEvent(c, d);
            this.__lastMouseDownHandled = true;
          } else {

            // This index is already selected -> We react when the mouse is released (because of drag and drop)
            this.__lastMouseDownHandled = false;
          };
        } else if(d.isRightPressed() && d.getModifiers() == 0){

          var e = this.getSelectionModel();
          if(!e.isSelectedIndex(c)){

            // This index is not selected -> Set the selection to this index
            e.setSelectionInterval(c, c);
          };
        };
      },
      /**
       * Handles the mouse up event.
       *
       * @param index {Integer} the index the mouse is pointing at.
       * @param evt {Map} the mouse event.
       * @return {void}
       */
      handleMouseUp : function(f, g){

        if(g.isLeftPressed() && !this.__lastMouseDownHandled){

          this._handleSelectEvent(f, g);
        };
      },
      /**
       * Handles the mouse click event.
       *
       * @param index {Integer} the index the mouse is pointing at.
       * @param evt {Map} the mouse event.
       * @return {void}
       */
      handleClick : function(h, i){
      },
      /**
       * Handles the key down event that is used as replacement for mouse clicks
       * (Normally space).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       * @return {void}
       */
      handleSelectKeyDown : function(j, k){

        this._handleSelectEvent(j, k);
      },
      /**
       * Handles a key down event that moved the focus (E.g. up, down, home, end, ...).
       *
       * @param index {Integer} the index that is currently focused.
       * @param evt {Map} the key event.
       * @return {void}
       */
      handleMoveKeyDown : function(l, m){

        var o = this.getSelectionModel();
        switch(m.getModifiers()){case 0:
        o.setSelectionInterval(l, l);
        break;case qx.event.type.Dom.SHIFT_MASK:
        var n = o.getAnchorSelectionIndex();
        if(n == -1){

          o.setSelectionInterval(l, l);
        } else {

          o.setSelectionInterval(n, l);
        };
        break;};
      },
      /**
       * Handles a select event.
       *
       * @param index {Integer} the index the event is pointing at.
       * @param evt {Map} the mouse event.
       * @return {void}
       */
      _handleSelectEvent : function(p, q){

        var t = this.getSelectionModel();
        var r = t.getLeadSelectionIndex();
        var s = t.getAnchorSelectionIndex();
        if(q.isShiftPressed()){

          if(p != r || t.isSelectionEmpty()){

            // The lead selection index was changed
            if(s == -1){

              s = p;
            };
            if(q.isCtrlOrCommandPressed()){

              t.addSelectionInterval(s, p);
            } else {

              t.setSelectionInterval(s, p);
            };
          };
        } else if(q.isCtrlOrCommandPressed()){

          if(t.isSelectedIndex(p)){

            t.removeSelectionInterval(p, p);
          } else {

            t.addSelectionInterval(p, p);
          };
        } else {

          // setSelectionInterval checks to see if the change is really necessary
          t.setSelectionInterval(p, p);
        };
      }
    }
  });
})();
(function(){

  var o = "]",n = "..",m = "changeSelection",l = "Try to turn off batch mode althoug it was not turned on.",k = " [",h = 'ie',g = "browser.version",f = "qx.event.type.Event",d = "Ranges:",c = "qx.ui.table.selection.Model",a = "browser.name",b = "_applySelectionMode";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */
  /**
   * A selection model.
   */
  qx.Class.define(c, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.core.Object.call(this);
      this.__selectedRangeArr = [];
      this.__anchorSelectionIndex = -1;
      this.__leadSelectionIndex = -1;
      this.hasBatchModeRefCount = 0;
      this.__hadChangeEventInBatchMode = false;
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the selection has changed. */
      "changeSelection" : f
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {int} The selection mode "none". Nothing can ever be selected. */
      NO_SELECTION : 1,
      /** {int} The selection mode "single". This mode only allows one selected item. */
      SINGLE_SELECTION : 2,
      /**
       * (int) The selection mode "single interval". This mode only allows one
       * continuous interval of selected items.
       */
      SINGLE_INTERVAL_SELECTION : 3,
      /**
       * (int) The selection mode "multiple interval". This mode only allows any
       * selection.
       */
      MULTIPLE_INTERVAL_SELECTION : 4,
      /**
       * (int) The selection mode "multiple interval". This mode only allows any
       * selection. The difference with the previous one, is that multiple
       * selection is eased. A click on an item, toggles its selection state.
       * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only
       * when Ctrl-clicking an item.
       */
      MULTIPLE_INTERVAL_SELECTION_TOGGLE : 5
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Set the selection mode. Valid values are {@link #NO_SELECTION},
       * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},
       * {@link #MULTIPLE_INTERVAL_SELECTION} and
       * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.
       */
      selectionMode : {
        init : 2,
        //SINGLE_SELECTION,
        check : [1, 2, 3, 4, 5],
        //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],
        apply : b
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __hadChangeEventInBatchMode : null,
      __anchorSelectionIndex : null,
      __leadSelectionIndex : null,
      __selectedRangeArr : null,
      // selectionMode property modifier
      _applySelectionMode : function(p){

        this.resetSelection();
      },
      /**
       *
       * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but
       * will be collected instead. When batch mode is turned off again and any events have
       * been collected, one event is thrown to inform the listeners.
       *
       * This method supports nested calling, i. e. batch mode can be turned more than once.
       * In this case, batch mode will not end until it has been turned off once for each
       * turning on.
       *
       * @param batchMode {Boolean} true to activate batch mode, false to deactivate
       * @return {Boolean} true if batch mode is active, false otherwise
       * @throws Error if batch mode is turned off once more than it has been turned on
       */
      setBatchMode : function(q){

        if(q){

          this.hasBatchModeRefCount += 1;
        } else {

          if(this.hasBatchModeRefCount == 0){

            throw new Error(l);
          };
          this.hasBatchModeRefCount -= 1;
          if(this.__hadChangeEventInBatchMode){

            this.__hadChangeEventInBatchMode = false;
            this._fireChangeSelection();
          };
        };
        return this.hasBatchMode();
      },
      /**
       *
       * Returns whether batch mode is active. See setter for a description of batch mode.
       *
       * @return {Boolean} true if batch mode is active, false otherwise
       */
      hasBatchMode : function(){

        return this.hasBatchModeRefCount > 0;
      },
      /**
       * Returns the first argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the anchor selection index.
       */
      getAnchorSelectionIndex : function(){

        return this.__anchorSelectionIndex;
      },
      /**
       * Sets the anchor selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setAnchorSelectionIndex : function(r){

        this.__anchorSelectionIndex = r;
      },
      /**
       * Returns the second argument of the last call to {@link #setSelectionInterval()},
       * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.
       *
       * @return {Integer} the lead selection index.
       */
      getLeadSelectionIndex : function(){

        return this.__leadSelectionIndex;
      },
      /**
       * Sets the lead selection index. Only use this function, if you want manipulate
       * the selection manually.
       *
       * @param index {Integer} the index to set.
       */
      _setLeadSelectionIndex : function(s){

        this.__leadSelectionIndex = s;
      },
      /**
       * Returns an array that holds all the selected ranges of the table. Each
       * entry is a map holding information about the "minIndex" and "maxIndex" of the
       * selection range.
       *
       * @return {Map[]} array with all the selected ranges.
       */
      _getSelectedRangeArr : function(){

        return this.__selectedRangeArr;
      },
      /**
       * Resets (clears) the selection.
       */
      resetSelection : function(){

        if(!this.isSelectionEmpty()){

          this._resetSelection();
          this._fireChangeSelection();
        };
      },
      /**
       * Returns whether the selection is empty.
       *
       * @return {Boolean} whether the selection is empty.
       */
      isSelectionEmpty : function(){

        return this.__selectedRangeArr.length == 0;
      },
      /**
       * Returns the number of selected items.
       *
       * @return {Integer} the number of selected items.
       */
      getSelectedCount : function(){

        var u = 0;
        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          var t = this.__selectedRangeArr[i];
          u += t.maxIndex - t.minIndex + 1;
        };
        return u;
      },
      /**
       * Returns whether an index is selected.
       *
       * @param index {Integer} the index to check.
       * @return {Boolean} whether the index is selected.
       */
      isSelectedIndex : function(v){

        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          var w = this.__selectedRangeArr[i];
          if(v >= w.minIndex && v <= w.maxIndex){

            return true;
          };
        };
        return false;
      },
      /**
       * Returns the selected ranges as an array. Each array element has a
       * <code>minIndex</code> and a <code>maxIndex</code> property.
       *
       * @return {Map[]} the selected ranges.
       */
      getSelectedRanges : function(){

        // clone the selection array and the individual elements - this prevents the
        // caller from messing with the internal model
        var x = [];
        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          x.push({
            minIndex : this.__selectedRangeArr[i].minIndex,
            maxIndex : this.__selectedRangeArr[i].maxIndex
          });
        };
        return x;
      },
      /**
       * Calls an iterator function for each selected index.
       *
       * Usage Example:
       * <pre class='javascript'>
       * var selectedRowData = [];
       * mySelectionModel.iterateSelection(function(index) {
       *   selectedRowData.push(myTableModel.getRowData(index));
       * });
       * </pre>
       *
       * @param iterator {Function} the function to call for each selected index.
       *          Gets the current index as parameter.
       * @param object {var ? null} the object to use when calling the handler.
       *          (this object will be available via "this" in the iterator)
       * @return {void}
       */
      iterateSelection : function(y, z){

        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          for(var j = this.__selectedRangeArr[i].minIndex;j <= this.__selectedRangeArr[i].maxIndex;j++){

            y.call(z, j);
          };
        };
      },
      /**
       * Sets the selected interval. This will clear the former selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       * @return {void}
       */
      setSelectionInterval : function(A, B){

        var C = this.self(arguments);
        switch(this.getSelectionMode()){case C.NO_SELECTION:
        return;case C.SINGLE_SELECTION:
        // Ensure there is actually a change of selection
        if(this.isSelectedIndex(B)){

          return;
        };
        A = B;
        break;case C.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
        this.setBatchMode(true);
        try{

          for(var i = A;i <= B;i++){

            if(!this.isSelectedIndex(i)){

              this._addSelectionInterval(i, i);
            } else {

              this.removeSelectionInterval(i, i);
            };
          };
        } catch(e) {

          // IE doesn't execute the "finally" block if no "catch" block is present
          // this hack is used to fix [BUG #3688]
          if(qx.core.Environment.get(a) == h && qx.core.Environment.get(g) <= 7){

            this.setBatchMode(false);
          };
          throw e;
        }finally{

          this.setBatchMode(false);
        };
        this._fireChangeSelection();
        return;};
        this._resetSelection();
        this._addSelectionInterval(A, B);
        this._fireChangeSelection();
      },
      /**
       * Adds a selection interval to the current selection.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       * @return {void}
       */
      addSelectionInterval : function(D, E){

        var F = qx.ui.table.selection.Model;
        switch(this.getSelectionMode()){case F.NO_SELECTION:
        return;case F.MULTIPLE_INTERVAL_SELECTION:case F.MULTIPLE_INTERVAL_SELECTION_TOGGLE:
        this._addSelectionInterval(D, E);
        this._fireChangeSelection();
        break;default:
        this.setSelectionInterval(D, E);
        break;};
      },
      /**
       * Removes an interval from the current selection.
       *
       * @param fromIndex {Integer} the first index of the interval (including).
       * @param toIndex {Integer} the last index of the interval (including).
       * @return {void}
       */
      removeSelectionInterval : function(G, H){

        this.__anchorSelectionIndex = G;
        this.__leadSelectionIndex = H;
        var I = Math.min(G, H);
        var K = Math.max(G, H);
        // Crop the affected ranges
        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          var M = this.__selectedRangeArr[i];
          if(M.minIndex > K){

            // We are done
            break;
          } else if(M.maxIndex >= I){

            // This range is affected
            var N = (M.minIndex >= I) && (M.minIndex <= K);
            var L = (M.maxIndex >= I) && (M.maxIndex <= K);
            if(N && L){

              // This range is removed completely
              this.__selectedRangeArr.splice(i, 1);
              // Check this index another time
              i--;
            } else if(N){

              // The range is cropped from the left
              M.minIndex = K + 1;
            } else if(L){

              // The range is cropped from the right
              M.maxIndex = I - 1;
            } else {

              // The range is split
              var J = {
                minIndex : K + 1,
                maxIndex : M.maxIndex
              };
              this.__selectedRangeArr.splice(i + 1, 0, J);
              M.maxIndex = I - 1;
              // We are done
              break;
            };;
          };
        };
        // this._dumpRanges();
        this._fireChangeSelection();
      },
      /**
       * Resets (clears) the selection, but doesn't inform the listeners.
       */
      _resetSelection : function(){

        this.__selectedRangeArr = [];
        this.__anchorSelectionIndex = -1;
        this.__leadSelectionIndex = -1;
      },
      /**
       * Adds a selection interval to the current selection, but doesn't inform
       * the listeners.
       *
       * @param fromIndex {Integer} the first index of the selection (including).
       * @param toIndex {Integer} the last index of the selection (including).
       * @return {void}
       */
      _addSelectionInterval : function(O, P){

        this.__anchorSelectionIndex = O;
        this.__leadSelectionIndex = P;
        var Q = Math.min(O, P);
        var S = Math.max(O, P);
        // Find the index where the new range should be inserted
        var R = 0;
        for(;R < this.__selectedRangeArr.length;R++){

          var T = this.__selectedRangeArr[R];
          if(T.minIndex > Q){

            break;
          };
        };
        // Add the new range
        this.__selectedRangeArr.splice(R, 0, {
          minIndex : Q,
          maxIndex : S
        });
        // Merge overlapping ranges
        var U = this.__selectedRangeArr[0];
        for(var i = 1;i < this.__selectedRangeArr.length;i++){

          var T = this.__selectedRangeArr[i];
          if(U.maxIndex + 1 >= T.minIndex){

            // The ranges are overlapping -> merge them
            U.maxIndex = Math.max(U.maxIndex, T.maxIndex);
            // Remove the current range
            this.__selectedRangeArr.splice(i, 1);
            // Check this index another time
            i--;
          } else {

            U = T;
          };
        };
      },
      // this._dumpRanges();
      /**
       * Logs the current ranges for debug perposes.
       *
       * @return {void}
       */
      _dumpRanges : function(){

        var V = d;
        for(var i = 0;i < this.__selectedRangeArr.length;i++){

          var W = this.__selectedRangeArr[i];
          V += k + W.minIndex + n + W.maxIndex + o;
        };
        this.debug(V);
      },
      /**
       * Fires the "changeSelection" event to all registered listeners. If the selection model
       * currently is in batch mode, only one event will be thrown when batch mode is ended.
       *
       * @return {void}
       */
      _fireChangeSelection : function(){

        if(this.hasBatchMode()){

          // In batch mode, remember event but do not throw (yet)
          this.__hadChangeEventInBatchMode = true;
        } else {

          // If not in batch mode, throw event
          this.fireEvent(m);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__selectedRangeArr = null;
    }
  });
})();
(function(){

  var a = "qx.ui.table.ICellRenderer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A cell renderer for data cells.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Creates the HTML for a data cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>rowData (var): contains the row data for the row, the cell belongs to.
       *   The kind of this object depends on the table model, see
       *   {@link qx.ui.table.ITableModel#getRowData}</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>table (qx.ui.table.Table): the table the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>selected (boolean): whether the cell is selected.</li>
       * <li>focusedRow (boolean): whether the cell is in the same row as the
       *   focused cell.</li>
       * <li>editable (boolean): whether the cell is editable.</li>
       * <li>style (string): The CSS styles that should be applied to the outer HTML
       *   element.</li>
       * <li>styleLeft (string): The left position of the cell.</li>
       * <li>styleWidth (string): The cell's width (pixel).</li>
       * <li>styleHeight (string): The cell's height (pixel).</li>
       * </ul>
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *     create.
       * @param htmlArr {String[]} Target string container. The HTML of the data
       *     cell should be appended to this array.
       *
       * @return {Boolean|undefined}
       *   A return value of <i>true</i> specifies that no additional cells in
       *   the row shall be rendered. This may be used, for example, for
       *   separator rows or for other special rendering purposes. Traditional
       *   cell renderers had no defined return value, so returned nothing
       *   (undefined). If this method returns either false or nothing, then
       *   rendering continues with the next cell in the row, which the normal
       *   mode of operation.
       */
      createDataCellHtml : function(b, c){

        return true;
      }
    }
  });
})();
(function(){

  var j = "qooxdoo-table-cell",i = "content",h = '</div>',g = "nowrap",f = "default",e = "}",d = "width:",c = ".qooxdoo-table-cell-right { text-align:right } ",b = "css.boxsizing",a = "css.boxmodel",I = "0px 6px",H = '<div class="',G = "0px",F = "height:",E = "1px solid ",D = ".qooxdoo-table-cell-bold { font-weight:bold } ",C = "String",B = "} ",A = '>',z = '" ',q = "ellipsis",r = "content-box",o = 'left:',p = "qx.ui.table.cellrenderer.Abstract",m = '" style="',n = "abstract",k = "none",l = "hidden",s = "table-column-line",t = 'px;',v = ".qooxdoo-table-cell-italic { font-style:italic} ",u = "absolute",x = "px;",w = ".qooxdoo-table-cell {",y = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /* ************************************************************************
  #require(qx.bom.Stylesheet)
  ************************************************************************ */
  /**
   * An abstract data cell renderer that does the basic coloring
   * (borders, selected look, ...).
   */
  qx.Class.define(p, {
    type : n,
    implement : qx.ui.table.ICellRenderer,
    extend : qx.core.Object,
    construct : function(){

      qx.core.Object.call(this);
      var J = qx.ui.table.cellrenderer.Abstract;
      if(!J.__clazz){

        var L = qx.theme.manager.Color.getInstance();
        J.__clazz = this.self(arguments);
        var K = w + qx.bom.element.Style.compile({
          position : u,
          top : G,
          overflow : l,
          whiteSpace : g,
          borderRight : E + L.resolve(s),
          padding : I,
          cursor : f,
          textOverflow : q,
          userSelect : k
        }) + B + c + v + D;
        if(qx.core.Environment.get(b)){

          K += w + qx.bom.element.BoxSizing.compile(r) + e;
        };
        J.__clazz.stylesheet = qx.bom.Stylesheet.createElement(K);
      };
    },
    properties : {
      /**
       * The default cell style. The value of this property will be provided
       * to the cell renderer as cellInfo.style.
       */
      defaultCellStyle : {
        init : null,
        check : C,
        nullable : true
      }
    },
    members : {
      /**
       * the sum of the horizontal insets. This is needed to compute the box model
       * independent size
       */
      _insetX : 6 + 6 + 1,
      // paddingLeft + paddingRight + borderRight
      /**
       * the sum of the vertical insets. This is needed to compute the box model
       * independent size
       */
      _insetY : 0,
      /**
       * Get a string of the cell element's HTML classes.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} cellInfo of the cell
       * @return {String} The table cell HTML classes as string.
       */
      _getCellClass : function(M){

        return j;
      },
      /**
       * Returns the CSS styles that should be applied to the main div of this
       * cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {var} the CSS styles of the main div.
       */
      _getCellStyle : function(N){

        return N.style || y;
      },
      /**
        * Retrieve any extra attributes the cell renderer wants applied to this
        * cell. Extra attributes could be such things as
        * "onclick='handleClick()';"
        *
        * @param cellInfo {Map} The information about the cell.
        *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
        *
        * @return {String}
        *   The extra attributes to be applied to this cell.
        */
      _getCellAttributes : function(O){

        return y;
      },
      /**
       * Returns the HTML that should be used inside the main div of this cell.
       *
       * This method may be overridden by sub classes.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the inner HTML of the cell.
       */
      _getContentHtml : function(P){

        return P.value || y;
      },
      /**
       * Get the cell size taking the box model into account
       *
       * @param width {Integer} The cell's (border-box) width in pixel
       * @param height {Integer} The cell's (border-box) height in pixel
       * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
       *    horizontal paddings and borders
       * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
       *    vertical paddings and borders
       * @return {String} The CSS style string for the cell size
       */
      _getCellSizeStyle : function(Q, R, S, T){

        var U = y;
        if(qx.core.Environment.get(a) == i){

          Q -= S;
          R -= T;
        };
        U += d + Math.max(Q, 0) + x;
        U += F + Math.max(R, 0) + x;
        return U;
      },
      // interface implementation
      createDataCellHtml : function(V, W){

        W.push(H, this._getCellClass(V), m, o, V.styleLeft, t, this._getCellSizeStyle(V.styleWidth, V.styleHeight, this._insetX, this._insetY), this._getCellStyle(V), z, this._getCellAttributes(V), A + this._getContentHtml(V), h);
      }
    }
  });
})();
(function(){

  var h = "Boolean",g = "qx.ui.table.cellrenderer.Default",f = " qooxdoo-table-cell-bold",e = " qooxdoo-table-cell-right",d = " qooxdoo-table-cell-italic",c = "string",b = "",a = "number";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * The default data cell renderer.
   */
  qx.Class.define(g, {
    extend : qx.ui.table.cellrenderer.Abstract,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      STYLEFLAG_ALIGN_RIGHT : 1,
      STYLEFLAG_BOLD : 2,
      STYLEFLAG_ITALIC : 4,
      _numberFormat : null
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Whether the alignment should automatically be set according to the cell value.
       * If true numbers will be right-aligned.
       */
      useAutoAlign : {
        check : h,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Determines the styles to apply to the cell
       *
       * @param cellInfo {Map} cellInfo of the cell
       *     See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Integer} the sum of any of the STYLEFLAGS defined below
       */
      _getStyleFlags : function(i){

        if(this.getUseAutoAlign()){

          if(typeof i.value == a){

            return qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT;
          };
        };
        return 0;
      },
      // overridden
      _getCellClass : function(j){

        var k = qx.ui.table.cellrenderer.Abstract.prototype._getCellClass.call(this, j);
        if(!k){

          return b;
        };
        var l = this._getStyleFlags(j);
        if(l & qx.ui.table.cellrenderer.Default.STYLEFLAG_ALIGN_RIGHT){

          k += e;
        };
        if(l & qx.ui.table.cellrenderer.Default.STYLEFLAG_BOLD){

          k += f;
        };
        if(l & qx.ui.table.cellrenderer.Default.STYLEFLAG_ITALIC){

          k += d;
        };
        return k;
      },
      // overridden
      _getContentHtml : function(m){

        return qx.bom.String.escape(this._formatValue(m));
      },
      /**
       * Formats a value.
       *
       * @param cellInfo {Map} A map containing the information about the cell to
       *          create. This map has the same structure as in
       *          {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {String} the formatted value.
       */
      _formatValue : function(n){

        var p = n.value;
        var o;
        if(p == null){

          return b;
        };
        if(typeof p == c){

          return p;
        } else if(typeof p == a){

          if(!qx.ui.table.cellrenderer.Default._numberFormat){

            qx.ui.table.cellrenderer.Default._numberFormat = new qx.util.format.NumberFormat();
            qx.ui.table.cellrenderer.Default._numberFormat.setMaximumFractionDigits(2);
          };
          o = qx.ui.table.cellrenderer.Default._numberFormat.format(p);
        } else if(p instanceof Date){

          o = qx.util.format.DateFormat.getDateInstance().format(p);
        } else {

          o = p.toString();
        };;
        return o;
      }
    }
  });
})();
(function(){

  var g = "<br",f = " &nbsp;",e = "<br>",d = " ",c = "\n",b = "qx.bom.String",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A Collection of utility functions to escape and unescape strings.
   */
  qx.Class.define(b, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** Mapping of HTML entity names to the corresponding char code */
      TO_CHARCODE : {
        "quot" : 34,
        // " - double-quote
        "amp" : 38,
        // &
        "lt" : 60,
        // <
        "gt" : 62,
        // >
        // http://www.w3.org/TR/REC-html40/sgml/entities.html
        // ISO 8859-1 characters
        "nbsp" : 160,
        // no-break space
        "iexcl" : 161,
        // inverted exclamation mark
        "cent" : 162,
        // cent sign
        "pound" : 163,
        // pound sterling sign
        "curren" : 164,
        // general currency sign
        "yen" : 165,
        // yen sign
        "brvbar" : 166,
        // broken (vertical) bar
        "sect" : 167,
        // section sign
        "uml" : 168,
        // umlaut (dieresis)
        "copy" : 169,
        // copyright sign
        "ordf" : 170,
        // ordinal indicator, feminine
        "laquo" : 171,
        // angle quotation mark, left
        "not" : 172,
        // not sign
        "shy" : 173,
        // soft hyphen
        "reg" : 174,
        // registered sign
        "macr" : 175,
        // macron
        "deg" : 176,
        // degree sign
        "plusmn" : 177,
        // plus-or-minus sign
        "sup2" : 178,
        // superscript two
        "sup3" : 179,
        // superscript three
        "acute" : 180,
        // acute accent
        "micro" : 181,
        // micro sign
        "para" : 182,
        // pilcrow (paragraph sign)
        "middot" : 183,
        // middle dot
        "cedil" : 184,
        // cedilla
        "sup1" : 185,
        // superscript one
        "ordm" : 186,
        // ordinal indicator, masculine
        "raquo" : 187,
        // angle quotation mark, right
        "frac14" : 188,
        // fraction one-quarter
        "frac12" : 189,
        // fraction one-half
        "frac34" : 190,
        // fraction three-quarters
        "iquest" : 191,
        // inverted question mark
        "Agrave" : 192,
        // capital A, grave accent
        "Aacute" : 193,
        // capital A, acute accent
        "Acirc" : 194,
        // capital A, circumflex accent
        "Atilde" : 195,
        // capital A, tilde
        "Auml" : 196,
        // capital A, dieresis or umlaut mark
        "Aring" : 197,
        // capital A, ring
        "AElig" : 198,
        // capital AE diphthong (ligature)
        "Ccedil" : 199,
        // capital C, cedilla
        "Egrave" : 200,
        // capital E, grave accent
        "Eacute" : 201,
        // capital E, acute accent
        "Ecirc" : 202,
        // capital E, circumflex accent
        "Euml" : 203,
        // capital E, dieresis or umlaut mark
        "Igrave" : 204,
        // capital I, grave accent
        "Iacute" : 205,
        // capital I, acute accent
        "Icirc" : 206,
        // capital I, circumflex accent
        "Iuml" : 207,
        // capital I, dieresis or umlaut mark
        "ETH" : 208,
        // capital Eth, Icelandic
        "Ntilde" : 209,
        // capital N, tilde
        "Ograve" : 210,
        // capital O, grave accent
        "Oacute" : 211,
        // capital O, acute accent
        "Ocirc" : 212,
        // capital O, circumflex accent
        "Otilde" : 213,
        // capital O, tilde
        "Ouml" : 214,
        // capital O, dieresis or umlaut mark
        "times" : 215,
        // multiply sign
        "Oslash" : 216,
        // capital O, slash
        "Ugrave" : 217,
        // capital U, grave accent
        "Uacute" : 218,
        // capital U, acute accent
        "Ucirc" : 219,
        // capital U, circumflex accent
        "Uuml" : 220,
        // capital U, dieresis or umlaut mark
        "Yacute" : 221,
        // capital Y, acute accent
        "THORN" : 222,
        // capital THORN, Icelandic
        "szlig" : 223,
        // small sharp s, German (sz ligature)
        "agrave" : 224,
        // small a, grave accent
        "aacute" : 225,
        // small a, acute accent
        "acirc" : 226,
        // small a, circumflex accent
        "atilde" : 227,
        // small a, tilde
        "auml" : 228,
        // small a, dieresis or umlaut mark
        "aring" : 229,
        // small a, ring
        "aelig" : 230,
        // small ae diphthong (ligature)
        "ccedil" : 231,
        // small c, cedilla
        "egrave" : 232,
        // small e, grave accent
        "eacute" : 233,
        // small e, acute accent
        "ecirc" : 234,
        // small e, circumflex accent
        "euml" : 235,
        // small e, dieresis or umlaut mark
        "igrave" : 236,
        // small i, grave accent
        "iacute" : 237,
        // small i, acute accent
        "icirc" : 238,
        // small i, circumflex accent
        "iuml" : 239,
        // small i, dieresis or umlaut mark
        "eth" : 240,
        // small eth, Icelandic
        "ntilde" : 241,
        // small n, tilde
        "ograve" : 242,
        // small o, grave accent
        "oacute" : 243,
        // small o, acute accent
        "ocirc" : 244,
        // small o, circumflex accent
        "otilde" : 245,
        // small o, tilde
        "ouml" : 246,
        // small o, dieresis or umlaut mark
        "divide" : 247,
        // divide sign
        "oslash" : 248,
        // small o, slash
        "ugrave" : 249,
        // small u, grave accent
        "uacute" : 250,
        // small u, acute accent
        "ucirc" : 251,
        // small u, circumflex accent
        "uuml" : 252,
        // small u, dieresis or umlaut mark
        "yacute" : 253,
        // small y, acute accent
        "thorn" : 254,
        // small thorn, Icelandic
        "yuml" : 255,
        // small y, dieresis or umlaut mark
        // Latin Extended-B
        "fnof" : 402,
        // latin small f with hook = function= florin, U+0192 ISOtech
        // Greek
        "Alpha" : 913,
        // greek capital letter alpha, U+0391
        "Beta" : 914,
        // greek capital letter beta, U+0392
        "Gamma" : 915,
        // greek capital letter gamma,U+0393 ISOgrk3
        "Delta" : 916,
        // greek capital letter delta,U+0394 ISOgrk3
        "Epsilon" : 917,
        // greek capital letter epsilon, U+0395
        "Zeta" : 918,
        // greek capital letter zeta, U+0396
        "Eta" : 919,
        // greek capital letter eta, U+0397
        "Theta" : 920,
        // greek capital letter theta,U+0398 ISOgrk3
        "Iota" : 921,
        // greek capital letter iota, U+0399
        "Kappa" : 922,
        // greek capital letter kappa, U+039A
        "Lambda" : 923,
        // greek capital letter lambda,U+039B ISOgrk3
        "Mu" : 924,
        // greek capital letter mu, U+039C
        "Nu" : 925,
        // greek capital letter nu, U+039D
        "Xi" : 926,
        // greek capital letter xi, U+039E ISOgrk3
        "Omicron" : 927,
        // greek capital letter omicron, U+039F
        "Pi" : 928,
        // greek capital letter pi, U+03A0 ISOgrk3
        "Rho" : 929,
        // greek capital letter rho, U+03A1
        // there is no Sigmaf, and no U+03A2 character either
        "Sigma" : 931,
        // greek capital letter sigma,U+03A3 ISOgrk3
        "Tau" : 932,
        // greek capital letter tau, U+03A4
        "Upsilon" : 933,
        // greek capital letter upsilon,U+03A5 ISOgrk3
        "Phi" : 934,
        // greek capital letter phi,U+03A6 ISOgrk3
        "Chi" : 935,
        // greek capital letter chi, U+03A7
        "Psi" : 936,
        // greek capital letter psi,U+03A8 ISOgrk3
        "Omega" : 937,
        // greek capital letter omega,U+03A9 ISOgrk3
        "alpha" : 945,
        // greek small letter alpha,U+03B1 ISOgrk3
        "beta" : 946,
        // greek small letter beta, U+03B2 ISOgrk3
        "gamma" : 947,
        // greek small letter gamma,U+03B3 ISOgrk3
        "delta" : 948,
        // greek small letter delta,U+03B4 ISOgrk3
        "epsilon" : 949,
        // greek small letter epsilon,U+03B5 ISOgrk3
        "zeta" : 950,
        // greek small letter zeta, U+03B6 ISOgrk3
        "eta" : 951,
        // greek small letter eta, U+03B7 ISOgrk3
        "theta" : 952,
        // greek small letter theta,U+03B8 ISOgrk3
        "iota" : 953,
        // greek small letter iota, U+03B9 ISOgrk3
        "kappa" : 954,
        // greek small letter kappa,U+03BA ISOgrk3
        "lambda" : 955,
        // greek small letter lambda,U+03BB ISOgrk3
        "mu" : 956,
        // greek small letter mu, U+03BC ISOgrk3
        "nu" : 957,
        // greek small letter nu, U+03BD ISOgrk3
        "xi" : 958,
        // greek small letter xi, U+03BE ISOgrk3
        "omicron" : 959,
        // greek small letter omicron, U+03BF NEW
        "pi" : 960,
        // greek small letter pi, U+03C0 ISOgrk3
        "rho" : 961,
        // greek small letter rho, U+03C1 ISOgrk3
        "sigmaf" : 962,
        // greek small letter final sigma,U+03C2 ISOgrk3
        "sigma" : 963,
        // greek small letter sigma,U+03C3 ISOgrk3
        "tau" : 964,
        // greek small letter tau, U+03C4 ISOgrk3
        "upsilon" : 965,
        // greek small letter upsilon,U+03C5 ISOgrk3
        "phi" : 966,
        // greek small letter phi, U+03C6 ISOgrk3
        "chi" : 967,
        // greek small letter chi, U+03C7 ISOgrk3
        "psi" : 968,
        // greek small letter psi, U+03C8 ISOgrk3
        "omega" : 969,
        // greek small letter omega,U+03C9 ISOgrk3
        "thetasym" : 977,
        // greek small letter theta symbol,U+03D1 NEW
        "upsih" : 978,
        // greek upsilon with hook symbol,U+03D2 NEW
        "piv" : 982,
        // greek pi symbol, U+03D6 ISOgrk3
        // General Punctuation
        "bull" : 8226,
        // bullet = black small circle,U+2022 ISOpub
        // bullet is NOT the same as bullet operator, U+2219
        "hellip" : 8230,
        // horizontal ellipsis = three dot leader,U+2026 ISOpub
        "prime" : 8242,
        // prime = minutes = feet, U+2032 ISOtech
        "Prime" : 8243,
        // double prime = seconds = inches,U+2033 ISOtech
        "oline" : 8254,
        // overline = spacing overscore,U+203E NEW
        "frasl" : 8260,
        // fraction slash, U+2044 NEW
        // Letterlike Symbols
        "weierp" : 8472,
        // script capital P = power set= Weierstrass p, U+2118 ISOamso
        "image" : 8465,
        // blackletter capital I = imaginary part,U+2111 ISOamso
        "real" : 8476,
        // blackletter capital R = real part symbol,U+211C ISOamso
        "trade" : 8482,
        // trade mark sign, U+2122 ISOnum
        "alefsym" : 8501,
        // alef symbol = first transfinite cardinal,U+2135 NEW
        // alef symbol is NOT the same as hebrew letter alef,U+05D0 although the same glyph could be used to depict both characters
        // Arrows
        "larr" : 8592,
        // leftwards arrow, U+2190 ISOnum
        "uarr" : 8593,
        // upwards arrow, U+2191 ISOnum-->
        "rarr" : 8594,
        // rightwards arrow, U+2192 ISOnum
        "darr" : 8595,
        // downwards arrow, U+2193 ISOnum
        "harr" : 8596,
        // left right arrow, U+2194 ISOamsa
        "crarr" : 8629,
        // downwards arrow with corner leftwards= carriage return, U+21B5 NEW
        "lArr" : 8656,
        // leftwards double arrow, U+21D0 ISOtech
        // ISO 10646 does not say that lArr is the same as the 'is implied by' arrowbut also does not have any other character for that function. So ? lArr canbe used for 'is implied by' as ISOtech suggests
        "uArr" : 8657,
        // upwards double arrow, U+21D1 ISOamsa
        "rArr" : 8658,
        // rightwards double arrow,U+21D2 ISOtech
        // ISO 10646 does not say this is the 'implies' character but does not have another character with this function so ?rArr can be used for 'implies' as ISOtech suggests
        "dArr" : 8659,
        // downwards double arrow, U+21D3 ISOamsa
        "hArr" : 8660,
        // left right double arrow,U+21D4 ISOamsa
        // Mathematical Operators
        "forall" : 8704,
        // for all, U+2200 ISOtech
        "part" : 8706,
        // partial differential, U+2202 ISOtech
        "exist" : 8707,
        // there exists, U+2203 ISOtech
        "empty" : 8709,
        // empty set = null set = diameter,U+2205 ISOamso
        "nabla" : 8711,
        // nabla = backward difference,U+2207 ISOtech
        "isin" : 8712,
        // element of, U+2208 ISOtech
        "notin" : 8713,
        // not an element of, U+2209 ISOtech
        "ni" : 8715,
        // contains as member, U+220B ISOtech
        // should there be a more memorable name than 'ni'?
        "prod" : 8719,
        // n-ary product = product sign,U+220F ISOamsb
        // prod is NOT the same character as U+03A0 'greek capital letter pi' though the same glyph might be used for both
        "sum" : 8721,
        // n-ary summation, U+2211 ISOamsb
        // sum is NOT the same character as U+03A3 'greek capital letter sigma' though the same glyph might be used for both
        "minus" : 8722,
        // minus sign, U+2212 ISOtech
        "lowast" : 8727,
        // asterisk operator, U+2217 ISOtech
        "radic" : 8730,
        // square root = radical sign,U+221A ISOtech
        "prop" : 8733,
        // proportional to, U+221D ISOtech
        "infin" : 8734,
        // infinity, U+221E ISOtech
        "ang" : 8736,
        // angle, U+2220 ISOamso
        "and" : 8743,
        // logical and = wedge, U+2227 ISOtech
        "or" : 8744,
        // logical or = vee, U+2228 ISOtech
        "cap" : 8745,
        // intersection = cap, U+2229 ISOtech
        "cup" : 8746,
        // union = cup, U+222A ISOtech
        "int" : 8747,
        // integral, U+222B ISOtech
        "there4" : 8756,
        // therefore, U+2234 ISOtech
        "sim" : 8764,
        // tilde operator = varies with = similar to,U+223C ISOtech
        // tilde operator is NOT the same character as the tilde, U+007E,although the same glyph might be used to represent both
        "cong" : 8773,
        // approximately equal to, U+2245 ISOtech
        "asymp" : 8776,
        // almost equal to = asymptotic to,U+2248 ISOamsr
        "ne" : 8800,
        // not equal to, U+2260 ISOtech
        "equiv" : 8801,
        // identical to, U+2261 ISOtech
        "le" : 8804,
        // less-than or equal to, U+2264 ISOtech
        "ge" : 8805,
        // greater-than or equal to,U+2265 ISOtech
        "sub" : 8834,
        // subset of, U+2282 ISOtech
        "sup" : 8835,
        // superset of, U+2283 ISOtech
        // note that nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding and is not included. Should it be, for symmetry?It is in ISOamsn  --> <!ENTITY nsub": 8836,  //not a subset of, U+2284 ISOamsn
        "sube" : 8838,
        // subset of or equal to, U+2286 ISOtech
        "supe" : 8839,
        // superset of or equal to,U+2287 ISOtech
        "oplus" : 8853,
        // circled plus = direct sum,U+2295 ISOamsb
        "otimes" : 8855,
        // circled times = vector product,U+2297 ISOamsb
        "perp" : 8869,
        // up tack = orthogonal to = perpendicular,U+22A5 ISOtech
        "sdot" : 8901,
        // dot operator, U+22C5 ISOamsb
        // dot operator is NOT the same character as U+00B7 middle dot
        // Miscellaneous Technical
        "lceil" : 8968,
        // left ceiling = apl upstile,U+2308 ISOamsc
        "rceil" : 8969,
        // right ceiling, U+2309 ISOamsc
        "lfloor" : 8970,
        // left floor = apl downstile,U+230A ISOamsc
        "rfloor" : 8971,
        // right floor, U+230B ISOamsc
        "lang" : 9001,
        // left-pointing angle bracket = bra,U+2329 ISOtech
        // lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark'
        "rang" : 9002,
        // right-pointing angle bracket = ket,U+232A ISOtech
        // rang is NOT the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark'
        // Geometric Shapes
        "loz" : 9674,
        // lozenge, U+25CA ISOpub
        // Miscellaneous Symbols
        "spades" : 9824,
        // black spade suit, U+2660 ISOpub
        // black here seems to mean filled as opposed to hollow
        "clubs" : 9827,
        // black club suit = shamrock,U+2663 ISOpub
        "hearts" : 9829,
        // black heart suit = valentine,U+2665 ISOpub
        "diams" : 9830,
        // black diamond suit, U+2666 ISOpub
        // Latin Extended-A
        "OElig" : 338,
        //  -- latin capital ligature OE,U+0152 ISOlat2
        "oelig" : 339,
        //  -- latin small ligature oe, U+0153 ISOlat2
        // ligature is a misnomer, this is a separate character in some languages
        "Scaron" : 352,
        //  -- latin capital letter S with caron,U+0160 ISOlat2
        "scaron" : 353,
        //  -- latin small letter s with caron,U+0161 ISOlat2
        "Yuml" : 376,
        //  -- latin capital letter Y with diaeresis,U+0178 ISOlat2
        // Spacing Modifier Letters
        "circ" : 710,
        //  -- modifier letter circumflex accent,U+02C6 ISOpub
        "tilde" : 732,
        // small tilde, U+02DC ISOdia
        // General Punctuation
        "ensp" : 8194,
        // en space, U+2002 ISOpub
        "emsp" : 8195,
        // em space, U+2003 ISOpub
        "thinsp" : 8201,
        // thin space, U+2009 ISOpub
        "zwnj" : 8204,
        // zero width non-joiner,U+200C NEW RFC 2070
        "zwj" : 8205,
        // zero width joiner, U+200D NEW RFC 2070
        "lrm" : 8206,
        // left-to-right mark, U+200E NEW RFC 2070
        "rlm" : 8207,
        // right-to-left mark, U+200F NEW RFC 2070
        "ndash" : 8211,
        // en dash, U+2013 ISOpub
        "mdash" : 8212,
        // em dash, U+2014 ISOpub
        "lsquo" : 8216,
        // left single quotation mark,U+2018 ISOnum
        "rsquo" : 8217,
        // right single quotation mark,U+2019 ISOnum
        "sbquo" : 8218,
        // single low-9 quotation mark, U+201A NEW
        "ldquo" : 8220,
        // left double quotation mark,U+201C ISOnum
        "rdquo" : 8221,
        // right double quotation mark,U+201D ISOnum
        "bdquo" : 8222,
        // double low-9 quotation mark, U+201E NEW
        "dagger" : 8224,
        // dagger, U+2020 ISOpub
        "Dagger" : 8225,
        // double dagger, U+2021 ISOpub
        "permil" : 8240,
        // per mille sign, U+2030 ISOtech
        "lsaquo" : 8249,
        // single left-pointing angle quotation mark,U+2039 ISO proposed
        // lsaquo is proposed but not yet ISO standardized
        "rsaquo" : 8250,
        // single right-pointing angle quotation mark,U+203A ISO proposed
        // rsaquo is proposed but not yet ISO standardized
        "euro" : 8364
      },
      /**
       * Escapes the characters in a <code>String</code> using HTML entities.
       *
       * For example: <tt>"bread" & "butter"</tt> => <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.
       * Supports all known HTML 4.0 entities, including funky accents.
       *
       * * <a href="http://www.w3.org/TR/REC-html32#latin1">HTML 3.2 Character Entities for ISO Latin-1</a>
       * * <a href="http://www.w3.org/TR/REC-html40/sgml/entities.html">HTML 4.0 Character entity references</a>
       * * <a href="http://www.w3.org/TR/html401/charset.html#h-5.3">HTML 4.01 Character References</a>
       * * <a href="http://www.w3.org/TR/html401/charset.html#code-position">HTML 4.01 Code positions</a>
       *
       * @param str {String} the String to escape
       * @return {String} a new escaped String
       * @see #unescape
       */
      escape : function(h){

        return qx.util.StringEscape.escape(h, qx.bom.String.FROM_CHARCODE);
      },
      /**
       * Unescapes a string containing entity escapes to a string
       * containing the actual Unicode characters corresponding to the
       * escapes. Supports HTML 4.0 entities.
       *
       * For example, the string "&amp;lt;Fran&amp;ccedil;ais&amp;gt;"
       * will become "&lt;Fran&ccedil;ais&gt;"
       *
       * If an entity is unrecognized, it is left alone, and inserted
       * verbatim into the result string. e.g. "&amp;gt;&amp;zzzz;x" will
       * become "&gt;&amp;zzzz;x".
       *
       * @param str {String} the String to unescape, may be null
       * @return {var} a new unescaped String
       * @see #escape
       */
      unescape : function(i){

        return qx.util.StringEscape.unescape(i, qx.bom.String.TO_CHARCODE);
      },
      /**
       * Converts a plain text string into HTML.
       * This is similar to {@link #escape} but converts new lines to
       * <tt>&lt:br&gt:</tt> and preserves whitespaces.
       *
       * @param str {String} the String to convert
       * @return {String} a new converted String
       * @see #escape
       */
      fromText : function(j){

        return qx.bom.String.escape(j).replace(/(  |\n)/g, function(k){

          var l = {
            "  " : f,
            "\n" : e
          };
          return l[k] || k;
        });
      },
      /**
       * Converts HTML to plain text.
       *
       * * Strips all HTML tags
       * * converts <tt>&lt:br&gt:</tt> to new line
       * * unescapes HTML entities
       *
       * @param str {String} HTML string to converts
       * @return {String} plain text representation of the HTML string
       */
      toText : function(m){

        return qx.bom.String.unescape(m.replace(/\s+|<([^>])+>/gi, function(n){

          if(n.indexOf(g) === 0){

            return c;
          } else if(n.length > 0 && n.replace(/^\s*/, a).replace(/\s*$/, a) == a){

            return d;
          } else {

            return a;
          };
        }));
      }
    },
    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer : function(o){

      /** Mapping of char codes to HTML entity names */
      o.FROM_CHARCODE = qx.lang.Object.invert(o.TO_CHARCODE);
    }
  });
})();
(function(){

  var g = "&",f = 'X',e = "",d = '#',c = "&#",b = "qx.util.StringEscape",a = ";";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Generic escaping and unescaping of DOM strings.
   *
   * {@link qx.bom.String} for (un)escaping of HTML strings.
   * {@link qx.xml.String} for (un)escaping of XML strings.
   */
  qx.Class.define(b, {
    statics : {
      /**
       * generic escaping method
       *
       * @param str {String} string to escape
       * @param charCodeToEntities {Map} entity to charcode map
       * @return {String} escaped string
       * @signature function(str, charCodeToEntities)
       */
      escape : function(h, j){

        var m,o = e;
        for(var i = 0,l = h.length;i < l;i++){

          var n = h.charAt(i);
          var k = n.charCodeAt(0);
          if(j[k]){

            m = g + j[k] + a;
          } else {

            if(k > 0x7F){

              m = c + k + a;
            } else {

              m = n;
            };
          };
          o += m;
        };
        return o;
      },
      /**
       * generic unescaping method
       *
       * @param str {String} string to unescape
       * @param entitiesToCharCode {Map} charcode to entity map
       * @return {String} unescaped string
       */
      unescape : function(p, q){

        return p.replace(/&[#\w]+;/gi, function(r){

          var s = r;
          var r = r.substring(1, r.length - 1);
          var t = q[r];
          if(t){

            s = String.fromCharCode(t);
          } else {

            if(r.charAt(0) == d){

              if(r.charAt(1).toUpperCase() == f){

                t = r.substring(2);
                // match hex number
                if(t.match(/^[0-9A-Fa-f]+$/gi)){

                  s = String.fromCharCode(parseInt(t, 16));
                };
              } else {

                t = r.substring(1);
                // match integer
                if(t.match(/^\d+$/gi)){

                  s = String.fromCharCode(parseInt(t, 10));
                };
              };
            };
          };
          return s;
        });
      }
    }
  });
})();
(function(){

  var a = "qx.util.format.IFormat";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * Superclass for formatters and parsers.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Formats an object.
       *
       * @abstract
       * @param obj {var} The object to format.
       * @return {String} the formatted object.
       * @throws the abstract function warning.
       */
      format : function(b){
      },
      /**
       * Parses an object.
       *
       * @abstract
       * @param str {String} the string to parse.
       * @return {var} the parsed object.
       * @throws the abstract function warning.
       */
      parse : function(c){
      }
    }
  });
})();
(function(){

  var j = "Boolean",i = "^",h = "Number string '",g = "' does not match the number format",f = "NaN",e = '(',d = "-Infinity",c = '{0,1}[0-9]{3}){0,})',b = '([0-9]{1,3}(?:',a = "qx.util.format.NumberFormat",v = '([-+]){0,1}',u = "g",t = "$",s = '\\d+){0,1}',r = ".",q = "Infinity",p = "0",o = "String",n = "changeNumberFormat",m = "-",k = "Number",l = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A formatter and parser for numbers.
   */
  qx.Class.define(a, {
    extend : qx.core.Object,
    implement : qx.util.format.IFormat,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param locale {String} optional locale to be used
     */
    construct : function(w){

      qx.core.Object.call(this);
      this.__locale = w;
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The minimum number of integer digits (digits before the decimal separator).
       * Missing digits will be filled up with 0 ("19" -> "0019").
       */
      minimumIntegerDigits : {
        check : k,
        init : 0
      },
      /**
       * The maximum number of integer digits (superfluous digits will be cut off
       * ("1923" -> "23").
       */
      maximumIntegerDigits : {
        check : k,
        nullable : true
      },
      /**
       * The minimum number of fraction digits (digits after the decimal separator).
       * Missing digits will be filled up with 0 ("1.5" -> "1.500")
       */
      minimumFractionDigits : {
        check : k,
        init : 0
      },
      /**
       * The maximum number of fraction digits (digits after the decimal separator).
       * Superfluous digits will cause rounding ("1.8277" -> "1.83")
       */
      maximumFractionDigits : {
        check : k,
        nullable : true
      },
      /** Whether thousand groupings should be used {e.g. "1,432,234.65"}. */
      groupingUsed : {
        check : j,
        init : true
      },
      /** The prefix to put before the number {"EUR " -> "EUR 12.31"}. */
      prefix : {
        check : o,
        init : l,
        event : n
      },
      /** Sets the postfix to put after the number {" %" -> "56.13 %"}. */
      postfix : {
        check : o,
        init : l,
        event : n
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __locale : null,
      /**
       * Formats a number.
       *
       * @param num {Number} the number to format.
       * @return {String} the formatted number as a string.
       */
      format : function(x){

        // handle special cases
        switch(x){case Infinity:
        return q;case -Infinity:
        return d;case NaN:
        return f;};
        var B = (x < 0);
        if(B){

          x = -x;
        };
        if(this.getMaximumFractionDigits() != null){

          // Do the rounding
          var I = Math.pow(10, this.getMaximumFractionDigits());
          x = Math.round(x * I) / I;
        };
        var H = String(Math.floor(x)).length;
        var y = l + x;
        // Prepare the integer part
        var E = y.substring(0, H);
        while(E.length < this.getMinimumIntegerDigits()){

          E = p + E;
        };
        if(this.getMaximumIntegerDigits() != null && E.length > this.getMaximumIntegerDigits()){

          // NOTE: We cut off even though we did rounding before, because there
          //     may be rounding errors ("12.24000000000001" -> "12.24")
          E = E.substring(E.length - this.getMaximumIntegerDigits());
        };
        // Prepare the fraction part
        var D = y.substring(H + 1);
        while(D.length < this.getMinimumFractionDigits()){

          D += p;
        };
        if(this.getMaximumFractionDigits() != null && D.length > this.getMaximumFractionDigits()){

          // We have already rounded -> Just cut off the rest
          D = D.substring(0, this.getMaximumFractionDigits());
        };
        // Add the thousand groupings
        if(this.getGroupingUsed()){

          var A = E;
          E = l;
          var G;
          for(G = A.length;G > 3;G -= 3){

            E = l + qx.locale.Number.getGroupSeparator(this.__locale) + A.substring(G - 3, G) + E;
          };
          E = A.substring(0, G) + E;
        };
        // Workaround: prefix and postfix are null even their defaultValue is "" and
        //             allowNull is set to false?!?
        var C = this.getPrefix() ? this.getPrefix() : l;
        var z = this.getPostfix() ? this.getPostfix() : l;
        // Assemble the number
        var F = C + (B ? m : l) + E;
        if(D.length > 0){

          F += l + qx.locale.Number.getDecimalSeparator(this.__locale) + D;
        };
        F += z;
        return F;
      },
      /**
       * Parses a number.
       *
       * @param str {String} the string to parse.
       * @return {Double} the number.
       * @throws {Error} If the number string does not match the number format.
       */
      parse : function(J){

        // use the escaped separators for regexp
        var O = qx.lang.String.escapeRegexpChars(qx.locale.Number.getGroupSeparator(this.__locale) + l);
        var M = qx.lang.String.escapeRegexpChars(qx.locale.Number.getDecimalSeparator(this.__locale) + l);
        var K = new RegExp(i + qx.lang.String.escapeRegexpChars(this.getPrefix()) + v + b + O + c + e + M + s + qx.lang.String.escapeRegexpChars(this.getPostfix()) + t);
        var N = K.exec(J);
        if(N == null){

          throw new Error(h + J + g);
        };
        var P = (N[1] == m);
        var R = N[2];
        var Q = N[3];
        // Remove the thousand groupings
        R = R.replace(new RegExp(O, u), l);
        var L = (P ? m : l) + R;
        if(Q != null && Q.length != 0){

          // Remove the leading decimal separator from the fractions string
          Q = Q.replace(new RegExp(M), l);
          L += r + Q;
        };
        return parseFloat(L);
      }
    }
  });
})();
(function(){

  var d = "cldr_number_decimal_separator",c = "cldr_number_percent_format",b = "qx.locale.Number",a = "cldr_number_group_separator";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /*
  #cldr
  */
  /**
   * Provides information about locale-dependent number formatting (like the decimal
   * separator).
   */
  qx.Class.define(b, {
    statics : {
      /**
       * Get decimal separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} decimal separator.
       */
      getDecimalSeparator : function(e){

        return qx.locale.Manager.getInstance().localize(d, [], e);
      },
      /**
       * Get thousand grouping separator for number formatting
       *
       * @param locale {String} optional locale to be used
       * @return {String} group separator.
       */
      getGroupSeparator : function(f){

        return qx.locale.Manager.getInstance().localize(a, [], f);
      },
      /**
       * Get percent format string
       *
       * @param locale {String} optional locale to be used
       * @return {String} percent format string.
       */
      getPercentFormat : function(g){

        return qx.locale.Manager.getInstance().localize(c, [], g);
      }
    }
  });
})();
(function(){

  var cU = 'W',cT = "qqqq",cS = "h",cR = "KK",cQ = " is not supported",cP = "Z",cO = "Date string '",cN = "GGGGG",cM = ". Wildcard ",cL = "LL",bQ = "^",bP = '4th quarter',bO = "SSS",bN = "qqq",bM = '3rd quarter',bL = "K",bK = 'q',bJ = "Provided date is invalid",bI = "Error parsing date '",bH = 'G',dc = "a",dd = '2nd quarter',da = "dd",db = "qx.util.format.DateFormat",cX = 'weekDay',cY = "ee",cV = "q",cW = "QQQQ",de = "ww",df = "H",cu = 'Y+',ct = 'wide',cw = "(\\d\\d\\d?)",cv = "(GMT[\\+\\-]\\d\\d:\\d\\d)",cy = "_applyLocale",cx = "Q",cA = "c",cz = "weekOfMonth",cs = "GGG",cr = '-',o = "w",p = "mm",q = 'h',r = "S",s = 's',t = "QQQ",u = "G",v = "GG",w = "kk",x = "ss",du = "([\\+\\-]\\d\\d\\d\\d)",dt = 'H',ds = 'S',dr = '1st quarter',dy = 'Q1',dx = "QQ",dw = "HH",dv = 'k',dA = "m",dz = "DDD",bh = 'D',bi = "': the value for day or month is too large",bf = 'K',bg = "L",bl = "hh",bm = "e",bj = "W",bk = "GGGG",bd = 'Q2',be = "MM",P = "y+",O = 'narrow',R = "yyyy-MM-dd HH:mm:ss",Q = "' does not match the date format: ",L = "short",K = 'd',N = "unkown",M = "\\d?",J = "k",I = "qx.debug",br = 'm',bs = "z",bt = "String",bu = 'Q3',bn = 'month',bo = "DD",bp = 'isoUtcDateTime',bq = "SS",bv = "s",bw = "M",ba = 'w',Y = "$",X = "?",W = 'Q4',V = "qq",U = 'L',T = 'abbreviated',S = "Y+",bc = ":",bb = 'y',bx = "quoted_literal",by = "weekOfYear",bz = 'a',bA = "day",bB = "(-*",bC = "GMT",bD = "HH:mm:ss",bE = 'y+',bF = "HHmmss",bG = "long",bV = "Malformed date format: ",bU = 'Y',bT = 'z',bS = 'BC',ca = 'c',bY = "d",bX = "D",bW = 'e',cd = 'B',cc = '',cn = 'Before Christ',co = 'Z',cl = " ",cm = "min",cj = 'M',ck = "sec",ch = "\\d",ci = "+?",cp = 'E',cq = "locale",cE = "eeeee",cD = "EEEE",cG = 'Anno Domini',cF = "+",cI = "eee",cH = "ccc",cK = "EEEEE",cJ = "EE",cC = "MMMM",cB = 'Q',dm = "eeee",dn = "LLLLL",dp = "LLLL",dq = "ms",di = "(\\d\\d?\\d?)",dj = "cccc",dk = "dayOfYear",dl = 'AD',dg = "ccccc",dh = "E",n = "MMM",m = "EEE",h = "MMMMM",g = "LLL",f = "quarter",e = 'A',d = "default",c = "0",b = "literal",a = "wildcard",A = "'",B = "(\\d?)",y = "hour",z = "abbreviated",E = "wide",F = "(\\d\\d*?)",C = "narrow",D = "-",G = "stand-alone",H = "",ce = "format",cb = "(\\d\\d?)",cg = "(",cf = "|",bR = ")";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A formatter and parser for dates, see
   * http://www.unicode.org/reports/tr35/#Date_Format_Patterns
   *
   * Here is a quick overview of the format pattern keys:
   * <table>
   * <tr><th>Key &nbsp;<th>Description
   * <tr><td><code> G </code><td> era, e.g. "AD"
   * <tr><td><code> y </code><td> year
   * <tr><td><code> Y </code><td> week year
   * <tr><td><code> u </code><td> extended year [Not supported yet]
   * <tr><td><code> Q </code><td> quarter
   * <tr><td><code> q </code><td> stand-alone quarter
   * <tr><td><code> M </code><td> month
   * <tr><td><code> L </code><td> stand-alone month
   * <tr><td><code> I </code><td> chinese leap month [Not supported yet]
   * <tr><td><code> w </code><td> week of year
   * <tr><td><code> W </code><td> week of month
   * <tr><td><code> d </code><td> day of month
   * <tr><td><code> D </code><td> day of year
   * <tr><td><code> F </code><td> day of week in month [Not supported yet]
   * <tr><td><code> g </code><td> modified Julian day [Not supported yet]
   * <tr><td><code> E </code><td> day of week
   * <tr><td><code> e </code><td> local day of week
   * <tr><td><code> c </code><td> stand-alone local day of week
   * <tr><td><code> a </code><td> period of day (am or pm)
   * <tr><td><code> h </code><td> 12-hour hour
   * <tr><td><code> H </code><td> 24-hour hour
   * <tr><td><code> K </code><td> hour [0-11]
   * <tr><td><code> k </code><td> hour [1-24]
   * <tr><td><code> j </code><td> special symbol [Not supported yet]
   * <tr><td><code> m </code><td> minute
   * <tr><td><code> s </code><td> second
   * <tr><td><code> S </code><td> fractional second
   * <tr><td><code> A </code><td> millisecond in day [Not supported yet]
   * <tr><td><code> z </code><td> time zone, specific non-location format
   * <tr><td><code> Z </code><td> time zone, rfc822/gmt format
   * <tr><td><code> v </code><td> time zone, generic non-location format [Not supported yet]
   * <tr><td><code> V </code><td> time zone, like z except metazone abbreviations [Not supported yet]
   * </table>
   *
   * (This list is preliminary, not all format keys might be implemented). Most
   * keys support repetitions that influence the meaning of the format. Parts of the
   * format string that should not be interpreted as format keys have to be
   * single-quoted.
   *
   * The same format patterns will be used for both parsing and output formatting.
   */
  qx.Class.define(db, {
    extend : qx.core.Object,
    implement : qx.util.format.IFormat,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param format {String|null} The format to use. If null, the locale's default
     * format is used.
     * @param locale {String?} optional locale to be used. In case this is not present, the {@link #locale} property of DateFormat
     * will be following the {@link qx.locale.Manager#locale} property of qx.locale.Manager
     */
    construct : function(dB, dC){

      qx.core.Object.call(this);
      if(!dC){

        this.__locale = qx.locale.Manager.getInstance().getLocale();
        this.__bindingId = qx.locale.Manager.getInstance().bind(cq, this, cq);
      } else {

        this.__locale = dC;
        this.setLocale(dC);
      };
      this.__initialLocale = this.__locale;
      if(dB != null){

        this.__format = dB.toString();
        if(this.__format in qx.util.format.DateFormat.ISO_MASKS){

          if(this.__format === bp){

            this.__UTC = true;
          };
          this.__format = qx.util.format.DateFormat.ISO_MASKS[this.__format];
        };
      } else {

        this.__format = qx.locale.Date.getDateFormat(bG, this.__locale) + cl + qx.locale.Date.getDateTimeFormat(bF, bD, this.__locale);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The locale used in this DateFormat instance*/
      locale : {
        apply : cy,
        nullable : true,
        check : bt
      }
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * Returns a <code>DateFomat</code> instance that uses the
       * format.
       *
       * @return {String} the date/time instance.
       */
      getDateTimeInstance : function(){

        var dE = qx.util.format.DateFormat;
        var dD = qx.locale.Date.getDateFormat(bG) + cl + qx.locale.Date.getDateTimeFormat(bF, bD);
        if(dE._dateInstance == null || dE._dateInstance.__format != dD){

          dE._dateTimeInstance = new dE();
        };
        return dE._dateTimeInstance;
      },
      /**
       * Returns a <code>DateFomat</code> instance that uses the format.
       *
       * @return {String} the date instance.
       */
      getDateInstance : function(){

        var dG = qx.util.format.DateFormat;
        var dF = qx.locale.Date.getDateFormat(L) + H;
        if(dG._dateInstance == null || dG._dateInstance.__format != dF){

          dG._dateInstance = new dG(dF);
        };
        return dG._dateInstance;
      },
      /**
       * {Integer} The threshold until when a year should be assumed to belong to the
       * 21st century (e.g. 12 -> 2012). Years over this threshold but below 100 will be
       * assumed to belong to the 20th century (e.g. 88 -> 1988). Years over 100 will be
       * used unchanged (e.g. 1792 -> 1792).
       */
      ASSUME_YEAR_2000_THRESHOLD : 30,
      /** {String} The date format used for logging. */
      LOGGING_DATE_TIME__format : R,
      /** Special masks of patterns that are used frequently*/
      ISO_MASKS : {
        isoDate : "yyyy-MM-dd",
        isoTime : "HH:mm:ss",
        isoDateTime : "yyyy-MM-dd'T'HH:mm:ss",
        isoUtcDateTime : "yyyy-MM-dd'T'HH:mm:ss'Z'"
      },
      /** {String} The am marker. */
      AM_MARKER : "am",
      /** {String} The pm marker. */
      PM_MARKER : "pm"
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __bindingId : null,
      __locale : null,
      __initialLocale : null,
      __format : null,
      __parseFeed : null,
      __parseRules : null,
      __formatTree : null,
      __UTC : null,
      /**
       * Fills a number with leading zeros ("25" -> "0025").
       *
       * @param number {Integer} the number to fill.
       * @param minSize {Integer} the minimum size the returned string should have.
       * @return {String} the filled number as string.
       */
      __fillNumber : function(dH, dI){

        var dJ = H + (dH < 0 ? ((-1) * dH) : dH);
        while(dJ.length < dI){

          dJ = c + dJ;
        };
        return dH < 0 ? D + dJ : dJ;
      },
      /**
       * Returns the day in year of a date.
       *
       * @param date {Date} the date.
       * @return {Integer} the day in year.
       */
      __getDayInYear : function(dK){

        var dL = new Date(dK.getTime());
        var dM = dL.getDate();
        while(dL.getMonth() != 0){

          // Set the date to the last day of the previous month
          dL.setDate(-1);
          dM += dL.getDate() + 1;
        };
        return dM;
      },
      /**
       * Returns the thursday in the same week as the date.
       *
       * @param date {Date} the date to get the thursday of.
       * @return {Date} the thursday in the same week as the date.
       */
      __thursdayOfSameWeek : function(dN){

        return new Date(dN.getTime() + (3 - ((dN.getDay() + 6) % 7)) * 86400000);
      },
      /**
       * Returns the week in year of a date.
       *
       * @param date {Date} the date to get the week in year of.
       * @return {Integer} the week in year.
       */
      __getWeekInYear : function(dO){

        // This algorithm gets the correct calendar week after ISO 8601.
        // This standard is used in almost all european countries.
        // TODO: In the US week in year is calculated different!
        // See http://www.merlyn.demon.co.uk/weekinfo.htm
        // The following algorithm comes from http://www.salesianer.de/util/kalwoch.html
        // Get the thursday of the week the date belongs to
        var dQ = this.__thursdayOfSameWeek(dO);
        // Get the year the thursday (and therefore the week) belongs to
        var dR = dQ.getFullYear();
        // Get the thursday of the week january 4th belongs to
        // (which defines week 1 of a year)
        var dP = this.__thursdayOfSameWeek(new Date(dR, 0, 4));
        // Calculate the calendar week
        return Math.floor(1.5 + (dQ.getTime() - dP.getTime()) / 86400000 / 7);
      },
      /**
       * Returns the week in month of a date.
       *
       * @param date {Date} the date to get the week in year of.
       * @return {Integer} the week in month.
       */
      __getWeekInMonth : function(dS){

        var dU = this.__thursdayOfSameWeek(dS);
        var dT = this.__thursdayOfSameWeek(new Date(dS.getFullYear(), dS.getMonth(), 4));
        return Math.floor(1.5 + (dU.getTime() - dT.getTime()) / 86400000 / 7);
      },
      /**
       * Returns the week year of a date. (that is the year of the week where this date happens to be)
       * For a week in the middle of the summer, the year is easily obtained, but for a week
       * when New Year's Eve takes place, the year of that week is ambigous.
       * The thursday day of that week is used to determine the year.
       *
       * @param date {Date} the date to get the week in year of.
       * @return {Integer} the week year.
       */
      __getWeekYear : function(dV){

        var dW = this.__thursdayOfSameWeek(dV);
        return dW.getFullYear();
      },
      /**
       * Returns true if the year is a leap one.
       *
       * @param year {Integer} the year to check.
       * @return {Boolean} true if it is a leap year.
       */
      __isLeapYear : function(dX){

        var dY = new Date(dX, 2, 1);
        dY.setDate(-1);
        return dY.getDate() + 1 === 29;
      },
      /**
       * Returns a json object with month and day as keys.
       *
       * @param dayOfYear {Integer} the day of year.
       * @param year {Integer} the year to check.
       * @return {Object} a json object {month: M, day: D}.
       */
      __getMonthAndDayFromDayOfYear : function(ea, eb){

        var ef = 0;
        var eg = 0;
        // if we don't know the year, we take a non-leap year'
        if(!eb){

          eb = 1971;
        };
        var ec = 0;
        for(var i = 1;i <= 12;i++){

          var ee = new Date(eb, i, 1);
          ee.setDate(-1);
          var ed = ee.getDate() + 1;
          ec += ed;
          if(ec < ea){

            ef++;
            eg += ed;
          } else {

            eg = ea - (ec - ed);
            break;
          };
        };
        return {
          month : ef,
          day : eg
        };
      },
      /**
       * Returns the year of a date when we know the week year
       *
       * @param weekYear {Integer} the week year.
       * @param month {Integer} the month
       * @param dayOfMonth {Integer} the day in month
       * @return {Integer} the year.
       */
      __getYearFromWeekYearAndMonth : function(eh, ei, ej){

        var ek;
        switch(ei){case 11:
        ek = eh - 1;
        if(eh != this.__getWeekYear(new Date(ek, ei, ej))){

          ek = eh;
        };
        break;case 0:
        ek = eh + 1;
        if(eh != this.__getWeekYear(new Date(ek, ei, ej))){

          ek = eh;
        };
        break;default:
        ek = eh;};
        return ek;
      },
      /**
       * Applies the new value for locale property
       * @param value {String} The new value.
       * @param old {String} The old value.
       *
       */
      _applyLocale : function(el, em){

        this.__locale = el === null ? this.setLocale(this.__initialLocale) : el;
      },
      /**
       * Formats a date.
       *
       * @param date {Date} The date to format.
       * @return {String} the formatted date.
       */
      format : function(en){

        // check for null dates
        if(en == null){

          return null;
        };
        if(isNaN(en.getTime())){

          if(qx.core.Environment.get(I)){

            qx.log.Logger.error(bJ);
          };
          return null;
        };
        if(this.__UTC){

          en = new Date(en.getUTCFullYear(), en.getUTCMonth(), en.getUTCDate(), en.getUTCHours(), en.getUTCMinutes(), en.getUTCSeconds(), en.getUTCMilliseconds());
        };
        var eq = this.__locale;
        var ev = en.getFullYear();
        var er = en.getMonth();
        var eu = en.getDate();
        var ey = en.getDay();
        var eB = en.getHours();
        var eH = en.getMinutes();
        var ez = en.getSeconds();
        var eF = en.getMilliseconds();
        var ex = en.getTimezoneOffset();
        var eC = ex > 0 ? 1 : -1;
        var eo = Math.floor(Math.abs(ex) / 60);
        var eE = Math.abs(ex) % 60;
        // Create the output
        this.__initFormatTree();
        var eG = H;
        for(var i = 0;i < this.__formatTree.length;i++){

          var ew = this.__formatTree[i];
          if(ew.type == b){

            eG += ew.text;
          } else {

            // This is a wildcard
            var ep = ew.character;
            var eA = ew.size;
            // Get its replacement
            var eI = X;
            switch(ep){// TODO: F - Day of week in month (e.g.   2). Problem: What is this?
            case bb:
            // Year
            if(eA == 2){

              eI = this.__fillNumber(ev % 100, 2);
            } else {

              var es = Math.abs(ev);
              eI = es + H;
              if(eA > eI.length){

                for(var j = eI.length;j < eA;j++){

                  eI = c + eI;
                };
              };
              if(ev < 0){

                eI = D + eI;
              };
            };
            break;case bU:
            // Year
            eI = this.__getWeekYear(en) + H;
            var es = eI.replace(cr, cc);
            if(eA > eI.length){

              for(var j = es.length;j < eA;j++){

                es = c + es;
              };
            };
            eI = eI.indexOf(D) != -1 ? D + es : es;
            break;case bH:
            // Era - there is no CLDR data for ERA yet
            if(eA >= 1 && eA <= 3){

              eI = ev > 0 ? dl : bS;
            } else if(eA == 4){

              eI = ev > 0 ? cG : cn;
            } else if(eA == 5){

              eI = ev > 0 ? e : cd;
            };;
            break;case cB:
            // quarter
            if(eA == 1 || eA == 2){

              eI = this.__fillNumber(parseInt(er / 4) + 1, eA);
            };
            if(eA == 3){

              eI = cB + (parseInt(er / 4) + 1);
            };
            break;case bK:
            // quarter stand alone
            if(eA == 1 || eA == 2){

              eI = this.__fillNumber(parseInt(er / 4) + 1, eA);
            };
            if(eA == 3){

              eI = cB + (parseInt(er / 4) + 1);
            };
            break;case bh:
            // Day in year (e.g. 189)
            eI = this.__fillNumber(this.__getDayInYear(en), eA);
            break;case K:
            // Day in month
            eI = this.__fillNumber(eu, eA);
            break;case ba:
            // Week in year (e.g. 27)
            eI = this.__fillNumber(this.__getWeekInYear(en), eA);
            break;case cU:
            // Week in year (e.g. 27)
            eI = this.__getWeekInMonth(en);
            break;case cp:
            // Day in week
            if(eA >= 1 && eA <= 3){

              eI = qx.locale.Date.getDayName(z, ey, eq, ce, true);
            } else if(eA == 4){

              eI = qx.locale.Date.getDayName(E, ey, eq, ce, true);
            } else if(eA == 5){

              eI = qx.locale.Date.getDayName(C, ey, eq, ce, true);
            };;
            break;case bW:
            // Day in week
            var et = qx.locale.Date.getWeekStart(eq);
            // the index is 1 based
            var eD = 1 + ((ey - et >= 0) ? (ey - et) : 7 + (ey - et));
            if(eA >= 1 && eA <= 2){

              eI = this.__fillNumber(eD, eA);
            } else if(eA == 3){

              eI = qx.locale.Date.getDayName(z, ey, eq, ce, true);
            } else if(eA == 4){

              eI = qx.locale.Date.getDayName(E, ey, eq, ce, true);
            } else if(eA == 5){

              eI = qx.locale.Date.getDayName(C, ey, eq, ce, true);
            };;;
            break;case ca:
            // Stand-alone local day in week
            var et = qx.locale.Date.getWeekStart(eq);
            // the index is 1 based
            var eD = 1 + ((ey - et >= 0) ? (ey - et) : 7 + (ey - et));
            if(eA == 1){

              eI = cc + eD;
            } else if(eA == 3){

              eI = qx.locale.Date.getDayName(z, ey, eq, G, true);
            } else if(eA == 4){

              eI = qx.locale.Date.getDayName(E, ey, eq, G, true);
            } else if(eA == 5){

              eI = qx.locale.Date.getDayName(C, ey, eq, G, true);
            };;;
            break;case cj:
            // Month
            if(eA == 1 || eA == 2){

              eI = this.__fillNumber(er + 1, eA);
            } else if(eA == 3){

              eI = qx.locale.Date.getMonthName(z, er, eq, ce, true);
            } else if(eA == 4){

              eI = qx.locale.Date.getMonthName(E, er, eq, ce, true);
            } else if(eA == 5){

              eI = qx.locale.Date.getMonthName(C, er, eq, ce, true);
            };;;
            break;case U:
            // Stand-alone month
            if(eA == 1 || eA == 2){

              eI = this.__fillNumber(er + 1, eA);
            } else if(eA == 3){

              eI = qx.locale.Date.getMonthName(z, er, eq, G, true);
            } else if(eA == 4){

              eI = qx.locale.Date.getMonthName(E, er, eq, G, true);
            } else if(eA == 5){

              eI = qx.locale.Date.getMonthName(C, er, eq, G, true);
            };;;
            break;case bz:
            // am/pm marker
            // NOTE: 0:00 is am, 12:00 is pm
            eI = (eB < 12) ? qx.locale.Date.getAmMarker(eq) : qx.locale.Date.getPmMarker(eq);
            break;case dt:
            // Hour in day (0-23)
            eI = this.__fillNumber(eB, eA);
            break;case dv:
            // Hour in day (1-24)
            eI = this.__fillNumber((eB == 0) ? 24 : eB, eA);
            break;case bf:
            // Hour in am/pm (0-11)
            eI = this.__fillNumber(eB % 12, eA);
            break;case q:
            // Hour in am/pm (1-12)
            eI = this.__fillNumber(((eB % 12) == 0) ? 12 : (eB % 12), eA);
            break;case br:
            // Minute in hour
            eI = this.__fillNumber(eH, eA);
            break;case s:
            // Second in minute
            eI = this.__fillNumber(ez, eA);
            break;case ds:
            // Fractional second
            eI = this.__fillNumber(eF, 3);
            if(eA < eI.length){

              eI = eI.substr(0, eA);
            } else {

              while(eA > eI.length){

                // if needed, fill the remaining wildcard length with trailing zeros
                eI += c;
              };
            };
            break;case bT:
            // Time zone
            if(eA >= 1 && eA <= 4){

              eI = bC + ((eC > 0) ? D : cF) + this.__fillNumber(Math.abs(eo), 2) + bc + this.__fillNumber(eE, 2);
            };
            break;case co:
            // RFC 822 time zone
            if(eA >= 1 && eA <= 3){

              eI = ((eC > 0) ? D : cF) + this.__fillNumber(Math.abs(eo), 2) + this.__fillNumber(eE, 2);
            } else {

              eI = bC + ((eC > 0) ? D : cF) + this.__fillNumber(Math.abs(eo), 2) + bc + this.__fillNumber(eE, 2);
            };
            break;};
            eG += eI;
          };
        };
        return eG;
      },
      /**
       * Parses a date.
       *
       * @param dateStr {String} the date to parse.
       * @return {Date} the parsed date.
       * @throws {Error} If the format is not well formed or if the date string does not
       *       match to the format.
       */
      parse : function(eJ){

        this.__initParseFeed();
        // Apply the regex
        var eS = this.__parseFeed.regex.exec(eJ);
        if(eS == null){

          throw new Error(cO + eJ + Q + this.__format);
        };
        // Apply the rules
        var eK = {
          era : 1,
          year : 1970,
          quarter : 1,
          month : 0,
          day : 1,
          dayOfYear : 1,
          hour : 0,
          ispm : false,
          weekDay : 4,
          weekYear : 1970,
          weekOfMonth : 1,
          weekOfYear : 1,
          min : 0,
          sec : 0,
          ms : 0
        };
        var eM = 1;
        var eL = false;
        var eN = false;
        for(var i = 0;i < this.__parseFeed.usedRules.length;i++){

          var eO = this.__parseFeed.usedRules[i];
          var eP = eS[eM];
          if(eO.field != null){

            eK[eO.field] = parseInt(eP, 10);
          } else {

            eO.manipulator(eK, eP, eO.pattern);
          };
          if(eO.pattern == S){

            var eQ = false;
            for(var k = 0;k < this.__parseFeed.usedRules.length;k++){

              if(this.__parseFeed.usedRules[k].pattern == bE){

                eQ = true;
                break;
              };
            };
            if(!eQ){

              eL = true;
            };
          };
          if(eO.pattern.indexOf(bX) != -1){

            var eU = false;
            for(var k = 0;k < this.__parseFeed.usedRules.length;k++){

              if(this.__parseFeed.usedRules[k].pattern.indexOf(bY) != -1){

                eU = true;
                break;
              };
            };
            if(!eU){

              eN = true;
            };
          };
          eM += (eO.groups == null) ? 1 : eO.groups;
        };
        if(eL){

          eK.year = this.__getYearFromWeekYearAndMonth(eK.weekYear, eK.month, eK.day);
        };
        if(eN){

          var eT = this.__getMonthAndDayFromDayOfYear(eK.dayOfYear, eK.year);
          eK.month = eT.month;
          eK.day = eT.day;
        };
        if(eK.era < 0 && (eK.year * eK.era < 0)){

          eK.year = eK.year * eK.era;
        };
        var eR = new Date(eK.year, eK.month, eK.day, (eK.ispm) ? (eK.hour + 12) : eK.hour, eK.min, eK.sec, eK.ms);
        if(this.__UTC){

          eR = new Date(eR.getUTCFullYear(), eR.getUTCMonth(), eR.getUTCDate(), eR.getUTCHours(), eR.getUTCMinutes(), eR.getUTCSeconds(), eR.getUTCMilliseconds());
        };
        if(eK.month != eR.getMonth() || eK.year != eR.getFullYear()){

          // TODO: check if this is also necessary for the time components
          throw new Error(bI + eJ + bi);
        };
        return eR;
      },
      /**
       * Helper method for {@link #format()} and {@link #parse()}.
       * Parses the date format.
       *
       * @return {void}
       */
      __initFormatTree : function(){

        if(this.__formatTree != null){

          return;
        };
        this.__formatTree = [];
        var fa;
        var eX = 0;
        var fc = H;
        var eV = this.__format;
        var eY = d;
        var i = 0;
        while(i < eV.length){

          var fb = eV.charAt(i);
          switch(eY){case bx:
          // We are now inside a quoted literal
          // Check whether the current character is an escaped "'" character
          if(fb == A){

            if(i + 1 >= eV.length){

              // this is the last character
              i++;
              break;
            };
            var eW = eV.charAt(i + 1);
            if(eW == A){

              fc += fb;
              i++;
            } else {

              // quoted literal ends
              i++;
              eY = N;
            };
          } else {

            fc += fb;
            i++;
          };
          break;case a:
          // Check whether the currChar belongs to that wildcard
          if(fb == fa){

            // It does -> Raise the size
            eX++;
            i++;
          } else {

            // It does not -> The current wildcard is done
            this.__formatTree.push({
              type : a,
              character : fa,
              size : eX
            });
            fa = null;
            eX = 0;
            eY = d;
          };
          break;default:
          // We are not (any more) in a wildcard or quoted literal -> Check what's starting here
          if((fb >= bz && fb <= bT) || (fb >= e && fb <= co)){

            // This is a letter -> All letters are wildcards
            // Start a new wildcard
            fa = fb;
            eY = a;
          } else if(fb == A){

            if(i + 1 >= eV.length){

              // this is the last character
              fc += fb;
              i++;
              break;
            };
            var eW = eV.charAt(i + 1);
            if(eW == A){

              fc += fb;
              i++;
            };
            i++;
            eY = bx;
          } else {

            eY = d;
          };
          if(eY != d){

            // Add the literal
            if(fc.length > 0){

              this.__formatTree.push({
                type : b,
                text : fc
              });
              fc = H;
            };
          } else {

            // This is an unquoted literal -> Add it to the current literal
            fc += fb;
            i++;
          };
          break;};
        };
        // Add the last wildcard or literal
        if(fa != null){

          this.__formatTree.push({
            type : a,
            character : fa,
            size : eX
          });
        } else if(fc.length > 0){

          this.__formatTree.push({
            type : b,
            text : fc
          });
        };
      },
      /**
       * Initializes the parse feed.
       *
       * The parse contains everything needed for parsing: The regular expression
       * (in compiled and uncompiled form) and the used rules.
       *
       * @return {Map} the parse feed.
       * @throws {Error} If the date format is malformed.
       */
      __initParseFeed : function(){

        if(this.__parseFeed != null){

          // We already have the parse feed
          return;
        };
        var fg = this.__format;
        // Initialize the rules
        this.__initParseRules();
        this.__initFormatTree();
        // Get the used rules and construct the regex pattern
        var fm = [];
        var fi = bQ;
        for(var fe = 0;fe < this.__formatTree.length;fe++){

          var fn = this.__formatTree[fe];
          if(fn.type == b){

            fi += qx.lang.String.escapeRegexpChars(fn.text);
          } else {

            // This is a wildcard
            var ff = fn.character;
            var fj = fn.size;
            // Get the rule for this wildcard
            var fh;
            for(var fo = 0;fo < this.__parseRules.length;fo++){

              var fk = this.__parseRules[fo];
              if(this.__isRuleForWildcard(fk, ff, fj)){

                // We found the right rule for the wildcard
                fh = fk;
                break;
              };
            };
            // Check the rule
            if(fh == null){

              // We have no rule for that wildcard -> Malformed date format
              var fl = H;
              for(var i = 0;i < fj;i++){

                fl += ff;
              };
              throw new Error(bV + fg + cM + fl + cQ);
            } else {

              // Add the rule to the pattern
              fm.push(fh);
              fi += fh.regex;
            };
          };
        };
        fi += Y;
        // Create the regex
        var fd;
        try{

          fd = new RegExp(fi);
        } catch(fp) {

          throw new Error(bV + fg);
        };
        // Create the this.__parseFeed
        this.__parseFeed = {
          regex : fd,
          "usedRules" : fm,
          pattern : fi
        };
      },
      /**
       * Checks wether the rule matches the wildcard or not.
       * @param rule {Object} the rule we try to match with the wildcard
       * @param wildcardChar {String} the character in the wildcard
       * @param wildcardSize {Integer} the number of  wildcardChar characters in the wildcard
       * @return {Boolean} if the rule matches or not
       */
      __isRuleForWildcard : function(fq, fr, fs){

        if(fr === bb && fq.pattern === bE){

          fq.regex = fq.regexFunc(fs);
          return true;
        } else if(fr === bU && fq.pattern === cu){

          fq.regex = fq.regexFunc(fs);
          return true;
        } else {

          return fr == fq.pattern.charAt(0) && fs == fq.pattern.length;
        };
      },
      /**
       * Initializes the static parse rules.
       *
       * @return {void}
       */
      __initParseRules : function(){

        var fG = qx.util.format.DateFormat;
        var fI = qx.lang.String;
        if(this.__parseRules != null){

          // The parse rules are already initialized
          return;
        };
        var fH = this.__parseRules = [];
        var fC = qx.locale.Date.getAmMarker(this.__locale).toString() || fG.AM_MARKER;
        var fP = qx.locale.Date.getPmMarker(this.__locale).toString() || fG.PM_MARKER;
        var fu = this.__locale;
        var fz = function(fT, fU){

          fU = parseInt(fU, 10);
          if(fU > 0){

            if(fU < fG.ASSUME_YEAR_2000_THRESHOLD){

              fU += 2000;
            } else if(fU < 100){

              fU += 1900;
            };
          };
          fT.year = fU;
        };
        var fR = function(fV, fW){

          fW = parseInt(fW, 10);
          if(fW > 0){

            if(fW < fG.ASSUME_YEAR_2000_THRESHOLD){

              fW += 2000;
            } else if(fW < 100){

              fW += 1900;
            };
          };
          fV.weekYear = fW;
        };
        var fS = function(fX, fY){

          fX.month = parseInt(fY, 10) - 1;
        };
        var fx = function(ga, gb){

          var gd = qx.locale.Date.getWeekStart(fu);
          var gc = (parseInt(gb, 10) - 1 + gd) <= 6 ? parseInt(gb, 10) - 1 + gd : (parseInt(gb, 10) - 1 + gd) - 7;
          ga.weekDay = gc;
        };
        var fw = function(ge, gf){

          var gg = qx.locale.Date.getPmMarker(fu).toString() || fG.PM_MARKER;
          ge.ispm = (gf == gg);
        };
        var fB = function(gh, gi){

          gh.hour = parseInt(gi, 10) % 24;
        };
        var fv = function(gj, gk){

          gj.hour = parseInt(gk, 10) % 12;
        };
        var fK = function(gl, gm){

          return;
        };
        var fL = [e, cd];
        var fM = function(gn, go){

          gn.era = go == e ? 1 : -1;
        };
        var fF = [dl, bS];
        var fE = function(gp, gq){

          gp.era = gq == dl ? 1 : -1;
        };
        var fO = [cG, cn];
        var fD = function(gr, gs){

          gr.era = gs == cG ? 1 : -1;
        };
        var fQ = [dy, bd, bu, W];
        var ft = function(gt, gu){

          gt.quarter = fQ.indexOf(gu);
        };
        var fN = [dr, dd, bM, bP];
        var fJ = function(gv, gw){

          gv.quarter = fN.indexOf(gw);
        };
        var fA = {
        };
        var fy = function(gx){

          var gC = [U, cj];
          var gy = [ca, bW, cp];
          var gF = gx.charAt(0);
          var gA = gC.indexOf(gF) >= 0;
          var gB = function(){

            var gH = gA ? gC : gy;
            var gI = gF === gH[0] ? G : ce;
            var gJ = gx.length;
            var gG = T;
            switch(gJ){case 4:
            gG = ct;
            break;case 5:
            gG = O;
            break;default:
            gG = T;};
            return [gI, gG];
          };
          if(!fA[gx]){

            fA[gx] = {
            };
            var gE = gB();
            var gz = gA ? qx.locale.Date.getMonthNames : qx.locale.Date.getDayNames;
            var gD = gz.call(qx.locale.Date, gE[1], fu, gE[0], true);
            for(var i = 0,l = gD.length;i < l;i++){

              gD[i] = fI.escapeRegexpChars(gD[i].toString());
            };
            fA[gx].data = gD;
            fA[gx].func = function(gK, gL){

              gL = fI.escapeRegexpChars(gL);
              gK[gA ? bn : cX] = gD.indexOf(gL);
            };
          };
          return fA[gx];
        };
        // Unsupported: F (Day of week in month)
        fH.push({
          pattern : P,
          regexFunc : function(gM){

            var gN = bB;
            for(var i = 0;i < gM;i++){

              gN += ch;
              if(i === gM - 1 && i !== 1){

                gN += ci;
              };
            };
            gN += bR;
            return gN;
          },
          manipulator : fz
        });
        fH.push({
          pattern : S,
          regexFunc : function(gO){

            var gP = bB;
            for(var i = 0;i < gO;i++){

              gP += ch;
              if(i === gO - 1){

                gP += ci;
              };
            };
            gP += bR;
            return gP;
          },
          manipulator : fR
        });
        fH.push({
          pattern : u,
          regex : cg + fF.join(cf) + bR,
          manipulator : fE
        });
        fH.push({
          pattern : v,
          regex : cg + fF.join(cf) + bR,
          manipulator : fE
        });
        fH.push({
          pattern : cs,
          regex : cg + fF.join(cf) + bR,
          manipulator : fE
        });
        fH.push({
          pattern : bk,
          regex : cg + fO.join(cf) + bR,
          manipulator : fD
        });
        fH.push({
          pattern : cN,
          regex : cg + fL.join(cf) + bR,
          manipulator : fM
        });
        fH.push({
          pattern : cx,
          regex : F,
          field : f
        });
        fH.push({
          pattern : dx,
          regex : cb,
          field : f
        });
        fH.push({
          pattern : t,
          regex : cg + fQ.join(cf) + bR,
          manipulator : ft
        });
        fH.push({
          pattern : cW,
          regex : cg + fN.join(cf) + bR,
          manipulator : fJ
        });
        fH.push({
          pattern : cV,
          regex : F,
          field : f
        });
        fH.push({
          pattern : V,
          regex : cb,
          field : f
        });
        fH.push({
          pattern : bN,
          regex : cg + fQ.join(cf) + bR,
          manipulator : ft
        });
        fH.push({
          pattern : cT,
          regex : cg + fN.join(cf) + bR,
          manipulator : fJ
        });
        fH.push({
          pattern : bw,
          regex : F,
          manipulator : fS
        });
        fH.push({
          pattern : be,
          regex : cb,
          manipulator : fS
        });
        fH.push({
          pattern : n,
          regex : cg + fy(n).data.join(cf) + bR,
          manipulator : fy(n).func
        });
        fH.push({
          pattern : cC,
          regex : cg + fy(cC).data.join(cf) + bR,
          manipulator : fy(cC).func
        });
        fH.push({
          pattern : h,
          regex : cg + fy(h).data.join(cf) + bR,
          manipulator : fy(h).func
        });
        fH.push({
          pattern : bg,
          regex : F,
          manipulator : fS
        });
        fH.push({
          pattern : cL,
          regex : cb,
          manipulator : fS
        });
        fH.push({
          pattern : g,
          regex : cg + fy(g).data.join(cf) + bR,
          manipulator : fy(g).func
        });
        fH.push({
          pattern : dp,
          regex : cg + fy(dp).data.join(cf) + bR,
          manipulator : fy(dp).func
        });
        fH.push({
          pattern : dn,
          regex : cg + fy(dn).data.join(cf) + bR,
          manipulator : fy(dn).func
        });
        fH.push({
          pattern : da,
          regex : cb,
          field : bA
        });
        fH.push({
          pattern : bY,
          regex : F,
          field : bA
        });
        fH.push({
          pattern : bX,
          regex : B,
          field : dk
        });
        fH.push({
          pattern : bo,
          regex : cb,
          field : dk
        });
        fH.push({
          pattern : dz,
          regex : cw,
          field : dk
        });
        fH.push({
          pattern : dh,
          regex : cg + fy(dh).data.join(cf) + bR,
          manipulator : fy(dh).func
        });
        fH.push({
          pattern : cJ,
          regex : cg + fy(cJ).data.join(cf) + bR,
          manipulator : fy(cJ).func
        });
        fH.push({
          pattern : m,
          regex : cg + fy(m).data.join(cf) + bR,
          manipulator : fy(m).func
        });
        fH.push({
          pattern : cD,
          regex : cg + fy(cD).data.join(cf) + bR,
          manipulator : fy(cD).func
        });
        fH.push({
          pattern : cK,
          regex : cg + fy(cK).data.join(cf) + bR,
          manipulator : fy(cK).func
        });
        fH.push({
          pattern : bm,
          regex : B,
          manipulator : fx
        });
        fH.push({
          pattern : cY,
          regex : cb,
          manipulator : fx
        });
        fH.push({
          pattern : cI,
          regex : cg + fy(cI).data.join(cf) + bR,
          manipulator : fy(cI).func
        });
        fH.push({
          pattern : dm,
          regex : cg + fy(dm).data.join(cf) + bR,
          manipulator : fy(dm).func
        });
        fH.push({
          pattern : cE,
          regex : cg + fy(cE).data.join(cf) + bR,
          manipulator : fy(cE).func
        });
        fH.push({
          pattern : cA,
          regex : M,
          manipulator : fx
        });
        fH.push({
          pattern : cH,
          regex : cg + fy(cH).data.join(cf) + bR,
          manipulator : fy(cH).func
        });
        fH.push({
          pattern : dj,
          regex : cg + fy(dj).data.join(cf) + bR,
          manipulator : fy(dj).func
        });
        fH.push({
          pattern : dg,
          regex : cg + fy(dg).data.join(cf) + bR,
          manipulator : fy(dg).func
        });
        fH.push({
          pattern : dc,
          regex : cg + fC + cf + fP + bR,
          manipulator : fw
        });
        fH.push({
          pattern : bj,
          regex : B,
          field : cz
        });
        fH.push({
          pattern : o,
          regex : B,
          field : by
        });
        fH.push({
          pattern : de,
          regex : cb,
          field : by
        });
        fH.push({
          pattern : dw,
          regex : cb,
          field : y
        });
        fH.push({
          pattern : df,
          regex : cb,
          field : y
        });
        fH.push({
          pattern : w,
          regex : cb,
          manipulator : fB
        });
        fH.push({
          pattern : J,
          regex : cb,
          manipulator : fB
        });
        fH.push({
          pattern : cR,
          regex : cb,
          field : y
        });
        fH.push({
          pattern : bL,
          regex : cb,
          field : y
        });
        fH.push({
          pattern : bl,
          regex : cb,
          manipulator : fv
        });
        fH.push({
          pattern : cS,
          regex : cb,
          manipulator : fv
        });
        fH.push({
          pattern : p,
          regex : cb,
          field : cm
        });
        fH.push({
          pattern : dA,
          regex : cb,
          field : cm
        });
        fH.push({
          pattern : x,
          regex : cb,
          field : ck
        });
        fH.push({
          pattern : bv,
          regex : cb,
          field : ck
        });
        fH.push({
          pattern : bO,
          regex : di,
          field : dq
        });
        fH.push({
          pattern : bq,
          regex : di,
          field : dq
        });
        fH.push({
          pattern : r,
          regex : di,
          field : dq
        });
        fH.push({
          pattern : cP,
          regex : du,
          manipulator : fK
        });
        fH.push({
          pattern : bs,
          regex : cv,
          manipulator : fK
        });
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__bindingId != null){

        qx.locale.Manager.getInstance().removeBinding(this.__bindingId);
      };
      this.__formatTree = this.__parseFeed = this.__parseRules = null;
    }
  });
})();
(function(){

  var k = "HH:mm",j = "HHmmsszz",h = "cldr_date_format_",g = "HHmm",f = "HHmmss",e = "This case should never happen.",d = "cldr_time_format_",c = "HH:mm:ss zz",b = "cldr_pm",a = "cldr_am",K = "qx.locale.Date",J = "cldr_date_time_format_",I = "HH:mm:ss",H = "sat",G = "cldr_day_",F = "cldr_month_",E = "wed",D = "fri",C = "tue",B = "mon",r = "sun",s = "thu",p = "short",q = "full",n = "long",o = "medium",l = '_',m = "stand-alone",t = "narrow",u = "abbreviated",w = "wide",v = 'stand-alone',y = "qx.debug",x = 'format',A = "format",z = "_";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /*
  #cldr
  */
  /**
   * Static class that provides localized date information (like names of week
   * days, AM/PM markers, start of week, etc.).
   */
  qx.Class.define(K, {
    statics : {
      /**
       * Reference to the locale manager.
       *
       * @internal
       */
      __mgr : qx.locale.Manager.getInstance(),
      /**
       * Get AM marker for time definitions
       *
       * @param locale {String} optional locale to be used
       * @return {String} translated AM marker.
       */
      getAmMarker : function(L){

        return this.__mgr.localize(a, [], L);
      },
      /**
       * Get PM marker for time definitions
       *
       * @param locale {String} optional locale to be used
       * @return {String} translated PM marker.
       */
      getPmMarker : function(M){

        return this.__mgr.localize(b, [], M);
      },
      /**
       * Return localized names of day names
       *
       * @param length {String} format of the day names.
       *       Possible values: "abbreviated", "narrow", "wide"
       * @param locale {String} optional locale to be used
       * @param context {String} (default: "format") intended context.
       *       Possible values: "format", "stand-alone"
       * @param withFallback {Boolean?} if true, the previous parameter's other value is tried
       * in order to find a localized name for the day
       * @return {String[]} array of localized day names starting with sunday.
       */
      getDayNames : function(length, N, O, P){

        var O = O ? O : A;
        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(length, [u, t, w]);
          qx.core.Assert.assertInArray(O, [A, m]);
        };
        var R = [r, B, C, E, s, D, H];
        var S = [];
        for(var i = 0;i < R.length;i++){

          var Q = G + O + z + length + z + R[i];
          S.push(P ? this.__localizeWithFallback(O, O === x ? v : x, Q, N) : this.__mgr.localize(Q, [], N));
        };
        return S;
      },
      /**
       * Return localized name of a week day name
       *
       * @param length {String} format of the day name.
       *       Possible values: "abbreviated", "narrow", "wide"
       * @param day {Integer} day number. 0=sunday, 1=monday, ...
       * @param locale {String} optional locale to be used
       * @param context {String} (default: "format") intended context.
       *       Possible values: "format", "stand-alone"
       * @param withFallback {Boolean?} if true, the previous parameter's other value is tried
       * in order to find a localized name for the day
       * @return {String} localized day name
       */
      getDayName : function(length, T, U, V, W){

        var V = V ? V : A;
        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(length, [u, t, w]);
          qx.core.Assert.assertInteger(T);
          qx.core.Assert.assertInRange(T, 0, 6);
          qx.core.Assert.assertInArray(V, [A, m]);
        };
        var Y = [r, B, C, E, s, D, H];
        var X = G + V + z + length + z + Y[T];
        return W ? this.__localizeWithFallback(V, V === x ? v : x, X, U) : this.__mgr.localize(X, [], U);
      },
      /**
       * Return localized names of month names
       *
       * @param length {String} format of the month names.
       *       Possible values: "abbreviated", "narrow", "wide"
       * @param locale {String} optional locale to be used
       * @param context {String} (default: "format") intended context.
       *       Possible values: "format", "stand-alone"
       * @param withFallback {Boolean?} if true, the previous parameter's other value is tried
       * in order to find a localized name for the month
       * @return {String[]} array of localized month names starting with january.
       */
      getMonthNames : function(length, ba, bb, bc){

        var bb = bb ? bb : A;
        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(length, [u, t, w]);
          qx.core.Assert.assertInArray(bb, [A, m]);
        };
        var be = [];
        for(var i = 0;i < 12;i++){

          var bd = F + bb + z + length + z + (i + 1);
          be.push(bc ? this.__localizeWithFallback(bb, bb === x ? v : x, bd, ba) : this.__mgr.localize(bd, [], ba));
        };
        return be;
      },
      /**
       * Return localized name of a month
       *
       * @param length {String} format of the month names.
       *       Possible values: "abbreviated", "narrow", "wide"
       * @param month {Integer} index of the month. 0=january, 1=february, ...
       * @param locale {String} optional locale to be used
       * @param context {String} (default: "format") intended context.
       *       Possible values: "format", "stand-alone"
       * @param withFallback {Boolean?} if true, the previous parameter's other value is tried
       * in order to find a localized name for the month
       * @return {String} localized month name
       */
      getMonthName : function(length, bf, bg, bh, bi){

        var bh = bh ? bh : A;
        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(length, [u, t, w]);
          qx.core.Assert.assertInArray(bh, [A, m]);
        };
        var bj = F + bh + z + length + z + (bf + 1);
        return bi ? this.__localizeWithFallback(bh, bh === x ? v : x, bj, bg) : this.__mgr.localize(bj, [], bg);
      },
      /**
       * Return localized date format string to be used with {@link qx.util.format.DateFormat}.
       *
       * @param size {String} format of the date format.
       *      Possible values: "short", "medium", "long", "full"
       * @param locale {String} optional locale to be used
       * @return {String} localized date format string
       */
      getDateFormat : function(bk, bl){

        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(bk, [p, o, n, q]);
        };
        var bm = h + bk;
        return this.__mgr.localize(bm, [], bl);
      },
      /**
       * Try to localize a date/time format string.
       *
       * If no localization is available take the fallback format string
       *
       * @param canonical {String} format string containing only field information, and in a canonical order.
       *       Examples are "yyyyMMMM" for year + full month, or "MMMd" for abbreviated month + day.
       * @param fallback {String} fallback format string if no localized version is found
       * @param locale {String} optional locale to be used
       * @return {String} best matching format string
       */
      getDateTimeFormat : function(bn, bo, bp){

        var br = J + bn;
        var bq = this.__mgr.localize(br, [], bp);
        if(bq == br){

          bq = bo;
        };
        return bq;
      },
      /**
       * Return localized time format string to be used with {@link qx.util.format.DateFormat}.
       *
       * @param size {String} format of the time pattern.
       *      Possible values: "short", "medium", "long", "full"
       * @param locale {String} optional locale to be used
       * @return {String} localized time format string
       */
      getTimeFormat : function(bs, bt){

        if(qx.core.Environment.get(y)){

          qx.core.Assert.assertInArray(bs, [p, o, n, q]);
        };
        var bv = d + bs;
        var bu = this.__mgr.localize(bv, [], bt);
        if(bu != bv){

          return bu;
        };
        switch(bs){case p:case o:
        return qx.locale.Date.getDateTimeFormat(g, k);case n:
        return qx.locale.Date.getDateTimeFormat(f, I);case q:
        return qx.locale.Date.getDateTimeFormat(j, c);default:
        throw new Error(e);};
      },
      /**
       * Return the day the week starts with
       *
       * Reference: Common Locale Data Repository (cldr) supplementalData.xml
       *
       * @param locale {String} optional locale to be used
       * @return {Integer} index of the first day of the week. 0=sunday, 1=monday, ...
       */
      getWeekStart : function(bw){

        var bx = {
          // default is monday
          "MV" : 5,
          // friday
          "AE" : 6,
          // saturday
          "AF" : 6,
          "BH" : 6,
          "DJ" : 6,
          "DZ" : 6,
          "EG" : 6,
          "ER" : 6,
          "ET" : 6,
          "IQ" : 6,
          "IR" : 6,
          "JO" : 6,
          "KE" : 6,
          "KW" : 6,
          "LB" : 6,
          "LY" : 6,
          "MA" : 6,
          "OM" : 6,
          "QA" : 6,
          "SA" : 6,
          "SD" : 6,
          "SO" : 6,
          "TN" : 6,
          "YE" : 6,
          "AS" : 0,
          // sunday
          "AU" : 0,
          "AZ" : 0,
          "BW" : 0,
          "CA" : 0,
          "CN" : 0,
          "FO" : 0,
          "GE" : 0,
          "GL" : 0,
          "GU" : 0,
          "HK" : 0,
          "IE" : 0,
          "IL" : 0,
          "IS" : 0,
          "JM" : 0,
          "JP" : 0,
          "KG" : 0,
          "KR" : 0,
          "LA" : 0,
          "MH" : 0,
          "MN" : 0,
          "MO" : 0,
          "MP" : 0,
          "MT" : 0,
          "NZ" : 0,
          "PH" : 0,
          "PK" : 0,
          "SG" : 0,
          "TH" : 0,
          "TT" : 0,
          "TW" : 0,
          "UM" : 0,
          "US" : 0,
          "UZ" : 0,
          "VI" : 0,
          "ZA" : 0,
          "ZW" : 0,
          "MW" : 0,
          "NG" : 0,
          "TJ" : 0
        };
        var by = qx.locale.Date._getTerritory(bw);
        // default is monday
        return bx[by] != null ? bx[by] : 1;
      },
      /**
       * Return the day the weekend starts with
       *
       * Reference: Common Locale Data Repository (cldr) supplementalData.xml
       *
       * @param locale {String} optional locale to be used
       * @return {Integer} index of the first day of the weekend. 0=sunday, 1=monday, ...
       */
      getWeekendStart : function(bz){

        var bB = {
          // default is saturday
          "EG" : 5,
          // friday
          "IL" : 5,
          "SY" : 5,
          "IN" : 0,
          // sunday
          "AE" : 4,
          // thursday
          "BH" : 4,
          "DZ" : 4,
          "IQ" : 4,
          "JO" : 4,
          "KW" : 4,
          "LB" : 4,
          "LY" : 4,
          "MA" : 4,
          "OM" : 4,
          "QA" : 4,
          "SA" : 4,
          "SD" : 4,
          "TN" : 4,
          "YE" : 4
        };
        var bA = qx.locale.Date._getTerritory(bz);
        // default is saturday
        return bB[bA] != null ? bB[bA] : 6;
      },
      /**
       * Return the day the weekend ends with
       *
       * Reference: Common Locale Data Repository (cldr) supplementalData.xml
       *
       * @param locale {String} optional locale to be used
       * @return {Integer} index of the last day of the weekend. 0=sunday, 1=monday, ...
       */
      getWeekendEnd : function(bC){

        var bD = {
          // default is sunday
          "AE" : 5,
          // friday
          "BH" : 5,
          "DZ" : 5,
          "IQ" : 5,
          "JO" : 5,
          "KW" : 5,
          "LB" : 5,
          "LY" : 5,
          "MA" : 5,
          "OM" : 5,
          "QA" : 5,
          "SA" : 5,
          "SD" : 5,
          "TN" : 5,
          "YE" : 5,
          "AF" : 5,
          "IR" : 5,
          "EG" : 6,
          // saturday
          "IL" : 6,
          "SY" : 6
        };
        var bE = qx.locale.Date._getTerritory(bC);
        // default is sunday
        return bD[bE] != null ? bD[bE] : 0;
      },
      /**
       * Returns whether a certain day of week belongs to the week end.
       *
       * @param day {Integer} index of the day. 0=sunday, 1=monday, ...
       * @param locale {String} optional locale to be used
       * @return {Boolean} whether the given day is a weekend day
       */
      isWeekend : function(bF, bG){

        var bI = qx.locale.Date.getWeekendStart(bG);
        var bH = qx.locale.Date.getWeekendEnd(bG);
        if(bH > bI){

          return ((bF >= bI) && (bF <= bH));
        } else {

          return ((bF >= bI) || (bF <= bH));
        };
      },
      /**
       * Extract the territory part from a locale
       *
       * @param locale {String} the locale
       * @return {String} territory
       */
      _getTerritory : function(bJ){

        if(bJ){

          var bK = bJ.split(z)[1] || bJ;
        } else {

          bK = this.__mgr.getTerritory() || this.__mgr.getLanguage();
        };
        return bK.toUpperCase();
      },
      /**
       * Provide localisation (CLDR) data with fallback between "format" and "stand-alone" contexts.
       * It is used in {@link #getDayName} and {@link #getMonthName} methods.
       *
       * @param context {String} intended context.
       *       Possible values: "format", "stand-alone".
       * @param fallbackContext {String} the context used in case no localisation is found for the key.
       * @param key {String} message id (may contain format strings)
       * @param locale {String} the locale
       * @return {String} localized name for the key
       *
       */
      __localizeWithFallback : function(bL, bM, bN, bO){

        var bQ = this.__mgr.localize(bN, [], bO);
        if(bQ == bN){

          var bP = bN.replace(l + bL + l, l + bM + l);
          return this.__mgr.localize(bP, [], bO);
        } else {

          return bQ;
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.table.ICellEditorFactory";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A factory creating widgets to use for editing table cells.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Creates a cell editor.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>value (var): the cell's value.</li>
       * <li>row (int): the model index of the row the cell belongs to.</li>
       * <li>col (int): the model index of the column the cell belongs to.</li>
       * <li>xPos (int): the x position of the cell in the table pane.</li>
       * <li>table (qx.ui.table.Table) reference to the table, the cell belongs to. </li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that should be used as cell editor.
       */
      createCellEditor : function(b){

        return true;
      },
      /**
       * Returns the current value of a cell editor.
       *
       * @abstract
       * @param cellEditor {qx.ui.core.Widget} The cell editor formally created by
       *      {@link #createCellEditor}.
       * @return {var} the current value from the editor.
       */
      getCellEditorValue : function(c){

        return true;
      }
    }
  });
})();
(function(){

  var g = "Function",f = "abstract",e = "number",d = "appear",c = "Abstract method call!",b = "qx.ui.table.celleditor.AbstractField",a = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * An abstract cell editor factory creating text/password/spinner/... fields.
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    implement : qx.ui.table.ICellEditorFactory,
    type : f,
    properties : {
      /**
       * function that validates the result
       * the function will be called with the new value and the old value and is
       * supposed to return the value that is set as the table value.
       **/
      validationFunction : {
        check : g,
        nullable : true,
        init : null
      }
    },
    members : {
      /**
       * Factory to create the editor widget
       *
       * @return {qx.ui.core.Widget} The editor widget
       */
      _createEditor : function(){

        throw new Error(c);
      },
      // interface implementation
      createCellEditor : function(h){

        var i = this._createEditor();
        i.originalValue = h.value;
        if(h.value === null || h.value === undefined){

          h.value = a;
        };
        i.setValue(a + h.value);
        i.addListener(d, function(){

          i.selectAllText();
        });
        return i;
      },
      // interface implementation
      getCellEditorValue : function(j){

        var l = j.getValue();
        // validation function will be called with new and old value
        var k = this.getValidationFunction();
        if(k){

          l = k(l, j.originalValue);
        };
        if(typeof j.originalValue == e){

          l = parseFloat(l);
        };
        return l;
      }
    }
  });
})();
(function(){

  var c = "number",b = "qx.ui.table.celleditor.TextField",a = "table-editor-textfield";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A cell editor factory creating text fields.
   */
  qx.Class.define(b, {
    extend : qx.ui.table.celleditor.AbstractField,
    members : {
      // overridden
      getCellEditorValue : function(d){

        var f = d.getValue();
        // validation function will be called with new and old value
        var e = this.getValidationFunction();
        if(e){

          f = e(f, d.originalValue);
        };
        if(typeof d.originalValue == c){

          if(f != null){

            f = parseFloat(f);
          };
        };
        return f;
      },
      _createEditor : function(){

        var g = new qx.ui.form.TextField();
        g.setAppearance(a);
        return g;
      }
    }
  });
})();
(function(){

  var l = "",k = "qx.ui.form.MForm",j = "_applyValid",i = "changeRequired",h = "changeValid",g = "Boolean",f = "changeLocale",d = "changeInvalidMessage",c = "String",b = "invalid",a = "qx.dynlocale";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin handling the valid and required properties for the form widgets.
   */
  qx.Mixin.define(k, {
    construct : function(){

      if(qx.core.Environment.get(a)){

        qx.locale.Manager.getInstance().addListener(f, this.__onChangeLocale, this);
      };
    },
    properties : {
      /**
       * Flag signaling if a widget is valid. If a widget is invalid, an invalid
       * state will be set.
       */
      valid : {
        check : g,
        init : true,
        apply : j,
        event : h
      },
      /**
       * Flag signaling if a widget is required.
       */
      required : {
        check : g,
        init : false,
        event : i
      },
      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage : {
        check : c,
        init : l,
        event : d
      },
      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage : {
        check : c,
        nullable : true,
        event : d
      }
    },
    members : {
      // apply method
      _applyValid : function(m, n){

        m ? this.removeState(b) : this.addState(b);
      },
      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      __onChangeLocale : qx.core.Environment.select(a, {
        "true" : function(e){

          // invalid message
          var o = this.getInvalidMessage();
          if(o && o.translate){

            this.setInvalidMessage(o.translate());
          };
          // required invalid message
          var p = this.getRequiredInvalidMessage();
          if(p && p.translate){

            this.setRequiredInvalidMessage(p.translate());
          };
        },
        "false" : null
      })
    },
    destruct : function(){

      if(qx.core.Environment.get(a)){

        qx.locale.Manager.getInstance().removeListener(f, this.__onChangeLocale, this);
      };
    }
  });
})();
(function(){

  var n = "readOnly",m = "text",l = "_applyTextAlign",k = "px",j = "RegExp",i = ")",h = "syncAppearance",g = "changeValue",f = "engine.version",d = "Invalid value type: ",bp = "input::-moz-placeholder, textarea::-moz-placeholder",bo = "center",bn = "changeStatus",bm = "textAlign",bl = "input.qx-placeholder-color::-webkit-input-placeholder, textarea.qx-placeholder-color::-webkit-input-placeholder",bk = "focused",bj = "qx-placeholder-color",bi = "class",bh = "PositiveInteger",bg = "url(",u = "_applyReadOnly",v = "input:-moz-placeholder, textarea:-moz-placeholder",s = "resize",t = "qx.ui.form.AbstractField",q = "disabled",r = "transparent",o = "input.qx-placeholder-color:-ms-input-placeholder, textarea.qx-placeholder-color:-ms-input-placeholder",p = "spellcheck",A = "false",B = "right",L = "gecko",I = "normal",T = "abstract",O = "visible",bc = "block",Y = "css.placeholder",E = "webkit",bf = "String",be = "change",bd = "_applyPlaceholder",D = "left",G = "off",H = "qx/static/blank.gif",K = "changeReadOnly",M = "Boolean",P = "A",V = "focusout",bb = "input",w = "qx.event.type.Data",x = "focusin",F = "changeLocale",S = "placeholder",R = " !important",Q = "readonly",X = "visibility",W = "mshtml",N = "hidden",U = "text-placeholder",a = "absolute",ba = "color: ",y = "qx.dynlocale",z = "color",J = "engine.name",b = "none",c = "showingPlaceholder",C = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This is a basic form field with common functionality for
   * {@link TextArea} and {@link TextField}.
   *
   * On every keystroke the value is synchronized with the
   * value of the textfield. Value changes can be monitored by listening to the
   * {@link #input} or {@link #changeValue} events, respectively.
   */
  qx.Class.define(t, {
    extend : qx.ui.core.Widget,
    implement : [qx.ui.form.IStringForm, qx.ui.form.IForm],
    include : [qx.ui.form.MForm],
    type : T,
    statics : {
      __stylesheet : null,
      /**
       * Adds the CSS rules needed to style the native placeholder element.
       */
      __addPlaceholderRules : function(){

        if(this.__stylesheet){

          return;
        };
        this.__stylesheet = qx.bom.Stylesheet.createElement();
        var br = qx.theme.manager.Color.getInstance();
        var bq = br.resolve(U);
        if(qx.core.Environment.get(J) == L){

          var bs;
          // see https://developer.mozilla.org/de/docs/CSS/:-moz-placeholder for details
          if(parseFloat(qx.core.Environment.get(f)) >= 19){

            bs = bp;
          } else {

            bs = v;
          };
          qx.bom.Stylesheet.addRule(this.__stylesheet, bs, ba + bq + R);
        } else if(qx.core.Environment.get(J) == E){

          bs = bl;
          qx.bom.Stylesheet.addRule(this.__stylesheet, bs, ba + bq);
        } else if(qx.core.Environment.get(J) == W){

          bs = o;
          qx.bom.Stylesheet.addRule(this.__stylesheet, bs, ba + bq + R);
        };;
      }
    },
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param value {String} initial text value of the input field ({@link #setValue}).
     */
    construct : function(bt){

      qx.ui.core.Widget.call(this);
      // shortcut for placeholder feature detection
      this.__useQxPlaceholder = !qx.core.Environment.get(Y);
      if(bt != null){

        this.setValue(bt);
      };
      this.getContentElement().addListener(be, this._onChangeContent, this);
      // use qooxdoo placeholder if no native placeholder is supported
      if(this.__useQxPlaceholder){

        // assign the placeholder text after the appearance has been applied
        this.addListener(h, this._syncPlaceholder, this);
      } else {

        // add rules for native placeholder color
        qx.ui.form.AbstractField.__addPlaceholderRules();
        // add a class to the input to restict the placeholder color
        this.getContentElement().setAttribute(bi, bj);
      };
      // translation support
      if(qx.core.Environment.get(y)){

        qx.locale.Manager.getInstance().addListener(F, this._onChangeLocale, this);
      };
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * The event is fired on every keystroke modifying the value of the field.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current value of the text field.
       */
      "input" : w,
      /**
       * The event is fired each time the text field looses focus and the
       * text field values has changed.
       *
       * If you change {@link #liveUpdate} to true, the changeValue event will
       * be fired after every keystroke and not only after every focus loss. In
       * that mode, the changeValue event is equal to the {@link #input} event.
       *
       * The method {@link qx.event.type.Data#getData} returns the
       * current text value of the field.
       */
      "changeValue" : w
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Alignment of the text
       */
      textAlign : {
        check : [D, bo, B],
        nullable : true,
        themeable : true,
        apply : l
      },
      /** Whether the field is read only */
      readOnly : {
        check : M,
        apply : u,
        event : K,
        init : false
      },
      // overridden
      selectable : {
        refine : true,
        init : true
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      },
      /** Maximal number of characters that can be entered in the TextArea. */
      maxLength : {
        check : bh,
        init : Infinity
      },
      /**
       * Whether the {@link #changeValue} event should be fired on every key
       * input. If set to true, the changeValue event is equal to the
       * {@link #input} event.
       */
      liveUpdate : {
        check : M,
        init : false
      },
      /**
       * String value which will be shown as a hint if the field is all of:
       * unset, unfocused and enabled. Set to null to not show a placeholder
       * text.
       */
      placeholder : {
        check : bf,
        nullable : true,
        apply : bd
      },
      /**
       * RegExp responsible for filtering the value of the textfield. the RegExp
       * gives the range of valid values.
       * The following example only allows digits in the textfield.
       * <pre class='javascript'>field.setFilter(/[0-9]/);</pre>
       */
      filter : {
        check : j,
        nullable : true,
        init : null
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __nullValue : true,
      _placeholder : null,
      __oldValue : null,
      __oldInputValue : null,
      __useQxPlaceholder : true,
      __font : null,
      __webfontListenerId : null,
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      getFocusElement : function(){

        var bu = this.getContentElement();
        if(bu){

          return bu;
        };
      },
      /**
       * Creates the input element. Derived classes may override this
       * method, to create different input elements.
       *
       * @return {qx.html.Input} a new input element.
       */
      _createInputElement : function(){

        return new qx.html.Input(m);
      },
      // overridden
      renderLayout : function(bv, top, bw, bx){

        var by = this._updateInsets;
        var bC = qx.ui.core.Widget.prototype.renderLayout.call(this, bv, top, bw, bx);
        // Directly return if superclass has detected that no
        // changes needs to be applied
        if(!bC){

          return;
        };
        var bA = bC.size || by;
        var bD = k;
        if(bA || bC.local || bC.margin){

          var bz = this.getInsets();
          var innerWidth = bw - bz.left - bz.right;
          var innerHeight = bx - bz.top - bz.bottom;
          // ensure that the width and height never get negative
          innerWidth = innerWidth < 0 ? 0 : innerWidth;
          innerHeight = innerHeight < 0 ? 0 : innerHeight;
        };
        var bB = this.getContentElement();
        // we don't need to update positions on native placeholders
        if(by && this.__useQxPlaceholder){

          // render the placeholder
          this.__getPlaceholderElement().setStyles({
            "left" : bz.left + bD,
            "top" : bz.top + bD
          });
        };
        if(bA){

          // we don't need to update dimensions on native placeholders
          if(this.__useQxPlaceholder){

            this.__getPlaceholderElement().setStyles({
              "width" : innerWidth + bD,
              "height" : innerHeight + bD
            });
          };
          bB.setStyles({
            "width" : innerWidth + bD,
            "height" : innerHeight + bD
          });
          this._renderContentElement(innerHeight, bB);
        };
      },
      /**
       * Hook into {@link qx.ui.form.AbstractField#renderLayout} method.
       * Called after the contentElement has a width and an innerWidth.
       *
       * Note: This was introduced to fix BUG#1585
       *
       * @param innerHeight {Integer} The inner height of the element.
       * @param element {Element} The element.
       */
      _renderContentElement : function(innerHeight, bE){
      },
      // overridden
      _createContentElement : function(){

        // create and add the input element
        var bF = this._createInputElement();
        // Apply styles
        bF.setStyles({
          "border" : b,
          "padding" : 0,
          "margin" : 0,
          "display" : bc,
          "background" : r,
          "outline" : b,
          "appearance" : b,
          "position" : a,
          "autoComplete" : G
        });
        // initialize the html input
        bF.setSelectable(this.getSelectable());
        bF.setEnabled(this.getEnabled());
        // Add listener for input event
        bF.addListener(bb, this._onHtmlInput, this);
        // Disable HTML5 spell checking
        bF.setAttribute(p, A);
        // Block resize handle
        bF.setStyle(s, b);
        // IE8 in standard mode needs some extra love here to receive events.
        if((qx.core.Environment.get(J) == W)){

          bF.setStyles({
            backgroundImage : bg + qx.util.ResourceManager.getInstance().toUri(H) + i
          });
        };
        return bF;
      },
      // overridden
      _applyEnabled : function(bG, bH){

        qx.ui.core.Widget.prototype._applyEnabled.call(this, bG, bH);
        this.getContentElement().setEnabled(bG);
        if(this.__useQxPlaceholder){

          if(bG){

            this._showPlaceholder();
          } else {

            this._removePlaceholder();
          };
        } else {

          var bI = this.getContentElement();
          // remove the placeholder on disabled input elements
          bI.setAttribute(S, bG ? this.getPlaceholder() : C);
        };
      },
      // default text sizes
      /**
       * @lint ignoreReferenceField(__textSize)
       */
      __textSize : {
        width : 16,
        height : 16
      },
      // overridden
      _getContentHint : function(){

        return {
          width : this.__textSize.width * 10,
          height : this.__textSize.height || 16
        };
      },
      // overridden
      _applyFont : function(bJ, bK){

        if(bK && this.__font && this.__webfontListenerId){

          this.__font.removeListenerById(this.__webfontListenerId);
          this.__webfontListenerId = null;
        };
        // Apply
        var bL;
        if(bJ){

          this.__font = qx.theme.manager.Font.getInstance().resolve(bJ);
          if(this.__font instanceof qx.bom.webfonts.WebFont){

            this.__webfontListenerId = this.__font.addListener(bn, this._onWebFontStatusChange, this);
          };
          bL = this.__font.getStyles();
        } else {

          bL = qx.bom.Font.getDefaultStyles();
        };
        // check if text color already set - if so this local value has higher priority
        if(this.getTextColor() != null){

          delete bL[z];
        };
        // apply the font to the content element
        this.getContentElement().setStyles(bL);
        // the font will adjust automatically on native placeholders
        if(this.__useQxPlaceholder){

          // don't apply the color to the placeholder
          delete bL[z];
          // apply the font to the placeholder
          this.__getPlaceholderElement().setStyles(bL);
        };
        // Compute text size
        if(bJ){

          this.__textSize = qx.bom.Label.getTextSize(P, bL);
        } else {

          delete this.__textSize;
        };
        // Update layout
        qx.ui.core.queue.Layout.add(this);
      },
      // overridden
      _applyTextColor : function(bM, bN){

        if(bM){

          this.getContentElement().setStyle(z, qx.theme.manager.Color.getInstance().resolve(bM));
        } else {

          this.getContentElement().removeStyle(z);
        };
      },
      // overridden
      tabFocus : function(){

        qx.ui.core.Widget.prototype.tabFocus.call(this);
        this.selectAllText();
      },
      /**
       * Returns the text size.
       * @return {Map} The text size.
       */
      _getTextSize : function(){

        return this.__textSize;
      },
      /*
      ---------------------------------------------------------------------------
        EVENTS
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for native input events. Redirects the event
       * to the widget. Also checks for the filter and max length.
       *
       * @param e {qx.event.type.Data} Input event
       */
      _onHtmlInput : function(e){

        var bR = e.getData();
        var bQ = true;
        this.__nullValue = false;
        // value unchanged; Firefox fires "input" when pressing ESC [BUG #5309]
        if(this.__oldInputValue && this.__oldInputValue === bR){

          bQ = false;
        };
        // check for the filter
        if(this.getFilter() != null){

          var bS = C;
          var bO = bR.search(this.getFilter());
          var bP = bR;
          while(bO >= 0){

            bS = bS + (bP.charAt(bO));
            bP = bP.substring(bO + 1, bP.length);
            bO = bP.search(this.getFilter());
          };
          if(bS != bR){

            bQ = false;
            bR = bS;
            this.getContentElement().setValue(bR);
          };
        };
        // check for the max length
        if(bR.length > this.getMaxLength()){

          bQ = false;
          this.getContentElement().setValue(bR.substr(0, this.getMaxLength()));
        };
        // fire the events, if necessary
        if(bQ){

          // store the old input value
          this.fireDataEvent(bb, bR, this.__oldInputValue);
          this.__oldInputValue = bR;
          // check for the live change event
          if(this.getLiveUpdate()){

            this.__fireChangeValueEvent(bR);
          };
        };
      },
      /**
       * Triggers text size recalculation after a web font was loaded
       *
       * @param ev {qx.event.type.Data} "changeStatus" event
       */
      _onWebFontStatusChange : function(bT){

        if(bT.getData().valid === true){

          var bU = this.__font.getStyles();
          this.__textSize = qx.bom.Label.getTextSize(P, bU);
          qx.ui.core.queue.Layout.add(this);
        };
      },
      /**
       * Handles the firing of the changeValue event including the local cache
       * for sending the old value in the event.
       *
       * @param value {String} The new value.
       */
      __fireChangeValueEvent : function(bV){

        var bW = this.__oldValue;
        this.__oldValue = bV;
        if(bW != bV){

          this.fireNonBubblingEvent(g, qx.event.type.Data, [bV, bW]);
        };
      },
      /*
      ---------------------------------------------------------------------------
        TEXTFIELD VALUE API
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the value of the textfield to the given value.
       *
       * @param value {String} The new value
       */
      setValue : function(bX){

        // handle null values
        if(bX === null){

          // just do nothing if null is already set
          if(this.__nullValue){

            return bX;
          };
          bX = C;
          this.__nullValue = true;
        } else {

          this.__nullValue = false;
          // native placeholders will be removed by the browser
          if(this.__useQxPlaceholder){

            this._removePlaceholder();
          };
        };
        if(qx.lang.Type.isString(bX)){

          var ca = this.getContentElement();
          if(bX.length > this.getMaxLength()){

            bX = bX.substr(0, this.getMaxLength());
          };
          if(ca.getValue() != bX){

            var cb = ca.getValue();
            ca.setValue(bX);
            var bY = this.__nullValue ? null : bX;
            this.__oldValue = cb;
            this.__fireChangeValueEvent(bY);
            // reset the input value on setValue calls [BUG #6892]
            this.__oldInputValue = this.__oldValue;
          };
          // native placeholders will be shown by the browser
          if(this.__useQxPlaceholder){

            this._showPlaceholder();
          };
          return bX;
        };
        throw new Error(d + bX);
      },
      /**
       * Returns the current value of the textfield.
       *
       * @return {String|null} The current value
       */
      getValue : function(){

        var cc = this.getContentElement().getValue();
        return this.__nullValue ? null : cc;
      },
      /**
       * Resets the value to the default
       */
      resetValue : function(){

        this.setValue(null);
      },
      /**
       * Event listener for change event of content element
       *
       * @param e {qx.event.type.Data} Incoming change event
       */
      _onChangeContent : function(e){

        this.__nullValue = e.getData() === null;
        this.__fireChangeValueEvent(e.getData());
      },
      /*
      ---------------------------------------------------------------------------
        TEXTFIELD SELECTION API
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {String|null}
       */
      getTextSelection : function(){

        return this.getContentElement().getTextSelection();
      },
      /**
       * Returns the current selection length.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @return {Integer|null}
       */
      getTextSelectionLength : function(){

        return this.getContentElement().getTextSelectionLength();
      },
      /**
       * Returns the start of the text selection
       *
       * @return {Integer|null} Start of selection or null if not available
       */
      getTextSelectionStart : function(){

        return this.getContentElement().getTextSelectionStart();
      },
      /**
       * Returns the end of the text selection
       *
       * @return {Integer|null} End of selection or null if not available
       */
      getTextSelectionEnd : function(){

        return this.getContentElement().getTextSelectionEnd();
      },
      /**
       * Set the selection to the given start and end (zero-based).
       * If no end value is given the selection will extend to the
       * end of the textfield's content.
       * This method only works if the widget is already created and
       * added to the document.
       *
       * @param start {Integer} start of the selection (zero-based)
       * @param end {Integer} end of the selection
       */
      setTextSelection : function(cd, ce){

        this.getContentElement().setTextSelection(cd, ce);
      },
      /**
       * Clears the current selection.
       * This method only works if the widget is already created and
       * added to the document.
       *
       */
      clearTextSelection : function(){

        this.getContentElement().clearTextSelection();
      },
      /**
       * Selects the whole content
       *
       */
      selectAllText : function(){

        this.setTextSelection(0);
      },
      /*
      ---------------------------------------------------------------------------
        PLACEHOLDER HELPER
      ---------------------------------------------------------------------------
      */
      /**
       * Helper to show the placeholder text in the field. It checks for all
       * states and possible conditions and shows the placeholder only if allowed.
       */
      _showPlaceholder : function(){

        var cg = this.getValue() || C;
        var cf = this.getPlaceholder();
        if(cf != null && cg == C && !this.hasState(bk) && !this.hasState(q)){

          if(this.hasState(c)){

            this._syncPlaceholder();
          } else {

            // the placeholder will be set as soon as the appearance is applied
            this.addState(c);
          };
        };
      },
      /**
       * Helper to remove the placeholder. Deletes the placeholder text from the
       * field and removes the state.
       */
      _removePlaceholder : function(){

        if(this.hasState(c)){

          this.__getPlaceholderElement().setStyle(X, N);
          this.removeState(c);
        };
      },
      /**
       * Updates the placeholder text with the DOM
       */
      _syncPlaceholder : function(){

        if(this.hasState(c)){

          this.__getPlaceholderElement().setStyle(X, O);
        };
      },
      /**
       * Returns the placeholder label and creates it if necessary.
       */
      __getPlaceholderElement : function(){

        if(this._placeholder == null){

          // create the placeholder
          this._placeholder = new qx.html.Label();
          var ch = qx.theme.manager.Color.getInstance();
          this._placeholder.setStyles({
            "visibility" : N,
            "zIndex" : 6,
            "position" : a,
            "color" : ch.resolve(U),
            "whiteSpace" : I
          });
          this.getContainerElement().add(this._placeholder);
        };
        return this._placeholder;
      },
      /**
       * Locale change event handler
       *
       * @signature function(e)
       * @param e {Event} the change event
       */
      _onChangeLocale : qx.core.Environment.select(y, {
        "true" : function(e){

          var content = this.getPlaceholder();
          if(content && content.translate){

            this.setPlaceholder(content.translate());
          };
        },
        "false" : null
      }),
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyPlaceholder : function(ci, cj){

        if(this.__useQxPlaceholder){

          this.__getPlaceholderElement().setValue(ci);
          if(ci != null){

            this.addListener(x, this._removePlaceholder, this);
            this.addListener(V, this._showPlaceholder, this);
            this._showPlaceholder();
          } else {

            this.removeListener(x, this._removePlaceholder, this);
            this.removeListener(V, this._showPlaceholder, this);
            this._removePlaceholder();
          };
        } else {

          // only apply if the widget is enabled
          if(this.getEnabled()){

            this.getContentElement().setAttribute(S, ci);
          };
        };
      },
      // property apply
      _applyTextAlign : function(ck, cl){

        this.getContentElement().setStyle(bm, ck);
      },
      // property apply
      _applyReadOnly : function(cm, cn){

        var co = this.getContentElement();
        co.setAttribute(n, cm);
        if(cm){

          this.addState(Q);
          this.setFocusable(false);
        } else {

          this.removeState(Q);
          this.setFocusable(true);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._placeholder = this.__font = null;
      if(qx.core.Environment.get(y)){

        qx.locale.Manager.getInstance().removeListener(F, this._onChangeLocale, this);
      };
      if(this.__font && this.__webfontListenerId){

        this.__font.removeListenerById(this.__webfontListenerId);
      };
    }
  });
})();
(function(){

  var o = "",n = "overflow",m = "input",l = "qx.html.Input",k = "select",j = "disabled",i = "read-only",h = "overflowX",g = "overflowY",f = "engine.name",c = "none",e = "Text wrapping is only support by textareas!",d = "wrap",b = "value",a = "textarea";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A Input wrap any valid HTML input element and make it accessible
   * through the normalized qooxdoo element interface.
   */
  qx.Class.define(l, {
    extend : qx.html.Element,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param type {String} The type of the input field. Valid values are
     *   <code>text</code>, <code>textarea</code>, <code>select</code>,
     *   <code>checkbox</code>, <code>radio</code>, <code>password</code>,
     *   <code>hidden</code>, <code>submit</code>, <code>image</code>,
     *   <code>file</code>, <code>search</code>, <code>reset</code>,
     *   <code>select</code> and <code>textarea</code>.
     * @param styles {Map?null} optional map of CSS styles, where the key is the name
     *    of the style and the value is the value to use.
     * @param attributes {Map?null} optional map of element attributes, where the
     *    key is the name of the attribute and the value is the value to use.
     */
    construct : function(p, q, r){

      // Update node name correctly
      if(p === k || p === a){

        var s = p;
      } else {

        s = m;
      };
      qx.html.Element.call(this, s, q, r);
      this.__type = p;
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __type : null,
      // used for webkit only
      __selectable : null,
      __enabled : null,
      /*
      ---------------------------------------------------------------------------
        ELEMENT API
      ---------------------------------------------------------------------------
      */
      //overridden
      _createDomElement : function(){

        return qx.bom.Input.create(this.__type);
      },
      // overridden
      _applyProperty : function(name, t){

        qx.html.Element.prototype._applyProperty.call(this, name, t);
        var u = this.getDomElement();
        if(name === b){

          qx.bom.Input.setValue(u, t);
        } else if(name === d){

          qx.bom.Input.setWrap(u, t);
          // qx.bom.Input#setWrap has the side-effect that the CSS property
          // overflow is set via DOM methods, causing queue and DOM to get
          // out of sync. Mirror all overflow properties to handle the case
          // when group and x/y property differ.
          this.setStyle(n, u.style.overflow, true);
          this.setStyle(h, u.style.overflowX, true);
          this.setStyle(g, u.style.overflowY, true);
        };
      },
      /**
       * Set the input element enabled / disabled.
       * Webkit needs a special treatment because the set color of the input
       * field changes automatically. Therefore, we use
       * <code>-webkit-user-modify: read-only</code> and
       * <code>-webkit-user-select: none</code>
       * for disabling the fields in webkit. All other browsers use the disabled
       * attribute.
       *
       * @param value {Boolean} true, if the inpout element should be enabled.
       */
      setEnabled : qx.core.Environment.select(f, {
        "webkit" : function(v){

          this.__enabled = v;
          if(!v){

            this.setStyles({
              "userModify" : i,
              "userSelect" : c
            });
          } else {

            this.setStyles({
              "userModify" : null,
              "userSelect" : this.__selectable ? null : c
            });
          };
        },
        "default" : function(w){

          this.setAttribute(j, w === false);
        }
      }),
      /**
       * Set whether the element is selectable. It uses the qooxdoo attribute
       * qxSelectable with the values 'on' or 'off'.
       * In webkit, a special css property will be used and checks for the
       * enabled state.
       *
       * @param value {Boolean} True, if the element should be selectable.
       */
      setSelectable : qx.core.Environment.select(f, {
        "webkit" : function(x){

          this.__selectable = x;
          qx.html.Element.prototype.setSelectable.call(this, this.__enabled && x);
        },
        "default" : function(y){

          qx.html.Element.prototype.setSelectable.call(this, y);
        }
      }),
      /*
      ---------------------------------------------------------------------------
        INPUT API
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the value of the input element.
       *
       * @param value {var} the new value
       * @return {qx.html.Input} This instance for for chaining support.
       */
      setValue : function(z){

        var A = this.getDomElement();
        if(A){

          // Do not overwrite when already correct (on input events)
          // This is needed to keep caret position while typing.
          if(A.value != z){

            qx.bom.Input.setValue(A, z);
          };
        } else {

          this._setProperty(b, z);
        };
        return this;
      },
      /**
       * Get the current value.
       *
       * @return {String} The element's current value.
       */
      getValue : function(){

        var B = this.getDomElement();
        if(B){

          return qx.bom.Input.getValue(B);
        };
        return this._getProperty(b) || o;
      },
      /**
       * Sets the text wrap behavior of a text area element.
       *
       * This property uses the style property "wrap" (IE) respectively "whiteSpace"
       *
       * @param wrap {Boolean} Whether to turn text wrap on or off.
       * @param direct {Boolean?false} Whether the execution should be made
       *  directly when possible
       * @return {qx.html.Input} This instance for for chaining support.
       */
      setWrap : function(C, D){

        if(this.__type === a){

          this._setProperty(d, C, D);
        } else {

          throw new Error(e);
        };
        return this;
      },
      /**
       * Gets the text wrap behavior of a text area element.
       *
       * This property uses the style property "wrap" (IE) respectively "whiteSpace"
       *
       * @return {Boolean} Whether wrapping is enabled or disabled.
       */
      getWrap : function(){

        if(this.__type === a){

          return this._getProperty(d);
        } else {

          throw new Error(e);
        };
      }
    }
  });
})();
(function(){

  var k = "text",j = "Unsupported input type.",h = "nowrap",g = "radio",f = "qx.debug",e = "input",d = "option",c = "value",b = "number",a = "qx.bom.Input",x = "normal",w = "mshtml",v = "wrap",u = "checkbox",t = "select-one",s = "textarea",r = "auto",q = "soft",p = "off",o = "engine.name",m = "select",n = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * jQuery
       http://jquery.com
       Version 1.3.1
  
       Copyright:
         2009 John Resig
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */
  /* ************************************************************************
  #require(qx.lang.Array#contains)
  ************************************************************************ */
  /**
   * Cross browser abstractions to work with input elements.
   */
  qx.Bootstrap.define(a, {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Map} Internal data structures with all supported input types */
      __types : {
        text : 1,
        textarea : 1,
        select : 1,
        checkbox : 1,
        radio : 1,
        password : 1,
        hidden : 1,
        submit : 1,
        image : 1,
        file : 1,
        search : 1,
        reset : 1,
        button : 1
      },
      /**
       * Creates an DOM input/textarea/select element.
       *
       * Attributes may be given directly with this call. This is critical
       * for some attributes e.g. name, type, ... in many clients.
       *
       * Note: <code>select</code> and <code>textarea</code> elements are created
       * using the identically named <code>type</code>.
       *
       * @param type {String} Any valid type for HTML, <code>select</code>
       *   and <code>textarea</code>
       * @param attributes {Map} Map of attributes to apply
       * @param win {Window} Window to create the element for
       * @return {Element} The created input node
       */
      create : function(y, z, A){

        if(qx.core.Environment.get(f)){

          qx.core.Assert.assertKeyInMap(y, this.__types, j);
        };
        // Work on a copy to not modify given attributes map
        var z = z ? qx.lang.Object.clone(z) : {
        };
        var B;
        if(y === s || y === m){

          B = y;
        } else {

          B = e;
          z.type = y;
        };
        return qx.dom.Element.create(B, z, A);
      },
      /**
       * Applies the given value to the element.
       *
       * Normally the value is given as a string/number value and applied
       * to the field content (textfield, textarea) or used to
       * detect whether the field is checked (checkbox, radiobutton).
       *
       * Supports array values for selectboxes (multiple-selection)
       * and checkboxes or radiobuttons (for convenience).
       *
       * Please note: To modify the value attribute of a checkbox or
       * radiobutton use {@link qx.bom.element.Attribute#set} instead.
       *
       * @param element {Element} element to update
       * @param value {String|Number|Array} the value to apply
       */
      setValue : function(C, D){

        var I = C.nodeName.toLowerCase();
        var F = C.type;
        var Array = qx.lang.Array;
        var J = qx.lang.Type;
        if(typeof D === b){

          D += n;
        };
        if((F === u || F === g)){

          if(J.isArray(D)){

            C.checked = Array.contains(D, C.value);
          } else {

            C.checked = C.value == D;
          };
        } else if(I === m){

          var E = J.isArray(D);
          var K = C.options;
          var G,H;
          for(var i = 0,l = K.length;i < l;i++){

            G = K[i];
            H = G.getAttribute(c);
            if(H == null){

              H = G.text;
            };
            G.selected = E ? Array.contains(D, H) : D == H;
          };
          if(E && D.length == 0){

            C.selectedIndex = -1;
          };
        } else if((F === k || F === s) && (qx.core.Environment.get(o) == w)){

          // These flags are required to detect self-made property-change
          // events during value modification. They are used by the Input
          // event handler to filter events.
          C.$$inValueSet = true;
          C.value = D;
          C.$$inValueSet = null;
        } else {

          C.value = D;
        };;
      },
      /**
       * Returns the currently configured value.
       *
       * Works with simple input fields as well as with
       * select boxes or option elements.
       *
       * Returns an array in cases of multi-selection in
       * select boxes but in all other cases a string.
       *
       * @param element {Element} DOM element to query
       * @return {String|Array} The value of the given element
       */
      getValue : function(L){

        var R = L.nodeName.toLowerCase();
        if(R === d){

          return (L.attributes.value || {
          }).specified ? L.value : L.text;
        };
        if(R === m){

          var M = L.selectedIndex;
          // Nothing was selected
          if(M < 0){

            return null;
          };
          var S = [];
          var U = L.options;
          var T = L.type == t;
          var Q = qx.bom.Input;
          var P;
          // Loop through all the selected options
          for(var i = T ? M : 0,O = T ? M + 1 : U.length;i < O;i++){

            var N = U[i];
            if(N.selected){

              // Get the specifc value for the option
              P = Q.getValue(N);
              // We don't need an array for one selects
              if(T){

                return P;
              };
              // Multi-Selects return an array
              S.push(P);
            };
          };
          return S;
        } else {

          return (L.value || n).replace(/\r/g, n);
        };
      },
      /**
       * Sets the text wrap behaviour of a text area element.
       * This property uses the attribute "wrap" respectively
       * the style property "whiteSpace"
       *
       * @signature function(element, wrap)
       * @param element {Element} DOM element to modify
       * @param wrap {Boolean} Whether to turn text wrap on or off.
       */
      setWrap : qx.core.Environment.select(o, {
        "mshtml" : function(V, W){

          var Y = W ? q : p;
          // Explicitly set overflow-y CSS property to auto when wrapped,
          // allowing the vertical scroll-bar to appear if necessary
          var X = W ? r : n;
          V.wrap = Y;
          V.style.overflowY = X;
        },
        "gecko|webkit" : function(ba, bb){

          var bd = bb ? q : p;
          var bc = bb ? n : r;
          ba.setAttribute(v, bd);
          ba.style.overflow = bc;
        },
        "default" : function(be, bf){

          be.style.whiteSpace = bf ? x : h;
        }
      })
    }
  });
})();
(function(){

  var g = "mshtml",f = "engine.name",e = "qx.ui.form.TextField",d = 'px',c = "textfield",b = "engine.version",a = "browser.documentmode";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Adrian Olaru (adrianolaru)
  
  ************************************************************************ */
  /**
   * The TextField is a single-line text input field.
   */
  qx.Class.define(e, {
    extend : qx.ui.form.AbstractField,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : c
      },
      // overridden
      allowGrowY : {
        refine : true,
        init : false
      },
      // overridden
      allowShrinkY : {
        refine : true,
        init : false
      }
    },
    members : {
      // overridden
      _renderContentElement : function(innerHeight, h){

        if((qx.core.Environment.get(f) == g) && (parseInt(qx.core.Environment.get(b), 10) < 9 || qx.core.Environment.get(a) < 9)){

          h.setStyles({
            "line-height" : innerHeight + d
          });
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.table.IHeaderRenderer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A cell renderer for header cells.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Creates a header cell.
       *
       * The cellInfo map contains the following properties:
       * <ul>
       * <li>col (int): the model index of the column.</li>
       * <li>xPos (int): the x position of the column in the table pane.</li>
       * <li>name (string): the name of the column.</li>
       * <li>editable (boolean): whether the column is editable.</li>
       * <li>sorted (boolean): whether the column is sorted.</li>
       * <li>sortedAscending (boolean): whether sorting is ascending.</li>
       * </ul>
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create.
       * @return {qx.ui.core.Widget} the widget that renders the header cell.
       */
      createHeaderCell : function(b){

        return true;
      },
      /**
       * Updates a header cell.
       *
       * @abstract
       * @param cellInfo {Map} A map containing the information about the cell to
       *      create. This map has the same structure as in {@link #createHeaderCell}.
       * @param cellWidget {qx.ui.core.Widget} the widget that renders the header cell. This is
       *      the same widget formally created by {@link #createHeaderCell}.
       * @return {void}
       */
      updateHeaderCell : function(c, d){

        return true;
      }
    }
  });
})();
(function(){

  var b = "qx.ui.table.headerrenderer.Default",a = "String";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */
  /**
   * The default header cell renderer.
   *
   * @state hovered {table-header-cell}
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    implement : qx.ui.table.IHeaderRenderer,
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /**
       * {String} The state which will be set for header cells of sorted columns.
       */
      STATE_SORTED : "sorted",
      /**
       * {String} The state which will be set when sorting is ascending.
       */
      STATE_SORTED_ASCENDING : "sortedAscending"
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * ToolTip to show if the mouse hovers of the icon
       */
      toolTip : {
        check : a,
        init : null,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // overridden
      createHeaderCell : function(c){

        var d = new qx.ui.table.headerrenderer.HeaderCell();
        this.updateHeaderCell(c, d);
        return d;
      },
      // overridden
      updateHeaderCell : function(e, f){

        var g = qx.ui.table.headerrenderer.Default;
        // check for localization [BUG #2699]
        if(e.name && e.name.translate){

          f.setLabel(e.name.translate());
        } else {

          f.setLabel(e.name);
        };
        // Set image tooltip if given
        var h = f.getToolTip();
        if(this.getToolTip() != null){

          if(h == null){

            // We have no tooltip yet -> Create one
            h = new qx.ui.tooltip.ToolTip(this.getToolTip());
            f.setToolTip(h);
            // Link disposer to cellwidget to prevent memory leak
            qx.util.DisposeUtil.disposeTriggeredBy(h, f);
          } else {

            // Update tooltip text
            h.setLabel(this.getToolTip());
          };
        };
        e.sorted ? f.addState(g.STATE_SORTED) : f.removeState(g.STATE_SORTED);
        e.sortedAscending ? f.addState(g.STATE_SORTED_ASCENDING) : f.removeState(g.STATE_SORTED_ASCENDING);
      }
    }
  });
})();
(function(){

  var i = "_applySortIcon",h = "_applyIcon",g = "table-header-cell",f = "qx.ui.table.headerrenderer.HeaderCell",e = "_applyLabel",d = "icon",c = "label",b = "String",a = "sort-icon";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The default header cell widget
   *
   * @childControl label {qx.ui.basic.Label} label of the header cell
   * @childControl sort-icon {qx.ui.basic.Image} sort icon of the header cell
   * @childControl icon {qx.ui.basic.Image} icon of the header cell
   */
  qx.Class.define(f, {
    extend : qx.ui.container.Composite,
    construct : function(){

      qx.ui.container.Composite.call(this);
      var j = new qx.ui.layout.Grid();
      j.setRowFlex(0, 1);
      j.setColumnFlex(1, 1);
      j.setColumnFlex(2, 1);
      this.setLayout(j);
    },
    properties : {
      appearance : {
        refine : true,
        init : g
      },
      /** header cell label */
      label : {
        check : b,
        init : null,
        nullable : true,
        apply : e
      },
      /** The icon URL of the sorting indicator */
      sortIcon : {
        check : b,
        init : null,
        nullable : true,
        apply : i,
        themeable : true
      },
      /** Icon URL */
      icon : {
        check : b,
        init : null,
        nullable : true,
        apply : h
      }
    },
    members : {
      // property apply
      _applyLabel : function(k, l){

        if(k){

          this._showChildControl(c).setValue(k);
        } else {

          this._excludeChildControl(c);
        };
      },
      // property apply
      _applySortIcon : function(m, n){

        if(m){

          this._showChildControl(a).setSource(m);
        } else {

          this._excludeChildControl(a);
        };
      },
      // property apply
      _applyIcon : function(o, p){

        if(o){

          this._showChildControl(d).setSource(o);
        } else {

          this._excludeChildControl(d);
        };
      },
      // overridden
      _createChildControlImpl : function(q, r){

        var s;
        switch(q){case c:
        s = new qx.ui.basic.Label(this.getLabel()).set({
          anonymous : true,
          allowShrinkX : true
        });
        this._add(s, {
          row : 0,
          column : 1
        });
        break;case a:
        s = new qx.ui.basic.Image(this.getSortIcon());
        s.setAnonymous(true);
        this._add(s, {
          row : 0,
          column : 2
        });
        break;case d:
        s = new qx.ui.basic.Image(this.getIcon()).set({
          anonymous : true,
          allowShrinkX : true
        });
        this._add(s, {
          row : 0,
          column : 0
        });
        break;};
        return s || qx.ui.container.Composite.prototype._createChildControlImpl.call(this, q);
      }
    }
  });
})();
(function(){

  var n = "' must be defined!",m = "height",h = "' is not supported by the Grid layout!",g = "Invalid parameter 'column'",f = "The property '",e = "'",d = "Value must be positive",c = "qx.ui.layout.Grid",b = "maxHeight",a = "Cannot add widget '",M = "width",L = ") for '",K = "'!. ",J = "minHeight",I = "' in this cell (",H = ", ",G = "The layout properties 'row' and 'column' of the child widget '",F = "minWidth",E = "maxWidth",D = "Invalid parameter 'row'",u = "There is already a widget '",v = "vAlign",s = "hAlign",t = "bottom",q = "Integer",r = "_applyLayoutChange",o = "center",p = "middle",w = "right",z = "flex",B = "qx.debug",A = "top",C = "left";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The grid layout manager arranges the items in a two dimensional
   * grid. Widgets can be placed into the grid's cells and may span multiple rows
   * and columns.
   *
   * *Features*
   *
   * * Flex values for rows and columns
   * * Minimal and maximal column and row sizes
   * * Manually setting of column and row sizes
   * * Horizontal and vertical alignment
   * * Horizontal and vertical spacing
   * * Column and row spans
   * * Auto-sizing
   *
   * *Item Properties*
   *
   * <ul>
   * <li><strong>row</strong> <em>(Integer)</em>: The row of the cell the
   *   widget should occupy. Each cell can only contain one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>column</strong> <em>(Integer)</em>: The column of the cell the
   *   widget should occupy. Each cell can only contain one widget. This layout
   *   property is mandatory.
   * </li>
   * <li><strong>rowSpan</strong> <em>(Integer)</em>: The number of rows, the
   *   widget should span, starting from the row specified in the <code>row</code>
   *   property. The cells in the spanned rows must be empty as well.
   * </li>
   * <li><strong>colSpan</strong> <em>(Integer)</em>: The number of columns, the
   *   widget should span, starting from the column specified in the <code>column</code>
   *   property. The cells in the spanned columns must be empty as well.
   * </li>
   * </ul>
   *
   * *Example*
   *
   * Here is a little example of how to use the grid layout.
   *
   * <pre class="javascript">
   * var layout = new qx.ui.layout.Grid();
   * layout.setRowFlex(0, 1); // make row 0 flexible
   * layout.setColumnWidth(1, 200); // set with of column 1 to 200 pixel
   *
   * var container = new qx.ui.container.Composite(layout);
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 0});
   * container.add(new qx.ui.core.Widget(), {row: 0, column: 1});
   * container.add(new qx.ui.core.Widget(), {row: 1, column: 0, rowSpan: 2});
   * </pre>
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/grid.html'>
   * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
   */
  qx.Class.define(c, {
    extend : qx.ui.layout.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param spacingX {Integer?0} The horizontal spacing between grid cells.
     *     Sets {@link #spacingX}.
     * @param spacingY {Integer?0} The vertical spacing between grid cells.
     *     Sets {@link #spacingY}.
     */
    construct : function(N, O){

      qx.ui.layout.Abstract.call(this);
      this.__rowData = [];
      this.__colData = [];
      if(N){

        this.setSpacingX(N);
      };
      if(O){

        this.setSpacingY(O);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The horizontal spacing between grid cells.
       */
      spacingX : {
        check : q,
        init : 0,
        apply : r
      },
      /**
       * The vertical spacing between grid cells.
       */
      spacingY : {
        check : q,
        init : 0,
        apply : r
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {Array} 2D array of grid cell data */
      __grid : null,
      __rowData : null,
      __colData : null,
      __colSpans : null,
      __rowSpans : null,
      __maxRowIndex : null,
      __maxColIndex : null,
      /** {Array} cached row heights */
      __rowHeights : null,
      /** {Array} cached column widths */
      __colWidths : null,
      // overridden
      verifyLayoutProperty : qx.core.Environment.select(B, {
        "true" : function(P, name, Q){

          var R = {
            "row" : 1,
            "column" : 1,
            "rowSpan" : 1,
            "colSpan" : 1
          };
          this.assert(R[name] == 1, f + name + h);
          this.assertInteger(Q);
          this.assert(Q >= 0, d);
        },
        "false" : null
      }),
      /**
       * Rebuild the internal representation of the grid
       */
      __buildGrid : function(){

        var X = [];
        var W = [];
        var Y = [];
        var U = -1;
        var T = -1;
        var bb = this._getLayoutChildren();
        for(var i = 0,l = bb.length;i < l;i++){

          var V = bb[i];
          var ba = V.getLayoutProperties();
          var bc = ba.row;
          var S = ba.column;
          ba.colSpan = ba.colSpan || 1;
          ba.rowSpan = ba.rowSpan || 1;
          // validate arguments
          if(bc == null || S == null){

            throw new Error(G + V + n);
          };
          if(X[bc] && X[bc][S]){

            throw new Error(a + V + K + u + X[bc][S] + I + bc + H + S + L + this + e);
          };
          for(var x = S;x < S + ba.colSpan;x++){

            for(var y = bc;y < bc + ba.rowSpan;y++){

              if(X[y] == undefined){

                X[y] = [];
              };
              X[y][x] = V;
              T = Math.max(T, x);
              U = Math.max(U, y);
            };
          };
          if(ba.rowSpan > 1){

            Y.push(V);
          };
          if(ba.colSpan > 1){

            W.push(V);
          };
        };
        // make sure all columns are defined so that accessing the grid using
        // this.__grid[column][row] will never raise an exception
        for(var y = 0;y <= U;y++){

          if(X[y] == undefined){

            X[y] = [];
          };
        };
        this.__grid = X;
        this.__colSpans = W;
        this.__rowSpans = Y;
        this.__maxRowIndex = U;
        this.__maxColIndex = T;
        this.__rowHeights = null;
        this.__colWidths = null;
        // Clear invalidation marker
        delete this._invalidChildrenCache;
      },
      /**
       * Stores data for a grid row
       *
       * @param row {Integer} The row index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setRowData : function(bd, be, bf){

        var bg = this.__rowData[bd];
        if(!bg){

          this.__rowData[bd] = {
          };
          this.__rowData[bd][be] = bf;
        } else {

          bg[be] = bf;
        };
      },
      /**
       * Stores data for a grid column
       *
       * @param column {Integer} The column index
       * @param key {String} The key under which the data should be stored
       * @param value {var} data to store
       */
      _setColumnData : function(bh, bi, bj){

        var bk = this.__colData[bh];
        if(!bk){

          this.__colData[bh] = {
          };
          this.__colData[bh][bi] = bj;
        } else {

          bk[bi] = bj;
        };
      },
      /**
       * Shortcut to set both horizontal and vertical spacing between grid cells
       * to the same value.
       *
       * @param spacing {Integer} new horizontal and vertical spacing
       * @return {qx.ui.layout.Grid} This object (for chaining support).
       */
      setSpacing : function(bl){

        this.setSpacingY(bl);
        this.setSpacingX(bl);
        return this;
      },
      /**
       * Set the default cell alignment for a column. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param column {Integer} Column index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnAlign : function(bm, bn, bo){

        if(qx.core.Environment.get(B)){

          this.assertInteger(bm, g);
          this.assertInArray(bn, [C, o, w]);
          this.assertInArray(bo, [A, p, t]);
        };
        this._setColumnData(bm, s, bn);
        this._setColumnData(bm, v, bo);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get a map of the column's alignment.
       *
       * @param column {Integer} The column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal column alignment.
       */
      getColumnAlign : function(bp){

        var bq = this.__colData[bp] || {
        };
        return {
          vAlign : bq.vAlign || A,
          hAlign : bq.hAlign || C
        };
      },
      /**
       * Set the default cell alignment for a row. This alignment can be
       * overridden on a per cell basis by setting the cell's content widget's
       * <code>alignX</code> and <code>alignY</code> properties.
       *
       * If on a grid cell both row and a column alignment is set, the horizontal
       * alignment is taken from the column and the vertical alignment is taken
       * from the row.
       *
       * @param row {Integer} Row index
       * @param hAlign {String} The horizontal alignment. Valid values are
       *    "left", "center" and "right".
       * @param vAlign {String} The vertical alignment. Valid values are
       *    "top", "middle", "bottom"
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowAlign : function(br, bs, bt){

        if(qx.core.Environment.get(B)){

          this.assertInteger(br, D);
          this.assertInArray(bs, [C, o, w]);
          this.assertInArray(bt, [A, p, t]);
        };
        this._setRowData(br, s, bs);
        this._setRowData(br, v, bt);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get a map of the row's alignment.
       *
       * @param row {Integer} The Row index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal row alignment.
       */
      getRowAlign : function(bu){

        var bv = this.__rowData[bu] || {
        };
        return {
          vAlign : bv.vAlign || A,
          hAlign : bv.hAlign || C
        };
      },
      /**
       * Get the widget located in the cell. If a the cell is empty or the widget
       * has a {@link qx.ui.core.Widget#visibility} value of <code>exclude</code>,
       * <code>null</code> is returned.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {qx.ui.core.Widget|null}The cell's widget. The value may be null.
       */
      getCellWidget : function(bw, bx){

        if(this._invalidChildrenCache){

          this.__buildGrid();
        };
        var bw = this.__grid[bw] || {
        };
        return bw[bx] || null;
      },
      /**
       * Get the number of rows in the grid layout.
       *
       * @return {Integer} The number of rows in the layout
       */
      getRowCount : function(){

        if(this._invalidChildrenCache){

          this.__buildGrid();
        };
        return this.__maxRowIndex + 1;
      },
      /**
       * Get the number of columns in the grid layout.
       *
       * @return {Integer} The number of columns in the layout
       */
      getColumnCount : function(){

        if(this._invalidChildrenCache){

          this.__buildGrid();
        };
        return this.__maxColIndex + 1;
      },
      /**
       * Get a map of the cell's alignment. For vertical alignment the row alignment
       * takes precedence over the column alignment. For horizontal alignment it is
       * the over way round. If an alignment is set on the cell widget using
       * {@link qx.ui.core.LayoutItem#setLayoutProperties}, this alignment takes
       * always precedence over row or column alignment.
       *
       * @param row {Integer} The cell's row index
       * @param column {Integer} The cell's column index
       * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>
       *     containing the vertical and horizontal cell alignment.
       */
      getCellAlign : function(by, bz){

        var bF = A;
        var bD = C;
        var bE = this.__rowData[by];
        var bB = this.__colData[bz];
        var bA = this.__grid[by][bz];
        if(bA){

          var bC = {
            vAlign : bA.getAlignY(),
            hAlign : bA.getAlignX()
          };
        } else {

          bC = {
          };
        };
        // compute vAlign
        // precedence : widget -> row -> column
        if(bC.vAlign){

          bF = bC.vAlign;
        } else if(bE && bE.vAlign){

          bF = bE.vAlign;
        } else if(bB && bB.vAlign){

          bF = bB.vAlign;
        };;
        // compute hAlign
        // precedence : widget -> column -> row
        if(bC.hAlign){

          bD = bC.hAlign;
        } else if(bB && bB.hAlign){

          bD = bB.hAlign;
        } else if(bE && bE.hAlign){

          bD = bE.hAlign;
        };;
        return {
          vAlign : bF,
          hAlign : bD
        };
      },
      /**
       * Set the flex value for a grid column.
       * By default the column flex value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param flex {Integer} The column's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnFlex : function(bG, bH){

        this._setColumnData(bG, z, bH);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the flex value of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's flex value
       */
      getColumnFlex : function(bI){

        var bJ = this.__colData[bI] || {
        };
        return bJ.flex !== undefined ? bJ.flex : 0;
      },
      /**
       * Set the flex value for a grid row.
       * By default the row flex value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param flex {Integer} The row's flex value
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowFlex : function(bK, bL){

        this._setRowData(bK, z, bL);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the flex value of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's flex value
       */
      getRowFlex : function(bM){

        var bN = this.__rowData[bM] || {
        };
        var bO = bN.flex !== undefined ? bN.flex : 0;
        return bO;
      },
      /**
       * Set the maximum width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param maxWidth {Integer} The column's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMaxWidth : function(bP, bQ){

        this._setColumnData(bP, E, bQ);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the maximum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's maximum width
       */
      getColumnMaxWidth : function(bR){

        var bS = this.__colData[bR] || {
        };
        return bS.maxWidth !== undefined ? bS.maxWidth : Infinity;
      },
      /**
       * Set the preferred width of a grid column.
       * The default value is <code>Infinity</code>.
       *
       * @param column {Integer} The column index
       * @param width {Integer} The column's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnWidth : function(bT, bU){

        this._setColumnData(bT, M, bU);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the preferred width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's width
       */
      getColumnWidth : function(bV){

        var bW = this.__colData[bV] || {
        };
        return bW.width !== undefined ? bW.width : null;
      },
      /**
       * Set the minimum width of a grid column.
       * The default value is <code>0</code>.
       *
       * @param column {Integer} The column index
       * @param minWidth {Integer} The column's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setColumnMinWidth : function(bX, bY){

        this._setColumnData(bX, F, bY);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the minimum width of a grid column.
       *
       * @param column {Integer} The column index
       * @return {Integer} The column's minimum width
       */
      getColumnMinWidth : function(ca){

        var cb = this.__colData[ca] || {
        };
        return cb.minWidth || 0;
      },
      /**
       * Set the maximum height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param maxHeight {Integer} The row's maximum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMaxHeight : function(cc, cd){

        this._setRowData(cc, b, cd);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the maximum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's maximum width
       */
      getRowMaxHeight : function(ce){

        var cf = this.__rowData[ce] || {
        };
        return cf.maxHeight || Infinity;
      },
      /**
       * Set the preferred height of a grid row.
       * The default value is <code>Infinity</code>.
       *
       * @param row {Integer} The row index
       * @param height {Integer} The row's width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowHeight : function(cg, ch){

        this._setRowData(cg, m, ch);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the preferred height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's width
       */
      getRowHeight : function(ci){

        var cj = this.__rowData[ci] || {
        };
        return cj.height !== undefined ? cj.height : null;
      },
      /**
       * Set the minimum height of a grid row.
       * The default value is <code>0</code>.
       *
       * @param row {Integer} The row index
       * @param minHeight {Integer} The row's minimum width
       * @return {qx.ui.layout.Grid} This object (for chaining support)
       */
      setRowMinHeight : function(ck, cl){

        this._setRowData(ck, J, cl);
        this._applyLayoutChange();
        return this;
      },
      /**
       * Get the minimum height of a grid row.
       *
       * @param row {Integer} The row index
       * @return {Integer} The row's minimum width
       */
      getRowMinHeight : function(cm){

        var cn = this.__rowData[cm] || {
        };
        return cn.minHeight || 0;
      },
      /**
       * Computes the widget's size hint including the widget's margins
       *
       * @param widget {qx.ui.core.LayoutItem} The widget to get the size for
       * @return {Map} a size hint map
       */
      __getOuterSize : function(co){

        var cs = co.getSizeHint();
        var cr = co.getMarginLeft() + co.getMarginRight();
        var cq = co.getMarginTop() + co.getMarginBottom();
        var cp = {
          height : cs.height + cq,
          width : cs.width + cr,
          minHeight : cs.minHeight + cq,
          minWidth : cs.minWidth + cr,
          maxHeight : cs.maxHeight + cq,
          maxWidth : cs.maxWidth + cr
        };
        return cp;
      },
      /**
       * Check whether all row spans fit with their preferred height into the
       * preferred row heights. If there is not enough space, the preferred
       * row sizes are increased. The distribution respects the flex and max
       * values of the rows.
       *
       *  The same is true for the min sizes.
       *
       *  The height array is modified in place.
       *
       * @param rowHeights {Map[]} The current row height array as computed by
       *     {@link #_getRowHeights}.
       */
      _fixHeightsRowSpan : function(ct){

        var cA = this.getSpacingY();
        for(var i = 0,l = this.__rowSpans.length;i < l;i++){

          var cH = this.__rowSpans[i];
          var cD = this.__getOuterSize(cH);
          var cw = cH.getLayoutProperties();
          var cC = cw.row;
          var cM = cA * (cw.rowSpan - 1);
          var cu = cM;
          var cx = {
          };
          for(var j = 0;j < cw.rowSpan;j++){

            var cB = cw.row + j;
            var cL = ct[cB];
            var cN = this.getRowFlex(cB);
            if(cN > 0){

              // compute flex array for the preferred height
              cx[cB] = {
                min : cL.minHeight,
                value : cL.height,
                max : cL.maxHeight,
                flex : cN
              };
            };
            cM += cL.height;
            cu += cL.minHeight;
          };
          // If there is not enough space for the preferred size
          // increment the preferred row sizes.
          if(cM < cD.height){

            if(!qx.lang.Object.isEmpty(cx)){

              var cy = qx.ui.layout.Util.computeFlexOffsets(cx, cD.height, cM);
              for(var k = 0;k < cw.rowSpan;k++){

                var cJ = cy[cC + k] ? cy[cC + k].offset : 0;
                ct[cC + k].height += cJ;
              };
            } else {

              var cG = cA * (cw.rowSpan - 1);
              var cE = cD.height - cG;
              // get the row height which every child would need to share the
              // available hight equally
              var cK = Math.floor(cE / cw.rowSpan);
              // get the hight already used and the number of children which do
              // not have at least that avg row height
              var cI = 0;
              var cv = 0;
              for(var k = 0;k < cw.rowSpan;k++){

                var cz = ct[cC + k].height;
                cI += cz;
                if(cz < cK){

                  cv++;
                };
              };
              // the difference of available and used needs to be shared among
              // those not having the min size
              var cF = Math.floor((cE - cI) / cv);
              // add the extra height to the too small children
              for(var k = 0;k < cw.rowSpan;k++){

                if(ct[cC + k].height < cK){

                  ct[cC + k].height += cF;
                };
              };
            };
          };
          // If there is not enough space for the min size
          // increment the min row sizes.
          if(cu < cD.minHeight){

            var cy = qx.ui.layout.Util.computeFlexOffsets(cx, cD.minHeight, cu);
            for(var j = 0;j < cw.rowSpan;j++){

              var cJ = cy[cC + j] ? cy[cC + j].offset : 0;
              ct[cC + j].minHeight += cJ;
            };
          };
        };
      },
      /**
       * Check whether all col spans fit with their preferred width into the
       * preferred column widths. If there is not enough space the preferred
       * column sizes are increased. The distribution respects the flex and max
       * values of the columns.
       *
       *  The same is true for the min sizes.
       *
       *  The width array is modified in place.
       *
       * @param colWidths {Map[]} The current column width array as computed by
       *     {@link #_getColWidths}.
       */
      _fixWidthsColSpan : function(cO){

        var cS = this.getSpacingX();
        for(var i = 0,l = this.__colSpans.length;i < l;i++){

          var cP = this.__colSpans[i];
          var cR = this.__getOuterSize(cP);
          var cU = cP.getLayoutProperties();
          var cQ = cU.column;
          var db = cS * (cU.colSpan - 1);
          var cT = db;
          var cV = {
          };
          var cX;
          for(var j = 0;j < cU.colSpan;j++){

            var dc = cU.column + j;
            var da = cO[dc];
            var cY = this.getColumnFlex(dc);
            // compute flex array for the preferred width
            if(cY > 0){

              cV[dc] = {
                min : da.minWidth,
                value : da.width,
                max : da.maxWidth,
                flex : cY
              };
            };
            db += da.width;
            cT += da.minWidth;
          };
          // If there is not enought space for the preferred size
          // increment the preferred column sizes.
          if(db < cR.width){

            var cW = qx.ui.layout.Util.computeFlexOffsets(cV, cR.width, db);
            for(var j = 0;j < cU.colSpan;j++){

              cX = cW[cQ + j] ? cW[cQ + j].offset : 0;
              cO[cQ + j].width += cX;
            };
          };
          // If there is not enought space for the min size
          // increment the min column sizes.
          if(cT < cR.minWidth){

            var cW = qx.ui.layout.Util.computeFlexOffsets(cV, cR.minWidth, cT);
            for(var j = 0;j < cU.colSpan;j++){

              cX = cW[cQ + j] ? cW[cQ + j].offset : 0;
              cO[cQ + j].minWidth += cX;
            };
          };
        };
      },
      /**
       * Compute the min/pref/max row heights.
       *
       * @return {Map[]} An array containg height information for each row. The
       *     entries have the keys <code>minHeight</code>, <code>maxHeight</code> and
       *     <code>height</code>.
       */
      _getRowHeights : function(){

        if(this.__rowHeights != null){

          return this.__rowHeights;
        };
        var dm = [];
        var df = this.__maxRowIndex;
        var de = this.__maxColIndex;
        for(var dn = 0;dn <= df;dn++){

          var dg = 0;
          var di = 0;
          var dh = 0;
          for(var dl = 0;dl <= de;dl++){

            var dd = this.__grid[dn][dl];
            if(!dd){

              continue;
            };
            // ignore rows with row spans at this place
            // these rows will be taken into account later
            var dj = dd.getLayoutProperties().rowSpan || 0;
            if(dj > 1){

              continue;
            };
            var dk = this.__getOuterSize(dd);
            if(this.getRowFlex(dn) > 0){

              dg = Math.max(dg, dk.minHeight);
            } else {

              dg = Math.max(dg, dk.height);
            };
            di = Math.max(di, dk.height);
          };
          var dg = Math.max(dg, this.getRowMinHeight(dn));
          var dh = this.getRowMaxHeight(dn);
          if(this.getRowHeight(dn) !== null){

            var di = this.getRowHeight(dn);
          } else {

            var di = Math.max(dg, Math.min(di, dh));
          };
          dm[dn] = {
            minHeight : dg,
            height : di,
            maxHeight : dh
          };
        };
        if(this.__rowSpans.length > 0){

          this._fixHeightsRowSpan(dm);
        };
        this.__rowHeights = dm;
        return dm;
      },
      /**
       * Compute the min/pref/max column widths.
       *
       * @return {Map[]} An array containg width information for each column. The
       *     entries have the keys <code>minWidth</code>, <code>maxWidth</code> and
       *     <code>width</code>.
       */
      _getColWidths : function(){

        if(this.__colWidths != null){

          return this.__colWidths;
        };
        var dt = [];
        var dq = this.__maxColIndex;
        var ds = this.__maxRowIndex;
        for(var dy = 0;dy <= dq;dy++){

          var dw = 0;
          var dv = 0;
          var dr = Infinity;
          for(var dz = 0;dz <= ds;dz++){

            var dp = this.__grid[dz][dy];
            if(!dp){

              continue;
            };
            // ignore columns with col spans at this place
            // these columns will be taken into account later
            var du = dp.getLayoutProperties().colSpan || 0;
            if(du > 1){

              continue;
            };
            var dx = this.__getOuterSize(dp);
            if(this.getColumnFlex(dy) > 0){

              dv = Math.max(dv, dx.minWidth);
            } else {

              dv = Math.max(dv, dx.width);
            };
            dw = Math.max(dw, dx.width);
          };
          dv = Math.max(dv, this.getColumnMinWidth(dy));
          dr = this.getColumnMaxWidth(dy);
          if(this.getColumnWidth(dy) !== null){

            var dw = this.getColumnWidth(dy);
          } else {

            var dw = Math.max(dv, Math.min(dw, dr));
          };
          dt[dy] = {
            minWidth : dv,
            width : dw,
            maxWidth : dr
          };
        };
        if(this.__colSpans.length > 0){

          this._fixWidthsColSpan(dt);
        };
        this.__colWidths = dt;
        return dt;
      },
      /**
       * Computes for each column by how many pixels it must grow or shrink, taking
       * the column flex values and min/max widths into account.
       *
       * @param width {Integer} The grid width
       * @return {Integer[]} Sparse array of offsets to add to each column width. If
       *     an array entry is empty nothing should be added to the column.
       */
      _getColumnFlexOffsets : function(dA){

        var dB = this.getSizeHint();
        var dF = dA - dB.width;
        if(dF == 0){

          return {
          };
        };
        // collect all flexible children
        var dD = this._getColWidths();
        var dC = {
        };
        for(var i = 0,l = dD.length;i < l;i++){

          var dG = dD[i];
          var dE = this.getColumnFlex(i);
          if((dE <= 0) || (dG.width == dG.maxWidth && dF > 0) || (dG.width == dG.minWidth && dF < 0)){

            continue;
          };
          dC[i] = {
            min : dG.minWidth,
            value : dG.width,
            max : dG.maxWidth,
            flex : dE
          };
        };
        return qx.ui.layout.Util.computeFlexOffsets(dC, dA, dB.width);
      },
      /**
       * Computes for each row by how many pixels it must grow or shrink, taking
       * the row flex values and min/max heights into account.
       *
       * @param height {Integer} The grid height
       * @return {Integer[]} Sparse array of offsets to add to each row height. If
       *     an array entry is empty nothing should be added to the row.
       */
      _getRowFlexOffsets : function(dH){

        var dI = this.getSizeHint();
        var dL = dH - dI.height;
        if(dL == 0){

          return {
          };
        };
        // collect all flexible children
        var dM = this._getRowHeights();
        var dJ = {
        };
        for(var i = 0,l = dM.length;i < l;i++){

          var dN = dM[i];
          var dK = this.getRowFlex(i);
          if((dK <= 0) || (dN.height == dN.maxHeight && dL > 0) || (dN.height == dN.minHeight && dL < 0)){

            continue;
          };
          dJ[i] = {
            min : dN.minHeight,
            value : dN.height,
            max : dN.maxHeight,
            flex : dK
          };
        };
        return qx.ui.layout.Util.computeFlexOffsets(dJ, dH, dI.height);
      },
      // overridden
      renderLayout : function(dO, dP){

        if(this._invalidChildrenCache){

          this.__buildGrid();
        };
        var ee = qx.ui.layout.Util;
        var dR = this.getSpacingX();
        var dX = this.getSpacingY();
        // calculate column widths
        var ej = this._getColWidths();
        var ei = this._getColumnFlexOffsets(dO);
        var dS = [];
        var el = this.__maxColIndex;
        var dQ = this.__maxRowIndex;
        var ek;
        for(var em = 0;em <= el;em++){

          ek = ei[em] ? ei[em].offset : 0;
          dS[em] = ej[em].width + ek;
        };
        // calculate row heights
        var eb = this._getRowHeights();
        var ed = this._getRowFlexOffsets(dP);
        var es = [];
        for(var dY = 0;dY <= dQ;dY++){

          ek = ed[dY] ? ed[dY].offset : 0;
          es[dY] = eb[dY].height + ek;
        };
        // do the layout
        var et = 0;
        for(var em = 0;em <= el;em++){

          var top = 0;
          for(var dY = 0;dY <= dQ;dY++){

            var eg = this.__grid[dY][em];
            // ignore empty cells
            if(!eg){

              top += es[dY] + dX;
              continue;
            };
            var dT = eg.getLayoutProperties();
            // ignore cells, which have cell spanning but are not the origin
            // of the widget
            if(dT.row !== dY || dT.column !== em){

              top += es[dY] + dX;
              continue;
            };
            // compute sizes width including cell spanning
            var er = dR * (dT.colSpan - 1);
            for(var i = 0;i < dT.colSpan;i++){

              er += dS[em + i];
            };
            var eh = dX * (dT.rowSpan - 1);
            for(var i = 0;i < dT.rowSpan;i++){

              eh += es[dY + i];
            };
            var dU = eg.getSizeHint();
            var ep = eg.getMarginTop();
            var ef = eg.getMarginLeft();
            var ec = eg.getMarginBottom();
            var dW = eg.getMarginRight();
            var ea = Math.max(dU.minWidth, Math.min(er - ef - dW, dU.maxWidth));
            var eq = Math.max(dU.minHeight, Math.min(eh - ep - ec, dU.maxHeight));
            var en = this.getCellAlign(dY, em);
            var eo = et + ee.computeHorizontalAlignOffset(en.hAlign, ea, er, ef, dW);
            var dV = top + ee.computeVerticalAlignOffset(en.vAlign, eq, eh, ep, ec);
            eg.renderLayout(eo, dV, ea, eq);
            top += es[dY] + dX;
          };
          et += dS[em] + dR;
        };
      },
      // overridden
      invalidateLayoutCache : function(){

        qx.ui.layout.Abstract.prototype.invalidateLayoutCache.call(this);
        this.__colWidths = null;
        this.__rowHeights = null;
      },
      // overridden
      _computeSizeHint : function(){

        if(this._invalidChildrenCache){

          this.__buildGrid();
        };
        // calculate col widths
        var ey = this._getColWidths();
        var eA = 0,eB = 0;
        for(var i = 0,l = ey.length;i < l;i++){

          var eC = ey[i];
          if(this.getColumnFlex(i) > 0){

            eA += eC.minWidth;
          } else {

            eA += eC.width;
          };
          eB += eC.width;
        };
        // calculate row heights
        var eD = this._getRowHeights();
        var ew = 0,ez = 0;
        for(var i = 0,l = eD.length;i < l;i++){

          var eE = eD[i];
          if(this.getRowFlex(i) > 0){

            ew += eE.minHeight;
          } else {

            ew += eE.height;
          };
          ez += eE.height;
        };
        var ev = this.getSpacingX() * (ey.length - 1);
        var eu = this.getSpacingY() * (eD.length - 1);
        var ex = {
          minWidth : eA + ev,
          width : eB + ev,
          minHeight : ew + eu,
          height : ez + eu
        };
        return ex;
      }
    },
    /*
    *****************************************************************************
       DESTRUCT
    *****************************************************************************
    */
    destruct : function(){

      this.__grid = this.__rowData = this.__colData = this.__colSpans = this.__rowSpans = this.__colWidths = this.__rowHeights = null;
    }
  });
})();
(function(){

  var k = "Invalid argument 'colCount'.",j = "__editorFactory",h = "__dataRenderer",g = "Invalid argument 'visible'.",f = "__headerRenderer",e = "Invalid argument 'factory'.",d = "Invalid argument 'newPositions'.",c = "Invalid argument 'width'.",b = "Invalid argument 'visXPos'.",a = "Invalid argument 'toOverXPos'.",C = "qx.ui.table.columnmodel.Basic",B = "headerCellRendererChanged",A = ". The column is not added to this TablePaneModel.",z = "setColumnsOrder: Invalid number of column positions given, expected ",y = "widthChanged",w = "Invalid argument 'overXPos'.",v = ", got ",u = "Invalid argument 'fromOverXPos'.",t = "Showing column failed: ",s = "orderChanged",q = "Invalid argument 'renderer'.",r = "visibilityChanged",o = "visibilityChangedPre",p = "qx.event.type.Data",m = "Column not found in table model",n = "Invalid argument 'col'.",l = "qx.debug";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * A model that contains all meta data about columns, such as width, renderer,
   * visibility and order.
   *
   * @see qx.ui.table.ITableModel
   */
  qx.Class.define(C, {
    extend : qx.core.Object,
    construct : function(){

      qx.core.Object.call(this);
      this.__overallColumnArr = [];
      this.__visibleColumnArr = [];
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Fired when the width of a column has changed. The data property of the event is
       * a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the width of which has changed.</li>
       *   <li>newWidth: The new width of the column in pixels.</li>
       *   <li>oldWidth: The old width of the column in pixels.</li>
       * </ul>
       */
      "widthChanged" : p,
      /**
       * Fired when the visibility of a column has changed. This event is equal to
        * "visibilityChanged", but is fired right before.
       */
      "visibilityChangedPre" : p,
      /**
       * Fired when the visibility of a column has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column the visibility of which has changed.</li>
       *   <li>visible: Whether the column is now visible.</li>
       * </ul>
       */
      "visibilityChanged" : p,
      /**
       * Fired when the column order has changed. The data property of the
       * event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       *   <li>fromOverXPos: The old overall x position of the column.</li>
       *   <li>toOverXPos: The new overall x position of the column.</li>
       * </ul>
       */
      "orderChanged" : p,
      /**
       * Fired when the cell renderer of a column has changed.
       * The data property of the event is a map having the following attributes:
       * <ul>
       *   <li>col: The model index of the column that was moved.</li>
       * </ul>
       */
      "headerCellRendererChanged" : p
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Integer} the default width of a column in pixels. */
      DEFAULT_WIDTH : 100,
      /** {qx.ui.table.headerrenderer.Default} the default header cell renderer. */
      DEFAULT_HEADER_RENDERER : qx.ui.table.headerrenderer.Default,
      /** {qx.ui.table.cellrenderer.Default} the default data cell renderer. */
      DEFAULT_DATA_RENDERER : qx.ui.table.cellrenderer.Default,
      /** {qx.ui.table.celleditor.TextField} the default editor factory. */
      DEFAULT_EDITOR_FACTORY : qx.ui.table.celleditor.TextField
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __internalChange : null,
      __colToXPosMap : null,
      __visibleColumnArr : null,
      __overallColumnArr : null,
      __columnDataArr : null,
      __headerRenderer : null,
      __dataRenderer : null,
      __editorFactory : null,
      /**
       * Initializes the column model.
       *
       * @param colCount {Integer}
       *   The number of columns the model should have.
       *
       * @param table {qx.ui.table.Table}
       *   The table to which this column model is attached.
       */
      init : function(D, E){

        if(qx.core.Environment.get(l)){

          this.assertInteger(D, k);
        };
        this.__columnDataArr = [];
        var I = qx.ui.table.columnmodel.Basic.DEFAULT_WIDTH;
        var J = this.__headerRenderer || (this.__headerRenderer = new qx.ui.table.columnmodel.Basic.DEFAULT_HEADER_RENDERER());
        var G = this.__dataRenderer || (this.__dataRenderer = new qx.ui.table.columnmodel.Basic.DEFAULT_DATA_RENDERER());
        var F = this.__editorFactory || (this.__editorFactory = new qx.ui.table.columnmodel.Basic.DEFAULT_EDITOR_FACTORY());
        this.__overallColumnArr = [];
        this.__visibleColumnArr = [];
        // Get the initially hidden column array, if one was provided. Older
        // subclasses may not provide the 'table' argument, so we treat them
        // traditionally with no initially hidden columns.
        var L;
        // Was a table provided to us?
        if(E){

          // Yup. Get its list of initially hidden columns, if the user provided
          // such a list.
          L = E.getInitiallyHiddenColumns();
        };
        // If no table was specified, or if the user didn't provide a list of
        // initially hidden columns, use an empty list.
        L = L || [];
        for(var M = 0;M < D;M++){

          this.__columnDataArr[M] = {
            width : I,
            headerRenderer : J,
            dataRenderer : G,
            editorFactory : F
          };
          this.__overallColumnArr[M] = M;
          this.__visibleColumnArr[M] = M;
        };
        this.__colToXPosMap = null;
        // If any columns are initialy hidden, hide them now. Make it an
        // internal change so that events are not generated.
        this.__internalChange = true;
        for(var K = 0;K < L.length;K++){

          this.setColumnVisible(L[K], false);
        };
        this.__internalChange = false;
        for(M = 0;M < D;M++){

          var H = {
            col : M,
            visible : this.isColumnVisible(M)
          };
          this.fireDataEvent(o, H);
          this.fireDataEvent(r, H);
        };
      },
      /**
       * Return the array of visible columns
       *
       * @return {Array} List of all visible columns
       */
      getVisibleColumns : function(){

        return this.__visibleColumnArr != null ? this.__visibleColumnArr : [];
      },
      /**
       * Sets the width of a column.
       *
       * @param col {Integer}
       *   The model index of the column.
       *
       * @param width {Integer}
       *   The new width the column should get in pixels.
       *
       * @param isMouseAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   mouse drag in the header; false or undefined otherwise.
       *
       * @return {void}
       */
      setColumnWidth : function(N, O, P){

        if(qx.core.Environment.get(l)){

          this.assertInteger(N, n);
          this.assertInteger(O, c);
          this.assertNotUndefined(this.__columnDataArr[N], m);
        };
        var R = this.__columnDataArr[N].width;
        if(R != O){

          this.__columnDataArr[N].width = O;
          var Q = {
            col : N,
            newWidth : O,
            oldWidth : R,
            isMouseAction : P || false
          };
          this.fireDataEvent(y, Q);
        };
      },
      /**
       * Returns the width of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the width of the column in pixels.
       */
      getColumnWidth : function(S){

        if(qx.core.Environment.get(l)){

          this.assertInteger(S, n);
          this.assertNotUndefined(this.__columnDataArr[S], m);
        };
        return this.__columnDataArr[S].width;
      },
      /**
       * Sets the header renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.IHeaderRenderer} the new header renderer the column
       *      should get.
       * @return {void}
       */
      setHeaderCellRenderer : function(T, U){

        if(qx.core.Environment.get(l)){

          this.assertInteger(T, n);
          this.assertInterface(U, qx.ui.table.IHeaderRenderer, q);
          this.assertNotUndefined(this.__columnDataArr[T], m);
        };
        var V = this.__columnDataArr[T].headerRenderer;
        if(V !== this.__headerRenderer){

          V.dispose();
        };
        this.__columnDataArr[T].headerRenderer = U;
        this.fireDataEvent(B, {
          col : T
        });
      },
      /**
       * Returns the header renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.IHeaderRenderer} the header renderer of the column.
       */
      getHeaderCellRenderer : function(W){

        if(qx.core.Environment.get(l)){

          this.assertInteger(W, n);
          this.assertNotUndefined(this.__columnDataArr[W], m);
        };
        return this.__columnDataArr[W].headerRenderer;
      },
      /**
       * Sets the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param renderer {qx.ui.table.ICellRenderer} the new data renderer
       *   the column should get.
       * @return {qx.ui.table.ICellRenderer?null} If an old renderer was set and
       *   it was not the default renderer, the old renderer is returned for
       *   pooling or disposing.
       */
      setDataCellRenderer : function(X, Y){

        if(qx.core.Environment.get(l)){

          this.assertInteger(X, n);
          this.assertInterface(Y, qx.ui.table.ICellRenderer, q);
          this.assertNotUndefined(this.__columnDataArr[X], m);
        };
        this.__columnDataArr[X].dataRenderer = Y;
        var ba = this.__columnDataArr[X].dataRenderer;
        if(ba !== this.__dataRenderer){

          return ba;
        };
        return null;
      },
      /**
       * Returns the data renderer of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellRenderer} the data renderer of the column.
       */
      getDataCellRenderer : function(bb){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bb, n);
          this.assertNotUndefined(this.__columnDataArr[bb], m);
        };
        return this.__columnDataArr[bb].dataRenderer;
      },
      /**
       * Sets the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @param factory {qx.ui.table.ICellEditorFactory} the new cell editor factory the column should get.
       * @return {void}
       */
      setCellEditorFactory : function(bc, bd){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bc, n);
          this.assertInterface(bd, qx.ui.table.ICellEditorFactory, e);
          this.assertNotUndefined(this.__columnDataArr[bc], m);
        };
        var be = this.__columnDataArr[bc].editorFactory;
        if(be !== this.__editorFactory){

          be.dispose();
        };
        this.__columnDataArr[bc].editorFactory = bd;
      },
      /**
       * Returns the cell editor factory of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {qx.ui.table.ICellEditorFactory} the cell editor factory of the column.
       */
      getCellEditorFactory : function(bf){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bf, n);
          this.assertNotUndefined(this.__columnDataArr[bf], m);
        };
        return this.__columnDataArr[bf].editorFactory;
      },
      /**
       * Returns the map that translates model indexes to x positions.
       *
       * The returned map contains for a model index (int) a map having two
       * properties: overX (the overall x position of the column, int) and
       * visX (the visible x position of the column, int). visX is missing for
       * hidden columns.
       *
       * @return {Map} the "column to x position" map.
       */
      _getColToXPosMap : function(){

        if(this.__colToXPosMap == null){

          this.__colToXPosMap = {
          };
          for(var bi = 0;bi < this.__overallColumnArr.length;bi++){

            var bh = this.__overallColumnArr[bi];
            this.__colToXPosMap[bh] = {
              overX : bi
            };
          };
          for(var bg = 0;bg < this.__visibleColumnArr.length;bg++){

            var bh = this.__visibleColumnArr[bg];
            this.__colToXPosMap[bh].visX = bg;
          };
        };
        return this.__colToXPosMap;
      },
      /**
       * Returns the number of visible columns.
       *
       * @return {Integer} the number of visible columns.
       */
      getVisibleColumnCount : function(){

        return this.__visibleColumnArr != null ? this.__visibleColumnArr.length : 0;
      },
      /**
       * Returns the model index of a column at a certain visible x position.
       *
       * @param visXPos {Integer} the visible x position of the column.
       * @return {Integer} the model index of the column.
       */
      getVisibleColumnAtX : function(bj){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bj, b);
        };
        return this.__visibleColumnArr[bj];
      },
      /**
       * Returns the visible x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the visible x position of the column.
       */
      getVisibleX : function(bk){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bk, n);
        };
        return this._getColToXPosMap()[bk].visX;
      },
      /**
       * Returns the overall number of columns (including hidden columns).
       *
       * @return {Integer} the overall number of columns.
       */
      getOverallColumnCount : function(){

        return this.__overallColumnArr.length;
      },
      /**
       * Returns the model index of a column at a certain overall x position.
       *
       * @param overXPos {Integer} the overall x position of the column.
       * @return {Integer} the model index of the column.
       */
      getOverallColumnAtX : function(bl){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bl, w);
        };
        return this.__overallColumnArr[bl];
      },
      /**
       * Returns the overall x position of a column.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the overall x position of the column.
       */
      getOverallX : function(bm){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bm, n);
        };
        return this._getColToXPosMap()[bm].overX;
      },
      /**
       * Returns whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @return {Boolean} whether the column is visible.
       */
      isColumnVisible : function(bn){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bn, n);
        };
        return (this._getColToXPosMap()[bn].visX != null);
      },
      /**
       * Sets whether a certain column is visible.
       *
       * @param col {Integer} the model index of the column.
       * @param visible {Boolean} whether the column should be visible.
       * @return {void}
       */
      setColumnVisible : function(bo, bp){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bo, n);
          this.assertBoolean(bp, g);
        };
        if(bp != this.isColumnVisible(bo)){

          if(bp){

            var bv = this._getColToXPosMap();
            var bs = bv[bo].overX;
            if(bs == null){

              throw new Error(t + bo + A);
            };
            // get the visX of the next visible column after the column to show
            var bt;
            for(var x = bs + 1;x < this.__overallColumnArr.length;x++){

              var bu = this.__overallColumnArr[x];
              var bq = bv[bu].visX;
              if(bq != null){

                bt = bq;
                break;
              };
            };
            // If there comes no visible column any more, then show the column
            // at the end
            if(bt == null){

              bt = this.__visibleColumnArr.length;
            };
            // Add the column to the visible columns
            this.__visibleColumnArr.splice(bt, 0, bo);
          } else {

            var br = this.getVisibleX(bo);
            this.__visibleColumnArr.splice(br, 1);
          };
          // Invalidate the __colToXPosMap
          this.__colToXPosMap = null;
          // Inform the listeners
          if(!this.__internalChange){

            var bw = {
              col : bo,
              visible : bp
            };
            this.fireDataEvent(o, bw);
            this.fireDataEvent(r, bw);
          };
        };
      },
      /**
       * Moves a column.
       *
       * @param fromOverXPos {Integer} the overall x position of the column to move.
       * @param toOverXPos {Integer} the overall x position of where the column should be
       *      moved to.
       */
      moveColumn : function(bx, by){

        if(qx.core.Environment.get(l)){

          this.assertInteger(bx, u);
          this.assertInteger(by, a);
        };
        this.__internalChange = true;
        var bB = this.__overallColumnArr[bx];
        var bz = this.isColumnVisible(bB);
        if(bz){

          this.setColumnVisible(bB, false);
        };
        this.__overallColumnArr.splice(bx, 1);
        this.__overallColumnArr.splice(by, 0, bB);
        // Invalidate the __colToXPosMap
        this.__colToXPosMap = null;
        if(bz){

          this.setColumnVisible(bB, true);
        };
        this.__internalChange = false;
        // Inform the listeners
        var bA = {
          col : bB,
          fromOverXPos : bx,
          toOverXPos : by
        };
        this.fireDataEvent(s, bA);
      },
      /**
       * Reorders all columns to new overall positions. Will fire one "orderChanged" event
       * without data afterwards
       *
       * @param newPositions {Integer[]} Array mapping the index of a column in table model to its wanted overall
       *                            position on screen (both zero based). If the table models holds
       *                            col0, col1, col2 and col3 and you give [1,3,2,0], the new column order
       *                            will be col3, col0, col2, col1
       */
      setColumnsOrder : function(bC){

        if(qx.core.Environment.get(l)){

          this.assertArray(bC, d);
        };
        if(bC.length == this.__overallColumnArr.length){

          this.__internalChange = true;
          // Go through each column an switch visible ones to invisible. Reason is unknown,
          // this just mimicks the behaviour of moveColumn. Possibly useful because setting
          // a column visible later updates a map with its screen coords.
          var bF = new Array(bC.length);
          for(var bD = 0;bD < this.__overallColumnArr.length;bD++){

            var bE = this.isColumnVisible(bD);
            bF[bD] = bE;
            //Remember, as this relies on this.__colToXPosMap which is cleared below
            if(bE){

              this.setColumnVisible(bD, false);
            };
          };
          // Store new position values
          this.__overallColumnArr = qx.lang.Array.clone(bC);
          // Invalidate the __colToXPosMap
          this.__colToXPosMap = null;
          // Go through each column an switch invisible ones back to visible
          for(var bD = 0;bD < this.__overallColumnArr.length;bD++){

            if(bF[bD]){

              this.setColumnVisible(bD, true);
            };
          };
          this.__internalChange = false;
          // Inform the listeners. Do not add data as all known listeners in qooxdoo
          // only take this event to mean "total repaint necesscary". Fabian will look
          // after deprecating the data part of the orderChanged - event
          this.fireDataEvent(s);
        } else {

          throw new Error(z + this.__overallColumnArr.length + v + bC.length);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      for(var i = 0;i < this.__columnDataArr.length;i++){

        this.__columnDataArr[i].headerRenderer.dispose();
        this.__columnDataArr[i].dataRenderer.dispose();
        this.__columnDataArr[i].editorFactory.dispose();
      };
      this.__overallColumnArr = this.__visibleColumnArr = this.__columnDataArr = this.__colToXPosMap = null;
      this._disposeObjects(f, h, j);
    }
  });
})();
(function(){

  var k = '<div>',j = "</div>",h = "overflow: hidden;",g = "qx.event.type.Data",f = "paneReloadsData",e = "div",d = 'style="',c = "_applyMaxCacheLines",b = "qx.ui.table.pane.Pane",a = "width: 100%;",E = "qx.event.type.Event",D = "_applyVisibleRowCount",C = '>',B = "line-height: ",A = "appear",z = 'class="',w = "width:100%;",v = "px;",u = '<div ',t = "'>",r = "_applyFirstVisibleRow",s = "<div style='",p = ";position:relative;",q = '</div>',n = '" ',o = "paneUpdated",l = "Number",m = "";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The table pane that shows a certain section from a table. This class handles
   * the display of the data part of a table and is therefore the base for virtual
   * scrolling.
   */
  qx.Class.define(b, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct : function(F){

      qx.ui.core.Widget.call(this);
      this.__paneScroller = F;
      this.__lastColCount = 0;
      this.__lastRowCount = 0;
      this.__rowCache = [];
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Whether the current view port of the pane has not loaded data.
       * The data object of the event indicates if the table pane has to reload
       * data or not. Can be used to give the user feedback of the loading state
       * of the rows.
       */
      "paneReloadsData" : g,
      /**
       * Whenever the content of the table panehas been updated (rendered)
       * trigger a paneUpdated event. This allows the canvas cellrenderer to act
       * once the new cells have been integrated in the dom.
       */
      "paneUpdated" : E
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The index of the first row to show. */
      firstVisibleRow : {
        check : l,
        init : 0,
        apply : r
      },
      /** The number of rows to show. */
      visibleRowCount : {
        check : l,
        init : 0,
        apply : D
      },
      /**
       * Maximum number of cached rows. If the value is <code>-1</code> the cache
       * size is unlimited
       */
      maxCacheLines : {
        check : l,
        init : 1000,
        apply : c
      },
      // overridden
      allowShrinkX : {
        refine : true,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lastRowCount : null,
      __lastColCount : null,
      __paneScroller : null,
      __tableContainer : null,
      __focusedRow : null,
      __focusedCol : null,
      // sparse array to cache rendered rows
      __rowCache : null,
      __rowCacheCount : 0,
      // property modifier
      _applyFirstVisibleRow : function(G, H){

        this.updateContent(false, G - H);
      },
      // property modifier
      _applyVisibleRowCount : function(I, J){

        this.updateContent(true);
      },
      // overridden
      _getContentHint : function(){

        // the preferred height is 400 pixel. We don't use rowCount * rowHeight
        // because this is typically too large.
        return {
          width : this.getPaneScroller().getTablePaneModel().getTotalWidth(),
          height : 400
        };
      },
      /**
       * Returns the TablePaneScroller this pane belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller : function(){

        return this.__paneScroller;
      },
      /**
       * Returns the table this pane belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable : function(){

        return this.__paneScroller.getTable();
      },
      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer?null} the model index of the focused cell's column.
       * @param row {Integer?null} the model index of the focused cell's row.
       * @param massUpdate {Boolean ? false} Whether other updates are planned as well.
       *          If true, no repaint will be done.
       * @return {void}
       */
      setFocusedCell : function(K, L, M){

        if(K != this.__focusedCol || L != this.__focusedRow){

          var N = this.__focusedRow;
          this.__focusedCol = K;
          this.__focusedRow = L;
          // Update the focused row background
          if(L != N && !M){

            if(N !== null){

              this.updateContent(false, null, N, true);
            };
            if(L !== null){

              this.updateContent(false, null, L, true);
            };
          };
        };
      },
      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged : function(){

        this.updateContent(false, null, null, true);
      },
      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged : function(){

        this.updateContent(false, null, null, true);
      },
      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       * @return {void}
       */
      setColumnWidth : function(O, P){

        this.updateContent(true);
      },
      /**
       * Event handler. Called the column order has changed.
       *
       * @return {void}
       */
      onColOrderChanged : function(){

        this.updateContent(true);
      },
      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged : function(){

        this.updateContent(true);
      },
      /**
       * Event handler. Called when the table model data has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged : function(Q, R, S, T){

        this.__rowCacheClear();
        var V = this.getFirstVisibleRow();
        var U = this.getVisibleRowCount();
        if(R == -1 || R >= V && Q < V + U){

          // The change intersects this pane
          this.updateContent();
        };
      },
      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @return {void}
       */
      onTableModelMetaDataChanged : function(){

        this.updateContent(true);
      },
      // property apply method
      _applyMaxCacheLines : function(W, X){

        if(this.__rowCacheCount >= W && W !== -1){

          this.__rowCacheClear();
        };
      },
      /**
       * Clear the row cache
       */
      __rowCacheClear : function(){

        this.__rowCache = [];
        this.__rowCacheCount = 0;
      },
      /**
       * Get a line from the row cache.
       *
       * @param row {Integer} Row index to get
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       * @return {String|null} The cached row or null if a row with the given
       *     index is not cached.
       */
      __rowCacheGet : function(Y, ba, bb){

        if(!ba && !bb && this.__rowCache[Y]){

          return this.__rowCache[Y];
        } else {

          return null;
        };
      },
      /**
       * Add a line to the row cache.
       *
       * @param row {Integer} Row index to set
       * @param rowString {String} computed row string to cache
       * @param selected {Boolean} Whether the row is currently selected
       * @param focused {Boolean} Whether the row is currently focused
       */
      __rowCacheSet : function(bc, bd, be, bf){

        var bg = this.getMaxCacheLines();
        if(!be && !bf && !this.__rowCache[bc] && bg > 0){

          this._applyMaxCacheLines(bg);
          this.__rowCache[bc] = bd;
          this.__rowCacheCount += 1;
        };
      },
      /**
       * Updates the content of the pane.
       *
       * @param completeUpdate {Boolean ? false} if true a complete update is performed.
       *      On a complete update all cell widgets are recreated.
       * @param scrollOffset {Integer ? null} If set specifies how many rows to scroll.
       * @param onlyRow {Integer ? null} if set only the specified row will be updated.
       * @param onlySelectionOrFocusChanged {Boolean ? false} if true, cell values won't
       *          be updated. Only the row background will.
       * @return {void}
       */
      updateContent : function(bh, bi, bj, bk){

        if(bh){

          this.__rowCacheClear();
        };
        //var start = new Date();
        if(bi && Math.abs(bi) <= Math.min(10, this.getVisibleRowCount())){

          //this.debug("scroll", scrollOffset);
          this._scrollContent(bi);
        } else if(bk && !this.getTable().getAlwaysUpdateCells()){

          //this.debug("update row styles");
          this._updateRowStyles(bj);
        } else {

          //this.debug("full update");
          this._updateAllRows();
        };
      },
      /**
       * If only focus or selection changes it is sufficient to only update the
       * row styles. This method updates the row styles of all visible rows or
       * of just one row.
       *
       * @param onlyRow {Integer|null ? null} If this parameter is set only the row
       *     with this index is updated.
       */
      _updateRowStyles : function(bl){

        var bp = this.getContentElement().getDomElement();
        if(!bp || !bp.firstChild){

          this._updateAllRows();
          return;
        };
        var bt = this.getTable();
        var bn = bt.getSelectionModel();
        var bq = bt.getTableModel();
        var bu = bt.getDataRowRenderer();
        var bo = bp.firstChild.childNodes;
        var bs = {
          table : bt
        };
        // We don't want to execute the row loop below more than necessary. If
        // onlyrow is not null, we want to do the loop only for that row.
        // In that case, we start at (set the "row" variable to) that row, and
        // stop at (set the "end" variable to the offset of) the next row.
        var bv = this.getFirstVisibleRow();
        var y = 0;
        // How many rows do we need to update?
        var bm = bo.length;
        if(bl != null){

          // How many rows are we skipping?
          var br = bl - bv;
          if(br >= 0 && br < bm){

            bv = bl;
            y = br;
            bm = br + 1;
          } else {

            return;
          };
        };
        for(;y < bm;y++,bv++){

          bs.row = bv;
          bs.selected = bn.isSelectedIndex(bv);
          bs.focusedRow = (this.__focusedRow == bv);
          bs.rowData = bq.getRowData(bv);
          bu.updateDataRowElement(bs, bo[y]);
        };
      },
      /**
       * Get the HTML table fragment for the given row range.
       *
       * @param firstRow {Integer} Index of the first row
       * @param rowCount {Integer} Number of rows
       * @return {String} The HTML table fragment for the given row range.
       */
      _getRowsHtml : function(bw, bx){

        var bD = this.getTable();
        var bG = bD.getSelectionModel();
        var bA = bD.getTableModel();
        var bB = bD.getTableColumnModel();
        var bV = this.getPaneScroller().getTablePaneModel();
        var bL = bD.getDataRowRenderer();
        bA.prefetchRows(bw, bw + bx - 1);
        var bS = bD.getRowHeight();
        var bU = bV.getColumnCount();
        var bC = 0;
        var bz = [];
        // precompute column properties
        for(var x = 0;x < bU;x++){

          var bY = bV.getColumnAtX(x);
          var bF = bB.getColumnWidth(bY);
          bz.push({
            col : bY,
            xPos : x,
            editable : bA.isColumnEditable(bY),
            focusedCol : this.__focusedCol == bY,
            styleLeft : bC,
            styleWidth : bF
          });
          bC += bF;
        };
        var bX = [];
        var ca = false;
        for(var bE = bw;bE < bw + bx;bE++){

          var bH = bG.isSelectedIndex(bE);
          var bK = (this.__focusedRow == bE);
          var bP = this.__rowCacheGet(bE, bH, bK);
          if(bP){

            bX.push(bP);
            continue;
          };
          var by = [];
          var bR = {
            table : bD
          };
          bR.styleHeight = bS;
          bR.row = bE;
          bR.selected = bH;
          bR.focusedRow = bK;
          bR.rowData = bA.getRowData(bE);
          if(!bR.rowData){

            ca = true;
          };
          by.push(u);
          var bO = bL.getRowAttributes(bR);
          if(bO){

            by.push(bO);
          };
          var bN = bL.getRowClass(bR);
          if(bN){

            by.push(z, bN, n);
          };
          var bM = bL.createRowStyle(bR);
          bM += p + bL.getRowHeightStyle(bS) + w;
          if(bM){

            by.push(d, bM, n);
          };
          by.push(C);
          var bW = false;
          for(x = 0;x < bU && !bW;x++){

            var bI = bz[x];
            for(var bT in bI){

              bR[bT] = bI[bT];
            };
            var bY = bR.col;
            // Use the "getValue" method of the tableModel to get the cell's
            // value working directly on the "rowData" object
            // (-> cellInfo.rowData[col];) is not a solution because you can't
            // work with the columnIndex -> you have to use the columnId of the
            // columnIndex This is exactly what the method "getValue" does
            bR.value = bA.getValue(bY, bE);
            var bJ = bB.getDataCellRenderer(bY);
            // Retrieve the current default cell style for this column.
            bR.style = bJ.getDefaultCellStyle();
            // Allow a cell renderer to tell us not to draw any further cells in
            // the row. Older, or traditional cell renderers don't return a
            // value, however, from createDataCellHtml, so assume those are
            // returning false.
            //
            // Tested with http://tinyurl.com/333hyhv
            bW = bJ.createDataCellHtml(bR, by) || false;
          };
          by.push(q);
          var bQ = by.join(m);
          this.__rowCacheSet(bE, bQ, bH, bK);
          bX.push(bQ);
        };
        this.fireDataEvent(f, ca);
        return bX.join(m);
      },
      /**
       * Scrolls the pane's contents by the given offset.
       *
       * @param rowOffset {Integer} Number of lines to scroll. Scrolling up is
       *     represented by a negative offset.
       */
      _scrollContent : function(cb){

        var cc = this.getContentElement().getDomElement();
        if(!(cc && cc.firstChild)){

          this._updateAllRows();
          return;
        };
        var cl = cc.firstChild;
        var cd = cl.childNodes;
        var cj = this.getVisibleRowCount();
        var ci = this.getFirstVisibleRow();
        var cg = this.getTable().getTableModel();
        var cm = 0;
        cm = cg.getRowCount();
        // don't handle this special case here
        if(ci + cj > cm){

          this._updateAllRows();
          return;
        };
        // remove old lines
        var cn = cb < 0 ? cj + cb : 0;
        var ce = cb < 0 ? 0 : cj - cb;
        for(i = Math.abs(cb) - 1;i >= 0;i--){

          var ch = cd[cn];
          try{

            cl.removeChild(ch);
          } catch(co) {

            break;
          };
        };
        // render new lines
        if(!this.__tableContainer){

          this.__tableContainer = document.createElement(e);
        };
        var ck = k;
        ck += this._getRowsHtml(ci + ce, Math.abs(cb));
        ck += q;
        this.__tableContainer.innerHTML = ck;
        var cf = this.__tableContainer.firstChild.childNodes;
        // append new lines
        if(cb > 0){

          for(var i = cf.length - 1;i >= 0;i--){

            var ch = cf[0];
            cl.appendChild(ch);
          };
        } else {

          for(var i = cf.length - 1;i >= 0;i--){

            var ch = cf[cf.length - 1];
            cl.insertBefore(ch, cl.firstChild);
          };
        };
        // update focus indicator
        if(this.__focusedRow !== null){

          this._updateRowStyles(this.__focusedRow - cb);
          this._updateRowStyles(this.__focusedRow);
        };
        this.fireEvent(o);
      },
      /**
       * Updates the content of the pane (implemented using array joins).
       */
      _updateAllRows : function(){

        var cs = this.getContentElement().getDomElement();
        if(!cs){

          // pane has not yet been rendered
          this.addListenerOnce(A, arguments.callee, this);
          return;
        };
        var cy = this.getTable();
        var cv = cy.getTableModel();
        var cx = this.getPaneScroller().getTablePaneModel();
        var cw = cx.getColumnCount();
        var cp = cy.getRowHeight();
        var ct = this.getFirstVisibleRow();
        var cq = this.getVisibleRowCount();
        var cz = cv.getRowCount();
        if(ct + cq > cz){

          cq = Math.max(0, cz - ct);
        };
        var cr = cx.getTotalWidth();
        var cu;
        // If there are any rows...
        if(cq > 0){

          // ... then create a div for them and add the rows to it.
          cu = [s, a, (cy.getForceLineHeight() ? B + cp + v : m), h, t, this._getRowsHtml(ct, cq), j];
        } else {

          // Otherwise, don't create the div, as even an empty div creates a
          // white row in IE.
          cu = [];
        };
        var cA = cu.join(m);
        cs.innerHTML = cA;
        this.setWidth(cr);
        this.__lastColCount = cw;
        this.__lastRowCount = cq;
        this.fireEvent(o);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__tableContainer = this.__paneScroller = this.__rowCache = null;
    }
  });
})();
(function(){

  var e = "__paneScroller",d = "qx.ui.table.pane.Header",c = "hovered",b = "first",a = "last";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * Shows the header of a table.
   */
  qx.Class.define(d, {
    extend : qx.ui.core.Widget,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param paneScroller {qx.ui.table.pane.Scroller} the TablePaneScroller the header belongs to.
     */
    construct : function(f){

      qx.ui.core.Widget.call(this);
      this._setLayout(new qx.ui.layout.HBox());
      // add blocker
      this.__blocker = new qx.ui.core.Blocker(this);
      this.__paneScroller = f;
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __paneScroller : null,
      __moveFeedback : null,
      __lastMouseOverColumn : null,
      __blocker : null,
      /**
       * Returns the TablePaneScroller this header belongs to.
       *
       * @return {qx.ui.table.pane.Scroller} the TablePaneScroller.
       */
      getPaneScroller : function(){

        return this.__paneScroller;
      },
      /**
       * Returns the table this header belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable : function(){

        return this.__paneScroller.getTable();
      },
      /**
       * Returns the blocker of the header.
       *
       * @return {qx.ui.core.Blocker} the blocker.
       */
      getBlocker : function(){

        return this.__blocker;
      },
      /**
       * Event handler. Called the column order has changed.
       *
       * @return {void}
       */
      onColOrderChanged : function(){

        this._updateContent(true);
      },
      /**
       * Event handler. Called when the pane model has changed.
       */
      onPaneModelChanged : function(){

        this._updateContent(true);
      },
      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @return {void}
       */
      onTableModelMetaDataChanged : function(){

        this._updateContent();
      },
      /**
       * Sets the column width. This overrides the width from the column model.
       *
       * @param col {Integer}
       *   The column to change the width for.
       *
       * @param width {Integer}
       *   The new width.
       *
       * @param isMouseAction {Boolean}
       *   <i>true</i> if the column width is being changed as a result of a
       *   mouse drag in the header; false or undefined otherwise.
       *
       * @return {void}
       */
      setColumnWidth : function(g, h, i){

        var j = this.getHeaderWidgetAtColumn(g);
        if(j != null){

          j.setWidth(h);
        };
      },
      /**
       * Sets the column the mouse is currently over.
       *
       * @param col {Integer} the model index of the column the mouse is currently over or
       *      null if the mouse is over no column.
       * @return {void}
       */
      setMouseOverColumn : function(k){

        if(k != this.__lastMouseOverColumn){

          if(this.__lastMouseOverColumn != null){

            var l = this.getHeaderWidgetAtColumn(this.__lastMouseOverColumn);
            if(l != null){

              l.removeState(c);
            };
          };
          if(k != null){

            this.getHeaderWidgetAtColumn(k).addState(c);
          };
          this.__lastMouseOverColumn = k;
        };
      },
      /**
       * Get the header widget for the given column
       *
       * @param col {Integer} The column number
       * @return {qx.ui.table.headerrenderer.HeaderCell} The header cell widget
       */
      getHeaderWidgetAtColumn : function(m){

        var n = this.getPaneScroller().getTablePaneModel().getX(m);
        return this._getChildren()[n];
      },
      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param col {Integer} the model index of the column to show the move feedback for.
       * @param x {Integer} the x position the left side of the feeback should have
       *      (in pixels, relative to the left side of the header).
       * @return {void}
       */
      showColumnMoveFeedback : function(o, x){

        var s = this.getContainerLocation();
        if(this.__moveFeedback == null){

          var y = this.getTable();
          var p = this.getPaneScroller().getTablePaneModel().getX(o);
          var r = this._getChildren()[p];
          var t = y.getTableModel();
          var v = y.getTableColumnModel();
          var w = {
            xPos : p,
            col : o,
            name : t.getColumnName(o),
            table : y
          };
          var u = v.getHeaderCellRenderer(o);
          var q = u.createHeaderCell(w);
          var z = r.getBounds();
          // Configure the feedback
          q.setWidth(z.width);
          q.setHeight(z.height);
          q.setZIndex(1000000);
          q.setOpacity(0.8);
          q.setLayoutProperties({
            top : s.top
          });
          this.getApplicationRoot().add(q);
          this.__moveFeedback = q;
        };
        this.__moveFeedback.setLayoutProperties({
          left : s.left + x
        });
        this.__moveFeedback.show();
      },
      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback : function(){

        if(this.__moveFeedback != null){

          this.__moveFeedback.destroy();
          this.__moveFeedback = null;
        };
      },
      /**
       * Returns whether the column move feedback is currently shown.
       *
       * @return {Boolean} <code>true</code> whether the column move feedback is
       *    currently shown, <code>false</code> otherwise.
       */
      isShowingColumnMoveFeedback : function(){

        return this.__moveFeedback != null;
      },
      /**
       * Updates the content of the header.
       *
       * @param completeUpdate {Boolean} if true a complete update is performed. On a
       *      complete update all header widgets are recreated.
       * @return {void}
       */
      _updateContent : function(A){

        var K = this.getTable();
        var E = K.getTableModel();
        var H = K.getTableColumnModel();
        var J = this.getPaneScroller().getTablePaneModel();
        var M = this._getChildren();
        var F = J.getColumnCount();
        var I = E.getSortColumnIndex();
        // Remove all widgets on the complete update
        if(A){

          this._cleanUpCells();
        };
        // Update the header
        var B = {
        };
        B.sortedAscending = E.isSortAscending();
        for(var x = 0;x < F;x++){

          var D = J.getColumnAtX(x);
          if(D === undefined){

            continue;
          };
          var L = H.getColumnWidth(D);
          // TODO: Get real cell renderer
          var G = H.getHeaderCellRenderer(D);
          B.xPos = x;
          B.col = D;
          B.name = E.getColumnName(D);
          B.editable = E.isColumnEditable(D);
          B.sorted = (D == I);
          B.table = K;
          // Get the cached widget
          var C = M[x];
          // Create or update the widget
          if(C == null){

            // We have no cached widget -> create it
            C = G.createHeaderCell(B);
            C.set({
              width : L
            });
            this._add(C);
          } else {

            // This widget already created before -> recycle it
            G.updateHeaderCell(B, C);
          };
          // set the states
          if(x === 0){

            C.addState(b);
            C.removeState(a);
          } else if(x === F - 1){

            C.removeState(b);
            C.addState(a);
          } else {

            C.removeState(b);
            C.removeState(a);
          };
        };
      },
      /**
       * Cleans up all header cells.
       *
       * @return {void}
       */
      _cleanUpCells : function(){

        var O = this._getChildren();
        for(var x = O.length - 1;x >= 0;x--){

          var N = O[x];
          N.destroy();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__blocker.dispose();
      this._disposeObjects(e);
    }
  });
})();
(function(){

  var k = "touchmove",j = "qx.ui.core.scroll.MTouchScroll",i = "touchend",h = "touchstart",g = "Top",f = "Left",d = "y",c = "getDocument",b = "x",a = "scrollbar-";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Tino Butz (tbtz)
       * Mustafa Sak (msak)
  
  ************************************************************************ */
  /**
   * This mixin provides scrolling for scroller widgets.
   */
  qx.Mixin.define(j, {
    construct : function(){

      // touch move listener for touch scrolling
      this.addListener(k, this._onTouchMove, this);
      // reset the delta on every touch session
      this.addListener(h, this._onTouchStart, this);
      this.addListener(i, this._onTouchEnd, this, true);
      this.__old = {
      };
      this.__impulseTimerId = {
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __momentum : false,
      __preventNextTouchEndEvent : false,
      __impulseTimerId : null,
      __old : null,
      /**
       * Returns true if touch momentum is currently on progress.
       *
       * @return {Boolean} true if in momentum
       */
      inTouchMomentum : function(){

        return this.__momentum;
      },
      /**
       * Handler for <code>touchstart</code> event. Clears timers and flags.
       *
       * @param e {qx.event.type.Touch} the touch event
       */
      _onTouchStart : function(e){

        if(this.__impulseTimerId){

          clearTimeout(this.__impulseTimerId.x);
          clearTimeout(this.__impulseTimerId.y);
        };
        this.__old = {
          "x" : 0,
          "y" : 0
        };
        if(this.__momentum){

          this.__preventNextTouchEndEvent = true;
          this.__momentum = false;
        };
      },
      /**
       * Handler for touchend event. Stops event propagation if needed.
       *
       * @param e {qx.event.type.Touch} the touch event
       */
      _onTouchEnd : function(e){

        if(this.__preventNextTouchEndEvent){

          this.__preventNextTouchEndEvent = false;
          e.stop();
        };
      },
      /**
       * Event handler for the touch move.
       *
       * @param e {qx.event.type.Touch} The touch event
       */
      _onTouchMove : function(e){

        this._onTouchMoveDirectional(b, e);
        this._onTouchMoveDirectional(d, e);
        this.__momentum = true;
        // Stop bubbling and native event
        e.stop();
      },
      /**
       * Touch move handler for one direction.
       *
       * @param dir {String} Either 'x' or 'y'
       * @param e {qx.event.type.Touch} The touch event
       */
      _onTouchMoveDirectional : function(l, e){

        var m = (l == b ? f : g);
        // current scrollbar
        var o = this.getChildControl(a + l, true);
        var p = this._isChildControlVisible(a + l);
        if(p && o){

          var n = null;
          // get the delta for the current direction
          if(this.__old[l] == 0){

            n = 0;
          } else {

            n = -(e[c + m]() - this.__old[l]);
          };
          // save the old value for the current direction
          this.__old[l] = e[c + m]();
          o.scrollBy(n);
          // if we have an old timeout for the current direction, clear it
          if(this.__impulseTimerId[l]){

            clearTimeout(this.__impulseTimerId[l]);
            this.__impulseTimerId[l] = null;
          };
          // set up a new timer for the current direction
          this.__impulseTimerId[l] = setTimeout(qx.lang.Function.bind(function(q){

            this.__handleScrollImpulse(q, l);
          }, this, n), 100);
        };
      },
      /**
       * Helper for momentum scrolling.
       *
       * @param delta {Number} The delta from the last scrolling.
       * @param dir {String} Direction of the scrollbar ('x' or 'y').
       */
      __handleScrollImpulse : function(r, s){

        // delete the old timer id
        this.__impulseTimerId[s] = null;
        // do nothing if the scrollbar is not visible or we don't need to scroll
        var u = this._isChildControlVisible(a + s);
        if(r == 0 || !u){

          this.__momentum = false;
          return;
        };
        // linear momentum calculation
        if(r > 0){

          r = Math.max(0, r - 3);
        } else {

          r = Math.min(0, r + 3);
        };
        // set up a new timer with the new delta
        this.__impulseTimerId[s] = setTimeout(qx.lang.Function.bind(function(v, w){

          this.__handleScrollImpulse(v, w);
        }, this, r, s), 10);
        // scroll the desired new delta
        var t = this.getChildControl(a + s, true);
        t.scrollBy(r);
      }
    },
    destruct : function(){

      clearTimeout(this.__impulseTimerId.x);
      clearTimeout(this.__impulseTimerId.y);
      this.__impulseTimerId = this.__old = this.__momentum = null;
    }
  });
})();
(function(){

  var b = "qx.ui.core.scroll.MScrollBarFactory",a = "qx.nativeScrollBars";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  qx.core.Environment.add(a, false);
  /**
   * Include this widget if you want to create scrollbars depending on the global
   * "qx.nativeScrollBars" setting.
   */
  qx.Mixin.define(b, {
    members : {
      /**
       * Creates a new scrollbar. This can either be a styled qooxdoo scrollbar
       * or a native browser scrollbar.
       *
       * @param orientation {String?"horizontal"} The initial scroll bar orientation
       * @return {qx.ui.core.scroll.IScrollBar} The scrollbar instance
       */
      _createScrollBar : function(c){

        if(qx.core.Environment.get(a)){

          return new qx.ui.core.scroll.NativeScrollBar(c);
        } else {

          return new qx.ui.core.scroll.ScrollBar(c);
        };
      }
    }
  });
})();
(function(){

  var b = "qx.ui.core.scroll.IScrollBar",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * All widget used as scrollbars must implement this interface.
   */
  qx.Interface.define(b, {
    events : {
      /** Fired if the user scroll */
      "scroll" : a
    },
    properties : {
      /**
       * The scroll bar orientation
       */
      orientation : {
      },
      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum : {
      },
      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position : {
      },
      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor : {
      }
    },
    members : {
      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @return {void}
       */
      scrollTo : function(c){

        this.assertNumber(c);
      },
      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @return {void}
       */
      scrollBy : function(d){

        this.assertNumber(d);
      },
      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @return {void}
       */
      scrollBySteps : function(e){

        this.assertNumber(e);
      }
    }
  });
})();
(function(){

  var k = "mousedown",j = "qx.ui.core.scroll.NativeScrollBar",i = "PositiveNumber",h = "Integer",g = "mousemove",f = "_applyMaximum",d = "_applyOrientation",c = "appear",b = "PositiveInteger",a = "mshtml",y = "engine.name",x = "mouseup",w = "Number",v = "_applyPosition",u = "scrollbar",t = "__scrollPaneElement",s = "native",r = "-1px",q = "0",p = "hidden",n = "vertical",o = "px",l = "scroll",m = "horizontal";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The scroll bar widget wraps the native browser scroll bars as a qooxdoo widget.
   * It can be uses instead of the styled qooxdoo scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.NativeScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/scrollbar.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(j, {
    extend : qx.ui.core.Widget,
    implement : qx.ui.core.scroll.IScrollBar,
    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct : function(z){

      qx.ui.core.Widget.call(this);
      this.addState(s);
      this.getContentElement().addListener(l, this._onScroll, this);
      this.addListener(k, this._stopPropagation, this);
      this.addListener(x, this._stopPropagation, this);
      this.addListener(g, this._stopPropagation, this);
      this.addListener(c, this._onAppear, this);
      this.getContentElement().add(this._getScrollPaneElement());
      // Configure orientation
      if(z != null){

        this.setOrientation(z);
      } else {

        this.initOrientation();
      };
    },
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : u
      },
      // interface implementation
      orientation : {
        check : [m, n],
        init : m,
        apply : d
      },
      // interface implementation
      maximum : {
        check : b,
        apply : f,
        init : 100
      },
      // interface implementation
      position : {
        check : w,
        init : 0,
        apply : v,
        event : l
      },
      /**
       * Step size for each click on the up/down or left/right buttons.
       */
      singleStep : {
        check : h,
        init : 20
      },
      // interface implementation
      knobFactor : {
        check : i,
        nullable : true
      }
    },
    members : {
      __isHorizontal : null,
      __scrollPaneElement : null,
      /**
       * Get the scroll pane html element.
       *
       * @return {qx.html.Element} The element
       */
      _getScrollPaneElement : function(){

        if(!this.__scrollPaneElement){

          this.__scrollPaneElement = new qx.html.Element();
        };
        return this.__scrollPaneElement;
      },
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      // overridden
      renderLayout : function(A, top, B, C){

        var D = qx.ui.core.Widget.prototype.renderLayout.call(this, A, top, B, C);
        this._updateScrollBar();
        return D;
      },
      // overridden
      _getContentHint : function(){

        var E = qx.bom.element.Overflow.getScrollbarWidth();
        return {
          width : this.__isHorizontal ? 100 : E,
          maxWidth : this.__isHorizontal ? null : E,
          minWidth : this.__isHorizontal ? null : E,
          height : this.__isHorizontal ? E : 100,
          maxHeight : this.__isHorizontal ? E : null,
          minHeight : this.__isHorizontal ? E : null
        };
      },
      // overridden
      _applyEnabled : function(F, G){

        qx.ui.core.Widget.prototype._applyEnabled.call(this, F, G);
        this._updateScrollBar();
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum : function(H){

        this._updateScrollBar();
      },
      // property apply
      _applyPosition : function(I){

        var content = this.getContentElement();
        if(this.__isHorizontal){

          content.scrollToX(I);
        } else {

          content.scrollToY(I);
        };
      },
      // property apply
      _applyOrientation : function(J, K){

        var L = this.__isHorizontal = J === m;
        this.set({
          allowGrowX : L,
          allowShrinkX : L,
          allowGrowY : !L,
          allowShrinkY : !L
        });
        if(L){

          this.replaceState(n, m);
        } else {

          this.replaceState(m, n);
        };
        this.getContentElement().setStyles({
          overflowX : L ? l : p,
          overflowY : L ? p : l
        });
        // Update layout
        qx.ui.core.queue.Layout.add(this);
      },
      /**
       * Update the scroll bar according to its current size, max value and
       * enabled state.
       */
      _updateScrollBar : function(){

        var N = this.__isHorizontal;
        var O = this.getBounds();
        if(!O){

          return;
        };
        if(this.isEnabled()){

          var P = N ? O.width : O.height;
          var M = this.getMaximum() + P;
        } else {

          M = 0;
        };
        // Scrollbars don't work properly in IE if the element with overflow has
        // excatly the size of the scrollbar. Thus we move the element one pixel
        // out of the view and increase the size by one.
        if((qx.core.Environment.get(y) == a)){

          var O = this.getBounds();
          this.getContentElement().setStyles({
            left : N ? q : r,
            top : N ? r : q,
            width : (N ? O.width : O.width + 1) + o,
            height : (N ? O.height + 1 : O.height) + o
          });
        };
        this._getScrollPaneElement().setStyles({
          left : 0,
          top : 0,
          width : (N ? M : 1) + o,
          height : (N ? 1 : M) + o
        });
        this.scrollTo(this.getPosition());
      },
      // interface implementation
      scrollTo : function(Q){

        this.setPosition(Math.max(0, Math.min(this.getMaximum(), Q)));
      },
      // interface implementation
      scrollBy : function(R){

        this.scrollTo(this.getPosition() + R);
      },
      // interface implementation
      scrollBySteps : function(S){

        var T = this.getSingleStep();
        this.scrollBy(S * T);
      },
      /**
       * Scroll event handler
       *
       * @param e {qx.event.type.Event} the scroll event
       */
      _onScroll : function(e){

        var V = this.getContentElement();
        var U = this.__isHorizontal ? V.getScrollX() : V.getScrollY();
        this.setPosition(U);
      },
      /**
       * Listener for appear which ensured the scroll bar is positioned right
       * on appear.
       *
       * @param e {qx.event.type.Data} Incoming event object
       */
      _onAppear : function(e){

        this._applyPosition(this.getPosition());
      },
      /**
       * Stops propagation on the given even
       *
       * @param e {qx.event.type.Event} the event
       */
      _stopPropagation : function(e){

        e.stopPropagation();
      }
    },
    destruct : function(){

      this._disposeObjects(t);
    }
  });
})();
(function(){

  var k = "PositiveNumber",j = "changeValue",i = "qx.lang.Type.isNumber(value)&&value>=0&&value<=this.getMaximum()",h = "_applyKnobFactor",g = "knob",f = "_applyMaximum",d = "qx.ui.core.scroll.ScrollBar",c = "resize",b = "_applyOrientation",a = "_applyPageStep",B = "PositiveInteger",A = "_applyPosition",z = "scrollbar",y = "scroll",x = "Integer",w = "execute",v = "visible",u = "right",t = "up",s = "hidden",q = "left",r = "down",o = "vertical",p = "button-begin",m = "button-end",n = "horizontal",l = "slider";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The scroll bar widget, is a special slider, which is used in qooxdoo instead
   * of the native browser scroll bars.
   *
   * Scroll bars are used by the {@link qx.ui.container.Scroll} container. Usually
   * a scroll bar is not used directly.
   *
   * @childControl slider {qx.ui.core.scroll.ScrollSlider} scroll slider component
   * @childControl button-begin {qx.ui.form.RepeatButton} button to scroll to top
   * @childControl button-end {qx.ui.form.RepeatButton} button to scroll to bottom
   *
   * *Example*
   *
   * Here is a little example of how to use the widget.
   *
   * <pre class='javascript'>
   *   var scrollBar = new qx.ui.core.scroll.ScrollBar("horizontal");
   *   scrollBar.set({
   *     maximum: 500
   *   })
   *   this.getRoot().add(scrollBar);
   * </pre>
   *
   * This example creates a horizontal scroll bar with a maximum value of 500.
   *
   * *External Documentation*
   *
   * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/scrollbar.html' target='_blank'>
   * Documentation of this widget in the qooxdoo manual.</a>
   */
  qx.Class.define(d, {
    extend : qx.ui.core.Widget,
    implement : qx.ui.core.scroll.IScrollBar,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param orientation {String?"horizontal"} The initial scroll bar orientation
     */
    construct : function(C){

      qx.ui.core.Widget.call(this);
      // Create child controls
      this._createChildControl(p);
      this._createChildControl(l).addListener(c, this._onResizeSlider, this);
      this._createChildControl(m);
      // Configure orientation
      if(C != null){

        this.setOrientation(C);
      } else {

        this.initOrientation();
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : z
      },
      /**
       * The scroll bar orientation
       */
      orientation : {
        check : [n, o],
        init : n,
        apply : b
      },
      /**
       * The maximum value (difference between available size and
       * content size).
       */
      maximum : {
        check : B,
        apply : f,
        init : 100
      },
      /**
       * Position of the scrollbar (which means the scroll left/top of the
       * attached area's pane)
       *
       * Strictly validates according to {@link #maximum}.
       * Does not apply any correction to the incoming value. If you depend
       * on this, please use {@link #scrollTo} instead.
       */
      position : {
        check : i,
        init : 0,
        apply : A,
        event : y
      },
      /**
       * Step size for each click on the up/down or left/right buttons.
       */
      singleStep : {
        check : x,
        init : 20
      },
      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep : {
        check : x,
        init : 10,
        apply : a
      },
      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor : {
        check : k,
        apply : h,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __offset : 2,
      __originalMinSize : 0,
      // overridden
      _computeSizeHint : function(){

        var D = qx.ui.core.Widget.prototype._computeSizeHint.call(this);
        if(this.getOrientation() === n){

          this.__originalMinSize = D.minWidth;
          D.minWidth = 0;
        } else {

          this.__originalMinSize = D.minHeight;
          D.minHeight = 0;
        };
        return D;
      },
      // overridden
      renderLayout : function(E, top, F, G){

        var I = qx.ui.core.Widget.prototype.renderLayout.call(this, E, top, F, G);
        var H = this.getOrientation() === n;
        if(this.__originalMinSize >= (H ? F : G)){

          this.getChildControl(p).setVisibility(s);
          this.getChildControl(m).setVisibility(s);
        } else {

          this.getChildControl(p).setVisibility(v);
          this.getChildControl(m).setVisibility(v);
        };
        return I;
      },
      // overridden
      _createChildControlImpl : function(J, K){

        var L;
        switch(J){case l:
        L = new qx.ui.core.scroll.ScrollSlider();
        L.setPageStep(100);
        L.setFocusable(false);
        L.addListener(j, this._onChangeSliderValue, this);
        this._add(L, {
          flex : 1
        });
        break;case p:
        // Top/Left Button
        L = new qx.ui.form.RepeatButton();
        L.setFocusable(false);
        L.addListener(w, this._onExecuteBegin, this);
        this._add(L);
        break;case m:
        // Bottom/Right Button
        L = new qx.ui.form.RepeatButton();
        L.setFocusable(false);
        L.addListener(w, this._onExecuteEnd, this);
        this._add(L);
        break;};
        return L || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, J);
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyMaximum : function(M){

        this.getChildControl(l).setMaximum(M);
      },
      // property apply
      _applyPosition : function(N){

        this.getChildControl(l).setValue(N);
      },
      // property apply
      _applyKnobFactor : function(O){

        this.getChildControl(l).setKnobFactor(O);
      },
      // property apply
      _applyPageStep : function(P){

        this.getChildControl(l).setPageStep(P);
      },
      // property apply
      _applyOrientation : function(Q, R){

        // Dispose old layout
        var S = this._getLayout();
        if(S){

          S.dispose();
        };
        // Reconfigure
        if(Q === n){

          this._setLayout(new qx.ui.layout.HBox());
          this.setAllowStretchX(true);
          this.setAllowStretchY(false);
          this.replaceState(o, n);
          this.getChildControl(p).replaceState(t, q);
          this.getChildControl(m).replaceState(r, u);
        } else {

          this._setLayout(new qx.ui.layout.VBox());
          this.setAllowStretchX(false);
          this.setAllowStretchY(true);
          this.replaceState(n, o);
          this.getChildControl(p).replaceState(q, t);
          this.getChildControl(m).replaceState(u, r);
        };
        // Sync slider orientation
        this.getChildControl(l).setOrientation(Q);
      },
      /*
      ---------------------------------------------------------------------------
        METHOD REDIRECTION TO SLIDER
      ---------------------------------------------------------------------------
      */
      /**
       * Scrolls to the given position.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param position {Integer} Scroll to this position. Must be greater zero.
       * @return {void}
       */
      scrollTo : function(T){

        this.getChildControl(l).slideTo(T);
      },
      /**
       * Scrolls by the given offset.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param offset {Integer} Scroll by this offset
       * @return {void}
       */
      scrollBy : function(U){

        this.getChildControl(l).slideBy(U);
      },
      /**
       * Scrolls by the given number of steps.
       *
       * This method automatically corrects the given position to respect
       * the {@link #maximum}.
       *
       * @param steps {Integer} Number of steps
       * @return {void}
       */
      scrollBySteps : function(V){

        var W = this.getSingleStep();
        this.getChildControl(l).slideBy(V * W);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER
      ---------------------------------------------------------------------------
      */
      /**
       * Executed when the up/left button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       * @return {void}
       */
      _onExecuteBegin : function(e){

        this.scrollBy(-this.getSingleStep());
      },
      /**
       * Executed when the down/right button is executed (pressed)
       *
       * @param e {qx.event.type.Event} Execute event of the button
       * @return {void}
       */
      _onExecuteEnd : function(e){

        this.scrollBy(this.getSingleStep());
      },
      /**
       * Change listener for slider value changes.
       *
       * @param e {qx.event.type.Data} The change event object
       * @return {void}
       */
      _onChangeSliderValue : function(e){

        this.setPosition(e.getData());
      },
      /**
       * Hide the knob of the slider if the slidebar is too small or show it
       * otherwise.
       *
       * @param e {qx.event.type.Data} event object
       */
      _onResizeSlider : function(e){

        var X = this.getChildControl(l).getChildControl(g);
        var bb = X.getSizeHint();
        var Y = false;
        var ba = this.getChildControl(l).getInnerSize();
        if(this.getOrientation() == o){

          if(ba.height < bb.minHeight + this.__offset){

            Y = true;
          };
        } else {

          if(ba.width < bb.minWidth + this.__offset){

            Y = true;
          };
        };
        if(Y){

          X.exclude();
        } else {

          X.show();
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.form.IRange";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all widgets which deal with ranges. The spinner is a good
   * example for a range using widget.
   */
  qx.Interface.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        MINIMUM PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Set the minimum value of the range.
       *
       * @param min {Number} The minimum.
       */
      setMinimum : function(b){

        return arguments.length == 1;
      },
      /**
       * Return the current set minimum of the range.
       *
       * @return {Number} The current set minimum.
       */
      getMinimum : function(){
      },
      /*
      ---------------------------------------------------------------------------
        MAXIMUM PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Set the maximum value of the range.
       *
       * @param max {Number} The maximum.
       */
      setMaximum : function(c){

        return arguments.length == 1;
      },
      /**
       * Return the current set maximum of the range.
       *
       * @return {Number} The current set maximum.
       */
      getMaximum : function(){
      },
      /*
      ---------------------------------------------------------------------------
        SINGLESTEP PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the value for single steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setSingleStep : function(d){

        return arguments.length == 1;
      },
      /**
       * Returns the value which will be stepped in a single step in the range.
       *
       * @return {Number} The current value for single steps.
       */
      getSingleStep : function(){
      },
      /*
      ---------------------------------------------------------------------------
        PAGESTEP PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the value for page steps in the range.
       *
       * @param step {Number} The value of the step.
       */
      setPageStep : function(e){

        return arguments.length == 1;
      },
      /**
       * Returns the value which will be stepped in a page step in the range.
       *
       * @return {Number} The current value for page steps.
       */
      getPageStep : function(){
      }
    }
  });
})();
(function(){

  var b = "qx.ui.form.INumberForm",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Form interface for all form widgets which use a numeric value as their
   * primary data type like a spinner.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the value was modified */
      "changeValue" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
      ---------------------------------------------------------------------------
        VALUE PROPERTY
      ---------------------------------------------------------------------------
      */
      /**
       * Sets the element's value.
       *
       * @param value {Number|null} The new value of the element.
       */
      setValue : function(c){

        return arguments.length == 1;
      },
      /**
       * Resets the element's value to its initial value.
       */
      resetValue : function(){
      },
      /**
       * The element's user set value.
       *
       * @return {Number|null} The value.
       */
      getValue : function(){
      }
    }
  });
})();
(function(){

  var k = "slider",j = "mousedown",i = "PageUp",h = "mouseout",g = "x",f = 'qx.event.type.Data',d = "Left",c = "Down",b = "Up",a = "dblclick",X = "qx.ui.form.Slider",W = "PageDown",V = "mousewheel",U = "_applyValue",T = "_applyKnobFactor",S = "End",R = "height",Q = "y",P = "Right",O = "width",r = "_applyOrientation",s = "Home",p = "mouseover",q = "floor",n = "_applyMinimum",o = "click",l = "typeof value==='number'&&value>=this.getMinimum()&&value<=this.getMaximum()",m = "keypress",u = "ceil",v = "losecapture",C = "contextmenu",A = "_applyMaximum",G = "Number",E = "changeMaximum",K = "changeMinimum",I = "pressed",x = "px",N = "changeValue",M = "interval",L = "mousemove",w = "resize",y = "hovered",z = "left",B = "top",D = "mouseup",F = "Integer",H = "vertical",J = "horizontal",t = "knob";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The Slider widget provides a vertical or horizontal slider.
   *
   * The Slider is the classic widget for controlling a bounded value.
   * It lets the user move a slider handle along a horizontal or vertical
   * groove and translates the handle's position into an integer value
   * within the defined range.
   *
   * The Slider has very few of its own functions.
   * The most useful functions are slideTo() to set the slider directly to some
   * value; setSingleStep(), setPageStep() to set the steps; and setMinimum()
   * and setMaximum() to define the range of the slider.
   *
   * A slider accepts focus on Tab and provides both a mouse wheel and
   * a keyboard interface. The keyboard interface is the following:
   *
   * * Left/Right move a horizontal slider by one single step.
   * * Up/Down move a vertical slider by one single step.
   * * PageUp moves up one page.
   * * PageDown moves down one page.
   * * Home moves to the start (minimum).
   * * End moves to the end (maximum).
   *
   * Here are the main properties of the class:
   *
   * # <code>value</code>: The bounded integer that {@link qx.ui.form.INumberForm}
   * maintains.
   * # <code>minimum</code>: The lowest possible value.
   * # <code>maximum</code>: The highest possible value.
   * # <code>singleStep</code>: The smaller of two natural steps that an abstract
   * sliders provides and typically corresponds to the user pressing an arrow key.
   * # <code>pageStep</code>: The larger of two natural steps that an abstract
   * slider provides and typically corresponds to the user pressing PageUp or
   * PageDown.
   *
   * @childControl knob {qx.ui.core.Widget} knob to set the value of the slider
   */
  qx.Class.define(X, {
    extend : qx.ui.core.Widget,
    implement : [qx.ui.form.IForm, qx.ui.form.INumberForm, qx.ui.form.IRange],
    include : [qx.ui.form.MForm],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param orientation {String?"horizontal"} Configure the
     * {@link #orientation} property
     */
    construct : function(Y){

      qx.ui.core.Widget.call(this);
      // Force canvas layout
      this._setLayout(new qx.ui.layout.Canvas());
      // Add listeners
      this.addListener(m, this._onKeyPress);
      this.addListener(V, this._onMouseWheel);
      this.addListener(j, this._onMouseDown);
      this.addListener(D, this._onMouseUp);
      this.addListener(v, this._onMouseUp);
      this.addListener(w, this._onUpdate);
      // Stop events
      this.addListener(C, this._onStopEvent);
      this.addListener(o, this._onStopEvent);
      this.addListener(a, this._onStopEvent);
      // Initialize orientation
      if(Y != null){

        this.setOrientation(Y);
      } else {

        this.initOrientation();
      };
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * Change event for the value.
       */
      changeValue : f
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : k
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      },
      /** Whether the slider is horizontal or vertical. */
      orientation : {
        check : [J, H],
        init : J,
        apply : r
      },
      /**
       * The current slider value.
       *
       * Strictly validates according to {@link #minimum} and {@link #maximum}.
       * Do not apply any value correction to the incoming value. If you depend
       * on this, please use {@link #slideTo} instead.
       */
      value : {
        check : l,
        init : 0,
        apply : U,
        nullable : true
      },
      /**
       * The minimum slider value (may be negative). This value must be smaller
       * than {@link #maximum}.
       */
      minimum : {
        check : F,
        init : 0,
        apply : n,
        event : K
      },
      /**
       * The maximum slider value (may be negative). This value must be larger
       * than {@link #minimum}.
       */
      maximum : {
        check : F,
        init : 100,
        apply : A,
        event : E
      },
      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing an arrow key.
       */
      singleStep : {
        check : F,
        init : 1
      },
      /**
       * The amount to increment on each event. Typically corresponds
       * to the user pressing <code>PageUp</code> or <code>PageDown</code>.
       */
      pageStep : {
        check : F,
        init : 10
      },
      /**
       * Factor to apply to the width/height of the knob in relation
       * to the dimension of the underlying area.
       */
      knobFactor : {
        check : G,
        apply : T,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __sliderLocation : null,
      __knobLocation : null,
      __knobSize : null,
      __dragMode : null,
      __dragOffset : null,
      __trackingMode : null,
      __trackingDirection : null,
      __trackingEnd : null,
      __timer : null,
      // event delay stuff during drag
      __dragTimer : null,
      __lastValueEvent : null,
      __dragValue : null,
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        invalid : true
      },
      // overridden
      _createChildControlImpl : function(ba, bb){

        var bc;
        switch(ba){case t:
        bc = new qx.ui.core.Widget();
        bc.addListener(w, this._onUpdate, this);
        bc.addListener(p, this._onMouseOver);
        bc.addListener(h, this._onMouseOut);
        this._add(bc);
        break;};
        return bc || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, ba);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler for mouseover events at the knob child control.
       *
       * Adds the 'hovered' state
       *
       * @param e {qx.event.type.Mouse} Incoming mouse event
       */
      _onMouseOver : function(e){

        this.addState(y);
      },
      /**
       * Event handler for mouseout events at the knob child control.
       *
       * Removes the 'hovered' state
       *
       * @param e {qx.event.type.Mouse} Incoming mouse event
       */
      _onMouseOut : function(e){

        this.removeState(y);
      },
      /**
       * Listener of mousewheel event
       *
       * @param e {qx.event.type.Mouse} Incoming event object
       * @return {void}
       */
      _onMouseWheel : function(e){

        var bf = this.getOrientation() === J ? g : Q;
        var be = e.getWheelDelta(bf);
        var bd = be > 0 ? 1 : be < 0 ? -1 : 0;
        this.slideBy(bd * this.getSingleStep());
        e.stop();
      },
      /**
       * Event handler for keypress events.
       *
       * Adds support for arrow keys, page up, page down, home and end keys.
       *
       * @param e {qx.event.type.KeySequence} Incoming keypress event
       * @return {void}
       */
      _onKeyPress : function(e){

        var bh = this.getOrientation() === J;
        var bg = bh ? d : b;
        var forward = bh ? P : c;
        switch(e.getKeyIdentifier()){case forward:
        this.slideForward();
        break;case bg:
        this.slideBack();
        break;case W:
        this.slidePageForward();
        break;case i:
        this.slidePageBack();
        break;case s:
        this.slideToBegin();
        break;case S:
        this.slideToEnd();
        break;default:
        return;};
        // Stop processed events
        e.stop();
      },
      /**
       * Listener of mousedown event. Initializes drag or tracking mode.
       *
       * @param e {qx.event.type.Mouse} Incoming event object
       * @return {void}
       */
      _onMouseDown : function(e){

        // this can happen if the user releases the button while dragging outside
        // of the browser viewport
        if(this.__dragMode){

          return;
        };
        var bk = this.__isHorizontal;
        var bi = this.getChildControl(t);
        var bj = bk ? z : B;
        var bm = bk ? e.getDocumentLeft() : e.getDocumentTop();
        var bn = this.__sliderLocation = qx.bom.element.Location.get(this.getContentElement().getDomElement())[bj];
        var bl = this.__knobLocation = qx.bom.element.Location.get(bi.getContainerElement().getDomElement())[bj];
        if(e.getTarget() === bi){

          // Switch into drag mode
          this.__dragMode = true;
          if(!this.__dragTimer){

            // create a timer to fire delayed dragging events if dragging stops.
            this.__dragTimer = new qx.event.Timer(100);
            this.__dragTimer.addListener(M, this._fireValue, this);
          };
          this.__dragTimer.start();
          // Compute dragOffset (includes both: inner position of the widget and
          // cursor position on knob)
          this.__dragOffset = bm + bn - bl;
          // add state
          bi.addState(I);
        } else {

          // Switch into tracking mode
          this.__trackingMode = true;
          // Detect tracking direction
          this.__trackingDirection = bm <= bl ? -1 : 1;
          // Compute end value
          this.__computeTrackingEnd(e);
          // Directly call interval method once
          this._onInterval();
          // Initialize timer (when needed)
          if(!this.__timer){

            this.__timer = new qx.event.Timer(100);
            this.__timer.addListener(M, this._onInterval, this);
          };
          // Start timer
          this.__timer.start();
        };
        // Register move listener
        this.addListener(L, this._onMouseMove);
        // Activate capturing
        this.capture();
        // Stop event
        e.stopPropagation();
      },
      /**
       * Listener of mouseup event. Used for cleanup of previously
       * initialized modes.
       *
       * @param e {qx.event.type.Mouse} Incoming event object
       * @return {void}
       */
      _onMouseUp : function(e){

        if(this.__dragMode){

          // Release capture mode
          this.releaseCapture();
          // Cleanup status flags
          delete this.__dragMode;
          // as we come out of drag mode, make
          // sure content gets synced
          this.__dragTimer.stop();
          this._fireValue();
          delete this.__dragOffset;
          // remove state
          this.getChildControl(t).removeState(I);
          // it's necessary to check whether the mouse cursor is over the knob widget to be able to
          // to decide whether to remove the 'hovered' state.
          if(e.getType() === D){

            var bp;
            var bq;
            var bo;
            if(this.__isHorizontal){

              bp = e.getDocumentLeft() - (this._valueToPosition(this.getValue()) + this.__sliderLocation);
              bo = qx.bom.element.Location.get(this.getContentElement().getDomElement())[B];
              bq = e.getDocumentTop() - (bo + this.getChildControl(t).getBounds().top);
            } else {

              bp = e.getDocumentTop() - (this._valueToPosition(this.getValue()) + this.__sliderLocation);
              bo = qx.bom.element.Location.get(this.getContentElement().getDomElement())[z];
              bq = e.getDocumentLeft() - (bo + this.getChildControl(t).getBounds().left);
            };
            if(bq < 0 || bq > this.__knobSize || bp < 0 || bp > this.__knobSize){

              this.getChildControl(t).removeState(y);
            };
          };
        } else if(this.__trackingMode){

          // Stop timer interval
          this.__timer.stop();
          // Release capture mode
          this.releaseCapture();
          // Cleanup status flags
          delete this.__trackingMode;
          delete this.__trackingDirection;
          delete this.__trackingEnd;
        };
        // Remove move listener again
        this.removeListener(L, this._onMouseMove);
        // Stop event
        if(e.getType() === D){

          e.stopPropagation();
        };
      },
      /**
       * Listener of mousemove event for the knob. Only used in drag mode.
       *
       * @param e {qx.event.type.Mouse} Incoming event object
       * @return {void}
       */
      _onMouseMove : function(e){

        if(this.__dragMode){

          var bs = this.__isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();
          var br = bs - this.__dragOffset;
          this.slideTo(this._positionToValue(br));
        } else if(this.__trackingMode){

          // Update tracking end on mousemove
          this.__computeTrackingEnd(e);
        };
        // Stop event
        e.stopPropagation();
      },
      /**
       * Listener of interval event by the internal timer. Only used
       * in tracking sequences.
       *
       * @param e {qx.event.type.Event} Incoming event object
       * @return {void}
       */
      _onInterval : function(e){

        // Compute new value
        var bt = this.getValue() + (this.__trackingDirection * this.getPageStep());
        // Limit value
        if(bt < this.getMinimum()){

          bt = this.getMinimum();
        } else if(bt > this.getMaximum()){

          bt = this.getMaximum();
        };
        // Stop at tracking position (where the mouse is pressed down)
        var bu = this.__trackingDirection == -1;
        if((bu && bt <= this.__trackingEnd) || (!bu && bt >= this.__trackingEnd)){

          bt = this.__trackingEnd;
        };
        // Finally slide to the desired position
        this.slideTo(bt);
      },
      /**
       * Listener of resize event for both the slider itself and the knob.
       *
       * @param e {qx.event.type.Data} Incoming event object
       * @return {void}
       */
      _onUpdate : function(e){

        // Update sliding space
        var bw = this.getInnerSize();
        var bx = this.getChildControl(t).getBounds();
        var bv = this.__isHorizontal ? O : R;
        // Sync knob size
        this._updateKnobSize();
        // Store knob size
        this.__slidingSpace = bw[bv] - bx[bv];
        this.__knobSize = bx[bv];
        // Update knob position (sliding space must be updated first)
        this._updateKnobPosition();
      },
      /*
      ---------------------------------------------------------------------------
        UTILS
      ---------------------------------------------------------------------------
      */
      /** {Boolean} Whether the slider is laid out horizontally */
      __isHorizontal : false,
      /**
       * {Integer} Available space for knob to slide on, computed on resize of
       * the widget
       */
      __slidingSpace : 0,
      /**
       * Computes the value where the tracking should end depending on
       * the current mouse position.
       *
       * @param e {qx.event.type.Mouse} Incoming mouse event
       * @return {void}
       */
      __computeTrackingEnd : function(e){

        var by = this.__isHorizontal;
        var bF = by ? e.getDocumentLeft() : e.getDocumentTop();
        var bH = this.__sliderLocation;
        var bz = this.__knobLocation;
        var bJ = this.__knobSize;
        // Compute relative position
        var bG = bF - bH;
        if(bF >= bz){

          bG -= bJ;
        };
        // Compute stop value
        var bD = this._positionToValue(bG);
        var bA = this.getMinimum();
        var bB = this.getMaximum();
        if(bD < bA){

          bD = bA;
        } else if(bD > bB){

          bD = bB;
        } else {

          var bE = this.getValue();
          var bC = this.getPageStep();
          var bI = this.__trackingDirection < 0 ? q : u;
          // Fix to page step
          bD = bE + (Math[bI]((bD - bE) / bC) * bC);
        };
        // Store value when undefined, otherwise only when it follows the
        // current direction e.g. goes up or down
        if(this.__trackingEnd == null || (this.__trackingDirection == -1 && bD <= this.__trackingEnd) || (this.__trackingDirection == 1 && bD >= this.__trackingEnd)){

          this.__trackingEnd = bD;
        };
      },
      /**
       * Converts the given position to a value.
       *
       * Does not respect single or page step.
       *
       * @param position {Integer} Position to use
       * @return {Integer} Resulting value (rounded)
       */
      _positionToValue : function(bK){

        // Reading available space
        var bL = this.__slidingSpace;
        // Protect undefined value (before initial resize) and division by zero
        if(bL == null || bL == 0){

          return 0;
        };
        // Compute and limit percent
        var bN = bK / bL;
        if(bN < 0){

          bN = 0;
        } else if(bN > 1){

          bN = 1;
        };
        // Compute range
        var bM = this.getMaximum() - this.getMinimum();
        // Compute value
        return this.getMinimum() + Math.round(bM * bN);
      },
      /**
       * Converts the given value to a position to place
       * the knob to.
       *
       * @param value {Integer} Value to use
       * @return {Integer} Computed position (rounded)
       */
      _valueToPosition : function(bO){

        // Reading available space
        var bP = this.__slidingSpace;
        if(bP == null){

          return 0;
        };
        // Computing range
        var bQ = this.getMaximum() - this.getMinimum();
        // Protect division by zero
        if(bQ == 0){

          return 0;
        };
        // Translating value to distance from minimum
        var bO = bO - this.getMinimum();
        // Compute and limit percent
        var bR = bO / bQ;
        if(bR < 0){

          bR = 0;
        } else if(bR > 1){

          bR = 1;
        };
        // Compute position from available space and percent
        return Math.round(bP * bR);
      },
      /**
       * Updates the knob position following the currently configured
       * value. Useful on reflows where the dimensions of the slider
       * itself have been modified.
       *
       * @return {void}
       */
      _updateKnobPosition : function(){

        this._setKnobPosition(this._valueToPosition(this.getValue()));
      },
      /**
       * Moves the knob to the given position.
       *
       * @param position {Integer} Any valid position (needs to be
       *   greater or equal than zero)
       * @return {void}
       */
      _setKnobPosition : function(bS){

        // Use DOM Element
        var bT = this.getChildControl(t).getContainerElement();
        if(this.__isHorizontal){

          bT.setStyle(z, bS + x, true);
        } else {

          bT.setStyle(B, bS + x, true);
        };
      },
      /**
       * Reconfigures the size of the knob depending on
       * the optionally defined {@link #knobFactor}.
       *
       * @return {void}
       */
      _updateKnobSize : function(){

        // Compute knob size
        var bV = this.getKnobFactor();
        if(bV == null){

          return;
        };
        // Ignore when not rendered yet
        var bU = this.getInnerSize();
        if(bU == null){

          return;
        };
        // Read size property
        if(this.__isHorizontal){

          this.getChildControl(t).setWidth(Math.round(bV * bU.width));
        } else {

          this.getChildControl(t).setHeight(Math.round(bV * bU.height));
        };
      },
      /*
      ---------------------------------------------------------------------------
        SLIDE METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Slides backward to the minimum value
       *
       * @return {void}
       */
      slideToBegin : function(){

        this.slideTo(this.getMinimum());
      },
      /**
       * Slides forward to the maximum value
       *
       * @return {void}
       */
      slideToEnd : function(){

        this.slideTo(this.getMaximum());
      },
      /**
       * Slides forward (right or bottom depending on orientation)
       *
       * @return {void}
       */
      slideForward : function(){

        this.slideBy(this.getSingleStep());
      },
      /**
       * Slides backward (to left or top depending on orientation)
       *
       * @return {void}
       */
      slideBack : function(){

        this.slideBy(-this.getSingleStep());
      },
      /**
       * Slides a page forward (to right or bottom depending on orientation)
       *
       * @return {void}
       */
      slidePageForward : function(){

        this.slideBy(this.getPageStep());
      },
      /**
       * Slides a page backward (to left or top depending on orientation)
       *
       * @return {void}
       */
      slidePageBack : function(){

        this.slideBy(-this.getPageStep());
      },
      /**
       * Slides by the given offset.
       *
       * This method works with the value, not with the coordinate.
       *
       * @param offset {Integer} Offset to scroll by
       * @return {void}
       */
      slideBy : function(bW){

        this.slideTo(this.getValue() + bW);
      },
      /**
       * Slides to the given value
       *
       * This method works with the value, not with the coordinate.
       *
       * @param value {Integer} Scroll to a value between the defined
       *   minimum and maximum.
       * @return {void}
       */
      slideTo : function(bX){

        // Bring into allowed range or fix to single step grid
        if(bX < this.getMinimum()){

          bX = this.getMinimum();
        } else if(bX > this.getMaximum()){

          bX = this.getMaximum();
        } else {

          bX = this.getMinimum() + Math.round((bX - this.getMinimum()) / this.getSingleStep()) * this.getSingleStep();
        };
        // Sync with property
        this.setValue(bX);
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyOrientation : function(bY, ca){

        var cb = this.getChildControl(t);
        // Update private flag for faster access
        this.__isHorizontal = bY === J;
        // Toggle states and knob layout
        if(this.__isHorizontal){

          this.removeState(H);
          cb.removeState(H);
          this.addState(J);
          cb.addState(J);
          cb.setLayoutProperties({
            top : 0,
            right : null,
            bottom : 0
          });
        } else {

          this.removeState(J);
          cb.removeState(J);
          this.addState(H);
          cb.addState(H);
          cb.setLayoutProperties({
            right : 0,
            bottom : null,
            left : 0
          });
        };
        // Sync knob position
        this._updateKnobPosition();
      },
      // property apply
      _applyKnobFactor : function(cc, cd){

        if(cc != null){

          this._updateKnobSize();
        } else {

          if(this.__isHorizontal){

            this.getChildControl(t).resetWidth();
          } else {

            this.getChildControl(t).resetHeight();
          };
        };
      },
      // property apply
      _applyValue : function(ce, cf){

        if(ce != null){

          this._updateKnobPosition();
          if(this.__dragMode){

            this.__dragValue = [ce, cf];
          } else {

            this.fireEvent(N, qx.event.type.Data, [ce, cf]);
          };
        } else {

          this.resetValue();
        };
      },
      /**
       * Helper for applyValue which fires the changeValue event.
       */
      _fireValue : function(){

        if(!this.__dragValue){

          return;
        };
        var cg = this.__dragValue;
        this.__dragValue = null;
        this.fireEvent(N, qx.event.type.Data, cg);
      },
      // property apply
      _applyMinimum : function(ch, ci){

        if(this.getValue() < ch){

          this.setValue(ch);
        };
        this._updateKnobPosition();
      },
      // property apply
      _applyMaximum : function(cj, ck){

        if(this.getValue() > cj){

          this.setValue(cj);
        };
        this._updateKnobPosition();
      }
    }
  });
})();
(function(){

  var d = "horizontal",c = "mousewheel",b = "qx.ui.core.scroll.ScrollSlider",a = "keypress";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's left-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Minimal modified version of the {@link qx.ui.form.Slider} to be
   * used by {@link qx.ui.core.scroll.ScrollBar}.
   *
   * @internal
   */
  qx.Class.define(b, {
    extend : qx.ui.form.Slider,
    // overridden
    construct : function(e){

      qx.ui.form.Slider.call(this, e);
      // Remove mousewheel/keypress events
      this.removeListener(a, this._onKeyPress);
      this.removeListener(c, this._onMouseWheel);
    },
    members : {
      // overridden
      getSizeHint : function(f){

        // get the original size hint
        var g = qx.ui.form.Slider.prototype.getSizeHint.call(this);
        // set the width or height to 0 depending on the orientation.
        // this is necessary to prevent the ScrollSlider to change the size
        // hint of its parent, which can cause errors on outer flex layouts
        // [BUG #3279]
        if(this.getOrientation() === d){

          g.width = 0;
        } else {

          g.height = 0;
        };
        return g;
      }
    }
  });
})();
(function(){

  var o = "__horScrollBar",n = "__clipperContainer",m = "__paneClipper",l = "mouseout",k = "changeHorizontalScrollBarVisible",j = "__headerClipper",i = "__header",h = "bottom",g = "_applyScrollTimeout",d = "changeScrollX",bq = "_applyTablePaneModel",bp = "Integer",bo = "dblclick",bn = "dataEdited",bm = "mousewheel",bl = "interval",bk = "__focusIndicator",bj = "qx.ui.table.pane.Scroller",bi = "_applyShowCellFocusIndicator",bh = "y",v = "__verScrollBar",w = "resize",t = "vertical",u = "__timer",r = "changeScrollY",s = "appear",p = "table-scroller",q = "beforeSort",C = "__tablePane",D = "cellDblclick",M = "horizontal",J = "losecapture",U = "contextmenu",P = "col-resize",bd = "disappear",ba = "_applyVerticalScrollBarVisible",F = "_applyHorizontalScrollBarVisible",bg = "os.scrollBarOverlayed",bf = "cellContextmenu",be = "close",E = "changeTablePaneModel",H = "__top",I = "x",L = "qx.ui.table.pane.Model",N = "changeVerticalScrollBarVisible",Q = "scroll",W = "focus-indicator",bc = "excluded",y = "scrollbar-y",z = "table-scroller-focus-indicator",G = "visible",T = "mousemove",S = "header",R = "editing",Y = "click",X = "modelChanged",O = "scrollbar-x",V = "cellClick",a = "pane",bb = "mousedown",A = "qx.event.type.Data",B = "mouseup",K = "qx.ui.table.pane.CellEvent",b = "resize-line",c = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Jonathan Weiß (jonathan_rass)
  
  ************************************************************************ */
  /**
   * Shows a whole meta column. This includes a {@link Header},
   * a {@link Pane} and the needed scroll bars. This class handles the
   * virtual scrolling and does all the mouse event handling.
   *
   * @childControl header {qx.ui.table.pane.Header} header pane
   * @childControl pane {qx.ui.table.pane.Pane} table pane to show the data
   * @childControl focus-indicator {qx.ui.table.pane.FocusIndicator} shows the current focused cell
   * @childControl resize-line {qx.ui.core.Widget} resize line widget
   * @childControl scrollbar-x {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               horizontal scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   * @childControl scrollbar-y {qx.ui.core.scroll.ScrollBar?qx.ui.core.scroll.NativeScrollBar}
   *               vertical scrollbar widget (depends on the "qx.nativeScrollBars" setting which implementation is used)
   */
  qx.Class.define(bj, {
    extend : qx.ui.core.Widget,
    include : qx.core.Environment.filter({
      "true" : qx.ui.core.scroll.MScrollBarFactory,
      "event.touch" : qx.ui.core.scroll.MTouchScroll
    }),
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param table {qx.ui.table.Table} the table the scroller belongs to.
     */
    construct : function(br){

      qx.ui.core.Widget.call(this);
      this.__table = br;
      // init layout
      var bs = new qx.ui.layout.Grid();
      bs.setColumnFlex(0, 1);
      bs.setRowFlex(1, 1);
      this._setLayout(bs);
      // init child controls
      this.__header = this._showChildControl(S);
      this.__tablePane = this._showChildControl(a);
      // the top line containing the header clipper and the top right widget
      this.__top = new qx.ui.container.Composite(new qx.ui.layout.HBox()).set({
        minWidth : 0
      });
      this._add(this.__top, {
        row : 0,
        column : 0,
        colSpan : 2
      });
      // embed header into a scrollable container
      this.__headerClipper = new qx.ui.table.pane.Clipper();
      this.__headerClipper.add(this.__header);
      this.__headerClipper.addListener(J, this._onChangeCaptureHeader, this);
      this.__headerClipper.addListener(T, this._onMousemoveHeader, this);
      this.__headerClipper.addListener(bb, this._onMousedownHeader, this);
      this.__headerClipper.addListener(B, this._onMouseupHeader, this);
      this.__headerClipper.addListener(Y, this._onClickHeader, this);
      this.__top.add(this.__headerClipper, {
        flex : 1
      });
      // embed pane into a scrollable container
      this.__paneClipper = new qx.ui.table.pane.Clipper();
      this.__paneClipper.add(this.__tablePane);
      this.__paneClipper.addListener(bm, this._onMousewheel, this);
      this.__paneClipper.addListener(T, this._onMousemovePane, this);
      this.__paneClipper.addListener(bb, this._onMousedownPane, this);
      this.__paneClipper.addListener(B, this._onMouseupPane, this);
      this.__paneClipper.addListener(Y, this._onClickPane, this);
      this.__paneClipper.addListener(U, this._onContextMenu, this);
      this.__paneClipper.addListener(bo, this._onDblclickPane, this);
      this.__paneClipper.addListener(w, this._onResizePane, this);
      // if we have overlayed scroll bars, we should use a separate container
      if(qx.core.Environment.get(bg)){

        this.__clipperContainer = new qx.ui.container.Composite();
        this.__clipperContainer.setLayout(new qx.ui.layout.Canvas());
        this.__clipperContainer.add(this.__paneClipper, {
          edge : 0
        });
        this._add(this.__clipperContainer, {
          row : 1,
          column : 0
        });
      } else {

        this._add(this.__paneClipper, {
          row : 1,
          column : 0
        });
      };
      // init scroll bars
      this.__horScrollBar = this._showChildControl(O);
      this.__verScrollBar = this._showChildControl(y);
      // init focus indicator
      this.__focusIndicator = this.getChildControl(W);
      // need to run the apply method at least once [BUG #4057]
      this.initShowCellFocusIndicator();
      // force creation of the resize line
      this.getChildControl(b).hide();
      this.addListener(l, this._onMouseout, this);
      this.addListener(s, this._onAppear, this);
      this.addListener(bd, this._onDisappear, this);
      this.__timer = new qx.event.Timer();
      this.__timer.addListener(bl, this._oninterval, this);
      this.initScrollTimeout();
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {int} The minimum width a column could get in pixels. */
      MIN_COLUMN_WIDTH : 10,
      /** {int} The radius of the resize region in pixels. */
      RESIZE_REGION_RADIUS : 5,
      /**
       * (int) The number of pixels the mouse may move between mouse down and mouse up
       * in order to count as a click.
       */
      CLICK_TOLERANCE : 5,
      /**
       * (int) The mask for the horizontal scroll bar.
       * May be combined with {@link #VERTICAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      HORIZONTAL_SCROLLBAR : 1,
      /**
       * (int) The mask for the vertical scroll bar.
       * May be combined with {@link #HORIZONTAL_SCROLLBAR}.
       *
       * @see #getNeededScrollBars
       */
      VERTICAL_SCROLLBAR : 2
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    events : {
      /** Dispatched if the pane is scolled horizontally */
      "changeScrollY" : A,
      /** Dispatched if the pane is scrolled vertically */
      "changeScrollX" : A,
      /**See {@link qx.ui.table.Table#cellClick}.*/
      "cellClick" : K,
      /*** See {@link qx.ui.table.Table#cellDblclick}.*/
      "cellDblclick" : K,
      /**See {@link qx.ui.table.Table#cellContextmenu}.*/
      "cellContextmenu" : K,
      /** Dispatched when a sortable header was clicked */
      "beforeSort" : A
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Whether to show the horizontal scroll bar */
      horizontalScrollBarVisible : {
        check : c,
        init : false,
        apply : F,
        event : k
      },
      /** Whether to show the vertical scroll bar */
      verticalScrollBarVisible : {
        check : c,
        init : false,
        apply : ba,
        event : N
      },
      /** The table pane model. */
      tablePaneModel : {
        check : L,
        apply : bq,
        event : E
      },
      /**
       * Whether column resize should be live. If false, during resize only a line is
       * shown and the real resize happens when the user releases the mouse button.
       */
      liveResize : {
        check : c,
        init : false
      },
      /**
       * Whether the focus should moved when the mouse is moved over a cell. If false
       * the focus is only moved on mouse clicks.
       */
      focusCellOnMouseMove : {
        check : c,
        init : false
      },
      /**
       * Whether to handle selections via the selection manager before setting the
       * focus.  The traditional behavior is to handle selections after setting the
       * focus, but setting the focus means redrawing portions of the table, and
       * some subclasses may want to modify the data to be displayed based on the
       * selection.
       */
      selectBeforeFocus : {
        check : c,
        init : false
      },
      /**
       * Whether the cell focus indicator should be shown
       */
      showCellFocusIndicator : {
        check : c,
        init : true,
        apply : bi
      },
      /**
       * By default, the "cellContextmenu" event is fired only when a data cell
       * is right-clicked. It is not fired when a right-click occurs in the
       * empty area of the table below the last data row. By turning on this
       * property, "cellContextMenu" events will also be generated when a
       * right-click occurs in that empty area. In such a case, row identifier
       * in the event data will be null, so event handlers can check (row ===
       * null) to handle this case.
       */
      contextMenuFromDataCellsOnly : {
        check : c,
        init : true
      },
      /**
       * Whether to reset the selection when a header cell is clicked. Since
       * most data models do not have provisions to retain a selection after
       * sorting, the default is to reset the selection in this case. Some data
       * models, however, do have the capability to retain the selection, so
       * when using those, this property should be set to false.
       */
      resetSelectionOnHeaderClick : {
        check : c,
        init : true
      },
      /**
       * Interval time (in milliseconds) for the table update timer.
       * Setting this to 0 clears the timer.
       */
      scrollTimeout : {
        check : bp,
        init : 100,
        apply : g
      },
      appearance : {
        refine : true,
        init : p
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __lastRowCount : null,
      __table : null,
      __updateInterval : null,
      __updateContentPlanned : null,
      __onintervalWrapper : null,
      __moveColumn : null,
      __lastMoveColPos : null,
      __lastMoveTargetX : null,
      __lastMoveTargetScroller : null,
      __lastMoveMousePageX : null,
      __resizeColumn : null,
      __lastResizeMousePageX : null,
      __lastResizeWidth : null,
      __lastMouseDownCell : null,
      __firedClickEvent : false,
      __ignoreClick : null,
      __lastMousePageX : null,
      __lastMousePageY : null,
      __focusedCol : null,
      __focusedRow : null,
      __cellEditor : null,
      __cellEditorFactory : null,
      __topRightWidget : null,
      __horScrollBar : null,
      __verScrollBar : null,
      __header : null,
      __headerClipper : null,
      __tablePane : null,
      __paneClipper : null,
      __clipperContainer : null,
      __focusIndicator : null,
      __top : null,
      __timer : null,
      /**
       * The right inset of the pane. The right inset is the maximum of the
       * top right widget width and the scrollbar width (if visible).
       *
       * @return {Integer} The right inset of the pane
       */
      getPaneInsetRight : function(){

        var bv = this.getTopRightWidget();
        var bw = bv && bv.isVisible() && bv.getBounds() ? bv.getBounds().width + bv.getMarginLeft() + bv.getMarginRight() : 0;
        var bu = this.__verScrollBar;
        var bt = this.getVerticalScrollBarVisible() ? this.getVerticalScrollBarWidth() + bu.getMarginLeft() + bu.getMarginRight() : 0;
        return Math.max(bw, bt);
      },
      /**
       * Set the pane's width
       *
       * @param width {Integer} The pane's width
       */
      setPaneWidth : function(bx){

        if(this.isVerticalScrollBarVisible()){

          bx += this.getPaneInsetRight();
        };
        this.setWidth(bx);
      },
      // overridden
      _createChildControlImpl : function(by, bz){

        var bA;
        switch(by){case S:
        bA = (this.getTable().getNewTablePaneHeader())(this);
        break;case a:
        bA = (this.getTable().getNewTablePane())(this);
        break;case W:
        bA = new qx.ui.table.pane.FocusIndicator(this);
        bA.setUserBounds(0, 0, 0, 0);
        bA.setZIndex(1000);
        bA.addListener(B, this._onMouseupFocusIndicator, this);
        this.__paneClipper.add(bA);
        bA.show();
        // must be active for editor to operate
        bA.setDecorator(null);
        // it can be initially invisible, though.
        break;case b:
        bA = new qx.ui.core.Widget();
        bA.setUserBounds(0, 0, 0, 0);
        bA.setZIndex(1000);
        this.__paneClipper.add(bA);
        break;case O:
        bA = this._createScrollBar(M).set({
          alignY : h
        });
        bA.addListener(Q, this._onScrollX, this);
        if(this.__clipperContainer != null){

          bA.setMinHeight(qx.bom.element.Overflow.DEFAULT_SCROLLBAR_WIDTH);
          this.__clipperContainer.add(bA, {
            bottom : 0,
            right : 0,
            left : 0
          });
        } else {

          this._add(bA, {
            row : 2,
            column : 0
          });
        };
        break;case y:
        bA = this._createScrollBar(t);
        bA.addListener(Q, this._onScrollY, this);
        if(this.__clipperContainer != null){

          this.__clipperContainer.add(bA, {
            right : 0,
            bottom : 0,
            top : 0
          });
        } else {

          this._add(bA, {
            row : 1,
            column : 1
          });
        };
        break;};
        return bA || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, by);
      },
      // property modifier
      _applyHorizontalScrollBarVisible : function(bB, bC){

        this.__horScrollBar.setVisibility(bB ? G : bc);
      },
      // property modifier
      _applyVerticalScrollBarVisible : function(bD, bE){

        this.__verScrollBar.setVisibility(bD ? G : bc);
      },
      // property modifier
      _applyTablePaneModel : function(bF, bG){

        if(bG != null){

          bG.removeListener(X, this._onPaneModelChanged, this);
        };
        bF.addListener(X, this._onPaneModelChanged, this);
      },
      // property modifier
      _applyShowCellFocusIndicator : function(bH, bI){

        if(bH){

          this.__focusIndicator.setDecorator(z);
          this._updateFocusIndicator();
        } else {

          if(this.__focusIndicator){

            this.__focusIndicator.setDecorator(null);
          };
        };
      },
      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollY : function(){

        return this.__verScrollBar.getPosition();
      },
      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollY {Integer} The new scroll position.
       * @param renderSync {Boolean?false} Whether the table update should be
       *     performed synchonously.
       */
      setScrollY : function(scrollY, bJ){

        this.__verScrollBar.scrollTo(scrollY);
        if(bJ){

          this._updateContent();
        };
      },
      /**
       * Get the current position of the vertical scroll bar.
       *
       * @return {Integer} The current scroll position.
       */
      getScrollX : function(){

        return this.__horScrollBar.getPosition();
      },
      /**
       * Set the current position of the vertical scroll bar.
       *
       * @param scrollX {Integer} The new scroll position.
       */
      setScrollX : function(scrollX){

        this.__horScrollBar.scrollTo(scrollX);
      },
      /**
       * Returns the table this scroller belongs to.
       *
       * @return {qx.ui.table.Table} the table.
       */
      getTable : function(){

        return this.__table;
      },
      /**
       * Event handler. Called when the visibility of a column has changed.
       */
      onColVisibilityChanged : function(){

        this.updateHorScrollBarMaximum();
        this._updateFocusIndicator();
      },
      /**
       * Sets the column width.
       *
       * @param col {Integer} the column to change the width for.
       * @param width {Integer} the new width.
       * @return {void}
       */
      setColumnWidth : function(bK, bL){

        this.__header.setColumnWidth(bK, bL);
        this.__tablePane.setColumnWidth(bK, bL);
        var bM = this.getTablePaneModel();
        var x = bM.getX(bK);
        if(x != -1){

          // The change was in this scroller
          this.updateHorScrollBarMaximum();
          this._updateFocusIndicator();
        };
      },
      /**
       * Event handler. Called when the column order has changed.
       *
       * @return {void}
       */
      onColOrderChanged : function(){

        this.__header.onColOrderChanged();
        this.__tablePane.onColOrderChanged();
        this.updateHorScrollBarMaximum();
      },
      /**
       * Event handler. Called when the table model has changed.
       *
       * @param firstRow {Integer} The index of the first row that has changed.
       * @param lastRow {Integer} The index of the last row that has changed.
       * @param firstColumn {Integer} The model index of the first column that has changed.
       * @param lastColumn {Integer} The model index of the last column that has changed.
       */
      onTableModelDataChanged : function(bN, bO, bP, bQ){

        this.__tablePane.onTableModelDataChanged(bN, bO, bP, bQ);
        var bR = this.getTable().getTableModel().getRowCount();
        if(bR != this.__lastRowCount){

          this.updateVerScrollBarMaximum();
          if(this.getFocusedRow() >= bR){

            if(bR == 0){

              this.setFocusedCell(null, null);
            } else {

              this.setFocusedCell(this.getFocusedColumn(), bR - 1);
            };
          };
          this.__lastRowCount = bR;
        };
      },
      /**
       * Event handler. Called when the selection has changed.
       */
      onSelectionChanged : function(){

        this.__tablePane.onSelectionChanged();
      },
      /**
       * Event handler. Called when the table gets or looses the focus.
       */
      onFocusChanged : function(){

        this.__tablePane.onFocusChanged();
      },
      /**
       * Event handler. Called when the table model meta data has changed.
       *
       * @return {void}
       */
      onTableModelMetaDataChanged : function(){

        this.__header.onTableModelMetaDataChanged();
        this.__tablePane.onTableModelMetaDataChanged();
      },
      /**
       * Event handler. Called when the pane model has changed.
       */
      _onPaneModelChanged : function(){

        this.__header.onPaneModelChanged();
        this.__tablePane.onPaneModelChanged();
      },
      /**
       * Event listener for the pane clipper's resize event
       */
      _onResizePane : function(){

        this.updateHorScrollBarMaximum();
        this.updateVerScrollBarMaximum();
        // The height has changed -> Update content
        this._updateContent();
        this.__header._updateContent();
        this.__table._updateScrollBarVisibility();
      },
      /**
       * Updates the maximum of the horizontal scroll bar, so it corresponds to the
       * total width of the columns in the table pane.
       */
      updateHorScrollBarMaximum : function(){

        var bV = this.__paneClipper.getInnerSize();
        if(!bV){

          // will be called on the next resize event again
          return;
        };
        var bT = this.getTablePaneModel().getTotalWidth();
        var bU = this.__horScrollBar;
        if(bV.width < bT){

          var bS = Math.max(0, bT - bV.width);
          bU.setMaximum(bS);
          bU.setKnobFactor(bV.width / bT);
          var bW = bU.getPosition();
          bU.setPosition(Math.min(bW, bS));
        } else {

          bU.setMaximum(0);
          bU.setKnobFactor(1);
          bU.setPosition(0);
        };
      },
      /**
       * Updates the maximum of the vertical scroll bar, so it corresponds to the
       * number of rows in the table.
       */
      updateVerScrollBarMaximum : function(){

        var cf = this.__paneClipper.getInnerSize();
        if(!cf){

          // will be called on the next resize event again
          return;
        };
        var cd = this.getTable().getTableModel();
        var bY = cd.getRowCount();
        if(this.getTable().getKeepFirstVisibleRowComplete()){

          bY += 1;
        };
        var bX = this.getTable().getRowHeight();
        var cb = bY * bX;
        var ce = this.__verScrollBar;
        if(cf.height < cb){

          var ca = Math.max(0, cb - cf.height);
          ce.setMaximum(ca);
          ce.setKnobFactor(cf.height / cb);
          var cc = ce.getPosition();
          ce.setPosition(Math.min(cc, ca));
        } else {

          ce.setMaximum(0);
          ce.setKnobFactor(1);
          ce.setPosition(0);
        };
      },
      /**
       * Event handler. Called when the table property "keepFirstVisibleRowComplete"
       * changed.
       */
      onKeepFirstVisibleRowCompleteChanged : function(){

        this.updateVerScrollBarMaximum();
        this._updateContent();
      },
      /**
       * Event handler for the scroller's appear event
       */
      _onAppear : function(){

        // after the Scroller appears we start the interval again
        this._startInterval(this.getScrollTimeout());
      },
      /**
       * Event handler for the disappear event
       */
      _onDisappear : function(){

        // before the scroller disappears we need to stop it
        this._stopInterval();
      },
      /**
       * Event handler. Called when the horizontal scroll bar moved.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onScrollX : function(e){

        var cg = e.getData();
        this.fireDataEvent(d, cg, e.getOldData());
        this.__headerClipper.scrollToX(cg);
        this.__paneClipper.scrollToX(cg);
      },
      /**
       * Event handler. Called when the vertical scroll bar moved.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onScrollY : function(e){

        this.fireDataEvent(r, e.getData(), e.getOldData());
        this._postponedUpdateContent();
      },
      /**
       * Event handler. Called when the user moved the mouse wheel.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMousewheel : function(e){

        var ch = this.getTable();
        if(!ch.getEnabled()){

          return;
        };
        // vertical scrolling
        var ck = e.getWheelDelta(bh);
        // normalize that at least one step is scrolled at a time
        if(ck > 0 && ck < 1){

          ck = 1;
        } else if(ck < 0 && ck > -1){

          ck = -1;
        };
        this.__verScrollBar.scrollBySteps(ck);
        // horizontal scrolling
        ck = e.getWheelDelta(I);
        // normalize that at least one step is scrolled at a time
        if(ck > 0 && ck < 1){

          ck = 1;
        } else if(ck < 0 && ck > -1){

          ck = -1;
        };
        this.__horScrollBar.scrollBySteps(ck);
        // Update the focus
        if(this.__lastMousePageX && this.getFocusCellOnMouseMove()){

          this._focusCellAtPagePos(this.__lastMousePageX, this.__lastMousePageY);
        };
        var cj = this.__verScrollBar.getPosition();
        var ci = this.__verScrollBar.getMaximum();
        // pass the event to the parent if the scrollbar is at an edge
        if(ck < 0 && cj <= 0 || ck > 0 && cj >= ci){

          return;
        };
        e.stop();
      },
      /**
       * Common column resize logic.
       *
       * @param pageX {Integer} the current mouse x position.
       * @return {void}
       */
      __handleResizeColumn : function(cl){

        var cq = this.getTable();
        // We are currently resizing -> Update the position
        var cr = this.__header.getHeaderWidgetAtColumn(this.__resizeColumn);
        var cm = cr.getSizeHint().minWidth;
        var co = Math.max(cm, this.__lastResizeWidth + cl - this.__lastResizeMousePageX);
        if(this.getLiveResize()){

          var cn = cq.getTableColumnModel();
          cn.setColumnWidth(this.__resizeColumn, co, true);
        } else {

          this.__header.setColumnWidth(this.__resizeColumn, co, true);
          var cp = this.getTablePaneModel();
          this._showResizeLine(cp.getColumnLeft(this.__resizeColumn) + co);
        };
        this.__lastResizeMousePageX += co - this.__lastResizeWidth;
        this.__lastResizeWidth = co;
      },
      /**
       * Common column move logic.
       *
       * @param pageX {Integer} the current mouse x position.
       * @return {void}
       *
       */
      __handleMoveColumn : function(cs){

        // We are moving a column
        // Check whether we moved outside the click tolerance so we can start
        // showing the column move feedback
        // (showing the column move feedback prevents the onclick event)
        var ct = qx.ui.table.pane.Scroller.CLICK_TOLERANCE;
        if(this.__header.isShowingColumnMoveFeedback() || cs > this.__lastMoveMousePageX + ct || cs < this.__lastMoveMousePageX - ct){

          this.__lastMoveColPos += cs - this.__lastMoveMousePageX;
          this.__header.showColumnMoveFeedback(this.__moveColumn, this.__lastMoveColPos);
          // Get the responsible scroller
          var cu = this.__table.getTablePaneScrollerAtPageX(cs);
          if(this.__lastMoveTargetScroller && this.__lastMoveTargetScroller != cu){

            this.__lastMoveTargetScroller.hideColumnMoveFeedback();
          };
          if(cu != null){

            this.__lastMoveTargetX = cu.showColumnMoveFeedback(cs);
          } else {

            this.__lastMoveTargetX = null;
          };
          this.__lastMoveTargetScroller = cu;
          this.__lastMoveMousePageX = cs;
        };
      },
      /**
       * Event handler. Called when the user moved the mouse over the header.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMousemoveHeader : function(e){

        var cB = this.getTable();
        if(!cB.getEnabled()){

          return;
        };
        var cC = false;
        var cv = null;
        var cz = e.getDocumentLeft();
        var cA = e.getDocumentTop();
        // Workaround: In onmousewheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.
        this.__lastMousePageX = cz;
        this.__lastMousePageY = cA;
        if(this.__resizeColumn != null){

          // We are currently resizing -> Update the position
          this.__handleResizeColumn(cz);
          cC = true;
          e.stopPropagation();
        } else if(this.__moveColumn != null){

          // We are moving a column
          this.__handleMoveColumn(cz);
          e.stopPropagation();
        } else {

          var cw = this._getResizeColumnForPageX(cz);
          if(cw != -1){

            // The mouse is over a resize region -> Show the right cursor
            cC = true;
          } else {

            var cy = cB.getTableModel();
            var cD = this._getColumnForPageX(cz);
            if(cD != null && cy.isColumnSortable(cD)){

              cv = cD;
            };
          };
        };
        var cx = cC ? P : null;
        this.getApplicationRoot().setGlobalCursor(cx);
        this.setCursor(cx);
        this.__header.setMouseOverColumn(cv);
      },
      /**
       * Event handler. Called when the user moved the mouse over the pane.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMousemovePane : function(e){

        var cE = this.getTable();
        if(!cE.getEnabled()){

          return;
        };
        //var useResizeCursor = false;
        var cG = e.getDocumentLeft();
        var cH = e.getDocumentTop();
        // Workaround: In onmousewheel the event has wrong coordinates for pageX
        //       and pageY. So we remember the last move event.
        this.__lastMousePageX = cG;
        this.__lastMousePageY = cH;
        var cF = this._getRowForPagePos(cG, cH);
        if(cF != null && this._getColumnForPageX(cG) != null){

          // The mouse is over the data -> update the focus
          if(this.getFocusCellOnMouseMove()){

            this._focusCellAtPagePos(cG, cH);
          };
        };
        this.__header.setMouseOverColumn(null);
      },
      /**
       * Event handler. Called when the user pressed a mouse button over the header.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMousedownHeader : function(e){

        if(!this.getTable().getEnabled()){

          return;
        };
        var cJ = e.getDocumentLeft();
        // mouse is in header
        var cK = this._getResizeColumnForPageX(cJ);
        if(cK != -1){

          // The mouse is over a resize region -> Start resizing
          this._startResizeHeader(cK, cJ);
          e.stop();
        } else {

          // The mouse is not in a resize region
          var cI = this._getColumnForPageX(cJ);
          if(cI != null){

            this._startMoveHeader(cI, cJ);
            e.stop();
          };
        };
      },
      /**
       * Start a resize session of the header.
       *
       * @param resizeCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the mouse event
       * @return {void}
       */
      _startResizeHeader : function(cL, cM){

        var cN = this.getTable().getTableColumnModel();
        // The mouse is over a resize region -> Start resizing
        this.__resizeColumn = cL;
        this.__lastResizeMousePageX = cM;
        this.__lastResizeWidth = cN.getColumnWidth(this.__resizeColumn);
        this.__headerClipper.capture();
      },
      /**
       * Start a move session of the header.
       *
       * @param moveCol {Integer} the column index
       * @param pageX {Integer} x coordinate of the mouse event
       * @return {void}
       */
      _startMoveHeader : function(cO, cP){

        // Prepare column moving
        this.__moveColumn = cO;
        this.__lastMoveMousePageX = cP;
        this.__lastMoveColPos = this.getTablePaneModel().getColumnLeft(cO);
        this.__headerClipper.capture();
      },
      /**
       * Event handler. Called when the user pressed a mouse button over the pane.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMousedownPane : function(e){

        var cT = this.getTable();
        if(!cT.getEnabled()){

          return;
        };
        if(cT.isEditing()){

          cT.stopEditing();
        };
        var cQ = e.getDocumentLeft();
        var cS = e.getDocumentTop();
        var cV = this._getRowForPagePos(cQ, cS);
        var cU = this._getColumnForPageX(cQ);
        if(cV !== null){

          // The focus indicator blocks the click event on the scroller so we
          // store the current cell and listen for the mouseup event on the
          // focus indicator
          //
          // INVARIANT:
          //  The members of this object always contain the last position of
          //  the cell on which the mousedown event occurred.
          //  *** These values are never cleared! ***.
          //  Different browsers/OS combinations issue events in different
          //  orders, and the context menu event, in particular, can be issued
          //  early or late (Firefox on Linux issues it early; Firefox on
          //  Windows issues it late) so no one may clear these values.
          //
          this.__lastMouseDownCell = {
            row : cV,
            col : cU
          };
          // On the other hand, we need to know if we've issued the click event
          // so we don't issue it twice, both from mouse-up on the focus
          // indicator, and from the click even on the pane. Both possibilities
          // are necessary, however, to maintain the qooxdoo order of events.
          this.__firedClickEvent = false;
          var cR = this.getSelectBeforeFocus();
          if(cR){

            cT.getSelectionManager().handleMouseDown(cV, e);
          };
          // The mouse is over the data -> update the focus
          if(!this.getFocusCellOnMouseMove()){

            this._focusCellAtPagePos(cQ, cS);
          };
          if(!cR){

            cT.getSelectionManager().handleMouseDown(cV, e);
          };
        };
      },
      /**
       * Event handler for the focus indicator's mouseup event
       *
       * @param e {qx.event.type.Mouse} The mouse event
       */
      _onMouseupFocusIndicator : function(e){

        if(this.__lastMouseDownCell && !this.__firedClickEvent && !this.isEditing() && this.__focusIndicator.getRow() == this.__lastMouseDownCell.row && this.__focusIndicator.getColumn() == this.__lastMouseDownCell.col){

          this.fireEvent(V, qx.ui.table.pane.CellEvent, [this, e, this.__lastMouseDownCell.row, this.__lastMouseDownCell.col], true);
          this.__firedClickEvent = true;
        } else if(!this.isEditing()){

          // if no cellClick event should be fired, act like a mousedown which
          // invokes the change of the selection e.g. [BUG #1632]
          this._onMousedownPane(e);
        };
      },
      /**
       * Event handler. Called when the event capturing of the header changed.
       * Stops/finishes an active header resize/move session if it lost capturing
       * during the session to stay in a stable state.
       *
       * @param e {qx.event.type.Data} The data event
       */
      _onChangeCaptureHeader : function(e){

        if(this.__resizeColumn != null){

          this._stopResizeHeader();
        };
        if(this.__moveColumn != null){

          this._stopMoveHeader();
        };
      },
      /**
       * Stop a resize session of the header.
       *
       * @return {void}
       */
      _stopResizeHeader : function(){

        var cW = this.getTable().getTableColumnModel();
        // We are currently resizing -> Finish resizing
        if(!this.getLiveResize()){

          this._hideResizeLine();
          cW.setColumnWidth(this.__resizeColumn, this.__lastResizeWidth, true);
        };
        this.__resizeColumn = null;
        this.__headerClipper.releaseCapture();
        this.getApplicationRoot().setGlobalCursor(null);
        this.setCursor(null);
        // handle edit cell if available
        if(this.isEditing()){

          var cX = this.__cellEditor.getBounds().height;
          this.__cellEditor.setUserBounds(0, 0, this.__lastResizeWidth, cX);
        };
      },
      /**
       * Stop a move session of the header.
       *
       * @return {void}
       */
      _stopMoveHeader : function(){

        var dd = this.getTable().getTableColumnModel();
        var de = this.getTablePaneModel();
        // We are moving a column -> Drop the column
        this.__header.hideColumnMoveFeedback();
        if(this.__lastMoveTargetScroller){

          this.__lastMoveTargetScroller.hideColumnMoveFeedback();
        };
        if(this.__lastMoveTargetX != null){

          var dg = de.getFirstColumnX() + de.getX(this.__moveColumn);
          var dc = this.__lastMoveTargetX;
          if(dc != dg && dc != dg + 1){

            // The column was really moved to another position
            // (and not moved before or after itself, which is a noop)
            // Translate visible positions to overall positions
            var df = dd.getVisibleColumnAtX(dg);
            var db = dd.getVisibleColumnAtX(dc);
            var da = dd.getOverallX(df);
            var cY = (db != null) ? dd.getOverallX(db) : dd.getOverallColumnCount();
            if(cY > da){

              // Don't count the column itself
              cY--;
            };
            // Move the column
            dd.moveColumn(da, cY);
            // update the focus indicator including the editor
            this._updateFocusIndicator();
          };
        };
        this.__moveColumn = null;
        this.__lastMoveTargetX = null;
        this.__headerClipper.releaseCapture();
      },
      /**
       * Event handler. Called when the user released a mouse button over the pane.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMouseupPane : function(e){

        var dh = this.getTable();
        if(!dh.getEnabled()){

          return;
        };
        var di = this._getRowForPagePos(e.getDocumentLeft(), e.getDocumentTop());
        if(di != -1 && di != null && this._getColumnForPageX(e.getDocumentLeft()) != null){

          dh.getSelectionManager().handleMouseUp(di, e);
        };
      },
      /**
       * Event handler. Called when the user released a mouse button over the header.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMouseupHeader : function(e){

        var dj = this.getTable();
        if(!dj.getEnabled()){

          return;
        };
        if(this.__resizeColumn != null){

          this._stopResizeHeader();
          this.__ignoreClick = true;
          e.stop();
        } else if(this.__moveColumn != null){

          this._stopMoveHeader();
          e.stop();
        };
      },
      /**
       * Event handler. Called when the user clicked a mouse button over the header.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onClickHeader : function(e){

        if(this.__ignoreClick){

          this.__ignoreClick = false;
          return;
        };
        var dp = this.getTable();
        if(!dp.getEnabled()){

          return;
        };
        var dm = dp.getTableModel();
        var dn = e.getDocumentLeft();
        var dl = this._getResizeColumnForPageX(dn);
        if(dl == -1){

          // mouse is not in a resize region
          var ds = this._getColumnForPageX(dn);
          if(ds != null && dm.isColumnSortable(ds)){

            // Sort that column
            var dk = dm.getSortColumnIndex();
            var dq = (ds != dk) ? true : !dm.isSortAscending();
            var dr = {
              column : ds,
              ascending : dq,
              clickEvent : e
            };
            if(this.fireDataEvent(q, dr, null, true)){

              // Stop cell editing
              if(dp.isEditing()){

                dp.stopEditing();
              };
              dm.sortByColumn(ds, dq);
              if(this.getResetSelectionOnHeaderClick()){

                dp.getSelectionModel().resetSelection();
              };
            };
          };
        };
        e.stop();
      },
      /**
       * Event handler. Called when the user clicked a mouse button over the pane.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onClickPane : function(e){

        var dt = this.getTable();
        if(!dt.getEnabled()){

          return;
        };
        var dw = e.getDocumentLeft();
        var dx = e.getDocumentTop();
        var du = this._getRowForPagePos(dw, dx);
        var dv = this._getColumnForPageX(dw);
        if(du != null && dv != null){

          dt.getSelectionManager().handleClick(du, e);
          if(this.__focusIndicator.isHidden() || (this.__lastMouseDownCell && !this.__firedClickEvent && !this.isEditing() && du == this.__lastMouseDownCell.row && dv == this.__lastMouseDownCell.col)){

            this.fireEvent(V, qx.ui.table.pane.CellEvent, [this, e, du, dv], true);
            this.__firedClickEvent = true;
          };
        };
      },
      /**
       * Event handler. Called when a context menu is invoked in a cell.
       *
       * @param e {qx.event.type.Mouse} the event.
       * @return {void}
       */
      _onContextMenu : function(e){

        var dB = e.getDocumentLeft();
        var dC = e.getDocumentTop();
        var dz = this._getRowForPagePos(dB, dC);
        var dA = this._getColumnForPageX(dB);
        /*
         * The 'row' value will be null if the right-click was in the blank
         * area below the last data row. Some applications desire to receive
         * the context menu event anyway, and can set the property value of
         * contextMenuFromDataCellsOnly to false to achieve that.
         */
        if(dz === null && this.getContextMenuFromDataCellsOnly()){

          return;
        };
        if(!this.getShowCellFocusIndicator() || dz === null || (this.__lastMouseDownCell && dz == this.__lastMouseDownCell.row && dA == this.__lastMouseDownCell.col)){

          this.fireEvent(bf, qx.ui.table.pane.CellEvent, [this, e, dz, dA], true);
          // Now that the cellContextmenu handler has had a chance to build
          // the menu for this cell, display it (if there is one).
          var dy = this.getTable().getContextMenu();
          if(dy){

            // A menu with no children means don't display any context menu
            // including the default context menu even if the default context
            // menu is allowed to be displayed normally. There's no need to
            // actually show an empty menu, though.
            if(dy.getChildren().length > 0){

              dy.openAtMouse(e);
            } else {

              dy.exclude();
            };
            // Do not show native menu
            e.preventDefault();
          };
        };
      },
      // overridden
      _onContextMenuOpen : function(e){
      },
      /**
       * Event handler. Called when the user double clicked a mouse button over the pane.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onDblclickPane : function(e){

        var dE = e.getDocumentLeft();
        var dF = e.getDocumentTop();
        this._focusCellAtPagePos(dE, dF);
        this.startEditing();
        var dD = this._getRowForPagePos(dE, dF);
        if(dD != -1 && dD != null){

          this.fireEvent(D, qx.ui.table.pane.CellEvent, [this, e, dD], true);
        };
      },
      /**
       * Event handler. Called when the mouse moved out.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onMouseout : function(e){

        var dG = this.getTable();
        if(!dG.getEnabled()){

          return;
        };
        // Reset the resize cursor when the mouse leaves the header
        // If currently a column is resized then do nothing
        // (the cursor will be reset on mouseup)
        if(this.__resizeColumn == null){

          this.setCursor(null);
          this.getApplicationRoot().setGlobalCursor(null);
        };
        this.__header.setMouseOverColumn(null);
        // in case the focus follows the mouse, it should be remove on mouseout
        if(this.getFocusCellOnMouseMove()){

          this.__table.setFocusedCell();
        };
      },
      /**
       * Shows the resize line.
       *
       * @param x {Integer} the position where to show the line (in pixels, relative to
       *      the left side of the pane).
       * @return {void}
       */
      _showResizeLine : function(x){

        var dI = this._showChildControl(b);
        var dH = dI.getWidth();
        var dJ = this.__paneClipper.getBounds();
        dI.setUserBounds(x - Math.round(dH / 2), 0, dH, dJ.height);
      },
      /**
       * Hides the resize line.
       */
      _hideResizeLine : function(){

        this._excludeChildControl(b);
      },
      /**
       * Shows the feedback shown while a column is moved by the user.
       *
       * @param pageX {Integer} the x position of the mouse in the page (in pixels).
       * @return {Integer} the visible x position of the column in the whole table.
       */
      showColumnMoveFeedback : function(dK){

        var dT = this.getTablePaneModel();
        var dS = this.getTable().getTableColumnModel();
        var dN = this.__tablePane.getContainerLocation().left;
        var dR = dT.getColumnCount();
        var dO = 0;
        var dM = 0;
        var dW = dN;
        for(var dL = 0;dL < dR;dL++){

          var dP = dT.getColumnAtX(dL);
          var dU = dS.getColumnWidth(dP);
          if(dK < dW + dU / 2){

            break;
          };
          dW += dU;
          dO = dL + 1;
          dM = dW - dN;
        };
        // Ensure targetX is visible
        var dQ = this.__paneClipper.getContainerLocation().left;
        var dV = this.__paneClipper.getBounds().width;
        var scrollX = dQ - dN;
        // NOTE: +2/-1 because of feedback width
        dM = qx.lang.Number.limit(dM, scrollX + 2, scrollX + dV - 1);
        this._showResizeLine(dM);
        // Return the overall target x position
        return dT.getFirstColumnX() + dO;
      },
      /**
       * Hides the feedback shown while a column is moved by the user.
       */
      hideColumnMoveFeedback : function(){

        this._hideResizeLine();
      },
      /**
       * Sets the focus to the cell that's located at the page position
       * <code>pageX</code>/<code>pageY</code>. If there is no cell at that position,
       * nothing happens.
       *
       * @param pageX {Integer} the x position in the page (in pixels).
       * @param pageY {Integer} the y position in the page (in pixels).
       * @return {void}
       */
      _focusCellAtPagePos : function(dX, dY){

        var eb = this._getRowForPagePos(dX, dY);
        if(eb != -1 && eb != null){

          // The mouse is over the data -> update the focus
          var ea = this._getColumnForPageX(dX);
          this.__table.setFocusedCell(ea, eb);
        };
      },
      /**
       * Sets the currently focused cell.
       *
       * @param col {Integer} the model index of the focused cell's column.
       * @param row {Integer} the model index of the focused cell's row.
       * @return {void}
       */
      setFocusedCell : function(ec, ed){

        if(!this.isEditing()){

          this.__tablePane.setFocusedCell(ec, ed, this.__updateContentPlanned);
          this.__focusedCol = ec;
          this.__focusedRow = ed;
          this._updateFocusIndicator();
        };
      },
      /**
       * Returns the column of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedColumn : function(){

        return this.__focusedCol;
      },
      /**
       * Returns the row of currently focused cell.
       *
       * @return {Integer} the model index of the focused cell's column.
       */
      getFocusedRow : function(){

        return this.__focusedRow;
      },
      /**
       * Scrolls a cell visible.
       *
       * @param col {Integer} the model index of the column the cell belongs to.
       * @param row {Integer} the model index of the row the cell belongs to.
       * @return {void}
       */
      scrollCellVisible : function(ee, ef){

        var ep = this.getTablePaneModel();
        var eg = ep.getX(ee);
        if(eg != -1){

          var em = this.__paneClipper.getInnerSize();
          if(!em){

            return;
          };
          var en = this.getTable().getTableColumnModel();
          var ej = ep.getColumnLeft(ee);
          var eq = en.getColumnWidth(ee);
          var eh = this.getTable().getRowHeight();
          var er = ef * eh;
          var scrollX = this.getScrollX();
          var scrollY = this.getScrollY();
          // NOTE: We don't use qx.lang.Number.limit, because min should win if max < min
          var eo = Math.min(ej, ej + eq - em.width);
          var el = ej;
          this.setScrollX(Math.max(eo, Math.min(el, scrollX)));
          var ei = er + eh - em.height;
          if(this.getTable().getKeepFirstVisibleRowComplete()){

            ei += eh;
          };
          var ek = er;
          this.setScrollY(Math.max(ei, Math.min(ek, scrollY)), true);
        };
      },
      /**
       * Returns whether currently a cell is editing.
       *
       * @return {var} whether currently a cell is editing.
       */
      isEditing : function(){

        return this.__cellEditor != null;
      },
      /**
       * Starts editing the currently focused cell. Does nothing if already
       * editing, if the column is not editable, or if the cell editor for the
       * column ascertains that the particular cell is not editable.
       *
       * @return {Boolean} whether editing was started
       */
      startEditing : function(){

        var ew = this.getTable();
        var eu = ew.getTableModel();
        var ey = this.__focusedCol;
        if(!this.isEditing() && (ey != null) && eu.isColumnEditable(ey)){

          var ez = this.__focusedRow;
          var es = this.getTablePaneModel().getX(ey);
          var et = eu.getValue(ey, ez);
          // scroll cell into view
          this.scrollCellVisible(es, ez);
          this.__cellEditorFactory = ew.getTableColumnModel().getCellEditorFactory(ey);
          var ev = {
            col : ey,
            row : ez,
            xPos : es,
            value : et,
            table : ew
          };
          // Get a cell editor
          this.__cellEditor = this.__cellEditorFactory.createCellEditor(ev);
          // We handle two types of cell editors: the traditional in-place
          // editor, where the cell editor returned by the factory must fit in
          // the space of the table cell; and a modal window in which the
          // editing takes place.  Additionally, if the cell editor determines
          // that it does not want to edit the particular cell being requested,
          // it may return null to indicate that that cell is not editable.
          if(this.__cellEditor === null){

            // This cell is not editable even though its column is.
            return false;
          } else if(this.__cellEditor instanceof qx.ui.window.Window){

            // It's a window.  Ensure that it's modal.
            this.__cellEditor.setModal(true);
            // At least for the time being, we disallow the close button.  It
            // acts differently than a cellEditor.close(), and invokes a bug
            // someplace.  Modal window cell editors should provide their own
            // buttons or means to activate a cellEditor.close() or equivalently
            // cellEditor.hide().
            this.__cellEditor.setShowClose(false);
            // Arrange to be notified when it is closed.
            this.__cellEditor.addListener(be, this._onCellEditorModalWindowClose, this);
            // If there's a pre-open function defined for the table...
            var f = ew.getModalCellEditorPreOpenFunction();
            if(f != null){

              f(this.__cellEditor, ev);
            };
            // Open it now.
            this.__cellEditor.open();
          } else {

            // The cell editor is a traditional in-place editor.
            var ex = this.__focusIndicator.getInnerSize();
            this.__cellEditor.setUserBounds(0, 0, ex.width, ex.height);
            // prevent click event from bubbling up to the table
            this.__focusIndicator.addListener(bb, function(e){

              this.__lastMouseDownCell = {
                row : this.__focusedRow,
                col : this.__focusedCol
              };
              e.stopPropagation();
            }, this);
            this.__focusIndicator.add(this.__cellEditor);
            this.__focusIndicator.addState(R);
            this.__focusIndicator.setKeepActive(false);
            // Make the focus indicator visible during editing
            this.__focusIndicator.setDecorator(z);
            this.__cellEditor.focus();
            this.__cellEditor.activate();
          };
          return true;
        };
        return false;
      },
      /**
       * Stops editing and writes the editor's value to the model.
       */
      stopEditing : function(){

        // If the focus indicator is not being shown normally...
        if(!this.getShowCellFocusIndicator()){

          // ... then hide it again
          this.__focusIndicator.setDecorator(null);
        };
        this.flushEditor();
        this.cancelEditing();
      },
      /**
       * Writes the editor's value to the model.
       */
      flushEditor : function(){

        if(this.isEditing()){

          var eB = this.__cellEditorFactory.getCellEditorValue(this.__cellEditor);
          var eA = this.getTable().getTableModel().getValue(this.__focusedCol, this.__focusedRow);
          this.getTable().getTableModel().setValue(this.__focusedCol, this.__focusedRow, eB);
          this.__table.focus();
          // Fire an event containing the value change.
          this.__table.fireDataEvent(bn, {
            row : this.__focusedRow,
            col : this.__focusedCol,
            oldValue : eA,
            value : eB
          });
        };
      },
      /**
       * Stops editing without writing the editor's value to the model.
       */
      cancelEditing : function(){

        if(this.isEditing() && !this.__cellEditor.pendingDispose){

          if(this._cellEditorIsModalWindow){

            this.__cellEditor.destroy();
            this.__cellEditor = null;
            this.__cellEditorFactory = null;
            this.__cellEditor.pendingDispose = true;
          } else {

            this.__focusIndicator.removeState(R);
            this.__focusIndicator.setKeepActive(true);
            this.__cellEditor.destroy();
            this.__cellEditor = null;
            this.__cellEditorFactory = null;
          };
        };
      },
      /**
       * Event handler. Called when the modal window of the cell editor closes.
       *
       * @param e {Map} the event.
       * @return {void}
       */
      _onCellEditorModalWindowClose : function(e){

        this.stopEditing();
      },
      /**
       * Returns the model index of the column the mouse is over or null if the mouse
       * is not over a column.
       *
       * @param pageX {Integer} the x position of the mouse in the page (in pixels).
       * @return {Integer} the model index of the column the mouse is over.
       */
      _getColumnForPageX : function(eC){

        var eF = this.getTable().getTableColumnModel();
        var eG = this.getTablePaneModel();
        var eE = eG.getColumnCount();
        var eI = this.__tablePane.getContentLocation().left;
        for(var x = 0;x < eE;x++){

          var eD = eG.getColumnAtX(x);
          var eH = eF.getColumnWidth(eD);
          eI += eH;
          if(eC < eI){

            return eD;
          };
        };
        return null;
      },
      /**
       * Returns the model index of the column that should be resized when dragging
       * starts here. Returns -1 if the mouse is in no resize region of any column.
       *
       * @param pageX {Integer} the x position of the mouse in the page (in pixels).
       * @return {Integer} the column index.
       */
      _getResizeColumnForPageX : function(eJ){

        var eN = this.getTable().getTableColumnModel();
        var eO = this.getTablePaneModel();
        var eM = eO.getColumnCount();
        var eQ = this.__header.getContainerLocation().left;
        var eK = qx.ui.table.pane.Scroller.RESIZE_REGION_RADIUS;
        for(var x = 0;x < eM;x++){

          var eL = eO.getColumnAtX(x);
          var eP = eN.getColumnWidth(eL);
          eQ += eP;
          if(eJ >= (eQ - eK) && eJ <= (eQ + eK)){

            return eL;
          };
        };
        return -1;
      },
      /**
       * Returns the model index of the row the mouse is currently over. Returns -1 if
       * the mouse is over the header. Returns null if the mouse is not over any
       * column.
       *
       * @param pageX {Integer} the mouse x position in the page.
       * @param pageY {Integer} the mouse y position in the page.
       * @return {Integer} the model index of the row the mouse is currently over.
       */
      _getRowForPagePos : function(eR, eS){

        var eT = this.__tablePane.getContentLocation();
        if(eR < eT.left || eR > eT.right){

          // There was no cell or header cell hit
          return null;
        };
        if(eS >= eT.top && eS <= eT.bottom){

          // This event is in the pane -> Get the row
          var eU = this.getTable().getRowHeight();
          var scrollY = this.__verScrollBar.getPosition();
          if(this.getTable().getKeepFirstVisibleRowComplete()){

            scrollY = Math.floor(scrollY / eU) * eU;
          };
          var eX = scrollY + eS - eT.top;
          var fa = Math.floor(eX / eU);
          var eY = this.getTable().getTableModel();
          var eV = eY.getRowCount();
          return (fa < eV) ? fa : null;
        };
        var eW = this.__header.getContainerLocation();
        if(eS >= eW.top && eS <= eW.bottom && eR <= eW.right){

          // This event is in the pane -> Return -1 for the header
          return -1;
        };
        return null;
      },
      /**
       * Sets the widget that should be shown in the top right corner.
       *
       * The widget will not be disposed, when this table scroller is disposed. So the
       * caller has to dispose it.
       *
       * @param widget {qx.ui.core.Widget} The widget to set. May be null.
       * @return {void}
       */
      setTopRightWidget : function(fb){

        var fc = this.__topRightWidget;
        if(fc != null){

          this.__top.remove(fc);
        };
        if(fb != null){

          this.__top.add(fb);
        };
        this.__topRightWidget = fb;
      },
      /**
       * Get the top right widget
       *
       * @return {qx.ui.core.Widget} The top right widget.
       */
      getTopRightWidget : function(){

        return this.__topRightWidget;
      },
      /**
       * Returns the header.
       *
       * @return {qx.ui.table.pane.Header} the header.
       */
      getHeader : function(){

        return this.__header;
      },
      /**
       * Returns the table pane.
       *
       * @return {qx.ui.table.pane.Pane} the table pane.
       */
      getTablePane : function(){

        return this.__tablePane;
      },
      /**
       * Get the rendered width of the vertical scroll bar. The return value is
       * <code>0</code> if the scroll bar is invisible or not yet rendered.
       *
       * @internal
       * @return {Integer} The width of the vertical scroll bar
       */
      getVerticalScrollBarWidth : function(){

        var fd = this.__verScrollBar;
        return fd.isVisible() ? (fd.getSizeHint().width || 0) : 0;
      },
      /**
       * Returns which scrollbars are needed.
       *
       * @param forceHorizontal {Boolean ? false} Whether to show the horizontal
       *      scrollbar always.
       * @param preventVertical {Boolean ? false} Whether to show the vertical scrollbar
       *      never.
       * @return {Integer} which scrollbars are needed. This may be any combination of
       *      {@link #HORIZONTAL_SCROLLBAR} or {@link #VERTICAL_SCROLLBAR}
       *      (combined by OR).
       */
      getNeededScrollBars : function(fe, ff){

        var fo = this.__verScrollBar;
        var fs = fo.getSizeHint().width + fo.getMarginLeft() + fo.getMarginRight();
        var fu = this.__horScrollBar;
        var ft = fu.getSizeHint().height + fu.getMarginTop() + fu.getMarginBottom();
        // Get the width and height of the view (without scroll bars)
        var fm = this.__paneClipper.getInnerSize();
        var fg = fm ? fm.width : 0;
        if(this.getVerticalScrollBarVisible()){

          fg += fs;
        };
        var fr = fm ? fm.height : 0;
        if(this.getHorizontalScrollBarVisible()){

          fr += ft;
        };
        var fn = this.getTable().getTableModel();
        var fk = fn.getRowCount();
        // Get the (virtual) width and height of the pane
        var fh = this.getTablePaneModel().getTotalWidth();
        var fp = this.getTable().getRowHeight() * fk;
        // Check which scrollbars are needed
        var fj = false;
        var fq = false;
        if(fh > fg){

          fj = true;
          if(fp > fr - ft){

            fq = true;
          };
        } else if(fp > fr){

          fq = true;
          if(!ff && (fh > fg - fs)){

            fj = true;
          };
        };
        // Create the mask
        var fl = qx.ui.table.pane.Scroller.HORIZONTAL_SCROLLBAR;
        var fi = qx.ui.table.pane.Scroller.VERTICAL_SCROLLBAR;
        return ((fe || fj) ? fl : 0) | ((ff || !fq) ? 0 : fi);
      },
      /**
       * Return the pane clipper. It is sometimes required for special activities
       * such as tracking events for drag&drop.
       *
       * @return {qx.ui.table.pane.Clipper}
       *   The pane clipper for this scroller.
       */
      getPaneClipper : function(){

        return this.__paneClipper;
      },
      // property apply method
      _applyScrollTimeout : function(fv, fw){

        this._startInterval(fv);
      },
      /**
       * Starts the current running interval
       *
       * @param timeout {Integer} The timeout between two table updates
       */
      _startInterval : function(fx){

        this.__timer.setInterval(fx);
        this.__timer.start();
      },
      /**
       * stops the current running interval
       */
      _stopInterval : function(){

        this.__timer.stop();
      },
      /**
       * Does a postponed update of the content.
       *
       * @see #_updateContent
       */
      _postponedUpdateContent : function(){

        //this.__updateContentPlanned = true;
        this._updateContent();
      },
      /**
       * Timer event handler. Periodically checks whether a table update is
       * required. The update interval is controlled by the {@link #scrollTimeout}
       * property.
       *
       * @signature function()
       */
      _oninterval : qx.event.GlobalError.observeMethod(function(){

        if(this.__updateContentPlanned && !this.__tablePane._layoutPending){

          this.__updateContentPlanned = false;
          this._updateContent();
        };
      }),
      /**
       * Updates the content. Sets the right section the table pane should show and
       * does the scrolling.
       */
      _updateContent : function(){

        var fC = this.__paneClipper.getInnerSize();
        if(!fC){

          return;
        };
        var fF = fC.height;
        var scrollX = this.__horScrollBar.getPosition();
        var scrollY = this.__verScrollBar.getPosition();
        var fz = this.getTable().getRowHeight();
        var fA = Math.floor(scrollY / fz);
        var fE = this.__tablePane.getFirstVisibleRow();
        this.__tablePane.setFirstVisibleRow(fA);
        var fB = Math.ceil(fF / fz);
        var fy = 0;
        var fD = this.getTable().getKeepFirstVisibleRowComplete();
        if(!fD){

          // NOTE: We don't consider paneOffset, because this may cause alternating
          //       adding and deleting of one row when scrolling. Instead we add one row
          //       in every case.
          fB++;
          fy = scrollY % fz;
        };
        this.__tablePane.setVisibleRowCount(fB);
        if(fA != fE){

          this._updateFocusIndicator();
        };
        this.__paneClipper.scrollToX(scrollX);
        // Avoid expensive calls to setScrollTop if
        // scrolling is not needed
        if(!fD){

          this.__paneClipper.scrollToY(fy);
        };
      },
      /**
       * Updates the location and the visibility of the focus indicator.
       *
       * @return {void}
       */
      _updateFocusIndicator : function(){

        var fG = this.getTable();
        if(!fG.getEnabled()){

          return;
        };
        this.__focusIndicator.moveToCell(this.__focusedCol, this.__focusedRow);
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._stopInterval();
      // this object was created by the table on init so we have to clean it up.
      var fH = this.getTablePaneModel();
      if(fH){

        fH.dispose();
      };
      this.__lastMouseDownCell = this.__topRightWidget = this.__table = null;
      this._disposeObjects(o, v, j, m, bk, i, C, H, u, n);
    }
  });
})();
(function(){

  var a = "qx.ui.table.pane.Clipper";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Clipping area for the table header and table pane.
   */
  qx.Class.define(a, {
    extend : qx.ui.container.Composite,
    construct : function(){

      qx.ui.container.Composite.call(this, new qx.ui.layout.Grow());
      this.setMinWidth(0);
    },
    members : {
      /**
       * Scrolls the element's content to the given left coordinate
       *
       * @param value {Integer} The vertical position to scroll to.
       * @return {void}
       */
      scrollToX : function(b){

        this.getContentElement().scrollToX(b, false);
      },
      /**
       * Scrolls the element's content to the given top coordinate
       *
       * @param value {Integer} The horizontal position to scroll to.
       * @return {void}
       */
      scrollToY : function(c){

        this.getContentElement().scrollToY(c, true);
      }
    }
  });
})();
(function(){

  var d = "qx.nativeScrollBars",c = "os.scrollBarOverlayed",b = "osx",a = "qx.bom.client.Scroll";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This class is responsible for checking the scrolling behavior of the client.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define(a, {
    statics : {
      /**
       * Check if the scrollbars should be positioned on top of the content. This
       * is true of OSX Lion when the scrollbars dissapear automatically.
       *
       * @internal
       *
       * @return {Boolean} <code>true</code> if the scrollbars should be
       *   positioned on top of the content.
       */
      scrollBarOverlayed : function(){

        var e = qx.bom.element.Overflow.getScrollbarWidth();
        var f = qx.bom.client.OperatingSystem.getName() === b;
        var g = qx.core.Environment.get(d);
        return e == 0 && f && g;
      }
    },
    defer : function(h){

      qx.core.Environment.add(c, h.scrollBarOverlayed);
    }
  });
})();
(function(){

  var g = "Escape",f = "keypress",d = "Enter",c = "excluded",b = "qx.ui.table.pane.FocusIndicator",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The focus indicator widget
   */
  qx.Class.define(b, {
    extend : qx.ui.container.Composite,
    /**
     * @param scroller {Scroller} The scroller, which contains this focus indicator
     */
    construct : function(h){

      qx.ui.container.Composite.call(this);
      this.__scroller = h;
      this.setKeepActive(true);
      this.addListener(f, this._onKeyPress, this);
    },
    properties : {
      // overridden
      visibility : {
        refine : true,
        init : c
      },
      /** Table row, where the indicator is placed. */
      row : {
        check : a,
        nullable : true
      },
      /** Table column, where the indicator is placed. */
      column : {
        check : a,
        nullable : true
      }
    },
    members : {
      __scroller : null,
      /**
       * Keypress handler. Suppress all key events but "Enter" and "Escape"
       *
       * @param e {qx.event.type.KeySequence} key event
       */
      _onKeyPress : function(e){

        var i = e.getKeyIdentifier();
        if(i !== g && i !== d){

          e.stopPropagation();
        };
      },
      /**
       * Move the focus indicator to the given table cell.
       *
       * @param col {Integer?null} The table column
       * @param row {Integer?null} The table row
       */
      moveToCell : function(j, k){

        // check if the focus indicator is shown and if the new column is
        // editable. if not, just exclude the incdicator because the mouse events
        // should go to the cell itself linke with HTML links [BUG #4250]
        if(!this.__scroller.getShowCellFocusIndicator() && !this.__scroller.getTable().getTableModel().isColumnEditable(j)){

          this.exclude();
          return;
        } else {

          this.show();
        };
        if(j == null){

          this.hide();
          this.setRow(null);
          this.setColumn(null);
        } else {

          var l = this.__scroller.getTablePaneModel().getX(j);
          if(l == -1){

            this.hide();
            this.setRow(null);
            this.setColumn(null);
          } else {

            var q = this.__scroller.getTable();
            var o = q.getTableColumnModel();
            var p = this.__scroller.getTablePaneModel();
            var n = this.__scroller.getTablePane().getFirstVisibleRow();
            var m = q.getRowHeight();
            this.setUserBounds(p.getColumnLeft(j) - 2, (k - n) * m - 2, o.getColumnWidth(j) + 3, m + 3);
            this.show();
            this.setRow(k);
            this.setColumn(j);
          };
        };
      }
    },
    destruct : function(){

      this.__scroller = null;
    }
  });
})();
(function(){

  var b = "qx.ui.table.pane.CellEvent",a = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
  
  ************************************************************************ */
  /**
   * A cell event instance contains all data for mouse events related to cells in
   * a table.
   **/
  qx.Class.define(b, {
    extend : qx.event.type.Mouse,
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The table row of the event target */
      row : {
        check : a,
        nullable : true
      },
      /** The table column of the event target */
      column : {
        check : a,
        nullable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /*
       *****************************************************************************
          CONSTRUCTOR
       *****************************************************************************
       */
      /**
       * Initialize the event
       *
       * @param scroller {qx.ui.table.pane.Scroller} The tables pane scroller
       * @param me {qx.event.type.Mouse} The original mouse event
       * @param row {Integer?null} The cell's row index
       * @param column {Integer?null} The cell's column index
       */
      init : function(c, d, e, f){

        d.clone(this);
        this.setBubbles(false);
        if(e != null){

          this.setRow(e);
        } else {

          this.setRow(c._getRowForPagePos(this.getDocumentLeft(), this.getDocumentTop()));
        };
        if(f != null){

          this.setColumn(f);
        } else {

          this.setColumn(c._getColumnForPageX(this.getDocumentLeft()));
        };
      },
      // overridden
      clone : function(g){

        var h = qx.event.type.Mouse.prototype.clone.call(this, g);
        h.set({
          row : this.getRow(),
          column : this.getColumn()
        });
        return h;
      }
    }
  });
})();
(function(){

  var a = "qx.lang.Number";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Helper functions for numbers.
   *
   * The native JavaScript Number is not modified by this class.
   *
   */
  qx.Class.define(a, {
    statics : {
      /**
       * Check whether the number is in a given range
       *
       * @param nr {Number} the number to check
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Boolean} whether the number is >= vmin and <= vmax
       */
      isInRange : function(b, c, d){

        return b >= c && b <= d;
      },
      /**
       * Check whether the number is between a given range
       *
       * @param nr {Number} the number to check
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Boolean} whether the number is > vmin and < vmax
       */
      isBetweenRange : function(e, f, g){

        return e > f && e < g;
      },
      /**
       * Limit the number to a given range
       *
       * * If the number is greater than the upper bound, the upper bound is returned
       * * If the number is smaller than the lower bound, the lower bound is returned
       * * If the number is in the range, the number is returned
       *
       * @param nr {Number} the number to limit
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Integer} the limited number
       */
      limit : function(h, i, j){

        if(j != null && h > j){

          return j;
        } else if(i != null && h < i){

          return i;
        } else {

          return h;
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.window.IWindowManager";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Required interface for all window manager.
   *
   * Window manager handle the z-order and modality blocking of windows managed
   * by the connected desktop {@link IDesktop}.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Connect the window manager to the window desktop
       *
       * @param desktop {IDesktop} The connected desktop
       */
      setDesktop : function(b){

        this.assertInterface(b, qx.ui.window.IDesktop);
      },
      /**
       * Inform the window manager about a new active window
       *
       * @param active {Window} new active window
       * @param oldActive {Window} old active window
       */
      changeActiveWindow : function(c, d){
      },
      /**
       * Update the window order and modality blocker
       */
      updateStack : function(){
      },
      /**
       * Ask the manager to bring a window to the front.
       *
       * @param win {Window} window to bring to front
       */
      bringToFront : function(e){

        this.assertInstance(e, qx.ui.window.Window);
      },
      /**
       * Ask the manager to send a window to the back.
       *
       * @param win {Window} window to sent to back
       */
      sendToBack : function(f){

        this.assertInstance(f, qx.ui.window.Window);
      }
    }
  });
})();
(function(){

  var a = "qx.ui.window.IDesktop";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * All parent widgets of windows must implement this interface.
   */
  qx.Interface.define(a, {
    members : {
      /**
       * Sets the desktop's window manager
       *
       * @param manager {qx.ui.window.IWindowManager} The window manager
       */
      setWindowManager : function(b){

        this.assertInterface(b, qx.ui.window.IWindowManager);
      },
      /**
       * Get a list of all windows added to the desktop (including hidden windows)
       *
       * @return {qx.ui.window.Window[]} Array of managed windows
       */
      getWindows : function(){
      },
      /**
       * Whether the configured layout supports a maximized window
       * e.g. is a Canvas.
       *
       * @return {Boolean} Whether the layout supports maximized windows
       */
      supportsMaximize : function(){
      },
      /**
       * Block direct child widgets with a zIndex below <code>zIndex</code>
       *
       * @param zIndex {zIndex} All child widgets with a zIndex below this value
       *     will be blocked
       */
      blockContent : function(c){

        this.assertInteger(c);
      },
      /**
       * Remove the content blocker.
       */
      unblockContent : function(){
      },
      /**
       * Whether the content is currently blocked
       *
       * @return {Boolean} whether the content is blocked.
       */
      isContentBlocked : function(){
      }
    }
  });
})();
(function(){

  var b = "qx.ui.window.Manager",a = "__desktop";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * The default window manager implementation
   */
  qx.Class.define(b, {
    extend : qx.core.Object,
    implement : qx.ui.window.IWindowManager,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __desktop : null,
      // interface implementation
      setDesktop : function(c){

        this.__desktop = c;
        this.updateStack();
      },
      /**
       * Returns the connected desktop
       *
       * @return {qx.ui.window.IDesktop} The desktop
       */
      getDesktop : function(){

        return this.__desktop;
      },
      // interface implementation
      changeActiveWindow : function(d, e){

        if(d){

          this.bringToFront(d);
          d.setActive(true);
        };
        if(e){

          e.resetActive();
        };
      },
      /** {Integer} Minimum zIndex to start with for windows */
      _minZIndex : 1e5,
      // interface implementation
      updateStack : function(){

        // we use the widget queue to do the sorting one before the queues are
        // flushed. The queue will call "syncWidget"
        qx.ui.core.queue.Widget.add(this);
      },
      /**
       * This method is called during the flush of the
       * {@link qx.ui.core.queue.Widget widget queue}.
       */
      syncWidget : function(){

        this.__desktop.forceUnblockContent();
        var f = this.__desktop.getWindows();
        // z-index for all three window kinds
        var h = this._minZIndex;
        var m = h + f.length * 2;
        var j = h + f.length * 4;
        // marker if there is an active window
        var k = null;
        for(var i = 0,l = f.length;i < l;i++){

          var g = f[i];
          // ignore invisible windows
          if(!g.isVisible()){

            continue;
          };
          // take the first window as active window
          k = k || g;
          // We use only every second z index to easily insert a blocker between
          // two windows
          // Modal Windows stays on top of AlwaysOnTop Windows, which stays on
          // top of Normal Windows.
          if(g.isModal()){

            g.setZIndex(j);
            this.__desktop.blockContent(j - 1);
            j += 2;
            //just activate it if it's modal
            k = g;
          } else if(g.isAlwaysOnTop()){

            g.setZIndex(m);
            m += 2;
          } else {

            g.setZIndex(h);
            h += 2;
          };
          // store the active window
          if(!k.isModal() && g.isActive() || g.getZIndex() > k.getZIndex()){

            k = g;
          };
        };
        //set active window or null otherwise
        this.__desktop.setActiveWindow(k);
      },
      // interface implementation
      bringToFront : function(n){

        var o = this.__desktop.getWindows();
        var p = qx.lang.Array.remove(o, n);
        if(p){

          o.push(n);
          this.updateStack();
        };
      },
      // interface implementation
      sendToBack : function(q){

        var r = this.__desktop.getWindows();
        var s = qx.lang.Array.remove(r, q);
        if(s){

          r.unshift(q);
          this.updateStack();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeObjects(a);
    }
  });
})();
(function(){

  var m = "mouseup",l = "mousedown",k = "losecapture",j = "__moveHandle",i = "qx.ui.core.MMovable",h = "The move handle could not be redefined!",g = "mousemove",f = "maximized",d = "__moveFrame",c = "move-frame",a = "Boolean",b = "move";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Provides move behavior to any widget.
   *
   * The widget using the mixin must register a widget as move handle so that
   * the mouse events needed for moving it are attached to this widget).
   * <pre class='javascript'>this._activateMoveHandle(widget);</pre>
   */
  qx.Mixin.define(i, {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Whether the widget is movable */
      movable : {
        check : a,
        init : true
      },
      /** Whether to use a frame instead of the original widget during move sequences */
      useMoveFrame : {
        check : a,
        init : false
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __moveHandle : null,
      __moveFrame : null,
      __dragRange : null,
      __dragLeft : null,
      __dragTop : null,
      __parentLeft : null,
      __parentTop : null,
      __blockerAdded : false,
      __oldBlockerColor : null,
      __oldBlockerOpacity : 0,
      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */
      /**
       * Configures the given widget as a move handle
       *
       * @param widget {qx.ui.core.Widget} Widget to activate as move handle
       */
      _activateMoveHandle : function(n){

        if(this.__moveHandle){

          throw new Error(h);
        };
        this.__moveHandle = n;
        n.addListener(l, this._onMoveMouseDown, this);
        n.addListener(m, this._onMoveMouseUp, this);
        n.addListener(g, this._onMoveMouseMove, this);
        n.addListener(k, this.__onMoveLoseCapture, this);
      },
      /**
       * Get the widget, which draws the resize/move frame.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      __getMoveFrame : function(){

        var o = this.__moveFrame;
        if(!o){

          o = this.__moveFrame = new qx.ui.core.Widget();
          o.setAppearance(c);
          o.exclude();
          qx.core.Init.getApplication().getRoot().add(o);
        };
        return o;
      },
      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showMoveFrame : function(){

        var location = this.getContainerLocation();
        var q = this.getBounds();
        var p = this.__getMoveFrame();
        p.setUserBounds(location.left, location.top, q.width, q.height);
        p.show();
        p.setZIndex(this.getZIndex() + 1);
      },
      /*
      ---------------------------------------------------------------------------
        MOVE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Computes the new drag coordinates
       *
       * @param e {qx.event.type.Mouse} Mouse event
       */
      __computeMoveCoordinates : function(e){

        var s = this.__dragRange;
        var v = Math.max(s.left, Math.min(s.right, e.getDocumentLeft()));
        var u = Math.max(s.top, Math.min(s.bottom, e.getDocumentTop()));
        var r = this.__dragLeft + v;
        var t = this.__dragTop + u;
        return {
          viewportLeft : r,
          viewportTop : t,
          parentLeft : r - this.__parentLeft,
          parentTop : t - this.__parentTop
        };
      },
      /*
      ---------------------------------------------------------------------------
        MOVE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Enables the capturing of the caption bar and prepares the drag session and the
       * appearance (translucent, frame or opaque) for the moving of the window.
       *
       * @param e {qx.event.type.Mouse} mouse down event
       */
      _onMoveMouseDown : function(e){

        if(!this.getMovable() || this.hasState(f)){

          return;
        };
        // Compute drag range
        var parent = this.getLayoutParent();
        var x = parent.getContentLocation();
        var y = parent.getBounds();
        // Added a blocker, this solves the issue described in [BUG #1462]
        if(qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)){

          if(!parent.isContentBlocked()){

            this.__oldBlockerColor = parent.getBlockerColor();
            this.__oldBlockerOpacity = parent.getBlockerOpacity();
            parent.setBlockerColor(null);
            parent.setBlockerOpacity(1);
            parent.blockContent(this.getZIndex() - 1);
            this.__blockerAdded = true;
          };
        };
        this.__dragRange = {
          left : x.left,
          top : x.top,
          right : x.left + y.width,
          bottom : x.top + y.height
        };
        // Compute drag positions
        var w = this.getContainerLocation();
        this.__parentLeft = x.left;
        this.__parentTop = x.top;
        this.__dragLeft = w.left - e.getDocumentLeft();
        this.__dragTop = w.top - e.getDocumentTop();
        // Add state
        this.addState(b);
        // Enable capturing
        this.__moveHandle.capture();
        // Enable drag frame
        if(this.getUseMoveFrame()){

          this.__showMoveFrame();
        };
        // Stop event
        e.stop();
      },
      /**
       * Does the moving of the window by rendering the position
       * of the window (or frame) at runtime using direct dom methods.
       *
       * @param e {qx.event.type.Event} mouse move event
       */
      _onMoveMouseMove : function(e){

        // Only react when dragging is active
        if(!this.hasState(b)){

          return;
        };
        // Apply new coordinates using DOM
        var z = this.__computeMoveCoordinates(e);
        if(this.getUseMoveFrame()){

          this.__getMoveFrame().setDomPosition(z.viewportLeft, z.viewportTop);
        } else {

          this.setDomPosition(z.parentLeft, z.parentTop);
        };
        e.stopPropagation();
      },
      /**
       * Disables the capturing of the caption bar and moves the window
       * to the last position of the drag session. Also restores the appearance
       * of the window.
       *
       * @param e {qx.event.type.Mouse} mouse up event
       */
      _onMoveMouseUp : function(e){

        // Only react when dragging is active
        if(!this.hasState(b)){

          return;
        };
        // Remove drag state
        this.removeState(b);
        // Removed blocker, this solves the issue described in [BUG #1462]
        var parent = this.getLayoutParent();
        if(qx.Class.implementsInterface(parent, qx.ui.window.IDesktop)){

          if(this.__blockerAdded){

            parent.unblockContent();
            parent.setBlockerColor(this.__oldBlockerColor);
            parent.setBlockerOpacity(this.__oldBlockerOpacity);
            this.__oldBlockerColor = null;
            this.__oldBlockerOpacity = 0;
            this.__blockerAdded = false;
          };
        };
        // Disable capturing
        this.__moveHandle.releaseCapture();
        // Apply them to the layout
        var A = this.__computeMoveCoordinates(e);
        this.setLayoutProperties({
          left : A.parentLeft,
          top : A.parentTop
        });
        // Hide frame afterwards
        if(this.getUseMoveFrame()){

          this.__getMoveFrame().exclude();
        };
        e.stopPropagation();
      },
      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onMoveLoseCapture : function(e){

        // Check for active move
        if(!this.hasState(b)){

          return;
        };
        // Remove drag state
        this.removeState(b);
        // Hide frame afterwards
        if(this.getUseMoveFrame()){

          this.__getMoveFrame().exclude();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeObjects(d, j);
      this.__dragRange = null;
    }
  });
})();
(function(){

  var p = "resetPaddingRight",o = "setPaddingBottom",n = "contentPaddingBottom",m = "resetPaddingTop",l = "qx.ui.core.MContentPadding",k = "resetPaddingLeft",j = "setPaddingTop",i = "setPaddingRight",h = "resetPaddingBottom",g = "contentPaddingLeft",c = "setPaddingLeft",f = "contentPaddingTop",e = "shorthand",b = "contentPaddingRight",a = "_applyContentPadding",d = "Integer";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * This mixin defines the <code>contentPadding</code> property, which is used
   * by widgets like the window or group box, which must have a property, which
   * defines the padding of an inner pane.
   *
   * The including class must implement the method
   * <code>_getContentPaddingTarget</code>, which must return the widget on which
   * the padding should be applied.
   */
  qx.Mixin.define(l, {
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Top padding of the content pane */
      contentPaddingTop : {
        check : d,
        init : 0,
        apply : a,
        themeable : true
      },
      /** Right padding of the content pane */
      contentPaddingRight : {
        check : d,
        init : 0,
        apply : a,
        themeable : true
      },
      /** Bottom padding of the content pane */
      contentPaddingBottom : {
        check : d,
        init : 0,
        apply : a,
        themeable : true
      },
      /** Left padding of the content pane */
      contentPaddingLeft : {
        check : d,
        init : 0,
        apply : a,
        themeable : true
      },
      /**
       * The 'contentPadding' property is a shorthand property for setting 'contentPaddingTop',
       * 'contentPaddingRight', 'contentPaddingBottom' and 'contentPaddingLeft'
       * at the same time.
       *
       * If four values are specified they apply to top, right, bottom and left respectively.
       * If there is only one value, it applies to all sides, if there are two or three,
       * the missing values are taken from the opposite side.
       */
      contentPadding : {
        group : [f, b, n, g],
        mode : e,
        themeable : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * {Map} Maps property names of content padding to the setter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingSetter)
       */
      __contentPaddingSetter : {
        contentPaddingTop : j,
        contentPaddingRight : i,
        contentPaddingBottom : o,
        contentPaddingLeft : c
      },
      /**
       * {Map} Maps property names of content padding to the resetter of the padding
       *
       * @lint ignoreReferenceField(__contentPaddingResetter)
       */
      __contentPaddingResetter : {
        contentPaddingTop : m,
        contentPaddingRight : p,
        contentPaddingBottom : h,
        contentPaddingLeft : k
      },
      // property apply
      _applyContentPadding : function(q, r, name){

        var s = this._getContentPaddingTarget();
        if(q == null){

          var t = this.__contentPaddingResetter[name];
          s[t]();
        } else {

          var u = this.__contentPaddingSetter[name];
          s[u](q);
        };
      }
    }
  });
})();
(function(){

  var k = "mousedown",j = "w-resize",i = "sw-resize",h = "n-resize",g = "resizableRight",f = "ne-resize",d = "se-resize",c = "Integer",b = "e-resize",a = "resizableLeft",z = "mousemove",y = "move",x = "shorthand",w = "maximized",v = "nw-resize",u = "mouseout",t = "qx.ui.core.MResizable",s = "mouseup",r = "losecapture",q = "resize-frame",o = "resizableBottom",p = "s-resize",m = "resizableTop",n = "Boolean",l = "resize";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007 David Pérez Carmona
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez Carmona (david-perez)
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Provides resizing behavior to any widget.
   */
  qx.Mixin.define(t, {
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      // Register listeners to the container
      var A = this.getContainerElement();
      A.addListener(k, this.__onResizeMouseDown, this, true);
      A.addListener(s, this.__onResizeMouseUp, this);
      A.addListener(z, this.__onResizeMouseMove, this);
      A.addListener(u, this.__onResizeMouseOut, this);
      A.addListener(r, this.__onResizeLoseCapture, this);
      // Get a reference of the drag and drop handler
      var B = this.getContainerElement().getDomElement();
      if(B == null){

        B = window;
      };
      this.__dragDropHandler = qx.event.Registration.getManager(B).getHandler(qx.event.handler.DragDrop);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** Whether the top edge is resizable */
      resizableTop : {
        check : n,
        init : true
      },
      /** Whether the right edge is resizable */
      resizableRight : {
        check : n,
        init : true
      },
      /** Whether the bottom edge is resizable */
      resizableBottom : {
        check : n,
        init : true
      },
      /** Whether the left edge is resizable */
      resizableLeft : {
        check : n,
        init : true
      },
      /**
       * Property group to configure the resize behaviour for all edges at once
       */
      resizable : {
        group : [m, g, o, a],
        mode : x
      },
      /** The tolerance to activate resizing */
      resizeSensitivity : {
        check : c,
        init : 5
      },
      /** Whether a frame replacement should be used during the resize sequence */
      useResizeFrame : {
        check : n,
        init : true
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __dragDropHandler : null,
      __resizeFrame : null,
      __resizeActive : null,
      __resizeLeft : null,
      __resizeTop : null,
      __resizeStart : null,
      __resizeRange : null,
      RESIZE_TOP : 1,
      RESIZE_BOTTOM : 2,
      RESIZE_LEFT : 4,
      RESIZE_RIGHT : 8,
      /*
      ---------------------------------------------------------------------------
        CORE FEATURES
      ---------------------------------------------------------------------------
      */
      /**
       * Get the widget, which draws the resize/move frame. The resize frame is
       * shared by all widgets and is added to the root widget.
       *
       * @return {qx.ui.core.Widget} The resize frame
       */
      _getResizeFrame : function(){

        var C = this.__resizeFrame;
        if(!C){

          C = this.__resizeFrame = new qx.ui.core.Widget();
          C.setAppearance(q);
          C.exclude();
          qx.core.Init.getApplication().getRoot().add(C);
        };
        return C;
      },
      /**
       * Creates, shows and syncs the frame with the widget.
       */
      __showResizeFrame : function(){

        var location = this.__getLocation();
        var D = this._getResizeFrame();
        D.setUserBounds(location.left, location.top, location.right - location.left, location.bottom - location.top);
        D.show();
        D.setZIndex(this.getZIndex() + 1);
      },
      /*
      ---------------------------------------------------------------------------
        RESIZE SUPPORT
      ---------------------------------------------------------------------------
      */
      /**
       * Computes the new boundaries at each interval
       * of the resize sequence.
       *
       * @param e {qx.event.type.Mouse} Last mouse event
       */
      __computeResizeResult : function(e){

        // Detect mode
        var F = this.__resizeActive;
        // Read size hint
        var G = this.getSizeHint();
        var K = this.__resizeRange;
        // Read original values
        var J = this.__resizeStart;
        var E = J.width;
        var I = J.height;
        var H = J.containerWidth;
        var M = J.containerHeight;
        var N = J.left;
        var top = J.top;
        var L;
        if((F & this.RESIZE_TOP) || (F & this.RESIZE_BOTTOM)){

          L = Math.max(K.top, Math.min(K.bottom, e.getDocumentTop())) - this.__resizeTop;
          if(F & this.RESIZE_TOP){

            I -= L;
            M -= L;
          } else {

            I += L;
            M += L;
          };
          if(M < G.minHeight){

            I += (G.minHeight - M);
            M = G.minHeight;
          } else if(M > G.maxHeight){

            I -= (M - G.maxHeight);
            M = G.maxHeight;
          };
          if(F & this.RESIZE_TOP){

            top += J.containerHeight - M;
          };
        };
        if((F & this.RESIZE_LEFT) || (F & this.RESIZE_RIGHT)){

          L = Math.max(K.left, Math.min(K.right, e.getDocumentLeft())) - this.__resizeLeft;
          if(F & this.RESIZE_LEFT){

            E -= L;
            H -= L;
          } else {

            E += L;
            H += L;
          };
          if(H < G.minWidth){

            E += (G.minWidth - H);
            H = G.minWidth;
          } else if(E > G.maxWidth){

            E -= (H - G.maxWidth);
            H = G.maxWidth;
          };
          if(F & this.RESIZE_LEFT){

            N += J.containerWidth - H;
          };
        };
        return {
          // left and top of the visible widget (content + decorator)
          viewportLeft : N,
          viewportTop : top,
          parentLeft : J.bounds.left + N - J.left,
          parentTop : J.bounds.top + top - J.top,
          // dimensions of the whole widget (container)
          containerWidth : H,
          containerHeight : M,
          // dimensions of the visible widget (content + decorator)
          width : E,
          height : I
        };
      },
      /**
       * {Map} Maps internal states to cursor symbols to use
       *
       * @lint ignoreReferenceField(__resizeCursors)
       */
      __resizeCursors : {
        '1' : h,
        '2' : p,
        '4' : j,
        '8' : b,
        '5' : v,
        '6' : i,
        '9' : f,
        '10' : d
      },
      /**
       * Returns the location to use. Either the location of the decorator
       * element, or the location of the content element.
       *
       * @return {Map} Location map. (see {@link qx.bom.element.Location#get})
       */
      __getLocation : function(){

        var O = this.getDecoratorElement();
        // use the decorator location if available (belongs to the resizable box)
        if(O && O.getDomElement()){

          return qx.bom.element.Location.get(O.getDomElement());
        } else {

          return this.getContentLocation();
        };
      },
      /**
       * Updates the internally stored resize mode
       *
       * @param e {qx.event.type.Mouse} Last mouse event
       */
      __computeResizeMode : function(e){

        var location = this.__getLocation();
        var P = this.getResizeSensitivity();
        var S = e.getDocumentLeft();
        var R = e.getDocumentTop();
        var Q = this.__computeResizeActive(location, S, R, P);
        // check again in case we have a corner [BUG #1200]
        if(Q > 0){

          // this is really a | (or)!
          Q = Q | this.__computeResizeActive(location, S, R, P * 2);
        };
        this.__resizeActive = Q;
      },
      /**
       * Internal helper for computing the proper resize action based on the
       * given parameters.
       *
       * @param location {Map} The current location of the widget.
       * @param mouseLeft {Integer} The left position of the mouse.
       * @param mouseTop {Integer} The top position of the mouse.
       * @param mouseTolerance {Integer} The desired distance to the edge.
       * @return {Integer} The resize active number.
       */
      __computeResizeActive : function(location, T, U, V){

        var W = 0;
        // TOP
        if(this.getResizableTop() && Math.abs(location.top - U) < V && T > location.left - V && T < location.right + V){

          W += this.RESIZE_TOP;
        } else if(this.getResizableBottom() && Math.abs(location.bottom - U) < V && T > location.left - V && T < location.right + V){

          W += this.RESIZE_BOTTOM;
        };
        // LEFT
        if(this.getResizableLeft() && Math.abs(location.left - T) < V && U > location.top - V && U < location.bottom + V){

          W += this.RESIZE_LEFT;
        } else if(this.getResizableRight() && Math.abs(location.right - T) < V && U > location.top - V && U < location.bottom + V){

          W += this.RESIZE_RIGHT;
        };
        return W;
      },
      /*
      ---------------------------------------------------------------------------
        RESIZE EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Event handler for the mouse down event
       *
       * @param e {qx.event.type.Mouse} The mouse event instance
       */
      __onResizeMouseDown : function(e){

        // Check for active resize
        if(!this.__resizeActive || !this.getEnabled()){

          return;
        };
        // Add resize state
        this.addState(l);
        // Store mouse coordinates
        this.__resizeLeft = e.getDocumentLeft();
        this.__resizeTop = e.getDocumentTop();
        // Cache bounds
        var bb = this.getContainerLocation();
        var X = this.__getLocation();
        var ba = this.getBounds();
        this.__resizeStart = {
          top : X.top,
          left : X.left,
          containerWidth : bb.right - bb.left,
          containerHeight : bb.bottom - bb.top,
          width : X.right - X.left,
          height : X.bottom - X.top,
          bounds : qx.lang.Object.clone(ba)
        };
        // Compute range
        var parent = this.getLayoutParent();
        var bc = parent.getContentLocation();
        var Y = parent.getBounds();
        this.__resizeRange = {
          left : bc.left,
          top : bc.top,
          right : bc.left + Y.width,
          bottom : bc.top + Y.height
        };
        // Show frame if configured this way
        if(this.getUseResizeFrame()){

          this.__showResizeFrame();
        };
        // Enable capturing
        this.capture();
        // Stop event
        e.stop();
      },
      /**
       * Event handler for the mouse up event
       *
       * @param e {qx.event.type.Mouse} The mouse event instance
       * @return {void}
       */
      __onResizeMouseUp : function(e){

        // Check for active resize
        if(!this.hasState(l) || !this.getEnabled()){

          return;
        };
        // Hide frame afterwards
        if(this.getUseResizeFrame()){

          this._getResizeFrame().exclude();
        };
        // Compute bounds
        var bd = this.__computeResizeResult(e);
        // Sync with widget
        this.setWidth(bd.containerWidth);
        this.setHeight(bd.containerHeight);
        // Update coordinate in canvas
        if(this.getResizableLeft() || this.getResizableTop()){

          this.setLayoutProperties({
            left : bd.parentLeft,
            top : bd.parentTop
          });
        };
        // Clear mode
        this.__resizeActive = 0;
        // Remove resize state
        this.removeState(l);
        // Reset cursor
        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor();
        // Disable capturing
        this.releaseCapture();
        e.stopPropagation();
      },
      /**
       * Event listener for <code>losecapture</code> event.
       *
       * @param e {qx.event.type.Event} Lose capture event
       */
      __onResizeLoseCapture : function(e){

        // Check for active resize
        if(!this.__resizeActive){

          return;
        };
        // Reset cursor
        this.resetCursor();
        this.getApplicationRoot().resetGlobalCursor();
        // Remove drag state
        this.removeState(y);
        // Hide frame afterwards
        if(this.getUseResizeFrame()){

          this._getResizeFrame().exclude();
        };
      },
      /**
       * Event handler for the mouse move event
       *
       * @param e {qx.event.type.Mouse} The mouse event instance
       * @return {void}
       */
      __onResizeMouseMove : function(e){

        if(!this.getEnabled()){

          return;
        };
        if(this.hasState(l)){

          var bh = this.__computeResizeResult(e);
          // Update widget
          if(this.getUseResizeFrame()){

            // Sync new bounds to frame
            var bf = this._getResizeFrame();
            bf.setUserBounds(bh.viewportLeft, bh.viewportTop, bh.width, bh.height);
          } else {

            // Update size
            this.setWidth(bh.containerWidth);
            this.setHeight(bh.containerHeight);
            // Update coordinate in canvas
            if(this.getResizableLeft() || this.getResizableTop()){

              this.setLayoutProperties({
                left : bh.parentLeft,
                top : bh.parentTop
              });
            };
          };
          // Full stop for event
          e.stopPropagation();
        } else if(!this.hasState(w) && !this.__dragDropHandler.isSessionActive()){

          this.__computeResizeMode(e);
          var bi = this.__resizeActive;
          var bg = this.getApplicationRoot();
          if(bi){

            var be = this.__resizeCursors[bi];
            this.setCursor(be);
            bg.setGlobalCursor(be);
          } else if(this.getCursor()){

            this.resetCursor();
            bg.resetGlobalCursor();
          };
        };
      },
      /**
       * Event handler for the mouse out event
       *
       * @param e {qx.event.type.Mouse} The mouse event instance
       */
      __onResizeMouseOut : function(e){

        // When the mouse left the window and resizing is not yet
        // active we must be sure to (especially) reset the global
        // cursor.
        if(this.getCursor() && !this.hasState(l)){

          this.resetCursor();
          this.getApplicationRoot().resetGlobalCursor();
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__resizeFrame != null && !qx.core.ObjectRegistry.inShutDown){

        this.__resizeFrame.destroy();
        this.__resizeFrame = null;
      };
      this.__dragDropHandler = null;
    }
  });
})();
(function(){

  var k = "beforeClose",j = "beforeMinimize",i = "mousedown",h = "window-resize-frame",g = "changeStatus",f = "changeIcon",d = "excluded",c = "_applyModal",b = "dblclick",a = "_applyActive",Y = "beforeRestore",X = "qx.ui.window.IDesktop. All root widgets implement this interface.",W = "minimize",V = "changeModal",U = "changeAlwaysOnTop",T = "_applyShowStatusbar",S = "_applyStatus",R = "qx.ui.window.Window",Q = "Windows can only be added to widgets, which implement the interface ",P = "changeCaption",r = "focusout",s = "beforeMaximize",p = "maximize",q = "restore",n = "window",o = "close",l = "changeActive",m = "Centering depends on parent bounds!",v = "minimized",w = "qx.debug",D = "active",B = "String",H = "modal",F = "normal",L = "statusbar",J = "statusbar-text",y = "execute",O = "title",N = "icon",M = "showStatusbar",x = "pane",z = "minimize-button",A = "close-button",C = "maximized",E = "restore-button",G = "maximize-button",I = "qx.event.type.Event",K = "captionbar",t = "_applyCaptionBarChange",u = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * A window widget
   *
   * More information can be found in the package description {@link qx.ui.window}.
   *
   * @state active Whether the window is activated
   * @state maximized Whether the window is maximized
   *
   * @childControl statusbar {qx.ui.container.Composite} statusbar container which shows the statusbar text
   * @childControl statusbar-text {qx.ui.basic.Label} text of the statusbar
   * @childControl pane {qx.ui.container.Composite} window pane which holds the content
   * @childControl captionbar {qx.ui.container.Composite} Container for all widgets inside the captionbar
   * @childControl icon {qx.ui.basic.Image} icon at the left of the captionbar
   * @childControl title {qx.ui.basic.Label} caption of the window
   * @childControl minimize-button {qx.ui.form.Button} button to minimize the window
   * @childControl restore-button {qx.ui.form.Button} button to restore the window
   * @childControl maximize-button {qx.ui.form.Button} button to maximize the window
   * @childControl close-button {qx.ui.form.Button} button to close the window
   */
  qx.Class.define(R, {
    extend : qx.ui.core.Widget,
    include : [qx.ui.core.MRemoteChildrenHandling, qx.ui.core.MRemoteLayoutHandling, qx.ui.core.MResizable, qx.ui.core.MMovable, qx.ui.core.MContentPadding],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param caption {String} The caption text
     * @param icon {String} The URL of the caption bar icon
     */
    construct : function(ba, bb){

      qx.ui.core.Widget.call(this);
      // configure internal layout
      this._setLayout(new qx.ui.layout.VBox());
      // force creation of captionbar
      this._createChildControl(K);
      this._createChildControl(x);
      // apply constructor parameters
      if(bb != null){

        this.setIcon(bb);
      };
      if(ba != null){

        this.setCaption(ba);
      };
      // Update captionbar
      this._updateCaptionBar();
      // Activation listener
      this.addListener(i, this._onWindowMouseDown, this, true);
      // Focusout listener
      this.addListener(r, this._onWindowFocusOut, this);
      // Automatically add to application root.
      qx.core.Init.getApplication().getRoot().add(this);
      // Initialize visibiltiy
      this.initVisibility();
      // Register as root for the focus handler
      qx.ui.core.FocusHandler.getInstance().addRoot(this);
      // change the reszie frames appearance
      this._getResizeFrame().setAppearance(h);
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {Class} The default window manager class. */
      DEFAULT_MANAGER_CLASS : qx.ui.window.Manager
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    events : {
      /**
       * Fired before the window is closed.
       *
       * The close action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeClose" : I,
      /** Fired if the window is closed */
      "close" : I,
      /**
       * Fired before the window is minimize.
       *
       * The minimize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMinimize" : I,
      /** Fired if the window is minimized */
      "minimize" : I,
      /**
       * Fired before the window is maximize.
       *
       * The maximize action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeMaximize" : I,
      /** Fired if the window is maximized */
      "maximize" : I,
      /**
       * Fired before the window is restored from a minimized or maximized state.
       *
       * The restored action can be prevented by calling
       * {@link qx.event.type.Event#preventDefault} on the event object
       */
      "beforeRestore" : I,
      /** Fired if the window is restored from a minimized or maximized state */
      "restore" : I
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        INTERNAL OPTIONS
      ---------------------------------------------------------------------------
      */
      // overridden
      appearance : {
        refine : true,
        init : n
      },
      // overridden
      visibility : {
        refine : true,
        init : d
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      },
      /**
       * If the window is active, only one window in a single qx.ui.window.Manager could
       *  have set this to true at the same time.
       */
      active : {
        check : u,
        init : false,
        apply : a,
        event : l
      },
      /*
      ---------------------------------------------------------------------------
        BASIC OPTIONS
      ---------------------------------------------------------------------------
      */
      /** Should the window be always on top */
      alwaysOnTop : {
        check : u,
        init : false,
        event : U
      },
      /** Should the window be modal (this disables minimize and maximize buttons) */
      modal : {
        check : u,
        init : false,
        event : V,
        apply : c
      },
      /** The text of the caption */
      caption : {
        apply : t,
        event : P,
        nullable : true
      },
      /** The icon of the caption */
      icon : {
        check : B,
        nullable : true,
        apply : t,
        event : f,
        themeable : true
      },
      /** The text of the statusbar */
      status : {
        check : B,
        nullable : true,
        apply : S,
        event : g
      },
      /*
      ---------------------------------------------------------------------------
        HIDE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */
      /** Should the close button be shown */
      showClose : {
        check : u,
        init : true,
        apply : t,
        themeable : true
      },
      /** Should the maximize button be shown */
      showMaximize : {
        check : u,
        init : true,
        apply : t,
        themeable : true
      },
      /** Should the minimize button be shown */
      showMinimize : {
        check : u,
        init : true,
        apply : t,
        themeable : true
      },
      /*
      ---------------------------------------------------------------------------
        DISABLE CAPTIONBAR FEATURES
      ---------------------------------------------------------------------------
      */
      /** Should the user have the ability to close the window */
      allowClose : {
        check : u,
        init : true,
        apply : t
      },
      /** Should the user have the ability to maximize the window */
      allowMaximize : {
        check : u,
        init : true,
        apply : t
      },
      /** Should the user have the ability to minimize the window */
      allowMinimize : {
        check : u,
        init : true,
        apply : t
      },
      /*
      ---------------------------------------------------------------------------
        STATUSBAR CONFIG
      ---------------------------------------------------------------------------
      */
      /** Should the statusbar be shown */
      showStatusbar : {
        check : u,
        init : false,
        apply : T
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {Integer} Original top value before maximation had occoured */
      __restoredTop : null,
      /** {Integer} Original left value before maximation had occoured */
      __restoredLeft : null,
      /*
      ---------------------------------------------------------------------------
        WIDGET API
      ---------------------------------------------------------------------------
      */
      /**
       * The children container needed by the {@link qx.ui.core.MRemoteChildrenHandling}
       * mixin
       *
       * @return {qx.ui.container.Composite} pane sub widget
       */
      getChildrenContainer : function(){

        return this.getChildControl(x);
      },
      // overridden
      /**
       * @lint ignoreReferenceField(_forwardStates)
       */
      _forwardStates : {
        active : true,
        maximized : true,
        showStatusbar : true,
        modal : true
      },
      // overridden
      setLayoutParent : function(parent){

        if(qx.core.Environment.get(w)){

          parent && this.assertInterface(parent, qx.ui.window.IDesktop, Q + X);
        };
        qx.ui.core.Widget.prototype.setLayoutParent.call(this, parent);
      },
      // overridden
      _createChildControlImpl : function(bc, bd){

        var be;
        switch(bc){case L:
        be = new qx.ui.container.Composite(new qx.ui.layout.HBox());
        this._add(be);
        be.add(this.getChildControl(J));
        break;case J:
        be = new qx.ui.basic.Label();
        be.setValue(this.getStatus());
        break;case x:
        be = new qx.ui.container.Composite();
        this._add(be, {
          flex : 1
        });
        break;case K:
        // captionbar
        var bg = new qx.ui.layout.Grid();
        bg.setRowFlex(0, 1);
        bg.setColumnFlex(1, 1);
        be = new qx.ui.container.Composite(bg);
        this._add(be);
        // captionbar events
        be.addListener(b, this._onCaptionMouseDblClick, this);
        // register as move handle
        this._activateMoveHandle(be);
        break;case N:
        be = new qx.ui.basic.Image(this.getIcon());
        this.getChildControl(K).add(be, {
          row : 0,
          column : 0
        });
        break;case O:
        be = new qx.ui.basic.Label(this.getCaption());
        be.setWidth(0);
        be.setAllowGrowX(true);
        var bf = this.getChildControl(K);
        bf.add(be, {
          row : 0,
          column : 1
        });
        break;case z:
        be = new qx.ui.form.Button();
        be.setFocusable(false);
        be.addListener(y, this._onMinimizeButtonClick, this);
        this.getChildControl(K).add(be, {
          row : 0,
          column : 2
        });
        break;case E:
        be = new qx.ui.form.Button();
        be.setFocusable(false);
        be.addListener(y, this._onRestoreButtonClick, this);
        this.getChildControl(K).add(be, {
          row : 0,
          column : 3
        });
        break;case G:
        be = new qx.ui.form.Button();
        be.setFocusable(false);
        be.addListener(y, this._onMaximizeButtonClick, this);
        this.getChildControl(K).add(be, {
          row : 0,
          column : 4
        });
        break;case A:
        be = new qx.ui.form.Button();
        be.setFocusable(false);
        be.addListener(y, this._onCloseButtonClick, this);
        this.getChildControl(K).add(be, {
          row : 0,
          column : 6
        });
        break;};
        return be || qx.ui.core.Widget.prototype._createChildControlImpl.call(this, bc);
      },
      /*
      ---------------------------------------------------------------------------
        CAPTIONBAR INTERNALS
      ---------------------------------------------------------------------------
      */
      /**
       * Updates the status and the visibility of each element of the captionbar.
       */
      _updateCaptionBar : function(){

        var bi;
        var bj = this.getIcon();
        if(bj){

          this.getChildControl(N).setSource(bj);
          this._showChildControl(N);
        } else {

          this._excludeChildControl(N);
        };
        var bh = this.getCaption();
        if(bh){

          this.getChildControl(O).setValue(bh);
          this._showChildControl(O);
        } else {

          this._excludeChildControl(O);
        };
        if(this.getShowMinimize()){

          this._showChildControl(z);
          bi = this.getChildControl(z);
          this.getAllowMinimize() ? bi.resetEnabled() : bi.setEnabled(false);
        } else {

          this._excludeChildControl(z);
        };
        if(this.getShowMaximize()){

          if(this.isMaximized()){

            this._showChildControl(E);
            this._excludeChildControl(G);
          } else {

            this._showChildControl(G);
            this._excludeChildControl(E);
          };
          bi = this.getChildControl(G);
          this.getAllowMaximize() ? bi.resetEnabled() : bi.setEnabled(false);
        } else {

          this._excludeChildControl(G);
          this._excludeChildControl(E);
        };
        if(this.getShowClose()){

          this._showChildControl(A);
          bi = this.getChildControl(A);
          this.getAllowClose() ? bi.resetEnabled() : bi.setEnabled(false);
        } else {

          this._excludeChildControl(A);
        };
      },
      /*
      ---------------------------------------------------------------------------
        USER API
      ---------------------------------------------------------------------------
      */
      /**
       * Closes the current window instance.
       * Technically calls the {@link qx.ui.core.Widget#hide} method.
       */
      close : function(){

        if(!this.isVisible()){

          return;
        };
        if(this.fireNonBubblingEvent(k, qx.event.type.Event, [false, true])){

          this.hide();
          this.fireEvent(o);
        };
      },
      /**
       * Opens the window.
       */
      open : function(){

        this.show();
        this.setActive(true);
        this.focus();
      },
      /**
       * Centers the window to the parent.
       *
       * This call works with the size of the parent widget and the size of
       * the window as calculated in the last layout flush. It is best to call
       * this method just after rendering the window in the "resize" event:
       * <pre class='javascript'>
       *   win.addListenerOnce("resize", this.center, this);
       * </pre>
       */
      center : function(){

        var parent = this.getLayoutParent();
        if(parent){

          var bl = parent.getBounds();
          if(bl){

            var bm = this.getSizeHint();
            var bk = Math.round((bl.width - bm.width) / 2);
            var top = Math.round((bl.height - bm.height) / 2);
            if(top < 0){

              top = 0;
            };
            this.moveTo(bk, top);
            return;
          };
        };
        if(qx.core.Environment.get(w)){

          this.warn(m);
        };
      },
      /**
       * Maximize the window.
       */
      maximize : function(){

        // If the window is already maximized -> return
        if(this.isMaximized()){

          return;
        };
        // First check if the parent uses a canvas layout
        // Otherwise maximize() is not possible
        var parent = this.getLayoutParent();
        if(parent != null && parent.supportsMaximize()){

          if(this.fireNonBubblingEvent(s, qx.event.type.Event, [false, true])){

            if(!this.isVisible()){

              this.open();
            };
            // store current dimension and location
            var bn = this.getLayoutProperties();
            this.__restoredLeft = bn.left === undefined ? 0 : bn.left;
            this.__restoredTop = bn.top === undefined ? 0 : bn.top;
            // Update layout properties
            this.setLayoutProperties({
              left : null,
              top : null,
              edge : 0
            });
            // Add state
            this.addState(C);
            // Update captionbar
            this._updateCaptionBar();
            // Fire user event
            this.fireEvent(p);
          };
        };
      },
      /**
       * Minimized the window.
       */
      minimize : function(){

        if(!this.isVisible()){

          return;
        };
        if(this.fireNonBubblingEvent(j, qx.event.type.Event, [false, true])){

          // store current dimension and location
          var bo = this.getLayoutProperties();
          this.__restoredLeft = bo.left === undefined ? 0 : bo.left;
          this.__restoredTop = bo.top === undefined ? 0 : bo.top;
          this.removeState(C);
          this.hide();
          this.fireEvent(W);
        };
      },
      /**
       * Restore the window to <code>"normal"</code>, if it is
       * <code>"maximized"</code> or <code>"minimized"</code>.
       */
      restore : function(){

        if(this.getMode() === F){

          return;
        };
        if(this.fireNonBubblingEvent(Y, qx.event.type.Event, [false, true])){

          if(!this.isVisible()){

            this.open();
          };
          // Restore old properties
          var bp = this.__restoredLeft;
          var top = this.__restoredTop;
          this.setLayoutProperties({
            edge : null,
            left : bp,
            top : top
          });
          // Remove maximized state
          this.removeState(C);
          // Update captionbar
          this._updateCaptionBar();
          // Fire user event
          this.fireEvent(q);
        };
      },
      /**
       * Set the window's position relative to its parent
       *
       * @param left {Integer} The left position
       * @param top {Integer} The top position
       */
      moveTo : function(bq, top){

        if(this.isMaximized()){

          return;
        };
        this.setLayoutProperties({
          left : bq,
          top : top
        });
      },
      /**
       * Return <code>true</code> if the window is in maximized state,
       * but note that the window in maximized state could also be invisible, this
       * is equivalent to minimized. So use the {@link qx.ui.window.Window#getMode}
       * to get the window mode.
       *
       * @return {Boolean} <code>true</code> if the window is maximized,
       *   <code>false</code> otherwise.
       */
      isMaximized : function(){

        return this.hasState(C);
      },
      /**
       * Return the window mode as <code>String</code>:
       * <code>"maximized"</code>, <code>"normal"</code> or <code>"minimized"</code>.
       *
       * @return {String} The window mode as <code>String</code> value.
       */
      getMode : function(){

        if(!this.isVisible()){

          return v;
        } else {

          if(this.isMaximized()){

            return C;
          } else {

            return F;
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyActive : function(br, bs){

        if(bs){

          this.removeState(D);
        } else {

          this.addState(D);
        };
      },
      // property apply
      _applyModal : function(bt, bu){

        if(bu){

          this.removeState(H);
        } else {

          this.addState(H);
        };
      },
      /**
       * Returns the element, to which the content padding should be applied.
       *
       * @return {qx.ui.core.Widget} The content padding target.
       */
      _getContentPaddingTarget : function(){

        return this.getChildControl(x);
      },
      // property apply
      _applyShowStatusbar : function(bv, bw){

        // store the state if the status bar is shown
        var bx = this._getResizeFrame();
        if(bv){

          this.addState(M);
          bx.addState(M);
        } else {

          this.removeState(M);
          bx.removeState(M);
        };
        if(bv){

          this._showChildControl(L);
        } else {

          this._excludeChildControl(L);
        };
      },
      // property apply
      _applyCaptionBarChange : function(by, bz){

        this._updateCaptionBar();
      },
      // property apply
      _applyStatus : function(bA, bB){

        var bC = this.getChildControl(J, true);
        if(bC){

          bC.setValue(bA);
        };
      },
      /*
      ---------------------------------------------------------------------------
        BASIC EVENT HANDLERS
      ---------------------------------------------------------------------------
      */
      /**
       * Stops every event
       *
       * @param e {qx.event.type.Event} any event
       */
      _onWindowEventStop : function(e){

        e.stopPropagation();
      },
      /**
       * Focuses the window instance.
       *
       * @param e {qx.event.type.Mouse} mouse down event
       */
      _onWindowMouseDown : function(e){

        this.setActive(true);
      },
      /**
       * Listens to the "focusout" event to deactivate the window (if the
       * currently focused widget is not a child of the window)
       *
       * @param e {qx.event.type.Focus} focus event
       */
      _onWindowFocusOut : function(e){

        // only needed for non-modal windows
        if(this.getModal()){

          return;
        };
        // get the current focused widget and check if it is a child
        var bD = e.getRelatedTarget();
        if(bD != null && !qx.ui.core.Widget.contains(this, bD)){

          this.setActive(false);
        };
      },
      /**
       * Maximizes the window or restores it if it is already
       * maximized.
       *
       * @param e {qx.event.type.Mouse} double click event
       */
      _onCaptionMouseDblClick : function(e){

        if(this.getAllowMaximize()){

          this.isMaximized() ? this.restore() : this.maximize();
        };
      },
      /*
      ---------------------------------------------------------------------------
        EVENTS FOR CAPTIONBAR BUTTONS
      ---------------------------------------------------------------------------
      */
      /**
       * Minimizes the window, removes all states from the minimize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Mouse} mouse click event
       */
      _onMinimizeButtonClick : function(e){

        this.minimize();
        this.getChildControl(z).reset();
      },
      /**
       * Restores the window, removes all states from the restore button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Mouse} mouse click event
       */
      _onRestoreButtonClick : function(e){

        this.restore();
        this.getChildControl(E).reset();
      },
      /**
       * Maximizes the window, removes all states from the maximize button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Mouse} mouse click event
       */
      _onMaximizeButtonClick : function(e){

        this.maximize();
        this.getChildControl(G).reset();
      },
      /**
       * Closes the window, removes all states from the close button and
       * stops the further propagation of the event (calling {@link qx.event.type.Event#stopPropagation}).
       *
       * @param e {qx.event.type.Mouse} mouse click event
       */
      _onCloseButtonClick : function(e){

        this.close();
        this.getChildControl(A).reset();
      }
    }
  });
})();
(function(){

  var h = "Number",g = "qx.event.type.Event",f = "_applyFirstColumnX",e = "Integer",d = "qx.ui.table.pane.Model",c = "_applyMaxColumnCount",b = "headerCellRendererChanged",a = "visibilityChangedPre";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
  
  ************************************************************************ */
  /**
   * The model of a table pane. This model works as proxy to a
   * {@link qx.ui.table.columnmodel.Basic} and manages the visual order of the columns shown in
   * a {@link Pane}.
   */
  qx.Class.define(d, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     *
     * @param tableColumnModel {qx.ui.table.columnmodel.Basic} The TableColumnModel of which this
     *    model is the proxy.
     */
    construct : function(i){

      qx.core.Object.call(this);
      this.setTableColumnModel(i);
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the model changed. */
      "modelChanged" : g
    },
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics : {
      /** {string} The type of the event fired when the model changed. */
      EVENT_TYPE_MODEL_CHANGED : "modelChanged"
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /** The visible x position of the first column this model should contain. */
      firstColumnX : {
        check : e,
        init : 0,
        apply : f
      },
      /**
       * The maximum number of columns this model should contain. If -1 this model will
       * contain all remaining columns.
       */
      maxColumnCount : {
        check : h,
        init : -1,
        apply : c
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __columnCount : null,
      __tableColumnModel : null,
      // property modifier
      _applyFirstColumnX : function(j, k){

        this.__columnCount = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      // property modifier
      _applyMaxColumnCount : function(l, m){

        this.__columnCount = null;
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      /**
       * Connects the table model to the column model
       *
       * @param tableColumnModel {qx.ui.table.columnmodel.Basic} the column model
       */
      setTableColumnModel : function(n){

        if(this.__tableColumnModel){

          this.__tableColumnModel.removeListener(a, this._onColVisibilityChanged, this);
          this.__tableColumnModel.removeListener(b, this._onColVisibilityChanged, this);
        };
        this.__tableColumnModel = n;
        this.__tableColumnModel.addListener(a, this._onColVisibilityChanged, this);
        this.__tableColumnModel.addListener(b, this._onHeaderCellRendererChanged, this);
        this.__columnCount = null;
      },
      /**
       * Event handler. Called when the visibility of a column has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onColVisibilityChanged : function(o){

        this.__columnCount = null;
        // TODO: Check whether the column is in this model (This is a little bit
        //     tricky, because the column could _have been_ in this model, but is
        //     not in it after the change)
        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      /**
       * Event handler. Called when the cell renderer of a column has changed.
       *
       * @param evt {Map} the event.
       * @return {void}
       */
      _onHeaderCellRendererChanged : function(p){

        this.fireEvent(qx.ui.table.pane.Model.EVENT_TYPE_MODEL_CHANGED);
      },
      /**
       * Returns the number of columns in this model.
       *
       * @return {Integer} the number of columns in this model.
       */
      getColumnCount : function(){

        if(this.__columnCount == null){

          var q = this.getFirstColumnX();
          var s = this.getMaxColumnCount();
          var r = this.__tableColumnModel.getVisibleColumnCount();
          if(s == -1 || (q + s) > r){

            this.__columnCount = r - q;
          } else {

            this.__columnCount = s;
          };
        };
        return this.__columnCount;
      },
      /**
       * Returns the model index of the column at the position <code>xPos</code>.
       *
       * @param xPos {Integer} the x position in the table pane of the column.
       * @return {Integer} the model index of the column.
       */
      getColumnAtX : function(t){

        var u = this.getFirstColumnX();
        return this.__tableColumnModel.getVisibleColumnAtX(u + t);
      },
      /**
       * Returns the x position of the column <code>col</code>.
       *
       * @param col {Integer} the model index of the column.
       * @return {Integer} the x position in the table pane of the column.
       */
      getX : function(v){

        var w = this.getFirstColumnX();
        var y = this.getMaxColumnCount();
        var x = this.__tableColumnModel.getVisibleX(v) - w;
        if(x >= 0 && (y == -1 || x < y)){

          return x;
        } else {

          return -1;
        };
      },
      /**
       * Gets the position of the left side of a column (in pixels, relative to the
       * left side of the table pane).
       *
       * This value corresponds to the sum of the widths of all columns left of the
       * column.
       *
       * @param col {Integer} the model index of the column.
       * @return {var} the position of the left side of the column.
       */
      getColumnLeft : function(z){

        var C = 0;
        var B = this.getColumnCount();
        for(var x = 0;x < B;x++){

          var A = this.getColumnAtX(x);
          if(A == z){

            return C;
          };
          C += this.__tableColumnModel.getColumnWidth(A);
        };
        return -1;
      },
      /**
       * Returns the total width of all columns in the model.
       *
       * @return {Integer} the total width of all columns in the model.
       */
      getTotalWidth : function(){

        var D = 0;
        var E = this.getColumnCount();
        for(var x = 0;x < E;x++){

          var F = this.getColumnAtX(x);
          D += this.__tableColumnModel.getColumnWidth(F);
        };
        return D;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      if(this.__tableColumnModel){

        this.__tableColumnModel.removeListener(a, this._onColVisibilityChanged, this);
        this.__tableColumnModel.removeListener(b, this._onColVisibilityChanged, this);
      };
      this.__tableColumnModel = null;
    }
  });
})();
(function(){

  var m = "Stopped",l = "Boolean",k = "aborted",j = "&format=csv",i = "Stopping",h = "/REST/services/dicomdump?src=",g = "GET",f = "timeout",d = "dicomheaderview.GetHeaders",c = "failed",a = "qx.event.type.Data",b = "completed";
  /**
   * Gets the DICOM headers associated with the given session url's. 
   * Headers are retrieved serially so the user can control when the process can stop.
   */
  qx.Class.define(d, {
    extend : qx.core.Object,
    /**
     * @param serverRoot{String} The root url for this XNAT server
     * @param urls{[String]} The session url's for which to retrieve headers
     * @param incrementNotifier{Function} Function to run after each url has been retrieved
     * @param cancelAction{Function} Function to stop the retrieval of headers
     */
    construct : function(n, o, p, q){

      qx.core.Object.call(this);
      this.initCounter(o.length);
      this.initUrls(o);
      this.initServerRoot(n);
      this.initHeaders([]);
      this.initIncrementNotifier(p);
      var r = this;
      this.initCancelAction(q(function(){

        r.debug(i);
        r.setStop(true);
      }));
    },
    events : {
      /**
       * Event fired when all the headers have been retrieved. 
       * Carries the 'header' property
       */
      "completed" : a
    },
    properties : {
      /**
       * Function to run if a user cancels downloading the headers
       */
      cancelAction : {
        deferredInit : true
      },
      /**
       * The name of the XNAT server
       */
      serverRoot : {
        deferredInit : true
      },
      /**
       * A list of session url's passed in by the user
       */
      urls : {
        deferredInit : true
      },
      /**
       * TODO doesn't appear to be used. Verify and update docs
       */
      counter : {
        deferredInit : true
      },
      /**
       * A list of DICOM headers as they are retrieved from the server
       */
      headers : {
        deferredInit : true
      },
      /**
       * Notify the user as each header is returned from the server.
       */
      incrementNotifier : {
        deferredInit : true,
        nullable : true
      },
      /**
       * A flag that determines whether to stop retrieving headers
       */
      stop : {
        init : false,
        check : l
      }
    },
    members : {
      /**
       * Retrieve headers serially using the list of urls passed in by the user.
       */
      retrieveHeaders : function(){

        var t = this;
        var s = 0;
        var w = function(){

          return new qx.io.remote.Request(t.createHeaderUrl(t.getServerRoot(), t.getUrls()[s]), g);
        };
        /**
         * Each time a header is retrieved this function is called to either
         * retrieve the next header or stop.
         */
        var v = function(){

          if(t.getStop() === false){

            s++;
            if(s < t.getUrls().length){

              var y = w();
              u(y);
            } else {

              t.fireDataEvent(b, {
                headers : t.getHeaders()
              });
            };
          } else {

            t.debug(m);
          };
        };
        /**
         * Notify the user after each header is retrieved
         */
        var x = function(){

          if(t.getIncrementNotifier() !== null){

            t.getIncrementNotifier()(1);
          };
        };
        /**
         * Create a request for the next header and decorate it with 
         * the necessary event listeners. 
         */
        var u = function(z){

          var A = function(e, B){

            if(!B){

              x();
              v();
            } else {

              x();
              t.addHeader(t.getUrls()[s], e.getContent());
              v();
            };
          };
          z.addListener(b, function(e){

            A(e, true);
          }, t);
          z.addListener(c, function(e){

            A(e, false);
          }, t);
          z.addListener(f, function(e){

            A(e, false);
          }, t);
          z.addListener(k, function(e){

            A(e, false);
          }, t);
          z.send();
        };
        if(this.getUrls().length != 0){

          u(w());
        } else {

          this.getCancelAction()();
          this.fireDataEvent(b, {
            headers : this.getHeaders()
          });
        };
      },
      /**
       * Marshall the header and add it to the global list of headers
       * @param curr{Integer} The index of the header
       * @param data{Object} A CSV representation of the headers 
       */
      addHeader : function(C, D){

        var E = new csvparser.CSVParser().csvToArray(D);
        var F = dicomheaderview.ExperimentTable.toObject(E);
        this.getHeaders().push({
          index : C,
          data : F
        });
      },
      /**
       * Create the server request URL to retrieve the headers
       * @param serverRoot{String} The root of the XNAT server
       * @param srcUrl{String} The url for the session 
       */
      createHeaderUrl : function(G, H){

        var I = G + h + H + j;
        return I;
      }
    }
  });
})();
(function(){

  var d = "\"tag1\",\"tag2\",\"vr\",\"value\",\"desc\" \n\
\"(0002,0001)\",\"\",\"OB\",\"00\01\",\"File Meta Information Version\" \n\
\"(0002,0002)\",\"\",\"UI\",\"1.2.840.10008.5.1.4.1.1.4.1\",\"Media Storage SOP Class UID\" \n\
\"(0002,0003)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.1.1.5020.1.1.1166546115.14677\",\"Media Storage SOP Instance UID\" \n\
\"(0002,0010)\",\"\",\"UI\",\"1.2.840.10008.1.2.1\",\"Transfer Syntax UID\" \n\
\"(0002,0012)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.2\",\"Implementation Class UID\" \n\
\"(0002,0013)\",\"\",\"SH\",\"DCTOOL100\",\"Implementation Version Name\" \n\
\"(0002,0016)\",\"\",\"AE\",\"CLUNIE1\",\"Source Application Entity Title\" \n\
\"(0008,0005)\",\"\",\"CS\",\"ISO_IR 100\",\"Specific Character Set\" \n\
\"(0008,0008)\",\"\",\"CS\",\"ORIGINAL\PRIMARY\T1\NONE\",\"Image Type\" \n\
\"(0008,0012)\",\"\",\"DA\",\"20061219\",\"Instance Creation Date\" \n\
\"(0008,0013)\",\"\",\"TM\",\"150932\",\"Instance Creation Time\" \n\
\"(0008,0014)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.3\",\"Instance Creator UID\" \n\
\"(0008,0016)\",\"\",\"UI\",\"1.2.840.10008.5.1.4.1.1.4.1\",\"SOP Class UID\" \n\
\"(0008,0018)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.1.1.5020.1.1.1166546115.14677\",\"SOP Instance UID\" \n\
\"(0008,0020)\",\"\",\"DA\",\"20061219\",\"Study Date\" \n\
\"(0008,0021)\",\"\",\"DA\",\"20061219\",\"Series Date\" \n\
\"(0008,0023)\",\"\",\"DA\",\"20061219\",\"Content Date\" \n\
\"(0008,002A)\",\"\",\"DT\",\"20061219083214\",\"Acquisition DateTime\" \n\
\"(0008,0030)\",\"\",\"TM\",\"083214\",\"Study Time\" \n\
\"(0008,0031)\",\"\",\"TM\",\"083214\",\"Series Time\" \n\
\"(0008,0033)\",\"\",\"TM\",\"083214\",\"Content Time\" \n\
\"(0008,0050)\",\"\",\"SH\",\"9995020\",\"Accession Number\" \n\
\"(0008,0060)\",\"\",\"CS\",\"MR\",\"Modality\" \n\
\"(0008,0070)\",\"\",\"LO\",\"Acme Medical Devices\",\"Manufacturer\" \n\
\"(0008,0080)\",\"\",\"LO\",\"St. Nowhere Hospital\",\"Institution Name\" \n\
\"(0008,0090)\",\"\",\"PN\",\"Thomas^Albert\",\"Referring Physician's Name\" \n\
\"(0008,0201)\",\"\",\"SH\",\"-0500\",\"Timezone Offset From UTC\" \n\
\"(0008,1010)\",\"\",\"SH\",\"CONSOLE01\",\"Station Name\" \n\
\"(0008,1030)\",\"\",\"LO\",,\"Study Description\" \n\
\"(0008,103E)\",\"\",\"LO\",\"* SAG LOC\",\"Series Description\" \n\
\"(0008,1050)\",\"\",\"PN\",\"Smith^John\",\"Performing Physician's Name\" \n\
\"(0008,1060)\",\"\",\"PN\",\"Smith^John\",\"Name of Physician(s) Reading Study\" \n\
\"(0008,1070)\",\"\",\"PN\",\"Jones^Molly\",\"Operators' Name\" \n\
\"(0008,1090)\",\"\",\"LO\",\"Super Dooper Scanner\",\"Manufacturer's Model Name\" \n\
\"(0008,9121)\",\"\",\"SQ\",\"\",\"Referenced Raw Data Sequence\" \n\
\"(0008,9121)\",\"(0008,1115)\",\"SQ\",\"\",\"Referenced Series Sequence\" \n\
\"(0008,9121)\",\"(0020,000D)\",\"UI\",\"1.3.6.1.4.1.5962.1.2.5020.1166546115.14677\",\"Study Instance UID\" \n\
\"(0008,9205)\",\"\",\"CS\",\"MONOCHROME\",\"Pixel Presentation\" \n\
\"(0008,9206)\",\"\",\"CS\",\"VOLUME\",\"Volumetric Properties\" \n\
\"(0008,9207)\",\"\",\"CS\",\"NONE\",\"Volume Based Calculation Technique\" \n\
\"(0008,9208)\",\"\",\"CS\",\"MAGNITUDE\",\"Complex Image Component\" \n\
\"(0008,9209)\",\"\",\"CS\",\"T1\",\"Acquisition Contrast\" \n\
\"(0010,0010)\",\"\",\"PN\",\"Subject_001\",\"Patient's Name\" \n\
\"(0010,0020)\",\"\",\"LO\",,\"Patient ID\" \n\
\"(0010,0030)\",\"\",\"DA\",\"19500704\",\"Patient's Birth Date\" \n\
\"(0010,0040)\",\"\",\"CS\",\"M\",\"Patient's Sex\" \n\
\"(0010,1010)\",\"\",\"AS\",\"052Y\",\"Patient's Age\" \n\
\"(0010,1020)\",\"\",\"DS\",\"1.6\",\"Patient's Size\" \n\
\"(0010,1030)\",\"\",\"DS\",\"75\",\"Patient's Weight\" \n\
\"(0010,21B0)\",\"\",\"LT\",,\"Additional Patient History\" \n\
\"(0012,0064)\",\"\",\"SQ\",\"\",\"De-identification Method Code Sequence\" \n\
\"(0012,0064)\",\"(0008,0100)\",\"SH\",\"655374\",\"Code Value\" \n\
\"(0012,0064)\",\"(0008,0102)\",\"SH\",\"XNAT\",\"Coding Scheme Designator\" \n\
\"(0012,0064)\",\"(0008,0103)\",\"SH\",\"0.1\",\"Coding Scheme Version\" \n\
\"(0012,0064)\",\"(0008,0104)\",\"LO\",\"XNAT Edit Script\",\"Code Meaning\" \n\
\"(0018,0023)\",\"\",\"CS\",\"2D\",\"MR Acquisition Type\" \n\
\"(0018,0087)\",\"\",\"DS\",\"1.5\",\"Magnetic Field Strength\" \n\
\"(0018,1000)\",\"\",\"LO\",\"123456\",\"Device Serial Number\" \n\
\"(0018,1020)\",\"\",\"LO\",\"1.00\",\"Software Version(s)\" \n\
\"(0018,1050)\",\"\",\"DS\",\"1.093750\",\"Spatial Resolution\" \n\
\"(0018,5100)\",\"\",\"CS\",\"HFS\",\"Patient Position\" \n\
\"(0018,9004)\",\"\",\"CS\",\"PRODUCT\",\"Content Qualification\" \n\
\"(0018,9005)\",\"\",\"SH\",\"UNNAMED\",\"Pulse Sequence Name\" \n\
\"(0018,9008)\",\"\",\"CS\",\"SPIN\",\"Echo Pulse Sequence\" \n\
\"(0018,9011)\",\"\",\"CS\",\"NO\",\"Multiple Spin Echo\" \n\
\"(0018,9012)\",\"\",\"CS\",\"YES\",\"Multi-planar Excitation\" \n\
\"(0018,9014)\",\"\",\"CS\",\"NO\",\"Phase Contrast\" \n\
\"(0018,9015)\",\"\",\"CS\",\"NO\",\"Time of Flight Contrast\" \n\
\"(0018,9017)\",\"\",\"CS\",\"NONE\",\"Steady State Pulse Sequence\" \n\
\"(0018,9018)\",\"\",\"CS\",\"NO\",\"Echo Planar Pulse Sequence\" \n\
\"(0018,9024)\",\"\",\"CS\",\"NO\",\"Saturation Recovery\" \n\
\"(0018,9025)\",\"\",\"CS\",\"NONE\",\"Spectrally Selected Suppression\" \n\
\"(0018,9029)\",\"\",\"CS\",\"NONE\",\"Oversampling Phase\" \n\
\"(0018,9032)\",\"\",\"CS\",\"RECTILINEAR\",\"Geometry of k-Space Traversal\" \n\
\"(0018,9033)\",\"\",\"CS\",\"SINGLE\",\"Segmented k-Space Traversal\" \n\
\"(0018,9034)\",\"\",\"CS\",\"LINEAR\",\"Rectilinear Phase Encode Reordering\" \n\
\"(0018,9064)\",\"\",\"CS\",\"NONE\",\"k-space Filtering\" \n\
\"(0018,9073)\",\"\",\"FD\",\"51.20001220703124\",\"Acquisition Duration\" \n\
\"(0018,9093)\",\"\",\"US\",\"1\",\"Number of k-Space Trajectories\" \n\
\"(0018,9100)\",\"\",\"CS\",\"1H\",\"Resonant Nucleus\" \n\
\"(0018,9174)\",\"\",\"CS\",\"FDA\",\"Applicable Safety Standard Agency\" \n\
\"(0020,000D)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.1.2.5020.1166546115.14677\",\"Study Instance UID\" \n\
\"(0020,000E)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.1.3.5020.1.1166546115.14677\",\"Series Instance UID\" \n\
\"(0020,0010)\",\"\",\"SH\",\"05020\",\"Study ID\" \n\
\"(0020,0011)\",\"\",\"IS\",\"1\",\"Series Number\" \n\
\"(0020,0012)\",\"\",\"IS\",\"1\",\"Acquisition Number\" \n\
\"(0020,0013)\",\"\",\"IS\",\"1\",\"Instance Number\" \n\
\"(0020,0052)\",\"\",\"UI\",\"1.3.6.1.4.1.5962.1.4.5020.1.1166546115.14677\",\"Frame of Reference UID\" \n\
\"(0020,1040)\",\"\",\"LO\",\"NA\",\"Position Reference Indicator\" \n\
\"(0028,0002)\",\"\",\"US\",\"1\",\"Samples per Pixel\" \n\
\"(0028,0004)\",\"\",\"CS\",\"MONOCHROME2\",\"Photometric Interpretation\" \n\
\"(0028,0008)\",\"\",\"IS\",\"15\",\"Number of Frames\" \n\
\"(0028,0010)\",\"\",\"US\",\"256\",\"Rows\" \n\
\"(0028,0011)\",\"\",\"US\",\"256\",\"Columns\" \n\
\"(0028,0100)\",\"\",\"US\",\"16\",\"Bits Allocated\" \n\
\"(0028,0101)\",\"\",\"US\",\"16\",\"Bits Stored\" \n\
\"(0028,0102)\",\"\",\"US\",\"15\",\"High Bit\" \n\
\"(0028,0103)\",\"\",\"US\",\"1\",\"Pixel Representation\" \n\
\"(0028,0301)\",\"\",\"CS\",\"NO\",\"Burned In Annotation\" \n\
\"(0028,2110)\",\"\",\"CS\",\"00\",\"Lossy Image Compression\" \n\
\"(2050,0020)\",\"\",\"CS\",\"IDENTITY\",\"Presentation LUT Shape\" \n\
\"(5200,9229)\",\"(5200,9229)\",\"SQ\",\"\",\"Shared Functional Groups Sequence\" \n\
\"(5200,9229)\",\"(0018,9006)\",\"SQ\",\"\",\"MR Imaging Modifier Sequence\" \n\
\"(5200,9229)\",\"(0018,9042)\",\"SQ\",\"\",\"MR Receive Coil Sequence\" \n\
\"(5200,9229)\",\"(0018,9049)\",\"SQ\",\"\",\"MR Transmit Coil Sequence\" \n\
\"(5200,9229)\",\"(0018,9112)\",\"SQ\",\"\",\"MR Timing and Related Parameters Sequence\" \n\
\"(5200,9229)\",\"(0018,9114)\",\"SQ\",\"\",\"MR Echo Sequence\" \n\
\"(5200,9229)\",\"(0018,9115)\",\"SQ\",\"\",\"MR Modifier Sequence\" \n\
\"(5200,9229)\",\"(0018,9119)\",\"SQ\",\"\",\"MR Averages Sequence\" \n\
\"(5200,9229)\",\"(0018,9125)\",\"SQ\",\"\",\"MR FOV/Geometry Sequence\" \n\
\"(5200,9229)\",\"(0018,9226)\",\"SQ\",\"\",\"MR Image Frame Type Sequence\" \n\
\"(5200,9229)\",\"(0020,9071)\",\"SQ\",\"\",\"Frame Anatomy Sequence\" \n\
\"(5200,9229)\",\"(0020,9116)\",\"SQ\",\"\",\"Plane Orientation Sequence\" \n\
\"(5200,9229)\",\"(0028,9110)\",\"SQ\",\"\",\"Pixel Measures Sequence\" \n\
\"(5200,9229)\",\"(0028,9145)\",\"SQ\",\"\",\"Pixel Value Transformation Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\" \n\
\"(5200,9230)\",\"(5200,9230)\",\"SQ\",\"\",\"Per-frame Functional Groups Sequence\" \n\
\"(5200,9230)\",\"(0020,9111)\",\"SQ\",\"\",\"Frame Content Sequence\" \n\
\"(5200,9230)\",\"(0020,9113)\",\"SQ\",\"\",\"Plane Position Sequence\" \n\
\"(5200,9230)\",\"(0028,9132)\",\"SQ\",\"\",\"Frame VOI LUT Sequence\"",c = "dicomheaderview.MockData",b = "exp",a = "static";
  qx.Class.define(c, {
    type : a,
    statics : {
      experiments : function(e){

        var f = [];
        for(var i = 0;i < e;i++){

          f.push(b + i);
        };
        return f;
      },
      csv : d
    }
  });
})();
(function(){

  var l = "tagToggled",k = "",j = "cellClick",i = "selectTag",h = "dataChanged",g = "cellDblclick",f = "dicomtag.TagTable",d = "visible",c = "Description",b = "qx.event.type.Data",a = "Tag";
  /**
   * Create the table for the list of tags
   */
  qx.Class.define(f, {
    extend : qx.core.Object,
    events : {
      /** 
       * Fired when the user selects the checkbox. I think this is unused.
       */
      "selectTag" : b,
      /**
       * Fired when any of the tags have been (un)checked.
       */
      "tagToggled" : b
    },
    members : {
      /**
       * Create the table model for the tag table.
       * @param tags{[String]} A list of tags eg. ["0008,0012", "0012,0024" ...]
       */
      createModel : function(m){

        var q = this;
        var o = new qx.ui.table.model.Simple();
        o.setColumns([k, c, a], [d, c, a]);
        var p = [];
        var t;
        for(t in m){

          var n = false;
          if(qx.lang.Array.contains(dicomtag.Tags.defaultVisibleTags, m[t])){

            n = true;
          };
          p.push([n, dicomtag.Tags.tags[m[t]], m[t]]);
        };
        o.setData(p);
        o.setColumnEditable(0, true);
        o.addListener(h, function(r){

          var u = r.getData();
          var w = u.firstRow;
          var s = o.getRowDataAsMap(w)[d];
          var v = o.getRowDataAsMap(w)[a];
          q.fireDataEvent(l, {
            visible : s,
            tag : v
          });
        });
        return o;
      },
      /**
       * Create the table given the model
       * @param model{Object} The given model 
       */
      createPublicTable : function(x){

        var y = new qx.ui.table.Table(x);
        y.getTableColumnModel().setDataCellRenderer(0, new qx.ui.table.cellrenderer.Boolean());
        y.getTableColumnModel().setColumnWidth(0, 25);
        y.getTableColumnModel().setCellEditorFactory(0, new qx.ui.table.celleditor.CheckBox());
        var z = this;
        y.addListener(j, function(A){

          var E = A.getRow();
          var D = x.getRowDataAsMap(E)[a];
          z.fireDataEvent(i, {
            row : E,
            tag : D
          });
          var B = A.getColumn();
          if(B == 0){

            var C = y.getTableModel().getValue(0, E);
            y.getTableModel().setValue(0, E, !C);
          };
        });
        // double clicking anywhere else on the row selects it
        y.addListener(g, function(e){

          var G = e.getRow();
          var F = y.getTableModel().getValue(0, G);
          y.getTableModel().setValue(0, G, !F);
        }, this);
        return y;
      }
    }
  });
})();
(function(){

  var DL = "Image Box Layout Type",DK = "Plane Position Sequence",DJ = "Gradient Output Type",DI = "Anatomic Perspective Description (Trial)",DH = "Presentation LUT Shape",DG = "Number of Event Timers",DF = "Patient Species Code Sequence",DE = "Topic Subject",DD = "Center of Circular Exposure Control Sensing Region",DC = "Termination Counts Threshold",Fn = "Scheduled Protocol Code Sequence",Fm = "Image Translation Vector",Fl = "Coincidence Window Width",Fk = "Interpretation Transcription Date",Fj = "Overlay Activation Layer",Fi = "Collimator Left Vertical Edge",Fh = "Data Collection Center (Patient)",Fg = "Spectroscopy Data",Ff = "Upper/Lower Pixel Values",Fe = "Scheduled Study Start Date",Pv = "ROI Description",Pw = "Phosphor Type",Pt = "Diffusion Anisotropy Type",Pu = "Institution Name",Pr = "In-Stack Position Number",Ps = "Line Dashing Style",Pp = "Retrieve AE Title",Pq = "Product Description",Px = "Termination Time Threshold",Py = "Structure Set Date",Lx = "Slice Thickness",Lw = "Relative X-Ray Exposure",Lz = "Number of Surfaces",Ly = "Acquisition Termination Condition Data",LB = "Clinical Trial Protocol Name",LA = "Contact URI",LD = "Number of Patient Related Instances",LC = "Move Originator Application Entity Title",Lu = "Bounding Box Top Left Hand Corner",Lt = "Terminal Type",dd = "Sequence Variant",de = "Human Performer's Name",df = "Attribute Item Selector",dg = "Sensitivity",dh = "Overlay Comments",di = "De-identification Method",dj = "Contour Sequence",dk = "Delivered Number of Pulses",dl = "Destination AE",dm = "Digital Signature UID",SL = "Type of Detector Motion",SK = "Referenced Basic Annotation Box Sequence",SJ = "Diffusion b-value XX",SI = "Borders",SP = "Angular Position",SO = "De-coupling Method",SN = "Interpretation Status ID",SM = "Filter Beam Path Length Maximum",SR = "Frame of Interest Type",SQ = "Number of Screens",jm = "Radius of Circular Shutter",jn = "Surface Points Sequence",jk = "Media Storage SOP Class UID",jl = "CTDIvol",jq = "Grid Spacing Material",jr = "Fluoroscopy Flag",jo = "Near Pupillary Distance",jp = "Frame Type",ji = "Phototimer Setting",jj = "Therapy Type",gh = "Scheduled Study Stop Time",gg = "Image Rotation",gj = "Shutter Upper Horizontal Edge",gi = "Slab Thickness",gd = "Data Block",gc = "Spatial Pre-saturation",gf = "Other Patient IDs",ge = "Referenced Frame of Reference Sequence",gb = "Annotation Flag",ga = "Segmented k-Space Traversal",jI = "Action Type ID",jJ = "Authorization Equipment Certification Number",jK = "Partial Fourier Direction",jL = "Issuer of Admission ID Sequence",jE = "Study Completion Time",jF = "Secondary Capture Device Software Versions",jG = "Anatomic Structure Space Or Region Code Sequence (Trial)",mF = "Nominal Percentage of Cardiac Phase",jN = "Show Patient Demographics Flag",jO = "Recorded Channel Shield Sequence",gB = "Special Needs",gA = "Patient's Birth Date",gz = "Exposures on Detector Since Last Calibration",gy = "De-coupling",gx = "MR Acquisition Type",gw = "Derivation Code Sequence",gv = "Radiopharmaceutical Stop Time",gu = "CT Geometry Sequence",gD = "Smallest Image Pixel Value in Plane",gC = "Detector Temperature",zG = "Window Center",zH = "Sample Rate",zI = "Number of Detectors",zJ = "Image Box Tile Vertical Dimension",zK = "Per-frame Functional Groups Sequence",zL = "Algorithm Description",xw = "Station Name",xx = "Applicable Safety Standard Agency",xy = "Affected SOP Instance UID",xz = "Date of Last Calibration",CG = "Image Processing Applied",CF = "Decimal Visual Acuity",CE = "Scan Arc",CD = "Number of k-Space Trajectories",CK = "Total Collimation Width",CJ = "Detector Lines of Response Used",CI = "Field of View Origin",CH = "Private Information",CO = "Real World Value Slope",CN = "Autorefraction Left Eye Sequence",qt = "Treatment Date",qu = "Algorithm Type",qr = "PET Frame Correction Factors Sequence",qs = "Study Comments",qp = "Parallel Reduction Factor Second In-plane",qq = "Secondary Capture Device Manufacturer's Model Name",qn = "Detector Time Since Last Exposure",qo = "Exposure Index",FU = "Beam Stopper Position",FV = "Vertex Point Index List",Iw = "Container Component Width",Iv = "Rotation of Scanned Film",Iy = "Pixel Measures Sequence",Ix = "Cranial Thermal Index",IA = "Number of Priors Referenced",Iz = "Exposure",IC = "Focus Depth",IB = "Overlay Compression Step Pointers",It = "Acquisition Start Condition",Is = "Slab Orientation",Ml = "Patient ID",Mm = "Counts Included",Mn = "Concatenation UID",Mo = "DVH Minimum Dose",Mh = "Pixel Spacing",Mi = "Overlay Location",Mj = "Selector Value Number",jH = "Real World Value First Value Mapped",Me = "Frame Label Vector",Mf = "Implementation Version Name",BW = "Volume Based Calculation Technique",BV = "Zonal Map",BU = "Overlay Format",BT = "Specimen Short Description",BR = "Procedure Code Sequence",BQ = "Fluence Mode",BP = "Modified Image Description",BO = "Referenced SOP Instance MAC Sequence",PO = "Acquired Image Area Dose Product",PN = "Contour Offset Vector",l = "Requested Decimate/Crop Behavior",m = "Images in Acquisition",j = "Filter Thickness Minimum",k = "Spoiling",p = "Modalities in Study",q = "Number of Time Slices",n = "MAC Algorithm",o = "DVH Type",r = "Region Pixel Shift Sequence",s = "Phase Number",dt = "Intensifier Active Shape",ds = "Approval Status Further Description",dv = "Radionuclide Code Sequence",du = "Calibration Image",dp = "Shutter Left Vertical Edge",dn = "Details of Coefficients",dr = "Half Value Layer",dq = "Intervention Drug Name",dx = "Distance Source to Isocenter",dw = "Radiation Machine SAD",bR = "Manipulated Image",bS = "Excluded Intervals Sequence",bT = "Physician Approving Interpretation",bU = "Horizontal Prism Base",bV = "Requested Procedure Priority",bW = "SOP Instance UID of Concatenation Source",bX = "Graphic Group Sequence",bY = "Steep Keratometric Axis Sequence",bJ = "Quantity",bK = "ICC Profile",eK = "Processing Function",eJ = "Event Type ID",eI = "Primary (Prompts) Counts Accumulated",eH = "General Purpose Scheduled Procedure Step Status",eO = "Print Queue ID",eN = "Focal Spot(s)",eM = "Inter-Marker Distance",eL = "Specimen Detailed Description",eG = "Modifying Device ID",eF = "Reconstruction Type",eA = "Effective Duration",ez = "Override Sequence",ey = "Meterset Exposure",ex = "Radiopharmaceutical Volume",eE = "Frame Label",eD = "Lesion Number",eC = "Source Image Evidence Sequence",eB = "Dimension Organization Type",ew = "Exposures on Plate",ev = "Scan Velocity",bB = "Override Reason",bC = "Pixel Intensity Relationship",bD = "Filler Order Number / Imaging Service Request (Retired)",bE = "Responsible Person Role",bF = "RT ROI Relationship",bG = "Alpha LUT Transfer Function",bH = "Network ID",bI = "Treatment Summary Calculated Dose Reference Sequence",by = "Multiple Spin Echo",bz = "Overlay Plane Origin",lr = "Treatment Control Point Date",lq = "Reformatting Interval",lt = "Placer Order Number / Procedure",ls = "Maximum Along-scan Distortion",lv = "Stereo Baseline Angle",lu = "Patient Orientation Code Sequence",lx = "Move Destination",lw = "Field of View Dimension(s) in Float",lz = "Run Length Triplet",ly = "Other Pupillary Distance",hN = "Compound Graphic Instance ID",hO = "Study Read Date",hL = "Repetition Time",hM = "Scheduled Procedure Step Status",hJ = "Curve Description",hK = "Curve Date",hH = "Chemical Shift Minimum Integration Limit in Hz",hI = "Dose Value",hF = "Column Angulation (Patient)",hG = "Volume Localization Sequence",qD = "Device ID",qC = "Transducer Data",qB = "Specified Secondary Meterset",qA = "Coverage of k-Space",qz = "Film Box Content Sequence",qy = "Spiral Pitch Factor",qw = "Mask Operation Explanation",qv = "Radiopharmaceutical Agent Number",qF = "Time of Flight Contrast",qE = "Interpretation Recorder",nY = "IVUS Pullback Stop Frame Number",oa = "Presentation Pixel Spacing",ob = "Number of Temporal Positions",oc = "Image Path Filter Pass-Through Wavelength",nU = "Results Distribution List Sequence",nV = "Axis Labels",nW = "Simple Frame List",nX = "Shadow Style",od = "Referenced Stereometric Instance Sequence",oe = "Number of Study Related Instances",wM = "Diffusion b-value YY",wL = "Acquisition Device Type Code Sequence",wO = "VOI LUT Function",wN = "Overlay Descriptor - Blue",wI = "Attached Contours",wH = "Icon Image Sequence",wK = "Overlay Foreground Density",wJ = "Sequence of Compressed Data",wG = "Time Slice Vector",wF = "Referenced Stored Print Sequence",tD = "Reconstruction Index",tE = "Table Longitudinal Increment",tB = "Energy Window Upper Limit",tC = "Vector Grid Data",tH = "Referenced Calculated Dose Reference Number",tI = "Referenced Image Real World Value Mapping Sequence",tF = "Calculated Anatomy Thickness",tG = "Fluence Mode ID",ty = "Vertices of the Region",tz = "Planar Configuration",Cw = "Images in Study",Cv = "Exposure Sequence",Cu = "Names of Intended Recipients of Results",Ct = "Number of Slices",CA = "Spectral Width",Cz = "Doppler Sample Volume X Position",Cy = "Detector Active Origin",Cx = "Average Pulse Width",CC = "Hanging Protocol Creator",CB = "Tag Thickness",zw = "Cine Rate",zx = "Alternate Representation Sequence",zy = "Display Set Label",zz = "Operators' Name",zA = "Total Number of Exposures",zB = "Display Set Number",zC = "Referenced SOP Class UID in File",zD = "Primary Anatomic Structure Sequence",zE = "Contrast/Bolus Route",zF = "Contrast/Bolus Ingredient",zh = "Print Management Capabilities Sequence",zl = "Exposures on Detector Since Manufactured",zf = "Graphic Layer Recommended Display RGB Value",zg = "Convolution Kernel Group",zu = "Table Frame of Reference UID",zv = "PET Frame Type Sequence",zq = "Mask Visibility Percentage",zt = "Substance Administration Notes",sO = "Interpretation ID",sP = "Graphic Object Sequence",we = "PVC Rejection",wd = "Film Orientation",wg = "Axial Length of the Eye",wf = "Performed Protocol Code Sequence",wa = "SAR",vY = "Identifying Comments",wc = "Structured Display Background CIELab Value",wb = "Coding Scheme Responsible Organization",wk = "ROI Area",wj = "Transmitter Frequency",ni = "Largest Monochrome Pixel Value",nj = "Source Frame of Reference UID",nk = "Exposure Time in µS",nl = "Protocol Context Sequence",ne = "Baseline Correction",nf = "RT ROI Identification Code Sequence",ng = "Patient Motion Corrected",nh = "CTDI Phantom Type Code Sequence",nc = "Scheduled Procedure Step Sequence",nd = "Segment Description",pV = "Responsible Person",pU = "Graphic Layer Order",pT = "Soft Tissue Thermal Index",pS = "File-set Descriptor File ID",pR = "Performed Procedure Step End Date",pQ = "Printer Status",pP = "Graphic Annotation Sequence",pO = "Military Rank",pN = "Mask Sub-pixel Shift",pM = "R-R Interval Vector",OC = "Performing Physician's Name",OH = "Repeat Interval",Ov = "Brachy Control Point Delivered Sequence",Ow = "Clinical Trial Time Point ID",gG = "Specified Meterset",gH = "Delivered Primary Meterset",gE = "ROI Generation Description",gF = "Image ID",gS = "Structure Set Label",gT = "Corrected Parameter Sequence",ka = "Referenced Image Box Sequence",jY = "Photometric Interpretation",kc = "Contrast/Bolus Agent Sequence",kb = "Positioner Isocenter Secondary Angle",ke = "Beam Task Sequence",kd = "Curve Dimensions",kg = "Container Component Sequence",kf = "Spatial Resolution",jX = "Code Value",jW = "Name of Physician(s) Reading Study",t = "Priority",u = "Pixel Presentation",v = "Table Head Tilt Angle",w = "List of MIME Types",x = "Gap Length",y = "(0020,000D)",z = "Frame Reference DateTime",A = "R Wave Pointer",B = "Overlay Bit Position",C = "Basic Grayscale Image Sequence",dB = "Magnify to Number of Columns",dA = "Inversion Recovery",dz = "Gradient Echo Train Length",dy = "Person's Telephone Numbers",dF = "Number of Surface Points",dE = "Variable Coefficients SDVN",dD = "Visual Acuity Modifiers",dC = "Data Information Sequence",dJ = "Add Intermediate Sequence",dI = "Patient Clinical Trial Participation Sequence",Mz = "Cardiac Number of Images",MA = "Delivered Meterset",Mx = "Label Text",My = "Light Path Filter Pass Band",MD = "Stage Name",ME = "Data Point Columns",MB = "Image Transformation Matrix",MC = "Number of Points",Mr = "Anatomic Location Of Examining Instrument Description (Trial)",Ms = "Lens Description",Qf = "MAC ID Number",Qe = "Topic Keywords",Qh = "Measured Dose Reference Sequence",Qg = "Safe Position Exit Date",Qb = "Referring Physician's Telephone Numbers",Qa = "PET Detector Motion Details Sequence",Qd = "Instance Creation Date",Qc = "Film Session Label",PY = "Quality Control Image",PX = "Perimeter Value",PU = "Axial Mash",PT = "Relative Time",PW = "Mapping Resource",PV = "(0010,0010)",PQ = "Largest Pixel Value in Series",PP = "Patient Comments",PS = "Radionuclide Positron Fraction",PR = "Interpretation ID Issuer",PM = "Concatenation Frame Offset Number",PL = "Doppler Sample Volume X Position (Retired)",Mg = "Lenses Code Sequence",Mk = "Date of Secondary Capture",js = "Real World Value LUT Data",jv = "Placer Order Number / Imaging Service Request",jQ = "Modified Image Date",jR = "Overlays - Green",jM = "Trigger Source or Type",jP = "Radiopharmaceutical Usage Sequence",Mc = "Billing Procedure Step Sequence",Md = "Overlay Number of Tables",IK = "Scheduled Performing Physician's Name",IJ = "Performed Location",II = "Histogram Number of Bins",IH = "Procedure Step Relationship Type",IG = "Diffusion b-value YZ",IF = "Channel Maximum Value",IE = "Keratometric Power",ID = "Viewing Distance Type",IP = "Issuer of Admission ID",IO = "Trigger Vector",FO = "Plane Orientation Sequence",FP = "MR Spatial Saturation Sequence",FQ = "Message ID",FR = "Image Box Tile Horizontal Dimension",FK = "Display Set Patient Orientation",FL = "Digital Signature DateTime",FM = "Starting Respiratory Phase",FN = "Order Entered By",FS = "Pixel Value Transformation Sequence",FT = "Substance Administration Parameter Sequence",QV = "Intervention Drug Start Time",QS = "Output Power",Rf = "Specific Absorption Rate Definition",mQ = "Curve Referenced Overlay Sequence",Rh = "Institutional Department Name",Rg = "Positioner Type",Rj = "Spectroscopy Acquisition Data Columns",Ri = "Variable Flip Angle Flag",CM = "Histogram Data",CL = "Filter Thickness Maximum",zU = "Performed Station Name",zV = "Dead Time Factor",zS = "Energy Weighting Factor",zT = "Referenced Visit Sequence",zQ = "Vertical Alignment",zR = "Skip Frame Range Flag",zO = "Burned In Annotation",zP = "Number of Patient Related Series",zM = "Blending Lookup Table Descriptor",zN = "Triangle Point Index List",wU = "Image Boxes Sequence",wT = "Interpretation Approval Date",wS = "CT Acquisition Type Sequence",wR = "Performed Procedure Step Start Time",wY = "Imaged Nucleus",wX = "Visual Acuity Left Eye Sequence",wW = "Show Image True Size Flag",wV = "Digital Image Format Acquired",wQ = "Command Group Length",wP = "Patient Orientation Modifier Code Sequence",tL = "Residual Syringe Counts",tM = "Phase Delay",tN = "Grid ID",tO = "Overlay Magnification Type",tP = "TID Offset",tQ = "Overlay Number",tR = "Table Feed per Rotation",tS = "Referenced Source Applicator Number",tJ = "Time Based Image Sets Sequence",tK = "Patient State",wA = "Units",wz = "Transverse Mash",wC = "Vector Accuracy",wB = "Attribute Modification DateTime",ww = "Overlay Compression Description",wv = "Overlays - Gray",wy = "Bold",wx = "KVP",wE = "(0010,4000)",wD = "Dose Rate Delivered",to = "Tissue Heterogeneity Correction",tp = "Acquisitions in Series",tm = "Detector Conditions Nominal Flag",tn = "Current Patient Location",ts = "Saturation Recovery",tt = "Positioner Isocenter Detector Rotation Angle",tq = "Primary Positioner Scan Arc",tr = "Scheduled Procedure Step ID",tv = "ROI Observation Label",tw = "Measured Dose Type",ba = "Exposure Control Mode Description",bb = "Border Density",bc = "RT Image Orientation",bd = "Non-uniform Radial Sampling Corrected",V = "Frame Acquisition DateTime",W = "Dimension Index Values",X = "Detector Vector",Y = "Interval Number",bi = "(0008,1030)",bj = "Illumination Wave Length",eg = "Relative Opacity",ef = "Smoothing Type",ee = "Admitting Diagnoses Description",ed = "Reference Coordinates",ec = "Maximum Across-scan Distortion",eb = "Acquisition Type",ea = "Intermediate Pupillary Distance",dY = "Quadrature Receive Coil",ei = "Ophthalmic Frame Location Sequence",eh = "Start Cardiac Trigger Count Threshold",hk = "De-identification Method Code Sequence",hl = "Radiopharmaceutical Start Time",hi = "Primary Anatomic Structure Modifier Sequence",hj = "Mean Point Distance",ho = "Structure Set Time",hp = "Rectification Type",hm = "Image Filter",hn = "Series Time",hg = "Bits Allocated",hh = "Audio Type",kO = "Treatment Time",kN = "Cylinder Sequence",kQ = "Performed Station Class Code Sequence",kP = "Light Path Filter Pass-Through Wavelength",kK = "Number of Frames",kJ = "Referenced Brachy Accessory Device Number",kM = "Recorded Source Sequence",kL = "Acquisition Time",kH = "Scheduled Station Name Code Sequence",kG = "Anatomic Region Sequence",Gk = "Transverse Detector Separation",Gl = "Image Index",Gm = "Specific Character Set of File-set Descriptor File",Gn = "Lossy Image Compression Method",Go = "Verification Image Timing",Gp = "Mask Operation",Gq = "Cassette Size",Gr = "Referenced Overlay Plane Sequence",Gi = "Position of Isocenter Projection",Gj = "MR FOV/Geometry Sequence",Jo = "Surface Processing Algorithm Identification Sequence",Jn = "Graphic Layer Recommended Display Grayscale Value",Jm = "Film Size ID",Jl = "X-Ray Tube Current in µA",Js = "Frame Reference Time",Jr = "Presentation Pixel Magnification Ratio",Jq = "De-coupling Frequency",Jp = "DVH Sequence",Jk = "Offset of Referenced Lower-Level Directory Entity",Jj = "Owner ID",Na = "Radionuclide Total Dose",Nb = "Image Set Selector Usage Flag",MX = "Referenced General Purpose Scheduled Procedure Step Transaction UID",MY = "Fill Pattern",MV = "Perimeter Table",MW = "Left Lens Sequence",MT = "Specific Absorption Rate Sequence",MU = "Requesting Physician Identification Sequence",MR = "Detector Element Physical Size",MS = "MR Metabolite Map Sequence",QD = "Pattern Off Opacity",QC = "Bits Grouped",QF = "ROI Mean",QE = "Creation Time",QH = "RT Referenced Study Sequence",QG = "Overlay Planes",QJ = "Transducer Orientation Sequence",QI = "CSS Font Name",QL = "Patient Eye Movement Command Code Sequence",QK = "Data Value Representation",At = "Acquisitions in Study",Au = "Frame Secondary Angle Vector",Av = "Data Frame Assignment Sequence",Aw = "Page Position ID",Ap = "dicomtag.Tags",Aq = "X-Ray Geometry Sequence",Ar = "Grid Resolution",As = "Anatomic Structure",Al = "Respiratory Signal Source ID",Am = "Beat Rejection Flag",Dj = "Number of Zero fills",Di = "Triangle Fan Sequence",Dh = "Spectroscopy Acquisition Phase Rows",Dg = "Multi-frame Presentation Sequence",Df = "Discharge Diagnosis Code Sequence",De = "Entrance Dose",Dd = "Patient's Address",Dc = "Print Priority",Db = "Affected SOP Class UID",Da = "Per Projection Acquisition Sequence",Ir = "Transmit Coil Manufacturer Name",Iq = "Line Sequence",Ip = "Exposure Control Sensing Region Right Vertical Edge",Io = "Acquisition Index",In = "Primary Positioner Increment",Im = "Dynamic Range",Il = "Application Manufacturer",Ik = "Contrast Flow Duration",Ij = "MR Acquisition Frequency Encoding Steps",Ii = "Gantry/Detector Tilt",FF = "Unified Procedure Step State",FG = "Segmentation Type",FH = "Gray Lookup Table Descriptor",FI = "Data Block Description",FB = "Recommended Display Frame Rate in Float",FC = "Selector FD Value",FD = "Failed SOP Sequence",FE = "Requested Procedure Comments",Fz = "Geometric Maximum Distortion",FA = "Contour Geometric Type",PG = "Transfer Syntax UID",PF = "Column Angulation",PI = "Series in Study",PH = "Multiple Copies Flag",PC = "Chemical Shift Minimum Integration Limit in ppm",PB = "Spectrally Selected Excitation",PE = "Large Red Palette Color Lookup Table Data",PD = "Start Respiratory Trigger Count Threshold",PK = "Operating Mode Sequence",PJ = "Nominal Percentage of Respiratory Phase",LT = "Anatomic Perspective Code Sequence (Trial)",LU = "US Image Description Sequence",LR = "Medium Type",LS = "Number of Averages",LX = "De-coupling Chemical Shift Reference",LY = "Annotation Position",LV = "Functional Group Private Creator",LW = "Safe Position Return Time",Ma = "Softcopy VOI LUT Sequence",Mb = "Positioner Isocenter Primary Angle",d = "Calculated Dose Reference Description",c = "Dose Type",b = "Vertices of the Polygonal Collimator",a = "Overlay Subtype",i = "Clinical Trial Coordinating Center Name",h = "Source Serial Number",f = "Underlined",e = "Patient's Size",wi = "Acquisition Device Processing Description",wh = "Ion Machine Verification Sequence",sE = "MR Imaging Modifier Sequence",sF = "Shadow Opacity",sG = "Reconstruction Pixel Spacing",sH = "Contrast/Bolus Total Dose",sI = "Medical Record Locator",sJ = "Filler Order Number / Imaging Service Request",sK = "Termination Density Threshold",sL = "X-Ray 3D Reconstruction Sequence",sM = "Patient's Sex",sN = "Requested SOP Class UID",Cm = "X-Ray 3D Frame Type Sequence",Cl = "Segment Algorithm Type",Co = "Performing Physician Identification Sequence",Cn = "Contact Display Name",Cq = "Study Read Time",Cp = "Intended Recipients of Results Identification Sequence",Cs = "Visual Acuity Right Eye Sequence",Cr = "Language Code Sequence",Ck = "Blue Palette Color Lookup Table Data",Cj = "Location",zb = "Temporal Position Sequence",zc = "Table Angle",yY = "Anchor Point",za = "Multi-Coil Configuration",yW = "Alternate Container Identifier Sequence",yX = "Media Storage SOP Instance UID",yU = "Text Style Sequence",yV = "Volume Localization Technique",zd = "Irradiation Event UID",ze = "De-coupled Nucleus",ko = "Current Fraction Number",kn = "DVH ROI Contribution Type",km = "Frame VOI LUT Sequence",kl = "Compression Originator",kk = "Comments on Radiation Dose",kj = "Intensifier Size",ki = "Scatter Correction Method",kh = "Triangle Strip Sequence",ks = "Bone Thermal Index",kr = "Annotation Display Format ID",gI = "Radiopharmaceutical",gJ = "Billing Supplies and Devices Sequence",gK = "Patient Orientation in Frame Sequence",gL = "Lossy Image Compression",Or = "Human Performer Code Sequence",Os = "Specimen Preparation Sequence",Ot = "Largest Valid Pixel Value",Ou = "Clinical Trial Site ID",gQ = "Recorded Brachy Accessory Device Sequence",gR = "Reconstruction Angle",LK = "Number of Patient Related Studies",LL = "Zoom Factor",LI = "RT Image Name",LJ = "Hanging Protocol Level",LG = "Storage Media File-set UID",LH = "Plane Identification",LE = "Percent Phase Field of View",LF = "Scheduled Procedure Step Start Date",LN = "Echo Pulse Sequence",LO = "Text Comments",Qv = "Label Style Selection",Qu = "Image Dimensions",Qx = "Field of View Rotation",Qw = "Alternate Content Description Sequence",Qz = "Filter Type",Qy = "Exposure Control Sensing Regions Sequence",QB = "Occupation",QA = "Selector LO Value",Qt = "Insurance Plan Identification",Qs = "Vertices of the Polygonal Shutter",Fo = "Energy Window Range Sequence",Fp = "Dead Time Correction Flag",Fq = "Energy Window Name",Fr = "Attribute Occurrence Private Creator",Fs = "Metabolite Map Description",Ft = "Start Angle",Fu = "Velocity Encoding Direction",Fv = "Intervals Acquired",Fw = "Graphic Data",Fx = "Product Type Code Sequence",HV = "Distance Object to Table Top",HU = "Depth(s) of Focus",HT = "Performed Procedure Step End Time",HS = "Primitive Point Index List",Ia = "Requesting Service Code Sequence",HY = "Histogram Sequence",HX = "Scatter Fraction Factor",HW = "Number of Remaining Sub-operations",Ic = "Facet Sequence",Ib = "Shift Table Triplet",gW = "Discharge Time",gX = "Large Blue Palette Color Lookup Table Descriptor",gU = "Block Columns",gV = "Barcode Symbology",hb = "Local Namespace Entity ID",hc = "Interpretation Approval Time",gY = "Contrast/Bolus Agent Phase",ha = "Image Box Large Scroll Amount",hd = "Energy Window Vector",he = "Message Set ID",kA = "Institution Address",kz = "DVH Referenced ROI Sequence",kC = "Patient's Age",kB = "Source Application Entity Title",kw = "Italic",kv = "Referenced Film Session Sequence",ky = "Patient Identity Removed",kx = "Bulk Motion Status",kE = "Data Set Subtype",kD = "Isotope Number",Q = "Prism Sequence",R = "Corneal Size",S = "Gray Scale",T = "Digital Signature Purpose Code Sequence",M = "Pixel Component Organization",N = "Table Z Position to Isocenter",O = "Energy Window Lower Limit",P = "Image Box Small Scroll Amount",K = "Mask Selection Mode",L = "Scheduled Station Geographic Location Code Sequence",dX = "Empty Image Density",dW = "Patient's Insurance Plan Code Sequence",dV = "Display Format",dU = "static",dT = "Frame Display Shutter Sequence",dS = "Tomo Layer Height",dR = "Dead Time Corrected",dQ = "Overlays - Blue",dP = "Branch of Service",dO = "Spectrally Selected Suppression",nI = "Code Meaning",nJ = "Transducer Position Modifier Sequence",nG = "Image Rotation (Retired)",nH = "Secondary Positioner Increment",nE = "Query/Retrieve Level",nF = "Collimator Upper Horizontal Edge",nC = "Offending Element",nD = "Message ID Being Responded To",nA = "DVH Mean Dose",nB = "Spectroscopy Acquisition Out-of-plane Phase Steps",pX = "Synchronization Frame of Reference UID",pW = "Frame Time Vector",qa = "Histogram Last Bin Value",pY = "Imager Pixel Spacing",qc = "Referring Physician's Address",qb = "Collimator Lower Horizontal Edge",qe = "Double Exposure Ordering",qd = "Referenced Frame Number",qg = "Printer Status Info",qf = "Sorting Operations Sequence",pD = "Tick Alignment",pC = "Acquisition Comments",pF = "Discharge Date",pE = "Shutter Lower Horizontal Edge",pH = "Bulk Motion Signal Source",pG = "Shutter Presentation Color CIELab Value",pJ = "Cassette Orientation",pI = "Contrast/Bolus Agent Number",pL = "Curve Data Descriptor",pK = "Blending Operation Type",na = "Number of Table Entries",nb = "Compression Code",mX = "Table Y Position to Isocenter",mY = "Point Coordinates Data",mV = "Distance Receptor Plane to Detector Housing",mW = "Graphic Layer Sequence",mT = "Scan Spot Metersets Delivered",mU = "Print Job Description Sequence",mR = "Detector Configuration",mS = "Table Position Sequence",jz = "Meterset Rate Set",jy = "Depth of Transverse Image",jx = "Specific Absorption Rate Value",jw = "SOP Classes in Study",jD = "Device Diameter",jC = "Safe Position Return Date",jB = "Applicable Safety Standard Description",jA = "Surface Mesh Primitives Sequence",ju = "Performed Workitem Code Sequence",jt = "Unified Procedure Step Progress Description",gm = "Acquisition Contrast",gn = "Nominal Scanned Pixel Spacing",go = "PET Frame Acquisition Sequence",gp = "Frame Acquisition Sequence",gq = "Trim",gr = "Configuration Information",gs = "Window Width",gt = "Blending LUT 1 Sequence",gk = "Count Rate",gl = "Smallest Image Pixel Value",BL = "Scheduled Station Class Code Sequence",BK = "CT Exposure Sequence",BN = "Requested Subsequent Workitem Code Sequence",BM = "Trigger Time Offset",BH = "CT Table Dynamics Sequence",BG = "Queue Status",BJ = "Presentation Pixel Aspect Ratio",BI = "Functional Group Pointer",BF = "Measured Dose Reference Number",BE = "Variable Next Data Group",yC = "Presentation Size Mode",yD = "Structured Display Image Box Sequence",yA = "Subjective Refraction Right Eye Sequence",yB = "Image Display Format",yG = "Waveform Sample Interpretation",yH = "Lossy Image Compression Ratio",yE = "Reconstruction Algorithm",yF = "Distance Pupillary Distance",yy = "Visual Acuity Both Eyes Open Sequence",yz = "Acquisition Duration",vL = "Number of Rotations",vK = "Effective Echo Time",vJ = "Clinical Trial Series Description",vI = "Issuer of Service Episode ID Sequence",vH = "Add Near Sequence",vG = "Scheduled Processing Applications Code Sequence",vF = "Autorefraction Right Eye Sequence",vE = "Field of View Dimension(s)",vN = "Interpretation Transcription Time",vM = "Include Non-DICOM Objects",so = "Modified Attributes Sequence",sp = "Diffusion b-value ZZ",sq = "Corrected Image",sr = "X-Ray Output",sk = "Doppler Correction Angle",sl = "Image Orientation (Volume)",sm = "Parallel Reduction Factor In-plane",sn = "Escape Triplet",ss = "MR Echo Sequence",st = "Fill Mode",OL = "Cine Relative to Real-Time",OK = "Referenced Digital Signature Sequence",ON = "Examined Body Thickness",OM = "Tube Angle",OP = "Structured Display Text Box Sequence",OO = "Algorithm Name Code Sequence",OR = "Filler Order Number / Procedure",OQ = "Shutter Shape",OJ = "Contrast/Bolus Ingredient Concentration",OI = "Referenced Print Job Sequence",KU = "Transmit Coil Name",KV = "Center of Rotation Offset",KS = "Pixel Intensity Relationship LUT Sequence",KT = "Multi-Frame Source SOP Instance UID",KQ = "Text Format ID",KR = "Target Exposure Index",KO = "(0008,0020)",KP = "High R-R Value",KW = "Dose Comment",KX = "Collation Flag",sw = "Secondary Counts Accumulated",sx = "Overlay Time",sy = "Reason for the Requested Procedure",sz = "Original Image Identification Nomenclature",sA = "Requested SOP Instance UID",sB = "Treatment Session Application Setup Sequence",sC = "Optotype Presentation",sD = "Stereo Horizontal Pixel Offset",su = "Exposure Time in ms",sv = "Distance Source to Detector",vT = "Raw Data Handling",vS = "Distribution Type",vR = "Ethnic Group",vQ = "Table Motion",vX = "Interpretation Diagnosis Code Sequence",vW = "Failed SOP Instance UID List",vV = "Breast Implant Present",vU = "Image Box Position",vP = "Real World Value Last Value Mapped",vO = "Illumination Bandwidth",yS = "(0008,103E)",yT = "Contrast/Bolus Agent",yQ = "Order Placer Identifier Sequence",yR = "Creation Date",yO = "Interpretation Type ID",yP = "Physical Detector Size",yM = "Positioner Primary Angle",yN = "Frame Delay",yK = "Beam Angle",yL = "In-concatenation Total Number",BY = "Largest Image Pixel Value",BX = "X-Ray 3D Acquisition Sequence",Cb = "Exposure Modulation Type",Ca = "Time of Flight Information Used",Cd = "TM-Line Position X1 (Retired)",Cc = "Maximum Memory Allocation",Cf = "Tag Angle Second Axis",Ce = "Region Location Min X0",Ch = "Estimated Dose Saving",Cg = "Constant Volume Flag",EW = "Related Series Sequence",EX = "Reference Pixel Physical Value X",EY = "Total Time",Fa = "Number of Frames in Overlay",ES = "Measured Dose Value",ET = "PET Position Sequence",EU = "Scheduled Workitem Code Sequence",EV = "Context Group Version",Fb = "Detector Geometry",Fc = "Storage Media File-set ID",HO = "Patient Species Description",HN = "Histogram Explanation",HM = "Related Procedure Step Sequence",HL = "Illumination Type Code Sequence",HK = "Referenced Study Sequence",HJ = "Container Identifier",HI = "Printer Name",HH = "Confidentiality Code",HQ = "Attribute Occurrence Pointer",HP = "Scheduled Study Location",Ln = "Calibration Sequence",Lo = "Samples per Pixel",Ll = "Compression Description",Lm = "Representative Frame Number",Lr = "Initial Cine Run State",Ls = "Partial Fourier",Lp = "Product Package Identifier",Lq = "Acquisition Context Sequence",Lj = "Scheduled Specimen Sequence",Lk = "Receiver",Pm = "Issuer of the Specimen Identifier Sequence",Pl = "Detector Description",Po = "Oversampling Phase",Pn = "Structure Set ROI Sequence",Pi = "Image Box Content Sequence",Ph = "Contour Data",Pk = "Dose Calibration Factor",Pj = "Display Window Label Vector",Pg = "Erase",Pf = "C-arm Positioner Tabletop Relationship",Sy = "Ending Respiratory Phase",Sz = "Cardiac Signal Source",SA = "Overlay Date",SB = "Stack ID",SC = "Code Table Location",SD = "Shape Type",SE = "Referenced Channel Shield Number",SF = "Slice Progression Direction",SG = "Reporting Priority",SH = "Number of Frames in Phase",cT = "Total Gain",cS = "Detector Mode",cR = "Application Version",cQ = "Exclusion Start Datetime",cX = "Large Red Palette Color Lookup Table Descriptor",cW = "Contrast/Bolus Stop Time",cV = "Trigger Time",cU = "Cardiac Synchronization Technique",da = "Overlay Description",cY = "Treatment Session Beam Sequence",Rv = "Contrast/Bolus Start Time",Ru = "Volume Frame of Reference UID",Rx = "Image Overlay Box Content Sequence",Rw = "MR Modifier Sequence",Rz = "Inversion Time",Ry = "Coding Scheme Version",RB = "DVH Data",RA = "Post Deformation Matrix Registration Sequence",RD = "Compression Step Pointers",RC = "Decay Factor",cc = "Issue Date of Imaging Service Request",cd = "Overlay Origin",ca = "Study Verified Date",cb = "Code Number Format",cg = "Overlay Bits Grouped",ch = "Dimension Organization Sequence",ce = "Tagging",cf = "Field of View Sequence",ck = "Radiopharmaceutical Start DateTime",cl = "Cardiac Cycle Position",eW = "Scheduled Step Attributes Sequence",eV = "Performed Station Name Code Sequence",eU = "Exposure Control Sensing Region Shape",eT = "Private Information Creator UID",eS = "Graphic Annotation Units",eR = "Pulse Repetition Frequency",eQ = "MAC Calculation Transfer Syntax UID",eP = "Measured Dose Description",fb = "Frame of Reference UID",fa = "Timezone Offset From UTC",hR = "Specimen Sequence",hS = "Bi-Plane Acquisition Sequence",hT = "Reconstruction Description",hU = "Recorded Channel Sequence",hV = "Image Set Label",hW = "Phase Description",hX = "Frame Numbers of Interest (FOI)",hY = "Large Green Palette Color Lookup Table Data",hP = "Show Graphic Annotation Flag",hQ = "Partial View Code Sequence",lJ = "Table Vertical Increment",lI = "Overlay Descriptor - Red",lL = "Context UID",lK = "Pupil Size",lF = "Anode Target Material",lE = "Masking Image",lH = "Comments on the Performed Procedure Step",lG = "Pixel Bandwidth",lD = "Optical Transmittance",lC = "Resulting General Purpose Performed Procedure Steps Sequence",op = "Region Flags",oq = "Flow Compensation Direction",on = "Unified Procedure Step Discontinuation Reason Code Sequence",oo = "Frame Extraction Sequence",ol = "Max Density",om = "Complex Image Component",oj = "Admitting Diagnoses Code Sequence",ok = "TM-Line Position X1",oh = "Memory Allocation",oi = "In-concatenation Number",qJ = "Diffusion b-value",qI = "Issuer of Patient ID",qH = "Source to Reference Object Distance",qG = "Image Data Type Sequence",qN = "Patient Eye Movement Commanded",qM = "Table of Pixel Values",qL = "Maximum Coordinate Value",qK = "Imaging Service Request Comments",qP = "Fluence Data Source",qO = "Event Code Sequence",tX = "Shutter Overlay Group",tY = "Breed Registration Sequence",ua = "Number of Stages",ub = "Table of X Break Points",tT = "Patient Position",tU = "Referenced Spatial Registration Sequence",tV = "SOP Instance Status",tW = "Number of Contour Points",uc = "Graphic Filled",ud = "Clinical Trial Subject ID",re = "Referenced General Purpose Scheduled Procedure Step Sequence",rd = "Patient Breed Code Sequence",rg = "View Position",rf = "Table Height",ri = "Hanging Protocol Description",rh = "Substance Administration DateTime",rk = "Overlay Descriptor - Green",rj = "Displayed Area Bottom Right Hand Corner (Trial)",rc = "X-Ray Receptor Type",rb = "Selector IS Value",us = "MR Transmit Coil Sequence",ut = "Rows For Nth Order Coefficients",uq = "Filter Material",ur = "Bits For Code Word",uw = "Pixel Shift Frame Range",ux = "Radius of Circular Collimator",uu = "Collimator Right Vertical Edge",uv = "Tomo Angle",uo = "Secondary Counts Type",up = "Data Path Assignment",Ne = "Point Position Accuracy",Nf = "Segmented Green Palette Color Lookup Table Data",Ng = "(0010,0020)",Nh = "MR Receive Coil Sequence",Ni = "Protocol Name",Nj = "Approval Status DateTime",Nk = "Modified Image Time",Nl = "Image Set Selector Category",Nc = "Command Field",Nd = "Meterset Rate Delivered",JC = "Relevant Information Sequence",JB = "Contrast Administration Profile Sequence",JA = "Transform Label",Jz = "Coding Scheme Name",Jy = "Receiving AE",Jx = "Gradient Output",Jw = "Zoom Center",Jv = "Smallest Valid Pixel Value",JE = "Operating Mode",JD = "CT Position Sequence",Gu = "Requesting Service",Gv = "Placer Order Number / Imaging Service Request (Retired)",Gs = "Scheduled Processing Parameters Sequence",Gt = "Image Position (Volume)",Gy = "Encrypted Content Transfer Syntax UID",Gz = "Filter Operations Sequence",Gw = "Overlay Compression Code",Gx = "Receive Coil Name",GC = "Presentation LUT Flag",GD = "Background Color",Dm = "Rotation Vector",Dl = "Status",Do = "Display Set Presentation Group Description",Dn = "Maximum Depth Distortion",Dq = "Overlay Rows",Dp = "Pattern On Color CIELab Value",Ds = "Selector FL Value",Dr = "Transducer Orientation",Du = "Curve Label",Dt = "ROI Observation Description",hv = "Reconstruction Diameter",hw = "Scheduled Procedure Step Start DateTime",hx = "Calculated Dose Reference Dose Value",hy = "Requested Procedure ID",hr = "Contrast/Bolus Volume",hs = "Detector Information Sequence",ht = "Shared Functional Groups Sequence",hu = "Rows",hB = "Attenuation Correction Method",hC = "RF Echo Train Length",em = "Radiation Machine Name",el = "Accession Number",ek = "Derivation Image Sequence",ej = "Data Elements Signed",eq = "Number of Graphic Points",ep = "Display Environment Spatial Position",eo = "Observation Number",en = "Time of Last Calibration",eu = "Study Arrival Time",et = "Allergies",bu = "Referenced Refractive Measurements Sequence",bv = "Acquisition Protocol Name",bs = "End Acquisition DateTime",bt = "Image Box Large Scroll Type",bq = "Image Format",br = "Offset of the Last Directory Record of the Root Directory Entity",bo = "Predictor Rows",bp = "Slice Vector",bm = "Image Path Filter Type Stack Code Sequence",bn = "Pixel Value Mapping Code Sequence",Rc = "Pixel Padding Value",Rb = "Initiator",Re = "Phase Vector",Rd = "Start Acquisition DateTime",QX = "Time of Secondary Capture",QW = "Cardiac R-R Interval Specified",Ra = "Scheduled Procedure Step Location",QY = "DIALOG Receiver",QU = "Performed Series Sequence",QT = "Contrast/Bolus Ingredient Code Sequence",nK = "General Machine Verification Sequence",nL = "Delivery Verification Image Sequence",nM = "Real World Value Intercept",nN = "Display Sets Sequence",nO = "Viewing Distance",nP = "Reformatting Operation Initial View Direction",nQ = "Nominal Respiratory Trigger Delay Time",nR = "Compound Graphic Sequence",nS = "Reason For Performed Procedure Code Sequence",nT = "Navigation Indicator Sequence",lp = "MR Timing and Related Parameters Sequence",lo = "Contour Slab Thickness",ln = "Used Fiducials Sequence",lm = "Hanging Protocol Name",ll = "Display Set Vertical Justification",lk = "Pseudo-Color Type",lj = "Transmit Coil Type",li = "Reason for Study",lh = "MIME Type of Encapsulated Document",lg = "Center of Circular Shutter",IT = "(0020,0011)",IS = "Decay Correction DateTime",IR = "Energy Window Information Sequence",IQ = "Scheduled Procedure Step End Date",IX = "Multi-Coil Element Used",IW = "Presentation Creation Time",IV = "Hardcopy Creation Device ID",IU = "Acquisition Time Synchronized",Jc = "dB/dt",Jb = "Field of View Description",MJ = "Detector Activation Offset From Exposure",MK = "Calculated Frame List",ML = "Respiratory Motion Compensation Technique",MM = "Collimator/grid Name",MF = "Field of View Horizontal Flip",MG = "Starting Respiratory Amplitude",MH = "Secondary Capture Device ID",MI = "Predictor Columns",MP = "Tick Position",MQ = "Overlay Descriptor - Gray",CW = "Blending LUT 1 Transfer Function",CV = "Fraction Status Summary Sequence",CY = "Topic Title",CX = "Exposure Control Sensing Region Left Vertical Edge",CS = "Focal Distance",CR = "Tomo Type",CU = "Positioner Primary Angle Increment",CT = "XA/XRF Frame Characteristics Sequence",CQ = "Content Label",CP = "Acquisition Start Condition Data",Gf = "R Wave Time Vector",Gg = "Channel Width",Gd = "Large Blue Palette Color Lookup Table Data",Ge = "Referenced SOP Sequence",Gb = "Blending Lookup Table Data",Gc = "Patient's Telephone Numbers",FY = "Coding Scheme Identification Sequence",Ga = "Compound Graphic Units",FW = "Study Arrival Date",FX = "Algorithm Parameters",xh = "Unified Procedure Step Communications URI Sequence",xg = "Cylinder Axis",xf = "Partial View Description",xe = "Country of Residence",xd = "Overlay Type",xc = "Acquisition Protocol Description",xb = "Parallel Acquisition",xa = "Acquisition Matrix",xl = "Input Availability Flag",xk = "Content Description",zY = "Steady State Pulse Sequence",Aa = "Convolution Kernel",Ab = "Segmented Property Category Code Sequence",Ac = "Channel Minimum Value",Ad = "Vector Coordinate Data",Ae = "CT Additional X-Ray Source Sequence",Af = "Modifying System",Ag = "Time Slot Time",zW = "Referenced ROI Number",zX = "DVH Dose Scaling",qR = "Selector UL Value",qQ = "Echo Number(s)",qT = "Single Collimation Width",qS = "Pixel Component Range Start",qV = "Data Point Rows",qU = "Double Exposure Meterset",qX = "Radiopharmaceutical Specific Activity",qW = "Detector Active Shape",ra = "Image Plane Pixel Spacing",qY = "Gantry/Detector Slew",ug = "Clinical Trial Protocol ID",uh = "Slice Sensitivity Factor",ue = "Energy Window Number",uf = "Instance Availability",uk = "Large Palette Color Lookup Table UID",ul = "Graphic Group Label",ui = "Overlay or Image Magnification",uj = "Alpha Palette Color Lookup Table Descriptor",um = "Distance Source to Entrance",un = "Fluence Data Scale",lR = "Number of Phase Encoding Steps",lQ = "Resonant Nucleus",lP = "Image Data Location",lO = "RT Image SID",lV = "PET Table Dynamics Sequence",lU = "Modifying Device Manufacturer",lT = "Physician(s) of Record Identification Sequence",lS = "Product Parameter Sequence",lN = "Fraction Group Summary Sequence",lM = "Number of Channels",ox = "Frame Primary Angle Vector",oy = "Rotation Offset",oz = "Specified Number of Pulses",oA = "Echo Train Length",ot = "Adaptive Map Format",ou = "Image Box Number",ov = "Detector Active Dimension(s)",ow = "Overlay Code Label",or = "Unified Procedure Step Performed Procedure Sequence",os = "Spacing Between Slices",uW = "Radionuclide",uX = "Referenced File ID",uU = "Image Orientation",uV = "Requested Resolution ID",vb = "Anatomic Region Modifier Sequence",vc = "Modality LUT Sequence",uY = "Optotype Detailed Definition",va = "Hanging Protocol User Group Name",uS = "Patient Gantry Relationship Code Sequence",uT = "Interpretation Recorded Time",rI = "Referenced Interpretation Sequence",rH = "Referenced Presentation State Sequence",rK = "DVH Normalization Dose Value",rJ = "Ultrasound Acquisition Geometry",rM = "Curve Time",rL = "Current Treatment Status",rO = "RT Related ROI Sequence",rN = "Video Image Format Acquired",rG = "Number of Series Related Instances",rF = "Event Elapsed Time(s)",AO = "Transducer Scan Pattern Code Sequence",AP = "Deletion Lock",AQ = "Expected Completion Date Time",AR = "Referenced Overlay Plane Groups",AS = "RT Dose ROI Sequence",AT = "Subscription List Status",AU = "Planes",AV = "Time Source",AW = "Media Disposition",AX = "Object Thickness Sequence",xJ = "Column Overlap",xI = "Nominal Screen Definition Sequence",xH = "Pixel Shift Sequence",xG = "Selector Code Sequence Value",xF = "Referenced Series Sequence",xE = "Consent for Distribution Flag",xD = "Collimator Shape Sequence",xC = "Major Ticks Sequence",xB = "Number of Failed Sub-operations",xA = "Frequency Correction",GK = "Failed Attributes Sequence",GL = "Studies Containing Other Referenced Instances Sequence",GI = "LUT Number",GJ = "Scan Options",GG = "Calcium Scoring Mass Factor Device",GH = "Filter Beam Path Length Minimum",GE = "Visual Acuity Type Code Sequence",GF = "SOP Authorization Comment",GM = "Gated Information Sequence",GN = "Recommended Viewing Mode",DT = "Originator",DS = "Impressions",DV = "Selector UT Value",DU = "Sequence of Ultrasound Regions",DP = "Position Reference Indicator",DO = "Patient's Birth Name",DR = "Patient Breed Description",DQ = "Performed Procedure Type Description",DX = "Chemical Shift Maximum Integration Limit in ppm",DW = "MR Image Frame Type Sequence",Nu = "Event Timer Name(s)",Nv = "Referenced Raw Data Sequence",Nw = "Contributing Sources Sequence",Nx = "VOI Type",Nq = "Graphic Layer",Nr = "Gantry Motion Corrected",Ns = "Projection Pixel Calibration Sequence",Nt = "Depth of Scan Field",No = "Parallel Reduction Factor In-plane (Retired)",Np = "Other Study Numbers",JK = "Min Density",JJ = "First Treatment Date",JI = "Series Number",JH = "Counts Source",JO = "Device Description",JN = "Frame Time",JM = "Along-scan Spatial Resolution",JL = "Sort-by Category",JG = "Calcium Scoring Mass Factor Patient",JF = "Study Date",bL = "Referenced SOP Class UID",bM = "Sensitivity Calibrated",hD = "Scheduled Study Start Time",hE = "Requested Image Size",bP = "Scheduled Procedure Step Description",bQ = "Coding Scheme External ID",bN = "Audio Sample Data",bO = "Pixel Padding Range Limit",ij = "LUT Function",im = "Curve Range",Rl = "Reprojection Method",Rk = "Response Sequence Number",Rn = "Requested Procedure Code Sequence",Rm = "Treatment Control Point Time",Rp = "ROI Contour Sequence",Ro = "Depth Spatial Resolution",Rr = "Move Originator Message ID",Rq = "Curve Number",Rt = "MR Acquisition Phase Encoding Steps in-plane",Rs = "Contrast Flow Rate",rq = "Reference Pixel X0",rp = "Red Palette Color Lookup Table Data",rs = "Clinical Trial Protocol Ethics Committee Name",rr = "LUT Label",rm = "Coefficient Coding",rl = "Pixel Aspect Ratio",ro = "Audio Comments",rn = "Modality",ru = "Radiopharmaceutical Route",rt = "General Purpose Performed Procedure Step Status",uE = "SOP Authorization DateTime",uF = "Display Filter Percentage",uC = "Image to Equipment Mapping Matrix",uD = "MR Acquisition Phase Encoding Steps out-of-plane",uA = "Reason for the Attribute Modification",uB = "Overlay Background Density",uy = "Minimum Coordinate Value",uz = "DVH Maximum Dose",uG = "Dimension Organization UID",uH = "Normal/Reverse",xr = "Modified Image ID",xq = "Results ID Issuer",xp = "Surface Number",xo = "Shadow Offset Y",xv = "Algorithm Version",xu = "Total Time of Fluoroscopy",xt = "Scan Length",xs = "Overlay Pixel Data Sequence",xn = "Number of Study Related Series",xm = "Multiplex Group Time Offset",AF = "Source Hanging Protocol Sequence",AG = "High Bit",AH = "Attenuation Correction Source",AI = "Allow Media Splitting",AB = "View Modifier Code Sequence",AC = "Referenced Patient Sequence",AD = "Variable Coefficients SDHN",AE = "Transducer Position",Ay = "Referenced Measured Dose Reference Sequence",Az = "Interpretation Recorded Date",ff = "Object Pixel Spacing in Center of Beam",fe = "Contrast/Bolus Agent Detected",fh = "Transaction UID",fg = "Assigning Jurisdiction Code Sequence",fj = "Waveform Bits Allocated",fi = "Rescale Slope",fl = "Operating Mode Type",fk = "Patient's Primary Language Modifier Code Sequence",fd = "MR Velocity Encoding Sequence",fc = "Hardcopy Device Manufacturer",iv = "Graphic Dimensions",iw = "3D Rendering Type",it = "Radiopharmaceutical Stop DateTime",iu = "PET Reconstruction Sequence",iz = "Data Representation",iA = "Temporal Position Identifier",ix = "Product Name",iy = "Angular Step",ir = "Plate Type",is = "Segmented Red Palette Color Lookup Table Data",mr = "Field of View Shape",mq = "Subjective Refraction Left Eye Sequence",mp = "Actual Respiratory Trigger Delay Time",mo = "Mydriatic Agent Sequence",mn = "View Name",mm = "Referenced First Frame Sequence",ml = "Admitting Time",mk = "Performed Protocol Type",mj = "MR Spectroscopy Frame Type Sequence",mi = "Performed Procedure Step ID",oD = "Display Set Scrolling Group",oE = "Metabolite Map Code Sequence",oF = "Parameter Sequence Pointer",oG = "X Focus Center",oH = "LUT Descriptor",oI = "Attenuation Correction Temporal Relationship",oJ = "Tag Spacing Second Dimension",oK = "Study Component Status ID",oL = "Add Power",oM = "Number of Transform Steps",QP = "Admitting Date",QO = "Anatomic Approach Direction Code Sequence (Trial)",QR = "Chemical Shift Reference",QQ = "Displayed Area Bottom Right Hand Corner",EH = "Referenced Frame of Reference UID",EG = "Reformatting Operation Type",QN = "Presentation Creation Date",QM = "RT Image Position",Ev = "Tick Label",Eu = "Generator Power",bk = "Intervention Drug Code Sequence",bl = "Referenced Non-Image Composite SOP Instance Sequence",fy = "Frame of Interest Description",fz = "Find Location",bg = "Normalization Point",bh = "Respiratory Synchronization Sequence",be = "Referenced SOP Instance UID in File",bf = "Audio Sample Format",fm = "Laterality",fn = "k-space Filtering",LM = "Issue Time of Imaging Service Request",pB = "MAC",LP = "Preferred Playback Sequencing",LQ = "Multi-Coil Definition Sequence",pm = "Reconstruction Target Center (Patient)",Lv = "Unified Procedure Step List Status",pp = "Person's Address",pq = "Issuer of Accession Number Sequence",of = "Axis Units",og = "Volume to Transducer Mapping Matrix",sU = "Specimen Description - Trial",sT = "Pause Between Frames",sS = "Diffusion Gradient Orientation",sR = "Region of Residence",te = "Breed Registry Code Sequence",sX = "Radius of Curvature",sW = "Referenced Print Job Sequence (Pull Stored Print)",sV = "Film Consumption Sequence",lB = "Intervention Drug Information Sequence",lA = "Shadow Color CIELab Value",ih = "Frame Pixel Shift Sequence",ii = "Columns",ie = "Radial Position",ig = "Zonal Map Number Format",ic = "Diffusion Gradient Direction Sequence",id = "Acquisition Termination Condition",ia = "Unified Procedure Step Progress Information Sequence",ib = "Actual Human Performers Sequence",ik = "Number of Vertical Pixels",il = "Frame Pixel Data Properties Sequence",AL = "Light Path Filter Type Stack Code Sequence",AK = "Dimension Index Pointer",AN = "Cylinder Power",AM = "Selector DS Value",AA = "Postprocessing Function",Ax = "Randoms Corrected",AJ = "Isocenter Reference System Sequence",Bg = "Error ID",eY = "Issuer of Patient ID Qualifiers Sequence",eX = "Ion Control Point Delivery Sequence",io = "Lens Segment Type",ip = "Contributing SOP Instances Reference Sequence",iq = "Segment Number",DB = "Shift Table Size",DM = "Edge Point Index List",DY = "Type of Data",iB = "Exposure Control Sensing Region Upper Horizontal Edge",iC = "Surface Processing",ci = "Add Other Sequence",cj = "Series Type",RJ = "Confidentiality Constraint on Patient Data Description",RI = "Breed Registration Number",RH = "Requesting AE",RG = "Directory Record Sequence",RF = "Stage Number",RE = "Diffusion b-matrix Sequence",Hv = "Record In-use Flag",Hu = "TM-Line Position Y1",Hr = "Specimen Description Sequence",Ho = "Study ID",NC = "Termination Cardiac Trigger Count Threshold",ND = "Frame Acquisition Duration",NA = "Transducer Type",NB = "Reformatting Thickness",NG = "Low R-R Value",NH = "Patient's Sex Neutered",NE = "Assigning Facility Sequence",NF = "Start Relative Density Difference Threshold",Ny = "Image Location",Nz = "Y Focus Center",JS = "Patient's Mother's Birth Name",JR = "Referenced Image Evidence Sequence",JU = "Results Comments",JT = "Unified Procedure Step Progress",JW = "Mechanical Index",JV = "Reference Pixel Y0",JY = "Horizontal Alignment",JX = "Bulk Motion Compensation Technique",JQ = "Angular View Vector",JP = "Identifier Type Code",Mt = "Content Time",Mu = "Surface Points Normals Sequence",Mv = "Nominal Interval",Mw = "Calculated Dose Reference Sequence",Mp = "Image Sets Sequence",Mq = "Selector AT Value",jS = "Shadow Offset X",jT = "Pattern On Opacity",kt = "Selector CS Value",ku = "Arbitrary",Ih = "Type of Filters",Ig = "Overlay Code Table Location",If = "Acquisition Number",Ie = "Variable Coefficients SDDN",Gh = "Blending Weight Constant",Iu = "Printer Pixel Spacing",FJ = "NTP Source Address",Fy = "X-Ray Tube Current in mA",IM = "Scheduled Study Stop Date",IL = "Geometry of k-Space Traversal",lc = "Curve Referenced Overlay Group",lb = "Font Name",la = "Parameter Pointer",kY = "Applicable Frame Range",kX = "ROI Generation Algorithm",kW = "Time Slot Number",kV = "Grid Aspect Ratio",kU = "Container Type Code Sequence",lf = "Stereo Vertical Pixel Offset",le = "Right Lens Sequence",g = "Rotation Direction",Fd = "Attribute Occurrence Sequence",IN = "Radiopharmaceutical Information Sequence",Dk = "Contrast Frame Averaging",Ja = "Table Position",Jd = "Type of Synchronization",Je = "Application Name",Jf = "Selector Attribute",nx = "Number of Subsets",ny = "Distance Source to Support",xL = "Zonal Map Location",xK = "Stereo Rotation",xP = "RT Image Label",xM = "Vertices of the Polygonal Exposure Control Sensing Region",xX = "Anatomic Structure, Space or Region Sequence",xR = "Segment Sequence",ya = "Delivered Secondary Meterset",xY = "Signal Domain Columns",es = "Acquisition Date",er = "Exposure Control Mode",RT = "Specimen UID",RW = "Font Name Type",RK = "Default Printer Resolution ID",RN = "Specimen Description Sequence - Trial",Sb = "Radiation Machine SSD",Sc = "Pixel Intensity Relationship Sign",RY = "Respiratory Cycle Position",Sa = "Rescale Type",hz = "Start Meterset",hA = "Container Component Thickness",wo = "Referenced Overlay Sequence",wn = "Referenced Curve Sequence",wm = "Image Frame Origin",wl = "Presentation LUT Sequence",ws = "Conversion Type",wr = "LUT Frame Range",wq = "Start Density Threshold",wp = "Slice Location",wu = "Frame Increment Pointer",wt = "Overlay Data",zm = "Radionuclide Half Life",zn = "Radiopharmaceutical Code Sequence",zo = "Issuer of Service Episode ID",zp = "Pattern Off Color CIELab Value",zi = "Overlay Bits For Code Word",zj = "Image Position (Patient)",zk = "Content Item Modifier Sequence",vz = "Type of Patient ID",zr = "Image Path Filter Pass Band",zs = "Multi-planar Excitation",qk = "Spherical Lens Power",qj = "Tomo Class",qm = "Left Image Sequence",ql = "Fiducial Identifier Code Sequence",PA = "Pixel Component Mask",Pz = "Curve Activation Layer",qi = "RT Image Description",qh = "File Meta Information Group Length",jV = "Number of Samples",jU = "Number of Time Slots",th = "Randoms Correction Method",ti = "Energy Window Total Width",tf = "Iterative Reconstruction Method",tg = "Secondary Capture Device Manufacturer",td = "Line Pattern",Ci = "Number of Warning Sub-operations",tb = "Primary Fluence Mode Sequence",tc = "Image Box Scroll Direction",sY = "Vertical Prism Power",ta = "Referring Physician Identification Sequence",DA = "ROI Standard Deviation",Dz = "Exposure in µAs",Dy = "Rescale Intercept",Dx = "Recorded Source Applicator Sequence",Dw = "Source of Previous Values",Dv = "Image Horizontal Flip",bA = "R - R Interval Time Nominal",Jg = "Person Identification Code Sequence",bx = "Performed Procedure Step Status",bw = "Table Horizontal Rotation Angle",tj = "Overlay Mode",tk = "Execution Status",tl = "Image Orientation (Patient)",iW = "Original Attributes Sequence",tu = "Blue Palette Color Lookup Table Descriptor",tx = "Bounding Box Text Horizontal Justification",tA = "Collimator Type",mE = "Include Display Application",GA = "Physician(s) Reading Study Identification Sequence",GB = "Structure Set Name",OV = "Number of Tomosynthesis Source Images",Pa = "Stereo Baseline Displacement",OS = "Segmentation Fractional Type",OT = "Graphic Group ID",gO = "Gantry ID",gP = "Color Image Printing Flag",gM = "View Number",gN = "Transform Version Number",Nm = "Device Length",Nn = "Data Type",dL = "Procedure Step Label",dK = "CT X-Ray Details Sequence",dN = "Skip Beats",dM = "Content Creator's Name",dH = "Slice Location Vector",dG = "Collimator Shape",vD = "Green Palette Color Lookup Table Descriptor",vC = "Code Label",vB = "Synchronized Image Box List",vA = "Text Object Sequence",nq = "Graphic Coordinates Data Sequence",nr = "Count Loss Normalization Corrected",ns = "Intervals Rejected",nt = "Anatomical Orientation Type",nm = "Variable Pixel Data",nn = "Normalization Factor Format",no = "Visit Status ID",np = "Implementation Class UID",nu = "Content Creator's Identification Code Sequence",nv = "Scheduled Procedure Step Modification Date Time",pd = "Organ Exposed",pa = "Requested Procedure Description",oY = "Manufacturer",oX = "Reflected Ambient Light",pn = "Exposed Area",BS = "Image Set Selector Sequence",pl = "Chemical Shift Maximum Integration Limit in Hz",pf = "Label Using Information Extracted From Instances",kq = "Text String",kp = "Revolution Time",hf = "Decay Corrected",kR = "Frame Acquisition Number",kF = "Offset of the First Directory Record of the Root Directory Entity",kI = "Image Geometry Type",mh = "Row Overlap",ld = "Request Priority",kS = "Fiducial Identifier",kT = "Scheduled Study Location AE Title",MN = "MR Diffusion Sequence",MO = "Interpretation Diagnosis Description",Jh = "Time Distribution Protocol",nz = "Time Slot Vector",sQ = "RT ROI Observations Sequence",Ji = "Receive Coil Type",oC = "Volumetric Properties",oB = "Table Lateral Increment",Ju = "MRDR Directory Record Offset",Jt = "Barcode Value",po = "Number of Iterations",IY = "VOI LUT Sequence",db = "Scheduled Station Name",dc = "Tag Spacing First Dimension",D = "Synchronized Scrolling Sequence",E = "Specified Primary Meterset",F = "Request Attributes Sequence",G = "Line Style Sequence",H = "Series Date",I = "Certified Timestamp Type",J = "Clinical Trial Subject Reading ID",U = "Manifold",Qp = "Reason for the Imaging Service Request",Qo = "Fraction Group Type",Qn = "Coordinate Start Value",Qm = "Human Performer's Organization",Ql = "Image Comments",Qk = "Counts Accumulated",Qj = "Inversion Times",Qi = "Event Time Offset",Qr = "Device Sequence",Qq = "Detector Active Time",An = "Performed Processing Parameters Sequence",Ao = "Treatment Status Comment",yw = "Image Type",yx = "DVH Number of Bins",Aj = "Scheduled Procedure Step Priority",Ak = "Execution Status Info",Ah = "Compression Sequence",Ai = "In-plane Phase Encoding Direction",yI = "Navigation Display Set",yJ = "Positioner Secondary Angle",fW = "Context Group Local Version",fQ = "Acquisition Context Description",fY = "Referenced Performed Procedure Step Sequence",fX = "Admission ID",fL = "First Order Phase Correction",fK = "Overlay Columns",fO = "Phase Contrast",fM = "Source Image IDs",xj = "(0008,0030)",xi = "Consent for Clinical Trial Use Sequence",Kx = "Rotation Point",Kw = "Transducer Position Sequence",Kz = "Device Diameter Units",Ky = "Shutter Right Vertical Edge",KB = "Intervention Drug Dose",KA = "Number of Energy Windows",KD = "Flow Compensation",KC = "Number of R-R Intervals",Kv = "Dimension Description Label",Ku = "Number of Completed Sub-operations",Ol = "Sequence Name",Om = "Columns For Nth Order Coefficients",Oj = "Universal Entity ID",Ok = "Image Position",Op = "Error Comment",Oq = "Acquisition Device Processing Code",On = "CT Reconstruction Sequence",Oo = "Sorting Direction",Oh = "Imaging Frequency",Oi = "Coordinate Step Value",Sn = "Phase Information Sequence",Sm = "Keratometry Right Eye Sequence",Sl = "Application Setup Check",Sk = "Requesting Physician",Sj = "MR Averages Sequence",Si = "Steering Angle",Sh = "Instance Creation Time",Sg = "Distance Source to Data Collection Center",Sf = "Configuration Information Description",Se = "Performed Processing Applications Code Sequence",cw = "Topic Author",cx = "Region Data Type",cy = "Number of Frames in Rotation",cz = "Study ID Issuer",cA = "Calculated Dose Reference Number",cB = "Study Completion Date",cC = "Intervention Drug Stop Time",cD = "Referenced Measured Dose Reference Number",cE = "Alpha Palette Color Lookup Table Data",cF = "Nominal Cardiac Trigger Delay Time",ft = "Receive Coil Manufacturer Name",fs = "Velocity Encoding Maximum Value",fv = "Safe Position Exit Time",fu = "Algorithm Name",fp = "CT Acquisition Details Sequence",fo = "Table of Y Break Points",fr = "Failure Reason",fq = "Treatment Session Ion Beam Sequence",fx = "Ending Respiratory Amplitude",fw = "Projection Eponymous Name Code Sequence",iJ = "Image Trigger Delay",iK = "Contour Image Sequence",iH = "Time Range",iI = "Huffman Table Triplet",iF = "Selector Attribute VR",iG = "Anchor Point Visibility",iD = "Comments on the Scheduled Procedure Step",iE = "Referring Physician's Name",iL = "Subtraction Item ID",iM = "Attenuation Corrected",mx = "Bounding Box Bottom Right Hand Corner",mw = "First Order Phase Correction Angle",mv = "Grid",mu = "X-Ray Tube Current",mB = "IVUS Acquisition",mA = "Responsible Organization",mz = "Creator-Version UID",my = "Therapy Description",mt = "Most Recent Treatment Date",ms = "Measuring Units Sequence",oT = "Mask Subtraction Sequence",oU = "Medical Alerts",oV = "Offset of the Next Directory Record",oW = "Reason for Cancellation",oP = "Tomo Time",oQ = "Pertinent Documents Sequence",oR = "Empty Image Box CIELab Value",oS = "Signal Domain Rows",oN = "Contour Number",oO = "Container Component Type Code Sequence",rw = "Instance Creator UID",rv = "Keratometric Axis",ry = "Graphic Layer Description",rx = "Recommended Display Frame Rate",rA = "Billing Item Sequence",rz = "Intensifier Active Dimension(s)",rC = "Private Record UID",rB = "Specific Character Set",rE = "SOP Class UID",rD = "Soft Tissue-surface Thermal Index",uK = "Specimen Localization Content Item Sequence",uL = "Curve Data",uI = "Coding Scheme Registry",uJ = "Instance Number",uO = "Detector Element Size",uP = "Bits Mapped to Color Lookup Table",uM = "Scheduled Station AE Title",uN = "Nuclear Medicine Series Type",uQ = "Largest Image Pixel Value in Plane",uR = "Results ID",GO = "Clinical Trial Site Name",GP = "Respiratory Signal Source",GQ = "Unformatted Text Value",GR = "Syringe Counts",GS = "Table Speed",GT = "Substance Administration Device ID",GU = "Transducer Frequency",GV = "Non-DICOM Output Code Sequence",GW = "Estimated Radiographic Magnification Factor",GX = "Primary Positioner Scan Start Angle",Ej = "Institution Code Sequence",Ei = "Tag Angle First Axis",Eh = "Organ Dose",Eg = "Image Presentation Comments",Ef = "Scheduled Procedure Step Start Time",Ee = "Service Episode Description",Ed = "Study Time",Ec = "Dimension Index Sequence",Eb = "Content Date",Ea = "Window Center &amp; Width Explanation",Bd = "Displayed Area Top Left Hand Corner",Be = "Number of Tables",Bb = "Mask Frame Numbers",Bc = "Keratometry Left Eye Sequence",Bh = "Order Filler Identifier Sequence",Bi = "Route of Admissions",Bf = "Beam Task Type",DN = "Referenced Image Box Sequence (Retired)",AY = "Respiratory Motion Compensation Technique Description",Ba = "Dose Units",mC = "Large Green Palette Color Lookup Table Descriptor",xQ = "Dimension Index Private Creator",xT = "Control Point Delivery Sequence",xS = "Overlay Compression Label",xV = "Selector Sequence Pointer",xU = "Beam Order Index",mD = "Fluence Map Sequence",xW = "Printer Characteristics Sequence",xO = "Referenced Treatment Record Sequence",xN = "Image Laterality",cs = "DVH Volume Units",ct = "Frame Detector Parameters Sequence",cu = "Performed Procedure Step Discontinuation Reason Code Sequence",cv = "Energy Window Centerline",co = "Vertical Prism Base",cp = "Maximum Collated Films",cq = "Displayed Area Top Left Hand Corner (Trial)",cr = "Blood Signal Nulling",cm = "Optotype",cn = "Overlays - Red",RR = "Fraction Number",RQ = "Patient's Birth Time",RP = "Content Qualification",RO = "DCT Label",RV = "Device UID",RU = "Graphic Group Description",HG = "View Code Sequence",RS = "Coefficient Coding Pointers",RM = "Show Acquisition Techniques Flag",RL = "Block Rows",NO = "Annotation Content Sequence",NP = "Patient's Name",NM = "Temporal Resolution",NN = "Number of Table Break Points",NK = "Specimen Preparation Step Content Item Sequence",NL = "Angio Flag",NI = "Operator Identification Sequence",NJ = "Number of Copies",NQ = "Patient Orientation",NR = "Patient's Primary Language Code Sequence",Kf = "Physician(s) of Record",Ke = "Histogram First Bin Value",Kh = "Surface Comments",Kg = "Patient Physiological State Code Sequence",Kb = "Graphic Layer Recommended Display CIELab Value",Ka = "Clinical Trial Time Point Description",Kd = "Parallel Acquisition Technique",Kc = "Study Description",Kj = "End Message ID",Ki = "Table Cradle Tilt Angle",pe = "Blocked Pixels",RX = "Distribution Name",pg = "Exposure in mAs",ph = "Bounding Box Annotation Units",pi = "Mask Pointer(s)",pj = "MR Spectroscopy FOV/Geometry Sequence",pk = "Encrypted Content",Sd = "Anatomic Location Of Examining Instrument Code Sequence (Trial)",pb = "CT Image Frame Type Sequence",pc = "Actual Cardiac Trigger Delay Time",me = "Selector Attribute Private Creator",md = "Respiratory Interval Time",mc = "SCP Status",mb = "Magnetic Field Strength",ma = "Graphic Type",lY = "Contour Uncertainty Radius",lX = "Attribute Identifier List",lW = "Body Part Examined",mg = "Entrance Dose in mGy",mf = "Reference",Bu = "Encapsulated Document",Bv = "Contrast/Bolus Ingredient Opaque",Bw = "Rotation Angle",Bx = "Velocity Encoding Minimum Value",By = "Input Information Sequence",Bz = "Image Box Synchronization Sequence",BA = "Filter-by Category",BB = "Frame Display Sequence",BC = "Related Reference RT Image Sequence",BD = "Secondary Positioner Scan Arc",yu = "Copies",yt = "Other Patient Names",ys = "Line Thickness",yr = "Segmented Blue Palette Color Lookup Table Data",yq = "Soft Tissue-focus Thermal Index",yp = "Spectroscopy Acquisition Phase Columns",yo = "Waveform Sequence",yn = "Frame Anatomy Sequence",ym = "Order Callback Phone Number",yl = "Diffusion b-value XZ",vs = "Performed Station AE Title",vt = "Exclusion Duration",vq = "Number of References",vr = "Segment Algorithm Name",vw = "Grid Dimensions",vx = "Show Tick Label",vu = "Number of Triggers in Phase",vv = "SOP Instance UID",vo = "Right Image Sequence",vp = "Heart Rate",sd = "Overlay Smoothing Type",sc = "Smallest Pixel Value in Series",sf = "Detector Secondary Angle",se = "Transducer Orientation Modifier Sequence",sh = "Source Instance Sequence",sg = "Exposure Time",sj = "Text Color CIELab Value",si = "Document Title",sb = "Quantity Sequence",sa = "Reference Display Sets",Pb = "Flat Keratometric Axis Sequence",Pc = "Print Job ID",Pd = "Output Information Sequence",Pe = "Performed Procedure Step Description",OW = "Cardiac Beat Rejection Technique",OX = "Number of Matches",OY = "Partial Data Display Handling",vy = "Tagging Delay",OU = "Positioner Position Sequence",vn = "Clinical Trial Sponsor Name",Le = "Decay Correction",Ld = "Interpretation Approver Sequence",Lc = "Plate ID",Lb = "Histogram Bin Width",Li = "Display Set Presentation Group",Lh = "Deviation Index",Lg = "Exposure Status",Lf = "Grid Pitch",La = "Number of Horizontal Pixels",KY = "Axial Acceptance",Hp = "MR Spectroscopy Acquisition Type",Hq = "Echo Time",Hn = "Cassette ID",yv = "Device Serial Number",Hl = "Override Parameter Pointer",Hm = "Ultrasound Color Data Present",Hj = "Referenced Transfer Syntax UID in File",Hk = "Image Box Small Scroll Type",Hs = "ROI Name",Ht = "Palette Color Lookup Table UID",EB = "Blending Sequence",EA = "Requested Contrast Agent",ED = "Cardiac Framing Type",EC = "Substance Administration Approval",Ex = "Printer Resolution ID",Ew = "Polarity",Ez = "TM-Line Position Y1 (Retired)",Ey = "Performed Station Geographic Location Code Sequence",EF = "Generator ID",EE = "Magnetization Transfer",iP = "Detector Normalization Correction",iQ = "Apex Position",iR = "Shutter Presentation Value",iS = "Temporal Position Index",iT = "Lossy Image Compression (Retired)",iU = "IVUS Pullback Start Frame Number",iV = "Signature",hq = "Respiratory Trigger Delay Threshold",iN = "Anchor Point Annotation Units",iO = "Deformable Registration Grid Sequence",fH = "Radiation Setting",fG = "Order Enterer's Location",fF = "Certificate of Signer",fE = "Mid Slab Position",fD = "Referenced VOI LUT Box Sequence",fC = "Frame Content Sequence",fB = "Filter-by Attribute Presence",fA = "Tick Label Alignment",fJ = "Event Timer Sequence",fI = "Positioner Secondary Angle Increment",EL = "Overlay Compression Originator",EK = "Grid Thickness",EN = "Basic Color Image Sequence",EM = "ROI Number",EP = "Double Exposure Flag",EO = "File-set ID",ER = "Termination Relative Density Threshold",EQ = "Service Episode ID",EJ = "Film Destination",EI = "Time Domain Filtering",HA = "Derivation Description",HB = "Referenced Image Sequence",Hy = "Pulse Sequence Name",Hz = "Modality LUT Type",HE = "Image Overlay Flag",HF = "Surface Sequence",HC = "Partial View",HD = "T2 Preparation",Hw = "Stereo Pairs Sequence",Hx = "Unspecified Laterality Lens Sequence",KN = "Display Set Horizontal Justification",KM = "Detector Type",KL = "Termination Respiratory Trigger Count Threshold",KK = "Waveform Data",KJ = "Structure Set Description",KI = "Pixel Representation",KH = "Referenced Other Plane Sequence",KG = "Requested Procedure Location",KF = "File-set Consistency Flag",KE = "LUT Data",Ox = "Deformable Registration Sequence",Oy = "Secondary Positioner Scan Start Angle",Oz = "Flip Angle",OA = "Detector Element Spacing",OB = "Certificate Type",Bt = "Frame Comments",OD = "Respiratory Trigger Type",OE = "Selector LT Value",OF = "Worklist Label",OG = "Specified Channel Total Time",St = "Calibration Data Sequence",Ss = "Clinical Trial Series ID",Sv = "Page Number Vector",Su = "Ophthalmic Image Orientation",Sp = "Specimen Identifier",So = "General Purpose Scheduled Procedure Step Priority",Sr = "Blending Position",Sq = "Compound Graphic Type",Sx = "Referenced Patient Alias Sequence",Sw = "File Meta Information Version",cM = "Other Patient IDs Sequence",cN = "Digitizing Device Transport Direction",cK = "Compression Label",cL = "Images in Series",cI = "Samples per Pixel Used",cJ = "Device Volume",cG = "Referenced Procedure Step Sequence",cH = "Cardiac Synchronization Sequence",cO = "Rotation Information Sequence",cP = "Universal Entity ID Type",fS = "Reconstruction Method",fR = "Physical Units X Direction",Id = "Show Grayscale Inverted",fP = "Scanning Sequence",nw = "Reference to Recorded Sound",fV = "Scatter Corrected",fU = "Positioner Motion",fT = "Original Image Identification",HR = "Filter-by Operator",fN = "Diffusion b-value XY",je = "Certified Timestamp",jf = "Image Box Overlap Priority",jg = "LUT Explanation",jh = "Horizontal Prism Power",ja = "Patient Physiological State Sequence",jb = "Pre-Medication",jc = "Overlay Label",jd = "Center of Circular Collimator",iX = "Equipment Coordinate System Identification",iY = "Item Number",mH = "Contrast/Bolus Agent Administered",mG = "Sphere Power",mJ = "Frame Laterality",mI = "Clinical Trial Protocol Ethics Committee Approval Number",mL = "Scheduled Human Performers Sequence",mK = "RT Referenced Series Sequence",mN = "Software Version(s)",mM = "Scheduled Procedure Step End Time",mP = "Echo Planar Pulse Sequence",mO = "Mydriatic Agent Concentration Units Sequence",pt = "Zonal Map Format",pu = "Real World Value Mapping Sequence",pr = "Patient Transport Arrangements",ps = "Overlay Bits Allocated",px = "Bits Stored",py = "Detector Primary Angle",pv = "Geometrical Properties",pw = "Time Slot Information Sequence",pz = "Multi-Coil Element Name",pA = "Reconstruction Field of View",vf = "Green Palette Color Lookup Table Data",vg = "Exposure Control Sensing Region Lower Horizontal Edge",vd = "Across-scan Spatial Resolution",ve = "Table Traverse",vj = "Anatomic Portal Of Entrance Code Sequence (Trial)",vk = "Selector Sequence Pointer Private Creator",vh = "Chemical Shift Sequence",vi = "Referenced Film Box Sequence",vl = "Number of Films",vm = "Cylinder Lens Power",rQ = "Directory Record Type",rP = "Visit Comments",rS = "Region Spatial Format",rR = "Rectilinear Phase Encode Reordering",rU = "Percent Sampling",rT = "Grid Absorbing Material",rW = "Conventional Machine Verification Sequence",rV = "Image Set Number",rY = "Diaphragm Position",rX = "Axial Detector Dimension",Bl = "Presentation Intent Type",Bm = "Start Trim",Bn = "Grid Period",Bo = "Overlay Repeat Interval",Bp = "Contrast/Bolus Usage Sequence",Bq = "Angle Number",Br = "Referenced Presentation LUT Sequence",Bs = "Red Palette Color Lookup Table Descriptor",Bj = "Study Verified Time",Bk = "Presentation LUT Content Sequence",yi = "Fill Style Sequence",yh = "Intervention Sequence",yg = "Actual Frame Duration",yf = "Performed Procedure Step Start Date",ye = "Cumulative Dose to Dose Reference",yd = "DVH Normalization Point",yc = "Diameter of Visibility",yb = "Registration Sequence",yk = "Segment Label",yj = "Table X Position to Isocenter",Hh = "Threshold Density",Hi = "Coding Scheme Designator",Hf = "Number of Phases",Hg = "Referenced Results Sequence",Hd = "Gray Lookup Table Data",He = "Physical Units Y Direction",Hb = "Predictor Constants",Hc = "Distance Source to Patient",GY = "Source Image Sequence",Ha = "Contrast/Bolus Administration Route Sequence",Er = "Stop Trim",Eq = "Data Collection Diameter",Et = "Referenced Calculated Dose Reference Sequence",Es = "Encrypted Attributes Sequence",En = "Administration Route Code Sequence",Em = "Parallel Reduction Factor out-of-plane",Ep = "Referenced Fraction Number",Eo = "Manufacturer's Model Name",El = "Huffman Table Size",Ek = "Add Gray Scale",NW = "Whole Body Technique",NX = "Referenced SOP Instance UID",NY = "Delivered Channel Total Time",Oa = "Illumination Power",NS = "Discharge Diagnosis Description",NT = "Irradiation Event Identification Sequence",NU = "IVUS Gated Rate",NV = "Patient's Weight",Ob = "Referenced Image Overlay Box Sequence",Oc = "Intervention Status",Kn = "Issuer of the Container Identifier Sequence",Km = "Matrix Registration Sequence",Kl = "Radius of Circular Exposure Control Sensing Region",Kk = "Diffusion Directionality",Kr = "Parameter Item Index",Kq = "IVUS Pullback Rate",Kp = "Patient's Institution Residence",Ko = "Maximum Point Distance",Kt = "Trigger Window",Ks = "Water Referenced Phase Correction",Of = "Length to End",Og = "Recognition Code",Od = "Magnification Type",Oe = "Data Set Type";
  /**
   * Master list of DICOM tags taken from dcm4che
   */
  qx.Class.define(Ap, {
    type : dU,
    statics : {
      /**
       * The DICOM Tags
       */
      tags : {
        "(0000,0000)" : wQ,
        "(0000,0001)" : Of,
        "(0000,0002)" : Db,
        "(0000,0003)" : sN,
        "(0000,0010)" : Og,
        "(0000,0100)" : Nc,
        "(0000,0110)" : FQ,
        "(0000,0120)" : nD,
        "(0000,0200)" : Rb,
        "(0000,0300)" : Lk,
        "(0000,0400)" : fz,
        "(0000,0600)" : lx,
        "(0000,0700)" : t,
        "(0000,0800)" : Oe,
        "(0000,0850)" : OX,
        "(0000,0860)" : Rk,
        "(0000,0900)" : Dl,
        "(0000,0901)" : nC,
        "(0000,0902)" : Op,
        "(0000,0903)" : Bg,
        "(0000,1000)" : xy,
        "(0000,1001)" : sA,
        "(0000,1002)" : eJ,
        "(0000,1005)" : lX,
        "(0000,1008)" : jI,
        "(0000,1020)" : HW,
        "(0000,1021)" : Ku,
        "(0000,1022)" : xB,
        "(0000,1023)" : Ci,
        "(0000,1030)" : LC,
        "(0000,1031)" : Rr,
        "(0000,4000)" : QY,
        "(0000,4010)" : Lt,
        "(0000,5010)" : he,
        "(0000,5020)" : Kj,
        "(0000,5110)" : dV,
        "(0000,5120)" : Aw,
        "(0000,5130)" : KQ,
        "(0000,5140)" : uH,
        "(0000,5150)" : Ek,
        "(0000,5160)" : SI,
        "(0000,5170)" : yu,
        "(0000,5180)" : Od,
        "(0000,5190)" : Pg,
        "(0000,51A0)" : "Print",
        "(0000,51B0)" : "Overlays",
        "(0002,0000)" : qh,
        "(0002,0001)" : Sw,
        "(0002,0002)" : jk,
        "(0002,0003)" : yX,
        "(0002,0010)" : PG,
        "(0002,0012)" : np,
        "(0002,0013)" : Mf,
        "(0002,0016)" : kB,
        "(0002,0100)" : eT,
        "(0002,0102)" : CH,
        "(0004,1130)" : EO,
        "(0004,1141)" : pS,
        "(0004,1142)" : Gm,
        "(0004,1200)" : kF,
        "(0004,1202)" : br,
        "(0004,1212)" : KF,
        "(0004,1220)" : RG,
        "(0004,1400)" : oV,
        "(0004,1410)" : Hv,
        "(0004,1420)" : Jk,
        "(0004,1430)" : rQ,
        "(0004,1432)" : rC,
        "(0004,1500)" : uX,
        "(0004,1504)" : Ju,
        "(0004,1510)" : zC,
        "(0004,1511)" : be,
        "(0004,1512)" : Hj,
        "(0004,151A)" : "Referenced Related General SOP Class UID in File",
        "(0004,1600)" : vq,
        "(0008,0001)" : Of,
        "(0008,0005)" : rB,
        "(0008,0006)" : Cr,
        "(0008,0008)" : yw,
        "(0008,0010)" : Og,
        "(0008,0012)" : Qd,
        "(0008,0013)" : Sh,
        "(0008,0014)" : rw,
        "(0008,0016)" : rE,
        "(0008,0018)" : vv,
        "(0008,001A)" : "Related General SOP Class UID",
        "(0008,001B)" : "Original Specialized SOP Class UID",
        "(0008,0020)" : JF,
        "(0008,0021)" : H,
        "(0008,0022)" : es,
        "(0008,0023)" : Eb,
        "(0008,0024)" : SA,
        "(0008,0025)" : hK,
        "(0008,002A)" : "Acquisition DateTime",
        "(0008,0030)" : Ed,
        "(0008,0031)" : hn,
        "(0008,0032)" : kL,
        "(0008,0033)" : Mt,
        "(0008,0034)" : sx,
        "(0008,0035)" : rM,
        "(0008,0040)" : Oe,
        "(0008,0041)" : kE,
        "(0008,0042)" : uN,
        "(0008,0050)" : el,
        "(0008,0051)" : pq,
        "(0008,0052)" : nE,
        "(0008,0054)" : Pp,
        "(0008,0056)" : uf,
        "(0008,0058)" : vW,
        "(0008,0060)" : rn,
        "(0008,0061)" : p,
        "(0008,0062)" : jw,
        "(0008,0064)" : ws,
        "(0008,0068)" : Bl,
        "(0008,0070)" : oY,
        "(0008,0080)" : Pu,
        "(0008,0081)" : kA,
        "(0008,0082)" : Ej,
        "(0008,0090)" : iE,
        "(0008,0092)" : qc,
        "(0008,0094)" : Qb,
        "(0008,0096)" : ta,
        "(0008,0100)" : jX,
        "(0008,0102)" : Hi,
        "(0008,0103)" : Ry,
        "(0008,0104)" : nI,
        "(0008,0105)" : PW,
        "(0008,0106)" : EV,
        "(0008,0107)" : fW,
        "(0008,010B)" : "Context Group Extension Flag",
        "(0008,010C)" : "Coding Scheme UID",
        "(0008,010D)" : "Context Group Extension Creator UID",
        "(0008,010F)" : "Context Identifier",
        "(0008,0110)" : FY,
        "(0008,0112)" : uI,
        "(0008,0114)" : bQ,
        "(0008,0115)" : Jz,
        "(0008,0116)" : wb,
        "(0008,0117)" : lL,
        "(0008,0201)" : fa,
        "(0008,1000)" : bH,
        "(0008,1010)" : xw,
        "(0008,1030)" : Kc,
        "(0008,1032)" : BR,
        "(0008,103E)" : "Series Description",
        "(0008,103F)" : "Series Description Code Sequence",
        "(0008,1040)" : Rh,
        "(0008,1048)" : Kf,
        "(0008,1049)" : lT,
        "(0008,1050)" : OC,
        "(0008,1052)" : Co,
        "(0008,1060)" : jW,
        "(0008,1062)" : GA,
        "(0008,1070)" : zz,
        "(0008,1072)" : NI,
        "(0008,1080)" : ee,
        "(0008,1084)" : oj,
        "(0008,1090)" : Eo,
        "(0008,1100)" : Hg,
        "(0008,1110)" : HK,
        "(0008,1111)" : fY,
        "(0008,1115)" : xF,
        "(0008,1120)" : AC,
        "(0008,1125)" : zT,
        "(0008,1130)" : wo,
        "(0008,1134)" : od,
        "(0008,113A)" : "Referenced Waveform Sequence",
        "(0008,1140)" : HB,
        "(0008,1145)" : wn,
        "(0008,114A)" : "Referenced Instance Sequence",
        "(0008,114B)" : "Referenced Real World Value Mapping Instance Sequence",
        "(0008,1150)" : bL,
        "(0008,1155)" : NX,
        "(0008,115A)" : "SOP Classes Supported",
        "(0008,1160)" : qd,
        "(0008,1161)" : nW,
        "(0008,1162)" : MK,
        "(0008,1163)" : iH,
        "(0008,1164)" : oo,
        "(0008,1167)" : KT,
        "(0008,1195)" : fh,
        "(0008,1197)" : fr,
        "(0008,1198)" : FD,
        "(0008,1199)" : Ge,
        "(0008,1200)" : GL,
        "(0008,1250)" : EW,
        "(0008,2110)" : iT,
        "(0008,2111)" : HA,
        "(0008,2112)" : GY,
        "(0008,2120)" : MD,
        "(0008,2122)" : RF,
        "(0008,2124)" : ua,
        "(0008,2127)" : mn,
        "(0008,2128)" : gM,
        "(0008,2129)" : DG,
        "(0008,212A)" : "Number of Views in Stage",
        "(0008,2130)" : rF,
        "(0008,2132)" : Nu,
        "(0008,2133)" : fJ,
        "(0008,2134)" : Qi,
        "(0008,2135)" : qO,
        "(0008,2142)" : Bm,
        "(0008,2143)" : Er,
        "(0008,2144)" : rx,
        "(0008,2200)" : AE,
        "(0008,2204)" : Dr,
        "(0008,2208)" : As,
        "(0008,2218)" : kG,
        "(0008,2220)" : vb,
        "(0008,2228)" : zD,
        "(0008,2229)" : xX,
        "(0008,2230)" : hi,
        "(0008,2240)" : Kw,
        "(0008,2242)" : nJ,
        "(0008,2244)" : QJ,
        "(0008,2246)" : se,
        "(0008,2251)" : jG,
        "(0008,2253)" : vj,
        "(0008,2255)" : QO,
        "(0008,2256)" : DI,
        "(0008,2257)" : LT,
        "(0008,2258)" : Mr,
        "(0008,2259)" : Sd,
        "(0008,225A)" : "Anatomic Structure Space Or Region Modifier Code Sequence (Trial)",
        "(0008,225C)" : "OnAxis Background Anatomic Structure Code Sequence (Trial)",
        "(0008,3001)" : zx,
        "(0008,3010)" : zd,
        "(0008,4000)" : vY,
        "(0008,9007)" : jp,
        "(0008,9092)" : JR,
        "(0008,9121)" : Nv,
        "(0008,9123)" : mz,
        "(0008,9124)" : ek,
        "(0008,9154)" : eC,
        "(0008,9205)" : u,
        "(0008,9206)" : oC,
        "(0008,9207)" : BW,
        "(0008,9208)" : om,
        "(0008,9209)" : gm,
        "(0008,9215)" : gw,
        "(0008,9237)" : rH,
        "(0008,9410)" : KH,
        "(0008,9458)" : BB,
        "(0008,9459)" : FB,
        "(0008,9460)" : zR,
        "(0010,0010)" : NP,
        "(0010,0020)" : Ml,
        "(0010,0021)" : qI,
        "(0010,0022)" : vz,
        "(0010,0024)" : eY,
        "(0010,0030)" : gA,
        "(0010,0032)" : RQ,
        "(0010,0040)" : sM,
        "(0010,0050)" : dW,
        "(0010,0101)" : NR,
        "(0010,0102)" : fk,
        "(0010,1000)" : gf,
        "(0010,1001)" : yt,
        "(0010,1002)" : cM,
        "(0010,1005)" : DO,
        "(0010,1010)" : kC,
        "(0010,1020)" : e,
        "(0010,1030)" : NV,
        "(0010,1040)" : Dd,
        "(0010,1050)" : Qt,
        "(0010,1060)" : JS,
        "(0010,1080)" : pO,
        "(0010,1081)" : dP,
        "(0010,1090)" : sI,
        "(0010,2000)" : oU,
        "(0010,2110)" : et,
        "(0010,2150)" : xe,
        "(0010,2152)" : sR,
        "(0010,2154)" : Gc,
        "(0010,2160)" : vR,
        "(0010,2180)" : QB,
        "(0010,21A0)" : "Smoking Status",
        "(0010,21B0)" : "Additional Patient History",
        "(0010,21C0)" : "Pregnancy Status",
        "(0010,21D0)" : "Last Menstrual Date",
        "(0010,21F0)" : "Patient's Religious Preference",
        "(0010,2201)" : HO,
        "(0010,2202)" : DF,
        "(0010,2203)" : NH,
        "(0010,2210)" : nt,
        "(0010,2292)" : DR,
        "(0010,2293)" : rd,
        "(0010,2294)" : tY,
        "(0010,2295)" : RI,
        "(0010,2296)" : te,
        "(0010,2297)" : pV,
        "(0010,2298)" : bE,
        "(0010,2299)" : mA,
        "(0010,4000)" : PP,
        "(0010,9431)" : ON,
        "(0012,0010)" : vn,
        "(0012,0020)" : ug,
        "(0012,0021)" : LB,
        "(0012,0030)" : Ou,
        "(0012,0031)" : GO,
        "(0012,0040)" : ud,
        "(0012,0042)" : J,
        "(0012,0050)" : Ow,
        "(0012,0051)" : Ka,
        "(0012,0060)" : i,
        "(0012,0062)" : ky,
        "(0012,0063)" : di,
        "(0012,0064)" : hk,
        "(0012,0071)" : Ss,
        "(0012,0072)" : vJ,
        "(0012,0081)" : rs,
        "(0012,0082)" : mI,
        "(0012,0083)" : xi,
        "(0012,0084)" : vS,
        "(0012,0085)" : xE,
        "(0018,0010)" : yT,
        "(0018,0012)" : kc,
        "(0018,0014)" : Ha,
        "(0018,0015)" : lW,
        "(0018,0020)" : fP,
        "(0018,0021)" : dd,
        "(0018,0022)" : GJ,
        "(0018,0023)" : gx,
        "(0018,0024)" : Ol,
        "(0018,0025)" : NL,
        "(0018,0026)" : lB,
        "(0018,0027)" : cC,
        "(0018,0028)" : KB,
        "(0018,0029)" : bk,
        "(0018,002A)" : "Additional Drug Sequence",
        "(0018,0030)" : uW,
        "(0018,0031)" : gI,
        "(0018,0032)" : cv,
        "(0018,0033)" : ti,
        "(0018,0034)" : dq,
        "(0018,0035)" : QV,
        "(0018,0036)" : yh,
        "(0018,0037)" : jj,
        "(0018,0038)" : Oc,
        "(0018,0039)" : my,
        "(0018,003A)" : "Intervention Description",
        "(0018,0040)" : zw,
        "(0018,0042)" : Lr,
        "(0018,0050)" : Lx,
        "(0018,0060)" : wx,
        "(0018,0070)" : Qk,
        "(0018,0071)" : id,
        "(0018,0072)" : eA,
        "(0018,0073)" : It,
        "(0018,0074)" : CP,
        "(0018,0075)" : Ly,
        "(0018,0080)" : hL,
        "(0018,0081)" : Hq,
        "(0018,0082)" : Rz,
        "(0018,0083)" : LS,
        "(0018,0084)" : Oh,
        "(0018,0085)" : wY,
        "(0018,0086)" : qQ,
        "(0018,0087)" : mb,
        "(0018,0088)" : os,
        "(0018,0089)" : lR,
        "(0018,0090)" : Eq,
        "(0018,0091)" : oA,
        "(0018,0093)" : rU,
        "(0018,0094)" : LE,
        "(0018,0095)" : lG,
        "(0018,1000)" : yv,
        "(0018,1002)" : RV,
        "(0018,1003)" : qD,
        "(0018,1004)" : Lc,
        "(0018,1005)" : EF,
        "(0018,1006)" : tN,
        "(0018,1007)" : Hn,
        "(0018,1008)" : gO,
        "(0018,1010)" : MH,
        "(0018,1011)" : IV,
        "(0018,1012)" : Mk,
        "(0018,1014)" : QX,
        "(0018,1016)" : tg,
        "(0018,1017)" : fc,
        "(0018,1018)" : qq,
        "(0018,1019)" : jF,
        "(0018,101A)" : "Hardcopy Device Software Version",
        "(0018,101B)" : "Hardcopy Device Manufacturer's Model Name",
        "(0018,1020)" : mN,
        "(0018,1022)" : rN,
        "(0018,1023)" : wV,
        "(0018,1030)" : Ni,
        "(0018,1040)" : zE,
        "(0018,1041)" : hr,
        "(0018,1042)" : Rv,
        "(0018,1043)" : cW,
        "(0018,1044)" : sH,
        "(0018,1045)" : GR,
        "(0018,1046)" : Rs,
        "(0018,1047)" : Ik,
        "(0018,1048)" : zF,
        "(0018,1049)" : OJ,
        "(0018,1050)" : kf,
        "(0018,1060)" : cV,
        "(0018,1061)" : jM,
        "(0018,1062)" : Mv,
        "(0018,1063)" : JN,
        "(0018,1064)" : ED,
        "(0018,1065)" : pW,
        "(0018,1066)" : yN,
        "(0018,1067)" : iJ,
        "(0018,1068)" : xm,
        "(0018,1069)" : BM,
        "(0018,106A)" : "Synchronization Trigger",
        "(0018,106C)" : "Synchronization Channel",
        "(0018,106E)" : "Trigger Sample Position",
        "(0018,1070)" : ru,
        "(0018,1071)" : ex,
        "(0018,1072)" : hl,
        "(0018,1073)" : gv,
        "(0018,1074)" : Na,
        "(0018,1075)" : zm,
        "(0018,1076)" : PS,
        "(0018,1077)" : qX,
        "(0018,1078)" : ck,
        "(0018,1079)" : it,
        "(0018,1080)" : Am,
        "(0018,1081)" : NG,
        "(0018,1082)" : KP,
        "(0018,1083)" : Fv,
        "(0018,1084)" : ns,
        "(0018,1085)" : we,
        "(0018,1086)" : dN,
        "(0018,1088)" : vp,
        "(0018,1090)" : Mz,
        "(0018,1094)" : Kt,
        "(0018,1100)" : hv,
        "(0018,1110)" : sv,
        "(0018,1111)" : Hc,
        "(0018,1114)" : GW,
        "(0018,1120)" : Ii,
        "(0018,1121)" : qY,
        "(0018,1130)" : rf,
        "(0018,1131)" : ve,
        "(0018,1134)" : vQ,
        "(0018,1135)" : lJ,
        "(0018,1136)" : oB,
        "(0018,1137)" : tE,
        "(0018,1138)" : zc,
        "(0018,113A)" : "Table Type",
        "(0018,1140)" : g,
        "(0018,1141)" : SP,
        "(0018,1142)" : ie,
        "(0018,1143)" : CE,
        "(0018,1144)" : iy,
        "(0018,1145)" : KV,
        "(0018,1146)" : oy,
        "(0018,1147)" : mr,
        "(0018,1149)" : vE,
        "(0018,1150)" : sg,
        "(0018,1151)" : mu,
        "(0018,1152)" : Iz,
        "(0018,1153)" : Dz,
        "(0018,1154)" : Cx,
        "(0018,1155)" : fH,
        "(0018,1156)" : hp,
        "(0018,115A)" : "Radiation Mode",
        "(0018,115E)" : "Image and Fluoroscopy Area Dose Product",
        "(0018,1160)" : Qz,
        "(0018,1161)" : Ih,
        "(0018,1162)" : kj,
        "(0018,1164)" : pY,
        "(0018,1166)" : mv,
        "(0018,1170)" : Eu,
        "(0018,1180)" : MM,
        "(0018,1181)" : tA,
        "(0018,1182)" : CS,
        "(0018,1183)" : oG,
        "(0018,1184)" : Nz,
        "(0018,1190)" : eN,
        "(0018,1191)" : lF,
        "(0018,11A0)" : "Body Part Thickness",
        "(0018,11A2)" : "Compression Force",
        "(0018,1200)" : xz,
        "(0018,1201)" : en,
        "(0018,1210)" : Aa,
        "(0018,1240)" : Ff,
        "(0018,1242)" : yg,
        "(0018,1243)" : gk,
        "(0018,1244)" : LP,
        "(0018,1250)" : Gx,
        "(0018,1251)" : KU,
        "(0018,1260)" : ir,
        "(0018,1261)" : Pw,
        "(0018,1300)" : ev,
        "(0018,1301)" : NW,
        "(0018,1302)" : xt,
        "(0018,1310)" : xa,
        "(0018,1312)" : Ai,
        "(0018,1314)" : Oz,
        "(0018,1315)" : Ri,
        "(0018,1316)" : wa,
        "(0018,1318)" : Jc,
        "(0018,1400)" : wi,
        "(0018,1401)" : Oq,
        "(0018,1402)" : pJ,
        "(0018,1403)" : Gq,
        "(0018,1404)" : ew,
        "(0018,1405)" : Lw,
        "(0018,1411)" : qo,
        "(0018,1412)" : KR,
        "(0018,1413)" : Lh,
        "(0018,1450)" : PF,
        "(0018,1460)" : dS,
        "(0018,1470)" : uv,
        "(0018,1480)" : oP,
        "(0018,1490)" : CR,
        "(0018,1491)" : qj,
        "(0018,1495)" : OV,
        "(0018,1500)" : fU,
        "(0018,1508)" : Rg,
        "(0018,1510)" : yM,
        "(0018,1511)" : yJ,
        "(0018,1520)" : CU,
        "(0018,1521)" : fI,
        "(0018,1530)" : py,
        "(0018,1531)" : sf,
        "(0018,1600)" : OQ,
        "(0018,1602)" : dp,
        "(0018,1604)" : Ky,
        "(0018,1606)" : gj,
        "(0018,1608)" : pE,
        "(0018,1610)" : lg,
        "(0018,1612)" : jm,
        "(0018,1620)" : Qs,
        "(0018,1622)" : iR,
        "(0018,1623)" : tX,
        "(0018,1624)" : pG,
        "(0018,1700)" : dG,
        "(0018,1702)" : Fi,
        "(0018,1704)" : uu,
        "(0018,1706)" : nF,
        "(0018,1708)" : qb,
        "(0018,1710)" : jd,
        "(0018,1712)" : ux,
        "(0018,1720)" : b,
        "(0018,1800)" : IU,
        "(0018,1801)" : AV,
        "(0018,1802)" : Jh,
        "(0018,1803)" : FJ,
        "(0018,2001)" : Sv,
        "(0018,2002)" : Me,
        "(0018,2003)" : ox,
        "(0018,2004)" : Au,
        "(0018,2005)" : dH,
        "(0018,2006)" : Pj,
        "(0018,2010)" : gn,
        "(0018,2020)" : cN,
        "(0018,2030)" : Iv,
        "(0018,3100)" : mB,
        "(0018,3101)" : Kq,
        "(0018,3102)" : NU,
        "(0018,3103)" : iU,
        "(0018,3104)" : nY,
        "(0018,3105)" : eD,
        "(0018,4000)" : pC,
        "(0018,5000)" : QS,
        "(0018,5010)" : qC,
        "(0018,5012)" : IC,
        "(0018,5020)" : eK,
        "(0018,5021)" : AA,
        "(0018,5022)" : JW,
        "(0018,5024)" : ks,
        "(0018,5026)" : Ix,
        "(0018,5027)" : pT,
        "(0018,5028)" : yq,
        "(0018,5029)" : rD,
        "(0018,5030)" : Im,
        "(0018,5040)" : cT,
        "(0018,5050)" : Nt,
        "(0018,5100)" : tT,
        "(0018,5101)" : rg,
        "(0018,5104)" : fw,
        "(0018,5210)" : MB,
        "(0018,5212)" : Fm,
        "(0018,6000)" : dg,
        "(0018,6011)" : DU,
        "(0018,6012)" : rS,
        "(0018,6014)" : cx,
        "(0018,6016)" : op,
        "(0018,6018)" : Ce,
        "(0018,601A)" : "Region Location Min Y0",
        "(0018,601C)" : "Region Location Max X1",
        "(0018,601E)" : "Region Location Max Y1",
        "(0018,6020)" : rq,
        "(0018,6022)" : JV,
        "(0018,6024)" : fR,
        "(0018,6026)" : He,
        "(0018,6028)" : EX,
        "(0018,602A)" : "Reference Pixel Physical Value Y",
        "(0018,602C)" : "Physical Delta X",
        "(0018,602E)" : "Physical Delta Y",
        "(0018,6030)" : GU,
        "(0018,6031)" : NA,
        "(0018,6032)" : eR,
        "(0018,6034)" : sk,
        "(0018,6036)" : Si,
        "(0018,6038)" : PL,
        "(0018,6039)" : Cz,
        "(0018,603A)" : "Doppler Sample Volume Y Position (Retired)",
        "(0018,603B)" : "Doppler Sample Volume Y Position",
        "(0018,603C)" : "TMLine Position X0 (Retired)",
        "(0018,603D)" : "TM-Line Position X0",
        "(0018,603E)" : "TM-Line Position Y0 (Retired)",
        "(0018,603F)" : "TM-Line Position Y0",
        "(0018,6040)" : Cd,
        "(0018,6041)" : ok,
        "(0018,6042)" : Ez,
        "(0018,6043)" : Hu,
        "(0018,6044)" : M,
        "(0018,6046)" : PA,
        "(0018,6048)" : qS,
        "(0018,604A)" : "Pixel Component Range Stop",
        "(0018,604C)" : "Pixel Component Physical Units",
        "(0018,604E)" : "Pixel Component Data Type",
        "(0018,6050)" : NN,
        "(0018,6052)" : ub,
        "(0018,6054)" : fo,
        "(0018,6056)" : na,
        "(0018,6058)" : qM,
        "(0018,605A)" : "Table of Parameter Values",
        "(0018,6060)" : Gf,
        "(0018,7000)" : tm,
        "(0018,7001)" : gC,
        "(0018,7004)" : KM,
        "(0018,7005)" : mR,
        "(0018,7006)" : Pl,
        "(0018,7008)" : cS,
        "(0018,700A)" : "Detector ID",
        "(0018,700C)" : "Date of Last Detector Calibration",
        "(0018,700E)" : "Time of Last Detector Calibration",
        "(0018,7010)" : gz,
        "(0018,7011)" : zl,
        "(0018,7012)" : qn,
        "(0018,7014)" : Qq,
        "(0018,7016)" : MJ,
        "(0018,701A)" : "Detector Binning",
        "(0018,7020)" : MR,
        "(0018,7022)" : OA,
        "(0018,7024)" : qW,
        "(0018,7026)" : ov,
        "(0018,7028)" : Cy,
        "(0018,702A)" : "Detector Manufacturer Name",
        "(0018,702B)" : "Detector Manufacturer's Model Name",
        "(0018,7030)" : CI,
        "(0018,7032)" : Qx,
        "(0018,7034)" : MF,
        "(0018,7040)" : rT,
        "(0018,7041)" : jq,
        "(0018,7042)" : EK,
        "(0018,7044)" : Lf,
        "(0018,7046)" : kV,
        "(0018,7048)" : Bn,
        "(0018,704C)" : "Grid Focal Distance",
        "(0018,7050)" : uq,
        "(0018,7052)" : j,
        "(0018,7054)" : CL,
        "(0018,7056)" : GH,
        "(0018,7058)" : SM,
        "(0018,7060)" : er,
        "(0018,7062)" : ba,
        "(0018,7064)" : Lg,
        "(0018,7065)" : ji,
        "(0018,8150)" : nk,
        "(0018,8151)" : Jl,
        "(0018,9004)" : RP,
        "(0018,9005)" : Hy,
        "(0018,9006)" : sE,
        "(0018,9008)" : LN,
        "(0018,9009)" : dA,
        "(0018,9010)" : KD,
        "(0018,9011)" : by,
        "(0018,9012)" : zs,
        "(0018,9014)" : fO,
        "(0018,9015)" : qF,
        "(0018,9016)" : k,
        "(0018,9017)" : zY,
        "(0018,9018)" : mP,
        "(0018,9019)" : Ei,
        "(0018,9020)" : EE,
        "(0018,9021)" : HD,
        "(0018,9022)" : cr,
        "(0018,9024)" : ts,
        "(0018,9025)" : dO,
        "(0018,9026)" : PB,
        "(0018,9027)" : gc,
        "(0018,9028)" : ce,
        "(0018,9029)" : Po,
        "(0018,9030)" : dc,
        "(0018,9032)" : IL,
        "(0018,9033)" : ga,
        "(0018,9034)" : rR,
        "(0018,9035)" : CB,
        "(0018,9036)" : jK,
        "(0018,9037)" : cU,
        "(0018,9041)" : ft,
        "(0018,9042)" : Nh,
        "(0018,9043)" : Ji,
        "(0018,9044)" : dY,
        "(0018,9045)" : LQ,
        "(0018,9046)" : za,
        "(0018,9047)" : pz,
        "(0018,9048)" : IX,
        "(0018,9049)" : us,
        "(0018,9050)" : Ir,
        "(0018,9051)" : lj,
        "(0018,9052)" : CA,
        "(0018,9053)" : QR,
        "(0018,9054)" : yV,
        "(0018,9058)" : Ij,
        "(0018,9059)" : gy,
        "(0018,9060)" : ze,
        "(0018,9061)" : Jq,
        "(0018,9062)" : SO,
        "(0018,9063)" : LX,
        "(0018,9064)" : fn,
        "(0018,9065)" : EI,
        "(0018,9066)" : Dj,
        "(0018,9067)" : ne,
        "(0018,9069)" : sm,
        "(0018,9070)" : QW,
        "(0018,9073)" : yz,
        "(0018,9074)" : V,
        "(0018,9075)" : Kk,
        "(0018,9076)" : ic,
        "(0018,9077)" : xb,
        "(0018,9078)" : Kd,
        "(0018,9079)" : Qj,
        "(0018,9080)" : Fs,
        "(0018,9081)" : Ls,
        "(0018,9082)" : vK,
        "(0018,9083)" : oE,
        "(0018,9084)" : vh,
        "(0018,9085)" : Sz,
        "(0018,9087)" : qJ,
        "(0018,9089)" : sS,
        "(0018,9090)" : Fu,
        "(0018,9091)" : Bx,
        "(0018,9093)" : CD,
        "(0018,9094)" : qA,
        "(0018,9095)" : Dh,
        "(0018,9096)" : No,
        "(0018,9098)" : wj,
        "(0018,9100)" : lQ,
        "(0018,9101)" : xA,
        "(0018,9103)" : pj,
        "(0018,9104)" : gi,
        "(0018,9105)" : Is,
        "(0018,9106)" : fE,
        "(0018,9107)" : FP,
        "(0018,9112)" : lp,
        "(0018,9114)" : ss,
        "(0018,9115)" : Rw,
        "(0018,9117)" : MN,
        "(0018,9118)" : cH,
        "(0018,9119)" : Sj,
        "(0018,9125)" : Gj,
        "(0018,9126)" : hG,
        "(0018,9127)" : Rj,
        "(0018,9147)" : Pt,
        "(0018,9151)" : z,
        "(0018,9152)" : MS,
        "(0018,9155)" : Em,
        "(0018,9159)" : nB,
        "(0018,9166)" : kx,
        "(0018,9168)" : qp,
        "(0018,9169)" : OW,
        "(0018,9170)" : ML,
        "(0018,9171)" : GP,
        "(0018,9172)" : JX,
        "(0018,9173)" : pH,
        "(0018,9174)" : xx,
        "(0018,9175)" : jB,
        "(0018,9176)" : PK,
        "(0018,9177)" : fl,
        "(0018,9178)" : JE,
        "(0018,9179)" : Rf,
        "(0018,9180)" : DJ,
        "(0018,9181)" : jx,
        "(0018,9182)" : Jx,
        "(0018,9183)" : oq,
        "(0018,9184)" : vy,
        "(0018,9185)" : AY,
        "(0018,9186)" : Al,
        "(0018,9195)" : hH,
        "(0018,9196)" : pl,
        "(0018,9197)" : fd,
        "(0018,9198)" : fL,
        "(0018,9199)" : Ks,
        "(0018,9200)" : Hp,
        "(0018,9214)" : RY,
        "(0018,9217)" : fs,
        "(0018,9218)" : oJ,
        "(0018,9219)" : Cf,
        "(0018,9220)" : ND,
        "(0018,9226)" : DW,
        "(0018,9227)" : mj,
        "(0018,9231)" : Rt,
        "(0018,9232)" : uD,
        "(0018,9234)" : yp,
        "(0018,9236)" : cl,
        "(0018,9239)" : MT,
        "(0018,9240)" : hC,
        "(0018,9241)" : dz,
        "(0018,9295)" : PC,
        "(0018,9296)" : DX,
        "(0018,9301)" : wS,
        "(0018,9302)" : eb,
        "(0018,9303)" : OM,
        "(0018,9304)" : fp,
        "(0018,9305)" : kp,
        "(0018,9306)" : qT,
        "(0018,9307)" : CK,
        "(0018,9308)" : BH,
        "(0018,9309)" : GS,
        "(0018,9310)" : tR,
        "(0018,9311)" : qy,
        "(0018,9312)" : gu,
        "(0018,9313)" : Fh,
        "(0018,9314)" : On,
        "(0018,9315)" : yE,
        "(0018,9316)" : zg,
        "(0018,9317)" : pA,
        "(0018,9318)" : pm,
        "(0018,9319)" : gR,
        "(0018,9320)" : hm,
        "(0018,9321)" : BK,
        "(0018,9322)" : sG,
        "(0018,9323)" : Cb,
        "(0018,9324)" : Ch,
        "(0018,9325)" : dK,
        "(0018,9326)" : JD,
        "(0018,9327)" : Ja,
        "(0018,9328)" : su,
        "(0018,9329)" : pb,
        "(0018,9330)" : Fy,
        "(0018,9332)" : pg,
        "(0018,9333)" : Cg,
        "(0018,9334)" : jr,
        "(0018,9335)" : Sg,
        "(0018,9337)" : pI,
        "(0018,9338)" : QT,
        "(0018,9340)" : JB,
        "(0018,9341)" : Bp,
        "(0018,9342)" : mH,
        "(0018,9343)" : fe,
        "(0018,9344)" : gY,
        "(0018,9345)" : jl,
        "(0018,9346)" : nh,
        "(0018,9351)" : JG,
        "(0018,9352)" : GG,
        "(0018,9353)" : zS,
        "(0018,9360)" : Ae,
        "(0018,9401)" : Ns,
        "(0018,9402)" : dx,
        "(0018,9403)" : HV,
        "(0018,9404)" : ff,
        "(0018,9405)" : OU,
        "(0018,9406)" : mS,
        "(0018,9407)" : xD,
        "(0018,9412)" : CT,
        "(0018,9417)" : gp,
        "(0018,9420)" : rc,
        "(0018,9423)" : bv,
        "(0018,9424)" : xc,
        "(0018,9425)" : Bv,
        "(0018,9426)" : mV,
        "(0018,9427)" : dt,
        "(0018,9428)" : rz,
        "(0018,9429)" : yP,
        "(0018,9430)" : Gi,
        "(0018,9432)" : cf,
        "(0018,9433)" : Jb,
        "(0018,9434)" : Qy,
        "(0018,9435)" : eU,
        "(0018,9436)" : CX,
        "(0018,9437)" : Ip,
        "(0018,9438)" : iB,
        "(0018,9439)" : vg,
        "(0018,9440)" : DD,
        "(0018,9441)" : Kl,
        "(0018,9442)" : xM,
        "(0018,9447)" : hF,
        "(0018,9449)" : yK,
        "(0018,9451)" : ct,
        "(0018,9452)" : tF,
        "(0018,9455)" : Ln,
        "(0018,9456)" : AX,
        "(0018,9457)" : LH,
        "(0018,9461)" : lw,
        "(0018,9462)" : AJ,
        "(0018,9463)" : Mb,
        "(0018,9464)" : kb,
        "(0018,9465)" : tt,
        "(0018,9466)" : yj,
        "(0018,9467)" : mX,
        "(0018,9468)" : N,
        "(0018,9469)" : bw,
        "(0018,9470)" : v,
        "(0018,9471)" : Ki,
        "(0018,9472)" : dT,
        "(0018,9473)" : PO,
        "(0018,9474)" : Pf,
        "(0018,9476)" : Aq,
        "(0018,9477)" : NT,
        "(0018,9504)" : Cm,
        "(0018,9506)" : Nw,
        "(0018,9507)" : BX,
        "(0018,9508)" : tq,
        "(0018,9509)" : BD,
        "(0018,9510)" : GX,
        "(0018,9511)" : Oy,
        "(0018,9514)" : In,
        "(0018,9515)" : nH,
        "(0018,9516)" : Rd,
        "(0018,9517)" : bs,
        "(0018,9524)" : Je,
        "(0018,9525)" : cR,
        "(0018,9526)" : Il,
        "(0018,9527)" : qu,
        "(0018,9528)" : zL,
        "(0018,9530)" : sL,
        "(0018,9531)" : hT,
        "(0018,9538)" : Da,
        "(0018,9601)" : RE,
        "(0018,9602)" : SJ,
        "(0018,9603)" : fN,
        "(0018,9604)" : yl,
        "(0018,9605)" : wM,
        "(0018,9606)" : IG,
        "(0018,9607)" : sp,
        "(0018,9701)" : IS,
        "(0018,9715)" : wq,
        "(0018,9716)" : NF,
        "(0018,9717)" : eh,
        "(0018,9718)" : PD,
        "(0018,9719)" : DC,
        "(0018,9720)" : sK,
        "(0018,9721)" : ER,
        "(0018,9722)" : Px,
        "(0018,9723)" : NC,
        "(0018,9724)" : KL,
        "(0018,9725)" : Fb,
        "(0018,9726)" : Gk,
        "(0018,9727)" : rX,
        "(0018,9729)" : qv,
        "(0018,9732)" : go,
        "(0018,9733)" : Qa,
        "(0018,9734)" : lV,
        "(0018,9735)" : ET,
        "(0018,9736)" : qr,
        "(0018,9737)" : jP,
        "(0018,9738)" : AH,
        "(0018,9739)" : po,
        "(0018,9740)" : nx,
        "(0018,9749)" : iu,
        "(0018,9751)" : zv,
        "(0018,9755)" : Ca,
        "(0018,9756)" : eF,
        "(0018,9758)" : hf,
        "(0018,9759)" : iM,
        "(0018,9760)" : fV,
        "(0018,9761)" : dR,
        "(0018,9762)" : Nr,
        "(0018,9763)" : ng,
        "(0018,9764)" : nr,
        "(0018,9765)" : Ax,
        "(0018,9766)" : bd,
        "(0018,9767)" : bM,
        "(0018,9768)" : iP,
        "(0018,9769)" : tf,
        "(0018,9770)" : oI,
        "(0018,9771)" : ja,
        "(0018,9772)" : Kg,
        "(0018,9801)" : HU,
        "(0018,9803)" : bS,
        "(0018,9804)" : cQ,
        "(0018,9805)" : vt,
        "(0018,9806)" : LU,
        "(0018,9807)" : qG,
        "(0018,9808)" : Nn,
        "(0018,9809)" : AO,
        "(0018,980B)" : "Aliased Data Type",
        "(0018,980C)" : "Position Measuring Device Used",
        "(0018,980D)" : "Transducer Geometry Code Sequence",
        "(0018,980E)" : "Transducer Beam Steering Code Sequence",
        "(0018,980F)" : "Transducer Application Code Sequence",
        "(0018,A001)" : "Contributing Equipment Sequence",
        "(0018,A002)" : "Contribution Date Time",
        "(0018,A003)" : "Contribution Description",
        "(0020,000D)" : "Study Instance UID",
        "(0020,000E)" : "Series Instance UID",
        "(0020,0010)" : Ho,
        "(0020,0011)" : JI,
        "(0020,0012)" : If,
        "(0020,0013)" : uJ,
        "(0020,0014)" : kD,
        "(0020,0015)" : s,
        "(0020,0016)" : Y,
        "(0020,0017)" : kW,
        "(0020,0018)" : Bq,
        "(0020,0019)" : iY,
        "(0020,0020)" : NQ,
        "(0020,0022)" : tQ,
        "(0020,0024)" : Rq,
        "(0020,0026)" : GI,
        "(0020,0030)" : Ok,
        "(0020,0032)" : zj,
        "(0020,0035)" : uU,
        "(0020,0037)" : tl,
        "(0020,0050)" : Cj,
        "(0020,0052)" : fb,
        "(0020,0060)" : fm,
        "(0020,0062)" : xN,
        "(0020,0070)" : kI,
        "(0020,0080)" : lE,
        "(0020,0100)" : iA,
        "(0020,0105)" : ob,
        "(0020,0110)" : NM,
        "(0020,0200)" : pX,
        "(0020,0242)" : bW,
        "(0020,1000)" : PI,
        "(0020,1001)" : tp,
        "(0020,1002)" : m,
        "(0020,1003)" : cL,
        "(0020,1004)" : At,
        "(0020,1005)" : Cw,
        "(0020,1020)" : mf,
        "(0020,1040)" : DP,
        "(0020,1041)" : wp,
        "(0020,1070)" : Np,
        "(0020,1200)" : LK,
        "(0020,1202)" : zP,
        "(0020,1204)" : LD,
        "(0020,1206)" : xn,
        "(0020,1208)" : oe,
        "(0020,1209)" : rG,
        "(0020,31xx)" : fM,
        "(0020,3401)" : eG,
        "(0020,3402)" : xr,
        "(0020,3403)" : jQ,
        "(0020,3404)" : lU,
        "(0020,3405)" : Nk,
        "(0020,3406)" : BP,
        "(0020,4000)" : Ql,
        "(0020,5000)" : fT,
        "(0020,5002)" : sz,
        "(0020,9056)" : SB,
        "(0020,9057)" : Pr,
        "(0020,9071)" : yn,
        "(0020,9072)" : mJ,
        "(0020,9111)" : fC,
        "(0020,9113)" : DK,
        "(0020,9116)" : FO,
        "(0020,9128)" : iS,
        "(0020,9153)" : cF,
        "(0020,9156)" : kR,
        "(0020,9157)" : W,
        "(0020,9158)" : Bt,
        "(0020,9161)" : Mn,
        "(0020,9162)" : oi,
        "(0020,9163)" : yL,
        "(0020,9164)" : uG,
        "(0020,9165)" : AK,
        "(0020,9167)" : BI,
        "(0020,9213)" : xQ,
        "(0020,9221)" : ch,
        "(0020,9222)" : Ec,
        "(0020,9228)" : PM,
        "(0020,9238)" : LV,
        "(0020,9241)" : mF,
        "(0020,9245)" : PJ,
        "(0020,9246)" : MG,
        "(0020,9247)" : FM,
        "(0020,9248)" : fx,
        "(0020,9249)" : Sy,
        "(0020,9250)" : OD,
        "(0020,9251)" : bA,
        "(0020,9252)" : pc,
        "(0020,9253)" : bh,
        "(0020,9254)" : md,
        "(0020,9255)" : nQ,
        "(0020,9256)" : hq,
        "(0020,9257)" : mp,
        "(0020,9301)" : Gt,
        "(0020,9302)" : sl,
        "(0020,9307)" : rJ,
        "(0020,9308)" : iQ,
        "(0020,9309)" : og,
        "(0020,930A)" : "Volume to Table Mapping Matrix",
        "(0020,930C)" : "Patient Frame of Reference Source",
        "(0020,930D)" : "Temporal Position Time Offset",
        "(0020,930E)" : "Plane Position (Volume) Sequence",
        "(0020,930F)" : "Plane Orientation (Volume) Sequence",
        "(0020,9310)" : zb,
        "(0020,9311)" : eB,
        "(0020,9312)" : Ru,
        "(0020,9313)" : zu,
        "(0020,9421)" : Kv,
        "(0020,9450)" : gK,
        "(0020,9453)" : eE,
        "(0020,9518)" : Io,
        "(0020,9529)" : ip,
        "(0020,9536)" : tD,
        "(0022,0001)" : kP,
        "(0022,0002)" : My,
        "(0022,0003)" : oc,
        "(0022,0004)" : zr,
        "(0022,0005)" : qN,
        "(0022,0006)" : QL,
        "(0022,0007)" : qk,
        "(0022,0008)" : vm,
        "(0022,0009)" : xg,
        "(0022,000A)" : "Emmetropic Magnification",
        "(0022,000B)" : "Intra Ocular Pressure",
        "(0022,000C)" : "Horizontal Field of View",
        "(0022,000D)" : "Pupil Dilated",
        "(0022,000E)" : "Degree of Dilation",
        "(0022,0010)" : lv,
        "(0022,0011)" : Pa,
        "(0022,0012)" : sD,
        "(0022,0013)" : lf,
        "(0022,0014)" : xK,
        "(0022,0015)" : wL,
        "(0022,0016)" : HL,
        "(0022,0017)" : AL,
        "(0022,0018)" : bm,
        "(0022,0019)" : Mg,
        "(0022,001A)" : "Channel Description Code Sequence",
        "(0022,001B)" : "Refractive State Sequence",
        "(0022,001C)" : "Mydriatic Agent Code Sequence",
        "(0022,001D)" : "Relative Image Position Code Sequence",
        "(0022,0020)" : Hw,
        "(0022,0021)" : qm,
        "(0022,0022)" : vo,
        "(0022,0030)" : wg,
        "(0022,0031)" : ei,
        "(0022,0032)" : ed,
        "(0022,0035)" : Ro,
        "(0022,0036)" : Dn,
        "(0022,0037)" : JM,
        "(0022,0038)" : ls,
        "(0022,0039)" : Su,
        "(0022,0041)" : jy,
        "(0022,0042)" : mO,
        "(0022,0048)" : vd,
        "(0022,0049)" : ec,
        "(0022,004E)" : "Mydriatic Agent Concentration",
        "(0022,0055)" : bj,
        "(0022,0056)" : Oa,
        "(0022,0057)" : vO,
        "(0022,0058)" : mo,
        "(0028,0002)" : Lo,
        "(0028,0003)" : cI,
        "(0028,0004)" : jY,
        "(0028,0005)" : Qu,
        "(0028,0006)" : tz,
        "(0028,0008)" : kK,
        "(0028,0009)" : wu,
        "(0028,000A)" : "Frame Dimension Pointer",
        "(0028,0010)" : hu,
        "(0028,0011)" : ii,
        "(0028,0012)" : AU,
        "(0028,0014)" : Hm,
        "(0028,0030)" : Mh,
        "(0028,0031)" : LL,
        "(0028,0032)" : Jw,
        "(0028,0034)" : rl,
        "(0028,0040)" : bq,
        "(0028,0050)" : bR,
        "(0028,0051)" : sq,
        "(0028,005F)" : "Compression Recognition Code",
        "(0028,0060)" : nb,
        "(0028,0061)" : kl,
        "(0028,0062)" : cK,
        "(0028,0063)" : Ll,
        "(0028,0065)" : Ah,
        "(0028,0066)" : RD,
        "(0028,0068)" : OH,
        "(0028,0069)" : QC,
        "(0028,0070)" : MV,
        "(0028,0071)" : PX,
        "(0028,0080)" : bo,
        "(0028,0081)" : MI,
        "(0028,0082)" : Hb,
        "(0028,0090)" : pe,
        "(0028,0091)" : RL,
        "(0028,0092)" : gU,
        "(0028,0093)" : mh,
        "(0028,0094)" : xJ,
        "(0028,0100)" : hg,
        "(0028,0101)" : px,
        "(0028,0102)" : AG,
        "(0028,0103)" : KI,
        "(0028,0104)" : Jv,
        "(0028,0105)" : Ot,
        "(0028,0106)" : gl,
        "(0028,0107)" : BY,
        "(0028,0108)" : sc,
        "(0028,0109)" : PQ,
        "(0028,0110)" : gD,
        "(0028,0111)" : uQ,
        "(0028,0120)" : Rc,
        "(0028,0121)" : bO,
        "(0028,0200)" : Ny,
        "(0028,0300)" : PY,
        "(0028,0301)" : zO,
        "(0028,0400)" : JA,
        "(0028,0401)" : gN,
        "(0028,0402)" : oM,
        "(0028,0403)" : wJ,
        "(0028,0404)" : dn,
        "(0028,04x0)" : ut,
        "(0028,04x1)" : Om,
        "(0028,04x2)" : rm,
        "(0028,04x3)" : RS,
        "(0028,0700)" : RO,
        "(0028,0701)" : FI,
        "(0028,0702)" : gd,
        "(0028,0710)" : nn,
        "(0028,0720)" : ig,
        "(0028,0721)" : xL,
        "(0028,0722)" : pt,
        "(0028,0730)" : ot,
        "(0028,0740)" : cb,
        "(0028,08x0)" : vC,
        "(0028,08x2)" : Be,
        "(0028,08x3)" : SC,
        "(0028,08x4)" : ur,
        "(0028,08x8)" : lP,
        "(0028,0A02)" : "Pixel Spacing Calibration Type",
        "(0028,0A04)" : "Pixel Spacing Calibration Description",
        "(0028,1040)" : bC,
        "(0028,1041)" : Sc,
        "(0028,1050)" : zG,
        "(0028,1051)" : gs,
        "(0028,1052)" : Dy,
        "(0028,1053)" : fi,
        "(0028,1054)" : Sa,
        "(0028,1055)" : Ea,
        "(0028,1056)" : wO,
        "(0028,1080)" : S,
        "(0028,1090)" : GN,
        "(0028,1100)" : FH,
        "(0028,1101)" : Bs,
        "(0028,1102)" : vD,
        "(0028,1103)" : tu,
        "(0028,1104)" : uj,
        "(0028,1111)" : cX,
        "(0028,1112)" : mC,
        "(0028,1113)" : gX,
        "(0028,1199)" : Ht,
        "(0028,1200)" : Hd,
        "(0028,1201)" : rp,
        "(0028,1202)" : vf,
        "(0028,1203)" : Ck,
        "(0028,1204)" : cE,
        "(0028,1211)" : PE,
        "(0028,1212)" : hY,
        "(0028,1213)" : Gd,
        "(0028,1214)" : uk,
        "(0028,1221)" : is,
        "(0028,1222)" : Nf,
        "(0028,1223)" : yr,
        "(0028,1300)" : vV,
        "(0028,1350)" : HC,
        "(0028,1351)" : xf,
        "(0028,1352)" : hQ,
        "(0028,135A)" : "Spatial Locations Preserved",
        "(0028,1401)" : Av,
        "(0028,1402)" : up,
        "(0028,1403)" : uP,
        "(0028,1404)" : gt,
        "(0028,1405)" : CW,
        "(0028,1406)" : Gh,
        "(0028,1407)" : zM,
        "(0028,1408)" : Gb,
        "(0028,140B)" : "Enhanced Palette Color Lookup Table Sequence",
        "(0028,140C)" : "Blending LUT 2 Sequence",
        "(0028,140D)" : "Blending LUT 2 Transfer Function",
        "(0028,140E)" : "Data Path ID",
        "(0028,140F)" : "RGB LUT Transfer Function",
        "(0028,1410)" : bG,
        "(0028,2000)" : bK,
        "(0028,2110)" : gL,
        "(0028,2112)" : yH,
        "(0028,2114)" : Gn,
        "(0028,3000)" : vc,
        "(0028,3002)" : oH,
        "(0028,3003)" : jg,
        "(0028,3004)" : Hz,
        "(0028,3006)" : KE,
        "(0028,3010)" : IY,
        "(0028,3110)" : Ma,
        "(0028,4000)" : Eg,
        "(0028,5000)" : hS,
        "(0028,6010)" : Lm,
        "(0028,6020)" : hX,
        "(0028,6022)" : fy,
        "(0028,6023)" : SR,
        "(0028,6030)" : pi,
        "(0028,6040)" : A,
        "(0028,6100)" : oT,
        "(0028,6101)" : Gp,
        "(0028,6102)" : kY,
        "(0028,6110)" : Bb,
        "(0028,6112)" : Dk,
        "(0028,6114)" : pN,
        "(0028,6120)" : tP,
        "(0028,6190)" : qw,
        "(0028,7FE0)" : "Pixel Data Provider URL",
        "(0028,9001)" : qV,
        "(0028,9002)" : ME,
        "(0028,9003)" : xY,
        "(0028,9099)" : ni,
        "(0028,9108)" : iz,
        "(0028,9110)" : Iy,
        "(0028,9132)" : km,
        "(0028,9145)" : FS,
        "(0028,9235)" : oS,
        "(0028,9411)" : uF,
        "(0028,9415)" : ih,
        "(0028,9416)" : iL,
        "(0028,9422)" : KS,
        "(0028,9443)" : il,
        "(0028,9444)" : pv,
        "(0028,9445)" : Fz,
        "(0028,9446)" : CG,
        "(0028,9454)" : K,
        "(0028,9474)" : ij,
        "(0028,9478)" : zq,
        "(0028,9501)" : xH,
        "(0028,9502)" : r,
        "(0028,9503)" : ty,
        "(0028,9505)" : Dg,
        "(0028,9506)" : uw,
        "(0028,9507)" : wr,
        "(0028,9520)" : uC,
        "(0028,9537)" : iX,
        "(0032,000A)" : "Study Status ID",
        "(0032,000C)" : "Study Priority ID",
        "(0032,0012)" : cz,
        "(0032,0032)" : ca,
        "(0032,0033)" : Bj,
        "(0032,0034)" : hO,
        "(0032,0035)" : Cq,
        "(0032,1000)" : Fe,
        "(0032,1001)" : hD,
        "(0032,1010)" : IM,
        "(0032,1011)" : gh,
        "(0032,1020)" : HP,
        "(0032,1021)" : kT,
        "(0032,1030)" : li,
        "(0032,1031)" : MU,
        "(0032,1032)" : Sk,
        "(0032,1033)" : Gu,
        "(0032,1034)" : Ia,
        "(0032,1040)" : FW,
        "(0032,1041)" : eu,
        "(0032,1050)" : cB,
        "(0032,1051)" : jE,
        "(0032,1055)" : oK,
        "(0032,1060)" : pa,
        "(0032,1064)" : Rn,
        "(0032,1070)" : EA,
        "(0032,4000)" : qs,
        "(0038,0004)" : Sx,
        "(0038,0008)" : no,
        "(0038,0010)" : fX,
        "(0038,0011)" : IP,
        "(0038,0014)" : jL,
        "(0038,0016)" : Bi,
        "(0038,001A)" : "Scheduled Admission Date",
        "(0038,001B)" : "Scheduled Admission Time",
        "(0038,001C)" : "Scheduled Discharge Date",
        "(0038,001D)" : "Scheduled Discharge Time",
        "(0038,001E)" : "Scheduled Patient Institution Residence",
        "(0038,0020)" : QP,
        "(0038,0021)" : ml,
        "(0038,0030)" : pF,
        "(0038,0032)" : gW,
        "(0038,0040)" : NS,
        "(0038,0044)" : Df,
        "(0038,0050)" : gB,
        "(0038,0060)" : EQ,
        "(0038,0061)" : zo,
        "(0038,0062)" : Ee,
        "(0038,0064)" : vI,
        "(0038,0100)" : oQ,
        "(0038,0300)" : tn,
        "(0038,0400)" : Kp,
        "(0038,0500)" : tK,
        "(0038,0502)" : dI,
        "(0038,4000)" : rP,
        "(003A,0004)" : "Waveform Originality",
        "(003A,0005)" : "Number of Waveform Channels",
        "(003A,0010)" : "Number of Waveform Samples",
        "(003A,001A)" : "Sampling Frequency",
        "(003A,0020)" : "Multiplex Group Label",
        "(003A,0200)" : "Channel Definition Sequence",
        "(003A,0202)" : "Waveform Channel Number",
        "(003A,0203)" : "Channel Label",
        "(003A,0205)" : "Channel Status",
        "(003A,0208)" : "Channel Source Sequence",
        "(003A,0209)" : "Channel Source Modifiers Sequence",
        "(003A,020A)" : "Source Waveform Sequence",
        "(003A,020C)" : "Channel Derivation Description",
        "(003A,0210)" : "Channel Sensitivity",
        "(003A,0211)" : "Channel Sensitivity Units Sequence",
        "(003A,0212)" : "Channel Sensitivity Correction Factor",
        "(003A,0213)" : "Channel Baseline",
        "(003A,0214)" : "Channel Time Skew",
        "(003A,0215)" : "Channel Sample Skew",
        "(003A,0218)" : "Channel Offset",
        "(003A,021A)" : "Waveform Bits Stored",
        "(003A,0220)" : "Filter Low Frequency",
        "(003A,0221)" : "Filter High Frequency",
        "(003A,0222)" : "Notch Filter Frequency",
        "(003A,0223)" : "Notch Filter Bandwidth",
        "(003A,0230)" : "Waveform Data Display Scale",
        "(003A,0231)" : "Waveform Display Background CIELab Value",
        "(003A,0240)" : "Waveform Presentation Group Sequence",
        "(003A,0241)" : "Presentation Group Number",
        "(003A,0242)" : "Channel Display Sequence",
        "(003A,0244)" : "Channel Recommended Display CIELab Value",
        "(003A,0245)" : "Channel Position",
        "(003A,0246)" : "Display Shading Flag",
        "(003A,0247)" : "Fractional Channel Display Scale",
        "(003A,0248)" : "Absolute Channel Display Scale",
        "(003A,0300)" : "Multiplexed Audio Channels Description Code Sequence",
        "(003A,0301)" : "Channel Identification Code",
        "(003A,0302)" : "Channel Mode",
        "(0040,0001)" : uM,
        "(0040,0002)" : LF,
        "(0040,0003)" : Ef,
        "(0040,0004)" : IQ,
        "(0040,0005)" : mM,
        "(0040,0006)" : IK,
        "(0040,0007)" : bP,
        "(0040,0008)" : Fn,
        "(0040,0009)" : tr,
        "(0040,000A)" : "Stage Code Sequence",
        "(0040,000B)" : "Scheduled Performing Physician Identification Sequence",
        "(0040,0010)" : db,
        "(0040,0011)" : Ra,
        "(0040,0012)" : jb,
        "(0040,0020)" : hM,
        "(0040,0026)" : yQ,
        "(0040,0027)" : Bh,
        "(0040,0031)" : hb,
        "(0040,0032)" : Oj,
        "(0040,0033)" : cP,
        "(0040,0035)" : JP,
        "(0040,0036)" : NE,
        "(0040,0039)" : fg,
        "(0040,003A)" : "Assigning Agency or Department Code Sequence",
        "(0040,0100)" : nc,
        "(0040,0220)" : bl,
        "(0040,0241)" : vs,
        "(0040,0242)" : zU,
        "(0040,0243)" : IJ,
        "(0040,0244)" : yf,
        "(0040,0245)" : wR,
        "(0040,0250)" : pR,
        "(0040,0251)" : HT,
        "(0040,0252)" : bx,
        "(0040,0253)" : mi,
        "(0040,0254)" : Pe,
        "(0040,0255)" : DQ,
        "(0040,0260)" : wf,
        "(0040,0261)" : mk,
        "(0040,0270)" : eW,
        "(0040,0275)" : F,
        "(0040,0280)" : lH,
        "(0040,0281)" : cu,
        "(0040,0293)" : sb,
        "(0040,0294)" : bJ,
        "(0040,0295)" : ms,
        "(0040,0296)" : rA,
        "(0040,0300)" : xu,
        "(0040,0301)" : zA,
        "(0040,0302)" : De,
        "(0040,0303)" : pn,
        "(0040,0306)" : um,
        "(0040,0307)" : ny,
        "(0040,030E)" : "Exposure Dose Sequence",
        "(0040,0310)" : kk,
        "(0040,0312)" : sr,
        "(0040,0314)" : dr,
        "(0040,0316)" : Eh,
        "(0040,0318)" : pd,
        "(0040,0320)" : Mc,
        "(0040,0321)" : sV,
        "(0040,0324)" : gJ,
        "(0040,0330)" : cG,
        "(0040,0340)" : QU,
        "(0040,0400)" : iD,
        "(0040,0440)" : nl,
        "(0040,0441)" : zk,
        "(0040,0500)" : Lj,
        "(0040,050A)" : "Specimen Accession Number",
        "(0040,0512)" : HJ,
        "(0040,0513)" : Kn,
        "(0040,0515)" : yW,
        "(0040,0518)" : kU,
        "(0040,051A)" : "Container Description",
        "(0040,0520)" : kg,
        "(0040,0550)" : hR,
        "(0040,0551)" : Sp,
        "(0040,0552)" : RN,
        "(0040,0553)" : sU,
        "(0040,0554)" : RT,
        "(0040,0555)" : Lq,
        "(0040,0556)" : fQ,
        "(0040,0560)" : Hr,
        "(0040,0562)" : Pm,
        "(0040,059A)" : "Specimen Type Code Sequence",
        "(0040,0600)" : BT,
        "(0040,0602)" : eL,
        "(0040,0610)" : Os,
        "(0040,0612)" : NK,
        "(0040,0620)" : uK,
        "(0040,06FA)" : "Slide Identifier",
        "(0040,071A)" : "Image Center Point Coordinates Sequence",
        "(0040,072A)" : "X offset in Slide Coordinate System",
        "(0040,073A)" : "Y offset in Slide Coordinate System",
        "(0040,074A)" : "Z offset in Slide Coordinate System",
        "(0040,08D8)" : "Pixel Spacing Sequence",
        "(0040,08DA)" : "Coordinate System Axis Code Sequence",
        "(0040,08EA)" : "Measurement Units Code Sequence",
        "(0040,09F8)" : "Vital Stain Code Sequence - Trial",
        "(0040,1001)" : hy,
        "(0040,1002)" : sy,
        "(0040,1003)" : bV,
        "(0040,1004)" : pr,
        "(0040,1005)" : KG,
        "(0040,1006)" : lt,
        "(0040,1007)" : OR,
        "(0040,1008)" : HH,
        "(0040,1009)" : SG,
        "(0040,100A)" : "Reason for Requested Procedure Code Sequence",
        "(0040,1010)" : Cu,
        "(0040,1011)" : Cp,
        "(0040,1012)" : nS,
        "(0040,1101)" : Jg,
        "(0040,1102)" : pp,
        "(0040,1103)" : dy,
        "(0040,1400)" : FE,
        "(0040,2001)" : Qp,
        "(0040,2004)" : cc,
        "(0040,2005)" : LM,
        "(0040,2006)" : Gv,
        "(0040,2007)" : bD,
        "(0040,2008)" : FN,
        "(0040,2009)" : fG,
        "(0040,2010)" : ym,
        "(0040,2016)" : jv,
        "(0040,2017)" : sJ,
        "(0040,2400)" : qK,
        "(0040,3001)" : RJ,
        "(0040,4001)" : eH,
        "(0040,4002)" : rt,
        "(0040,4003)" : So,
        "(0040,4004)" : vG,
        "(0040,4005)" : hw,
        "(0040,4006)" : PH,
        "(0040,4007)" : Se,
        "(0040,4009)" : Or,
        "(0040,4010)" : nv,
        "(0040,4011)" : AQ,
        "(0040,4015)" : lC,
        "(0040,4016)" : re,
        "(0040,4018)" : EU,
        "(0040,4019)" : ju,
        "(0040,4020)" : xl,
        "(0040,4021)" : By,
        "(0040,4022)" : JC,
        "(0040,4023)" : MX,
        "(0040,4025)" : kH,
        "(0040,4026)" : BL,
        "(0040,4027)" : L,
        "(0040,4028)" : eV,
        "(0040,4029)" : kQ,
        "(0040,4030)" : Ey,
        "(0040,4031)" : BN,
        "(0040,4032)" : GV,
        "(0040,4033)" : Pd,
        "(0040,4034)" : mL,
        "(0040,4035)" : ib,
        "(0040,4036)" : Qm,
        "(0040,4037)" : de,
        "(0040,4040)" : vT,
        "(0040,8302)" : mg,
        "(0040,9094)" : tI,
        "(0040,9096)" : pu,
        "(0040,9098)" : bn,
        "(0040,9210)" : rr,
        "(0040,9211)" : vP,
        "(0040,9212)" : js,
        "(0040,9216)" : jH,
        "(0040,9224)" : nM,
        "(0040,9225)" : CO,
        "(0040,A010)" : "Relationship Type",
        "(0040,A027)" : "Verifying Organization",
        "(0040,A030)" : "Verification Date Time",
        "(0040,A032)" : "Observation Date Time",
        "(0040,A040)" : "Value Type",
        "(0040,A043)" : "Concept Name Code Sequence",
        "(0040,A050)" : "Continuity Of Content",
        "(0040,A073)" : "Verifying Observer Sequence",
        "(0040,A075)" : "Verifying Observer Name",
        "(0040,A078)" : "Author Observer Sequence",
        "(0040,A07A)" : "Participant Sequence",
        "(0040,A07C)" : "Custodial Organization Sequence",
        "(0040,A080)" : "Participation Type",
        "(0040,A082)" : "Participation DateTime",
        "(0040,A084)" : "Observer Type",
        "(0040,A088)" : "Verifying Observer Identification Code Sequence",
        "(0040,A090)" : "Equivalent CDA Document Sequence",
        "(0040,A0B0)" : "Referenced Waveform Channels",
        "(0040,A120)" : "DateTime",
        "(0040,A121)" : "Date",
        "(0040,A122)" : "Time",
        "(0040,A123)" : "Person Name",
        "(0040,A124)" : "UID",
        "(0040,A130)" : "Temporal Range Type",
        "(0040,A132)" : "Referenced Sample Positions",
        "(0040,A136)" : "Referenced Frame Numbers",
        "(0040,A138)" : "Referenced Time Offsets",
        "(0040,A13A)" : "Referenced DateTime",
        "(0040,A160)" : "Text Value",
        "(0040,A168)" : "Concept Code Sequence",
        "(0040,A170)" : "Purpose of Reference Code Sequence",
        "(0040,A180)" : "Annotation Group Number",
        "(0040,A195)" : "Modifier Code Sequence",
        "(0040,A300)" : "Measured Value Sequence",
        "(0040,A301)" : "Numeric Value Qualifier Code Sequence",
        "(0040,A30A)" : "Numeric Value",
        "(0040,A353)" : "Address - Trial",
        "(0040,A354)" : "Telephone Number - Trial",
        "(0040,A360)" : "Predecessor Documents Sequence",
        "(0040,A370)" : "Referenced Request Sequence",
        "(0040,A372)" : "Performed Procedure Code Sequence",
        "(0040,A375)" : "Current Requested Procedure Evidence Sequence",
        "(0040,A385)" : "Pertinent Other Evidence Sequence",
        "(0040,A390)" : "HL7 Structured Document Reference Sequence",
        "(0040,A491)" : "Completion Flag",
        "(0040,A492)" : "Completion Flag Description",
        "(0040,A493)" : "Verification Flag",
        "(0040,A494)" : "Archive Requested",
        "(0040,A496)" : "Preliminary Flag",
        "(0040,A504)" : "Content Template Sequence",
        "(0040,A525)" : "Identical Documents Sequence",
        "(0040,A730)" : "Content Sequence",
        "(0040,B020)" : "Waveform Annotation Sequence",
        "(0040,DB00)" : "Template Identifier",
        "(0040,DB06)" : "Template Version",
        "(0040,DB07)" : "Template Local Version",
        "(0040,DB0B)" : "Template Extension Flag",
        "(0040,DB0C)" : "Template Extension Organization UID",
        "(0040,DB0D)" : "Template Extension Creator UID",
        "(0040,DB73)" : "Referenced Content Item Identifier",
        "(0040,E001)" : "HL7 Instance Identifier",
        "(0040,E004)" : "HL7 Document Effective Time",
        "(0040,E006)" : "HL7 Document Type Code Sequence",
        "(0040,E010)" : "Retrieve URI",
        "(0040,E011)" : "Retrieve Location UID",
        "(0042,0010)" : si,
        "(0042,0011)" : Bu,
        "(0042,0012)" : lh,
        "(0042,0013)" : sh,
        "(0042,0014)" : w,
        "(0044,0001)" : Lp,
        "(0044,0002)" : EC,
        "(0044,0003)" : ds,
        "(0044,0004)" : Nj,
        "(0044,0007)" : Fx,
        "(0044,0008)" : ix,
        "(0044,0009)" : Pq,
        "(0044,000A)" : "Product Lot Identifier",
        "(0044,000B)" : "Product Expiration DateTime",
        "(0044,0010)" : rh,
        "(0044,0011)" : zt,
        "(0044,0012)" : GT,
        "(0044,0013)" : lS,
        "(0044,0019)" : FT,
        "(0046,0012)" : Ms,
        "(0046,0014)" : le,
        "(0046,0015)" : MW,
        "(0046,0016)" : Hx,
        "(0046,0018)" : kN,
        "(0046,0028)" : Q,
        "(0046,0030)" : jh,
        "(0046,0032)" : bU,
        "(0046,0034)" : sY,
        "(0046,0036)" : co,
        "(0046,0038)" : io,
        "(0046,0040)" : lD,
        "(0046,0042)" : Gg,
        "(0046,0044)" : lK,
        "(0046,0046)" : R,
        "(0046,0050)" : vF,
        "(0046,0052)" : CN,
        "(0046,0060)" : yF,
        "(0046,0062)" : jo,
        "(0046,0063)" : ea,
        "(0046,0064)" : ly,
        "(0046,0070)" : Sm,
        "(0046,0071)" : Bc,
        "(0046,0074)" : bY,
        "(0046,0075)" : sX,
        "(0046,0076)" : IE,
        "(0046,0077)" : rv,
        "(0046,0080)" : Pb,
        "(0046,0092)" : GD,
        "(0046,0094)" : cm,
        "(0046,0095)" : sC,
        "(0046,0097)" : yA,
        "(0046,0098)" : mq,
        "(0046,0100)" : vH,
        "(0046,0101)" : dJ,
        "(0046,0102)" : ci,
        "(0046,0104)" : oL,
        "(0046,0106)" : nO,
        "(0046,0121)" : GE,
        "(0046,0122)" : Cs,
        "(0046,0123)" : wX,
        "(0046,0124)" : yy,
        "(0046,0125)" : ID,
        "(0046,0135)" : dD,
        "(0046,0137)" : CF,
        "(0046,0139)" : uY,
        "(0046,0145)" : bu,
        "(0046,0146)" : mG,
        "(0046,0147)" : AN,
        "(0050,0004)" : du,
        "(0050,0010)" : Qr,
        "(0050,0012)" : oO,
        "(0050,0013)" : hA,
        "(0050,0014)" : Nm,
        "(0050,0015)" : Iw,
        "(0050,0016)" : jD,
        "(0050,0017)" : Kz,
        "(0050,0018)" : cJ,
        "(0050,0019)" : eM,
        "(0050,001A)" : "Container Component Material",
        "(0050,001B)" : "Container Component ID",
        "(0050,001C)" : "Container Component Length",
        "(0050,001D)" : "Container Component Diameter",
        "(0050,001E)" : "Container Component Description",
        "(0050,0020)" : JO,
        "(0054,0010)" : hd,
        "(0054,0011)" : KA,
        "(0054,0012)" : IR,
        "(0054,0013)" : Fo,
        "(0054,0014)" : O,
        "(0054,0015)" : tB,
        "(0054,0016)" : IN,
        "(0054,0017)" : tL,
        "(0054,0018)" : Fq,
        "(0054,0020)" : X,
        "(0054,0021)" : zI,
        "(0054,0022)" : hs,
        "(0054,0030)" : Re,
        "(0054,0031)" : Hf,
        "(0054,0032)" : Sn,
        "(0054,0033)" : SH,
        "(0054,0036)" : tM,
        "(0054,0038)" : sT,
        "(0054,0039)" : hW,
        "(0054,0050)" : Dm,
        "(0054,0051)" : vL,
        "(0054,0052)" : cO,
        "(0054,0053)" : cy,
        "(0054,0060)" : pM,
        "(0054,0061)" : KC,
        "(0054,0062)" : GM,
        "(0054,0063)" : dC,
        "(0054,0070)" : nz,
        "(0054,0071)" : jU,
        "(0054,0072)" : pw,
        "(0054,0073)" : Ag,
        "(0054,0080)" : bp,
        "(0054,0081)" : Ct,
        "(0054,0090)" : JQ,
        "(0054,0100)" : wG,
        "(0054,0101)" : q,
        "(0054,0200)" : Ft,
        "(0054,0202)" : SL,
        "(0054,0210)" : IO,
        "(0054,0211)" : vu,
        "(0054,0220)" : HG,
        "(0054,0222)" : AB,
        "(0054,0300)" : dv,
        "(0054,0302)" : En,
        "(0054,0304)" : zn,
        "(0054,0306)" : St,
        "(0054,0308)" : ue,
        "(0054,0400)" : gF,
        "(0054,0410)" : lu,
        "(0054,0412)" : wP,
        "(0054,0414)" : uS,
        "(0054,0500)" : SF,
        "(0054,1000)" : cj,
        "(0054,1001)" : wA,
        "(0054,1002)" : JH,
        "(0054,1004)" : Rl,
        "(0054,1100)" : th,
        "(0054,1101)" : hB,
        "(0054,1102)" : Le,
        "(0054,1103)" : fS,
        "(0054,1104)" : CJ,
        "(0054,1105)" : ki,
        "(0054,1200)" : KY,
        "(0054,1201)" : PU,
        "(0054,1202)" : wz,
        "(0054,1203)" : uO,
        "(0054,1210)" : Fl,
        "(0054,1220)" : uo,
        "(0054,1300)" : Js,
        "(0054,1310)" : eI,
        "(0054,1311)" : sw,
        "(0054,1320)" : uh,
        "(0054,1321)" : RC,
        "(0054,1322)" : Pk,
        "(0054,1323)" : HX,
        "(0054,1324)" : zV,
        "(0054,1330)" : Gl,
        "(0054,1400)" : Mm,
        "(0054,1401)" : Fp,
        "(0060,3000)" : HY,
        "(0060,3002)" : II,
        "(0060,3004)" : Ke,
        "(0060,3006)" : qa,
        "(0060,3008)" : Lb,
        "(0060,3010)" : HN,
        "(0060,3020)" : CM,
        "(0062,0001)" : FG,
        "(0062,0002)" : xR,
        "(0062,0003)" : Ab,
        "(0062,0004)" : iq,
        "(0062,0005)" : yk,
        "(0062,0006)" : nd,
        "(0062,0008)" : Cl,
        "(0062,0009)" : vr,
        "(0062,000A)" : "Segment Identification Sequence",
        "(0062,000B)" : "Referenced Segment Number",
        "(0062,000C)" : "Recommended Display Grayscale Value",
        "(0062,000D)" : "Recommended Display CIELab Value",
        "(0062,000E)" : "Maximum Fractional Value",
        "(0062,000F)" : "Segmented Property Type Code Sequence",
        "(0062,0010)" : OS,
        "(0064,0002)" : Ox,
        "(0064,0003)" : nj,
        "(0064,0005)" : iO,
        "(0064,0007)" : vw,
        "(0064,0008)" : Ar,
        "(0064,0009)" : tC,
        "(0064,000F)" : "Pre Deformation Matrix Registration Sequence",
        "(0064,0010)" : RA,
        "(0066,0001)" : Lz,
        "(0066,0002)" : HF,
        "(0066,0003)" : xp,
        "(0066,0004)" : Kh,
        "(0066,0009)" : iC,
        "(0066,000A)" : "Surface Processing Ratio",
        "(0066,000B)" : "Surface Processing Description",
        "(0066,000C)" : "Recommended Presentation Opacity",
        "(0066,000D)" : "Recommended Presentation Type",
        "(0066,000E)" : "Finite Volume",
        "(0066,0010)" : U,
        "(0066,0011)" : jn,
        "(0066,0012)" : Mu,
        "(0066,0013)" : jA,
        "(0066,0015)" : dF,
        "(0066,0016)" : mY,
        "(0066,0017)" : Ne,
        "(0066,0018)" : hj,
        "(0066,0019)" : Ko,
        "(0066,001A)" : "Points Bounding Box Coordinates",
        "(0066,001B)" : "Axis of Rotation",
        "(0066,001C)" : "Center of Rotation",
        "(0066,001E)" : "Number of Vectors",
        "(0066,001F)" : "Vector Dimensionality",
        "(0066,0020)" : wC,
        "(0066,0021)" : Ad,
        "(0066,0023)" : zN,
        "(0066,0024)" : DM,
        "(0066,0025)" : FV,
        "(0066,0026)" : kh,
        "(0066,0027)" : Di,
        "(0066,0028)" : Iq,
        "(0066,0029)" : HS,
        "(0066,002A)" : "Surface Count",
        "(0066,002B)" : "Referenced Surface Sequence",
        "(0066,002C)" : "Referenced Surface Number",
        "(0066,002D)" : "Segment Surface Generation Algorithm Identification Sequence",
        "(0066,002E)" : "Segment Surface Source Instance Sequence",
        "(0066,002F)" : "Algorithm Family Code Sequence",
        "(0066,0030)" : OO,
        "(0066,0031)" : xv,
        "(0066,0032)" : FX,
        "(0066,0034)" : Ic,
        "(0066,0035)" : Jo,
        "(0066,0036)" : fu,
        "(0070,0001)" : pP,
        "(0070,0002)" : Nq,
        "(0070,0003)" : ph,
        "(0070,0004)" : iN,
        "(0070,0005)" : eS,
        "(0070,0006)" : GQ,
        "(0070,0008)" : vA,
        "(0070,0009)" : sP,
        "(0070,0010)" : Lu,
        "(0070,0011)" : mx,
        "(0070,0012)" : tx,
        "(0070,0014)" : yY,
        "(0070,0015)" : iG,
        "(0070,0020)" : iv,
        "(0070,0021)" : eq,
        "(0070,0022)" : Fw,
        "(0070,0023)" : ma,
        "(0070,0024)" : uc,
        "(0070,0040)" : nG,
        "(0070,0041)" : Dv,
        "(0070,0042)" : gg,
        "(0070,0050)" : cq,
        "(0070,0051)" : rj,
        "(0070,0052)" : Bd,
        "(0070,0053)" : QQ,
        "(0070,005A)" : "Displayed Area Selection Sequence",
        "(0070,0060)" : mW,
        "(0070,0062)" : pU,
        "(0070,0066)" : Jn,
        "(0070,0067)" : zf,
        "(0070,0068)" : ry,
        "(0070,0080)" : CQ,
        "(0070,0081)" : xk,
        "(0070,0082)" : QN,
        "(0070,0083)" : IW,
        "(0070,0084)" : dM,
        "(0070,0086)" : nu,
        "(0070,0087)" : Qw,
        "(0070,0100)" : yC,
        "(0070,0101)" : oa,
        "(0070,0102)" : BJ,
        "(0070,0103)" : Jr,
        "(0070,0207)" : ul,
        "(0070,0208)" : RU,
        "(0070,0209)" : nR,
        "(0070,0226)" : hN,
        "(0070,0227)" : lb,
        "(0070,0228)" : RW,
        "(0070,0229)" : QI,
        "(0070,0230)" : Bw,
        "(0070,0231)" : yU,
        "(0070,0232)" : G,
        "(0070,0233)" : yi,
        "(0070,0234)" : bX,
        "(0070,0241)" : sj,
        "(0070,0242)" : JY,
        "(0070,0243)" : zQ,
        "(0070,0244)" : nX,
        "(0070,0245)" : jS,
        "(0070,0246)" : xo,
        "(0070,0247)" : lA,
        "(0070,0248)" : f,
        "(0070,0249)" : wy,
        "(0070,0250)" : kw,
        "(0070,0251)" : Dp,
        "(0070,0252)" : zp,
        "(0070,0253)" : ys,
        "(0070,0254)" : Ps,
        "(0070,0255)" : td,
        "(0070,0256)" : MY,
        "(0070,0257)" : st,
        "(0070,0258)" : sF,
        "(0070,0261)" : x,
        "(0070,0262)" : yc,
        "(0070,0273)" : Kx,
        "(0070,0274)" : pD,
        "(0070,0278)" : vx,
        "(0070,0279)" : fA,
        "(0070,0282)" : Ga,
        "(0070,0284)" : jT,
        "(0070,0285)" : QD,
        "(0070,0287)" : xC,
        "(0070,0288)" : MP,
        "(0070,0289)" : Ev,
        "(0070,0294)" : Sq,
        "(0070,0295)" : OT,
        "(0070,0306)" : SD,
        "(0070,0308)" : yb,
        "(0070,0309)" : Km,
        "(0070,030A)" : "Matrix Sequence",
        "(0070,030C)" : "Frame of Reference Transformation Matrix Type",
        "(0070,030D)" : "Registration Type Code Sequence",
        "(0070,030F)" : "Fiducial Description",
        "(0070,0310)" : kS,
        "(0070,0311)" : ql,
        "(0070,0312)" : lY,
        "(0070,0314)" : ln,
        "(0070,0318)" : nq,
        "(0070,031A)" : "Fiducial UID",
        "(0070,031C)" : "Fiducial Set Sequence",
        "(0070,031E)" : "Fiducial Sequence",
        "(0070,0401)" : Kb,
        "(0070,0402)" : EB,
        "(0070,0403)" : eg,
        "(0070,0404)" : tU,
        "(0070,0405)" : Sr,
        "(0072,0002)" : lm,
        "(0072,0004)" : ri,
        "(0072,0006)" : LJ,
        "(0072,0008)" : CC,
        "(0072,000A)" : "Hanging Protocol Creation DateTime",
        "(0072,000C)" : "Hanging Protocol Definition Sequence",
        "(0072,000E)" : "Hanging Protocol User Identification Code Sequence",
        "(0072,0010)" : va,
        "(0072,0012)" : AF,
        "(0072,0014)" : IA,
        "(0072,0020)" : Mp,
        "(0072,0022)" : BS,
        "(0072,0024)" : Nb,
        "(0072,0026)" : Jf,
        "(0072,0028)" : Mj,
        "(0072,0030)" : tJ,
        "(0072,0032)" : rV,
        "(0072,0034)" : Nl,
        "(0072,0038)" : PT,
        "(0072,003A)" : "Relative Time Units",
        "(0072,003C)" : "Abstract Prior Value",
        "(0072,003E)" : "Abstract Prior Code Sequence",
        "(0072,0040)" : hV,
        "(0072,0050)" : iF,
        "(0072,0052)" : xV,
        "(0072,0054)" : vk,
        "(0072,0056)" : me,
        "(0072,0060)" : Mq,
        "(0072,0062)" : kt,
        "(0072,0064)" : rb,
        "(0072,0066)" : QA,
        "(0072,0068)" : OE,
        "(0072,006A)" : "Selector PN Value",
        "(0072,006C)" : "Selector SH Value",
        "(0072,006E)" : "Selector ST Value",
        "(0072,0070)" : DV,
        "(0072,0072)" : AM,
        "(0072,0074)" : FC,
        "(0072,0076)" : Ds,
        "(0072,0078)" : qR,
        "(0072,007A)" : "Selector US Value",
        "(0072,007C)" : "Selector SL Value",
        "(0072,007E)" : "Selector SS Value",
        "(0072,0080)" : xG,
        "(0072,0100)" : SQ,
        "(0072,0102)" : xI,
        "(0072,0104)" : ik,
        "(0072,0106)" : La,
        "(0072,0108)" : ep,
        "(0072,010A)" : "Screen Minimum Grayscale Bit Depth",
        "(0072,010C)" : "Screen Minimum Color Bit Depth",
        "(0072,010E)" : "Application Maximum Repaint Time",
        "(0072,0200)" : nN,
        "(0072,0202)" : zB,
        "(0072,0203)" : zy,
        "(0072,0204)" : Li,
        "(0072,0206)" : Do,
        "(0072,0208)" : OY,
        "(0072,0210)" : D,
        "(0072,0212)" : oD,
        "(0072,0214)" : nT,
        "(0072,0216)" : yI,
        "(0072,0218)" : sa,
        "(0072,0300)" : wU,
        "(0072,0302)" : ou,
        "(0072,0304)" : DL,
        "(0072,0306)" : FR,
        "(0072,0308)" : zJ,
        "(0072,0310)" : tc,
        "(0072,0312)" : Hk,
        "(0072,0314)" : P,
        "(0072,0316)" : bt,
        "(0072,0318)" : ha,
        "(0072,0320)" : jf,
        "(0072,0330)" : OL,
        "(0072,0400)" : Gz,
        "(0072,0402)" : BA,
        "(0072,0404)" : fB,
        "(0072,0406)" : HR,
        "(0072,0420)" : wc,
        "(0072,0421)" : oR,
        "(0072,0422)" : yD,
        "(0072,0424)" : OP,
        "(0072,0427)" : mm,
        "(0072,0430)" : Bz,
        "(0072,0432)" : vB,
        "(0072,0434)" : Jd,
        "(0072,0500)" : pK,
        "(0072,0510)" : EG,
        "(0072,0512)" : NB,
        "(0072,0514)" : lq,
        "(0072,0516)" : nP,
        "(0072,0520)" : iw,
        "(0072,0600)" : qf,
        "(0072,0602)" : JL,
        "(0072,0604)" : Oo,
        "(0072,0700)" : FK,
        "(0072,0702)" : Nx,
        "(0072,0704)" : lk,
        "(0072,0706)" : Id,
        "(0072,0710)" : wW,
        "(0072,0712)" : hP,
        "(0072,0714)" : jN,
        "(0072,0716)" : RM,
        "(0072,0717)" : KN,
        "(0072,0718)" : ll,
        "(0074,1000)" : FF,
        "(0074,1002)" : ia,
        "(0074,1004)" : JT,
        "(0074,1006)" : jt,
        "(0074,1008)" : xh,
        "(0074,100a)" : LA,
        "(0074,100c)" : Cn,
        "(0074,100e)" : on,
        "(0074,1020)" : ke,
        "(0074,1022)" : Bf,
        "(0074,1024)" : xU,
        "(0074,1030)" : nL,
        "(0074,1032)" : Go,
        "(0074,1034)" : EP,
        "(0074,1036)" : qe,
        "(0074,1038)" : qU,
        "(0074,103A)" : "Double Exposure Field Delta",
        "(0074,1040)" : BC,
        "(0074,1042)" : nK,
        "(0074,1044)" : rW,
        "(0074,1046)" : wh,
        "(0074,1048)" : GK,
        "(0074,104A)" : "Overridden Attributes Sequence",
        "(0074,104C)" : "Conventional Control Point Verification Sequence",
        "(0074,104E)" : "Ion Control Point Verification Sequence",
        "(0074,1050)" : Fd,
        "(0074,1052)" : HQ,
        "(0074,1054)" : df,
        "(0074,1056)" : Fr,
        "(0074,1200)" : Aj,
        "(0074,1202)" : OF,
        "(0074,1204)" : dL,
        "(0074,1210)" : Gs,
        "(0074,1212)" : An,
        "(0074,1216)" : or,
        "(0074,1220)" : HM,
        "(0074,1222)" : IH,
        "(0074,1230)" : AP,
        "(0074,1234)" : Jy,
        "(0074,1236)" : RH,
        "(0074,1238)" : oW,
        "(0074,1242)" : mc,
        "(0074,1244)" : AT,
        "(0074,1246)" : Lv,
        "(0088,0130)" : Fc,
        "(0088,0140)" : LG,
        "(0088,0200)" : wH,
        "(0088,0904)" : CY,
        "(0088,0906)" : DE,
        "(0088,0910)" : cw,
        "(0088,0912)" : Qe,
        "(0100,0410)" : tV,
        "(0100,0420)" : uE,
        "(0100,0424)" : GF,
        "(0100,0426)" : jJ,
        "(0400,0005)" : Qf,
        "(0400,0010)" : eQ,
        "(0400,0015)" : n,
        "(0400,0020)" : ej,
        "(0400,0100)" : dm,
        "(0400,0105)" : FL,
        "(0400,0110)" : OB,
        "(0400,0115)" : fF,
        "(0400,0120)" : iV,
        "(0400,0305)" : I,
        "(0400,0310)" : je,
        "(0400,0401)" : T,
        "(0400,0402)" : OK,
        "(0400,0403)" : BO,
        "(0400,0404)" : pB,
        "(0400,0500)" : Es,
        "(0400,0510)" : Gy,
        "(0400,0520)" : pk,
        "(0400,0550)" : so,
        "(0400,0561)" : iW,
        "(0400,0562)" : wB,
        "(0400,0563)" : Af,
        "(0400,0564)" : Dw,
        "(0400,0565)" : uA,
        "(1000,xxx0)" : sn,
        "(1000,xxx1)" : lz,
        "(1000,xxx2)" : El,
        "(1000,xxx3)" : iI,
        "(1000,xxx4)" : DB,
        "(1000,xxx5)" : Ib,
        "(1010,xxxx)" : BV,
        "(2000,0010)" : NJ,
        "(2000,001E)" : "Printer Configuration Sequence",
        "(2000,0020)" : Dc,
        "(2000,0030)" : LR,
        "(2000,0040)" : EJ,
        "(2000,0050)" : Qc,
        "(2000,0060)" : oh,
        "(2000,0061)" : Cc,
        "(2000,0062)" : gP,
        "(2000,0063)" : KX,
        "(2000,0065)" : gb,
        "(2000,0067)" : HE,
        "(2000,0069)" : GC,
        "(2000,006A)" : "Image Box Presentation LUT Flag",
        "(2000,00A0)" : "Memory Bit Depth",
        "(2000,00A1)" : "Printing Bit Depth",
        "(2000,00A2)" : "Media Installed Sequence",
        "(2000,00A4)" : "Other Media Available Sequence",
        "(2000,00A8)" : "Supported Image Display Formats Sequence",
        "(2000,0500)" : vi,
        "(2000,0510)" : wF,
        "(2010,0010)" : yB,
        "(2010,0030)" : kr,
        "(2010,0040)" : wd,
        "(2010,0050)" : Jm,
        "(2010,0052)" : Ex,
        "(2010,0054)" : RK,
        "(2010,0060)" : Od,
        "(2010,0080)" : ef,
        "(2010,00A6)" : "Default Magnification Type",
        "(2010,00A7)" : "Other Magnification Types Available",
        "(2010,00A8)" : "Default Smoothing Type",
        "(2010,00A9)" : "Other Smoothing Types Available",
        "(2010,0100)" : bb,
        "(2010,0110)" : dX,
        "(2010,0120)" : JK,
        "(2010,0130)" : ol,
        "(2010,0140)" : gq,
        "(2010,0150)" : gr,
        "(2010,0152)" : Sf,
        "(2010,0154)" : cp,
        "(2010,015E)" : "Illumination",
        "(2010,0160)" : oX,
        "(2010,0376)" : Iu,
        "(2010,0500)" : kv,
        "(2010,0510)" : ka,
        "(2010,0520)" : SK,
        "(2020,0010)" : vU,
        "(2020,0020)" : Ew,
        "(2020,0030)" : hE,
        "(2020,0040)" : l,
        "(2020,0050)" : uV,
        "(2020,00A0)" : "Requested Image Size Flag",
        "(2020,00A2)" : "Decimate/Crop Result",
        "(2020,0110)" : C,
        "(2020,0111)" : EN,
        "(2020,0130)" : Ob,
        "(2020,0140)" : fD,
        "(2030,0010)" : LY,
        "(2030,0020)" : kq,
        "(2040,0010)" : Gr,
        "(2040,0011)" : AR,
        "(2040,0020)" : xs,
        "(2040,0060)" : tO,
        "(2040,0070)" : sd,
        "(2040,0072)" : ui,
        "(2040,0074)" : dB,
        "(2040,0080)" : wK,
        "(2040,0082)" : uB,
        "(2040,0090)" : tj,
        "(2040,0100)" : Hh,
        "(2040,0500)" : DN,
        "(2050,0010)" : wl,
        "(2050,0020)" : DH,
        "(2050,0500)" : Br,
        "(2100,0010)" : Pc,
        "(2100,0020)" : tk,
        "(2100,0030)" : Ak,
        "(2100,0040)" : yR,
        "(2100,0050)" : QE,
        "(2100,0070)" : DT,
        "(2100,0140)" : dl,
        "(2100,0160)" : Jj,
        "(2100,0170)" : vl,
        "(2100,0500)" : sW,
        "(2110,0010)" : pQ,
        "(2110,0020)" : qg,
        "(2110,0030)" : HI,
        "(2110,0099)" : eO,
        "(2120,0010)" : BG,
        "(2120,0050)" : mU,
        "(2120,0070)" : OI,
        "(2130,0010)" : zh,
        "(2130,0015)" : xW,
        "(2130,0030)" : qz,
        "(2130,0040)" : Pi,
        "(2130,0050)" : NO,
        "(2130,0060)" : Rx,
        "(2130,0080)" : Bk,
        "(2130,00A0)" : "Proposed Study Sequence",
        "(2130,00C0)" : "Original Image Sequence",
        "(2200,0001)" : pf,
        "(2200,0002)" : Mx,
        "(2200,0003)" : Qv,
        "(2200,0004)" : AW,
        "(2200,0005)" : Jt,
        "(2200,0006)" : gV,
        "(2200,0007)" : AI,
        "(2200,0008)" : vM,
        "(2200,0009)" : mE,
        "(2200,000A)" : "Preserve Composite Instances After Media Creation",
        "(2200,000B)" : "Total Number of Pieces of Media Created",
        "(2200,000C)" : "Requested Media Application Profile",
        "(2200,000D)" : "Referenced Storage Media Sequence",
        "(2200,000E)" : "Failure Attributes",
        "(2200,000F)" : "Allow Lossy Compression",
        "(2200,0020)" : ld,
        "(3002,0002)" : xP,
        "(3002,0003)" : LI,
        "(3002,0004)" : qi,
        "(3002,000A)" : "Reported Values Origin",
        "(3002,000C)" : "RT Image Plane",
        "(3002,000D)" : "X-Ray Image Receptor Translation",
        "(3002,000E)" : "X-Ray Image Receptor Angle",
        "(3002,0010)" : bc,
        "(3002,0011)" : ra,
        "(3002,0012)" : QM,
        "(3002,0020)" : em,
        "(3002,0022)" : dw,
        "(3002,0024)" : Sb,
        "(3002,0026)" : lO,
        "(3002,0028)" : qH,
        "(3002,0029)" : RR,
        "(3002,0030)" : Cv,
        "(3002,0032)" : ey,
        "(3002,0034)" : rY,
        "(3002,0040)" : mD,
        "(3002,0041)" : qP,
        "(3002,0042)" : un,
        "(3002,0050)" : tb,
        "(3002,0051)" : BQ,
        "(3002,0052)" : tG,
        "(3004,0001)" : o,
        "(3004,0002)" : Ba,
        "(3004,0004)" : c,
        "(3004,0006)" : KW,
        "(3004,0008)" : bg,
        "(3004,000A)" : "Dose Summation Type",
        "(3004,000C)" : "Grid Frame Offset Vector",
        "(3004,000E)" : "Dose Grid Scaling",
        "(3004,0010)" : AS,
        "(3004,0012)" : hI,
        "(3004,0014)" : to,
        "(3004,0040)" : yd,
        "(3004,0042)" : rK,
        "(3004,0050)" : Jp,
        "(3004,0052)" : zX,
        "(3004,0054)" : cs,
        "(3004,0056)" : yx,
        "(3004,0058)" : RB,
        "(3004,0060)" : kz,
        "(3004,0062)" : kn,
        "(3004,0070)" : Mo,
        "(3004,0072)" : uz,
        "(3004,0074)" : nA,
        "(3006,0002)" : gS,
        "(3006,0004)" : GB,
        "(3006,0006)" : KJ,
        "(3006,0008)" : Py,
        "(3006,0009)" : ho,
        "(3006,0010)" : ge,
        "(3006,0012)" : QH,
        "(3006,0014)" : mK,
        "(3006,0016)" : iK,
        "(3006,0020)" : Pn,
        "(3006,0022)" : EM,
        "(3006,0024)" : EH,
        "(3006,0026)" : Hs,
        "(3006,0028)" : Pv,
        "(3006,002A)" : "ROI Display Color",
        "(3006,002C)" : "ROI Volume",
        "(3006,0030)" : rO,
        "(3006,0033)" : bF,
        "(3006,0036)" : kX,
        "(3006,0038)" : gE,
        "(3006,0039)" : Rp,
        "(3006,0040)" : dj,
        "(3006,0042)" : FA,
        "(3006,0044)" : lo,
        "(3006,0045)" : PN,
        "(3006,0046)" : tW,
        "(3006,0048)" : oN,
        "(3006,0049)" : wI,
        "(3006,0050)" : Ph,
        "(3006,0080)" : sQ,
        "(3006,0082)" : eo,
        "(3006,0084)" : zW,
        "(3006,0085)" : tv,
        "(3006,0086)" : nf,
        "(3006,0088)" : Dt,
        "(3006,00A0)" : "Related RT ROI Observations Sequence",
        "(3006,00A4)" : "RT ROI Interpreted Type",
        "(3006,00A6)" : "ROI Interpreter",
        "(3006,00B0)" : "ROI Physical Properties Sequence",
        "(3006,00B2)" : "ROI Physical Property",
        "(3006,00B4)" : "ROI Physical Property Value",
        "(3006,00B6)" : "ROI Elemental Composition Sequence",
        "(3006,00B7)" : "ROI Elemental Composition Atomic Number",
        "(3006,00B8)" : "ROI Elemental Composition Atomic Mass Fraction",
        "(3006,00C0)" : "Frame of Reference Relationship Sequence",
        "(3006,00C2)" : "Related Frame of Reference UID",
        "(3006,00C4)" : "Frame of Reference Transformation Type",
        "(3006,00C6)" : "Frame of Reference Transformation Matrix",
        "(3006,00C8)" : "Frame of Reference Transformation Comment",
        "(3008,0010)" : Qh,
        "(3008,0012)" : eP,
        "(3008,0014)" : tw,
        "(3008,0016)" : ES,
        "(3008,0020)" : cY,
        "(3008,0021)" : fq,
        "(3008,0022)" : ko,
        "(3008,0024)" : lr,
        "(3008,0025)" : Rm,
        "(3008,002A)" : "Treatment Termination Status",
        "(3008,002B)" : "Treatment Termination Code",
        "(3008,002C)" : "Treatment Verification Status",
        "(3008,0030)" : xO,
        "(3008,0032)" : E,
        "(3008,0033)" : qB,
        "(3008,0036)" : gH,
        "(3008,0037)" : ya,
        "(3008,003A)" : "Specified Treatment Time",
        "(3008,003B)" : "Delivered Treatment Time",
        "(3008,0040)" : xT,
        "(3008,0041)" : eX,
        "(3008,0042)" : gG,
        "(3008,0044)" : MA,
        "(3008,0045)" : jz,
        "(3008,0046)" : Nd,
        "(3008,0047)" : mT,
        "(3008,0048)" : wD,
        "(3008,0050)" : bI,
        "(3008,0052)" : ye,
        "(3008,0054)" : JJ,
        "(3008,0056)" : mt,
        "(3008,005A)" : "Number of Fractions Delivered",
        "(3008,0060)" : ez,
        "(3008,0061)" : oF,
        "(3008,0062)" : Hl,
        "(3008,0063)" : Kr,
        "(3008,0064)" : BF,
        "(3008,0065)" : la,
        "(3008,0066)" : bB,
        "(3008,0068)" : gT,
        "(3008,006A)" : "Correction Value",
        "(3008,0070)" : Mw,
        "(3008,0072)" : cA,
        "(3008,0074)" : d,
        "(3008,0076)" : hx,
        "(3008,0078)" : hz,
        "(3008,007A)" : "End Meterset",
        "(3008,0080)" : Ay,
        "(3008,0082)" : cD,
        "(3008,0090)" : Et,
        "(3008,0092)" : tH,
        "(3008,00A0)" : "Beam Limiting Device Leaf Pairs Sequence",
        "(3008,00B0)" : "Recorded Wedge Sequence",
        "(3008,00C0)" : "Recorded Compensator Sequence",
        "(3008,00D0)" : "Recorded Block Sequence",
        "(3008,00E0)" : "Treatment Summary Measured Dose Reference Sequence",
        "(3008,00F0)" : "Recorded Snout Sequence",
        "(3008,00F2)" : "Recorded Range Shifter Sequence",
        "(3008,00F4)" : "Recorded Lateral Spreading Device Sequence",
        "(3008,00F6)" : "Recorded Range Modulator Sequence",
        "(3008,0100)" : kM,
        "(3008,0105)" : h,
        "(3008,0110)" : sB,
        "(3008,0116)" : Sl,
        "(3008,0120)" : gQ,
        "(3008,0122)" : kJ,
        "(3008,0130)" : hU,
        "(3008,0132)" : OG,
        "(3008,0134)" : NY,
        "(3008,0136)" : oz,
        "(3008,0138)" : dk,
        "(3008,013A)" : "Specified Pulse Repetition Interval",
        "(3008,013C)" : "Delivered Pulse Repetition Interval",
        "(3008,0140)" : Dx,
        "(3008,0142)" : tS,
        "(3008,0150)" : jO,
        "(3008,0152)" : SE,
        "(3008,0160)" : Ov,
        "(3008,0162)" : Qg,
        "(3008,0164)" : fv,
        "(3008,0166)" : jC,
        "(3008,0168)" : LW,
        "(3008,0200)" : rL,
        "(3008,0202)" : Ao,
        "(3008,0220)" : lN,
        "(3008,0223)" : Ep,
        "(3008,0224)" : Qo,
        "(3008,0230)" : FU,
        "(3008,0240)" : CV,
        "(3008,0250)" : qt,
        "(3008,0251)" : kO,
        "(300A,0002)" : "RT Plan Label",
        "(300A,0003)" : "RT Plan Name",
        "(300A,0004)" : "RT Plan Description",
        "(300A,0006)" : "RT Plan Date",
        "(300A,0007)" : "RT Plan Time",
        "(300A,0009)" : "Treatment Protocols",
        "(300A,000A)" : "Plan Intent",
        "(300A,000B)" : "Treatment Sites",
        "(300A,000C)" : "RT Plan Geometry",
        "(300A,000E)" : "Prescription Description",
        "(300A,0010)" : "Dose Reference Sequence",
        "(300A,0012)" : "Dose Reference Number",
        "(300A,0013)" : "Dose Reference UID",
        "(300A,0014)" : "Dose Reference Structure Type",
        "(300A,0015)" : "Nominal Beam Energy Unit",
        "(300A,0016)" : "Dose Reference Description",
        "(300A,0018)" : "Dose Reference Point Coordinates",
        "(300A,001A)" : "Nominal Prior Dose",
        "(300A,0020)" : "Dose Reference Type",
        "(300A,0021)" : "Constraint Weight",
        "(300A,0022)" : "Delivery Warning Dose",
        "(300A,0023)" : "Delivery Maximum Dose",
        "(300A,0025)" : "Target Minimum Dose",
        "(300A,0026)" : "Target Prescription Dose",
        "(300A,0027)" : "Target Maximum Dose",
        "(300A,0028)" : "Target Underdose Volume Fraction",
        "(300A,002A)" : "Organ at Risk Full-volume Dose",
        "(300A,002B)" : "Organ at Risk Limit Dose",
        "(300A,002C)" : "Organ at Risk Maximum Dose",
        "(300A,002D)" : "Organ at Risk Overdose Volume Fraction",
        "(300A,0040)" : "Tolerance Table Sequence",
        "(300A,0042)" : "Tolerance Table Number",
        "(300A,0043)" : "Tolerance Table Label",
        "(300A,0044)" : "Gantry Angle Tolerance",
        "(300A,0046)" : "Beam Limiting Device Angle Tolerance",
        "(300A,0048)" : "Beam Limiting Device Tolerance Sequence",
        "(300A,004A)" : "Beam Limiting Device Position Tolerance",
        "(300A,004B)" : "Snout Position Tolerance",
        "(300A,004C)" : "Patient Support Angle Tolerance",
        "(300A,004E)" : "Table Top Eccentric Angle Tolerance",
        "(300A,004F)" : "Table Top Pitch Angle Tolerance",
        "(300A,0050)" : "Table Top Roll Angle Tolerance",
        "(300A,0051)" : "Table Top Vertical Position Tolerance",
        "(300A,0052)" : "Table Top Longitudinal Position Tolerance",
        "(300A,0053)" : "Table Top Lateral Position Tolerance",
        "(300A,0055)" : "RT Plan Relationship",
        "(300A,0070)" : "Fraction Group Sequence",
        "(300A,0071)" : "Fraction Group Number",
        "(300A,0072)" : "Fraction Group Description",
        "(300A,0078)" : "Number of Fractions Planned",
        "(300A,0079)" : "Number of Fraction Pattern Digits Per Day",
        "(300A,007A)" : "Repeat Fraction Cycle Length",
        "(300A,007B)" : "Fraction Pattern",
        "(300A,0080)" : "Number of Beams",
        "(300A,0082)" : "Beam Dose Specification Point",
        "(300A,0084)" : "Beam Dose",
        "(300A,0086)" : "Beam Meterset",
        "(300A,0088)" : "Beam Dose Point Depth",
        "(300A,0089)" : "Beam Dose Point Equivalent Depth",
        "(300A,008A)" : "Beam Dose Point SSD",
        "(300A,00A0)" : "Number of Brachy Application Setups",
        "(300A,00A2)" : "Brachy Application Setup Dose Specification Point",
        "(300A,00A4)" : "Brachy Application Setup Dose",
        "(300A,00B0)" : "Beam Sequence",
        "(300A,00B2)" : "Treatment Machine Name",
        "(300A,00B3)" : "Primary Dosimeter Unit",
        "(300A,00B4)" : "Source-Axis Distance",
        "(300A,00B6)" : "Beam Limiting Device Sequence",
        "(300A,00B8)" : "RT Beam Limiting Device Type",
        "(300A,00BA)" : "Source to Beam Limiting Device Distance",
        "(300A,00BB)" : "Isocenter to Beam Limiting Device Distance",
        "(300A,00BC)" : "Number of Leaf/Jaw Pairs",
        "(300A,00BE)" : "Leaf Position Boundaries",
        "(300A,00C0)" : "Beam Number",
        "(300A,00C2)" : "Beam Name",
        "(300A,00C3)" : "Beam Description",
        "(300A,00C4)" : "Beam Type",
        "(300A,00C6)" : "Radiation Type",
        "(300A,00C7)" : "High-Dose Technique Type",
        "(300A,00C8)" : "Reference Image Number",
        "(300A,00CA)" : "Planned Verification Image Sequence",
        "(300A,00CC)" : "Imaging Device-Specific Acquisition Parameters",
        "(300A,00CE)" : "Treatment Delivery Type",
        "(300A,00D0)" : "Number of Wedges",
        "(300A,00D1)" : "Wedge Sequence",
        "(300A,00D2)" : "Wedge Number",
        "(300A,00D3)" : "Wedge Type",
        "(300A,00D4)" : "Wedge ID",
        "(300A,00D5)" : "Wedge Angle",
        "(300A,00D6)" : "Wedge Factor",
        "(300A,00D7)" : "Total Wedge Tray Water-Equivalent Thickness",
        "(300A,00D8)" : "Wedge Orientation",
        "(300A,00D9)" : "Isocenter to Wedge Tray Distance",
        "(300A,00DA)" : "Source to Wedge Tray Distance",
        "(300A,00DB)" : "Wedge Thin Edge Position",
        "(300A,00DC)" : "Bolus ID",
        "(300A,00DD)" : "Bolus Description",
        "(300A,00E0)" : "Number of Compensators",
        "(300A,00E1)" : "Material ID",
        "(300A,00E2)" : "Total Compensator Tray Factor",
        "(300A,00E3)" : "Compensator Sequence",
        "(300A,00E4)" : "Compensator Number",
        "(300A,00E5)" : "Compensator ID",
        "(300A,00E6)" : "Source to Compensator Tray Distance",
        "(300A,00E7)" : "Compensator Rows",
        "(300A,00E8)" : "Compensator Columns",
        "(300A,00E9)" : "Compensator Pixel Spacing",
        "(300A,00EA)" : "Compensator Position",
        "(300A,00EB)" : "Compensator Transmission Data",
        "(300A,00EC)" : "Compensator Thickness Data",
        "(300A,00ED)" : "Number of Boli",
        "(300A,00EE)" : "Compensator Type",
        "(300A,00F0)" : "Number of Blocks",
        "(300A,00F2)" : "Total Block Tray Factor",
        "(300A,00F3)" : "Total Block Tray Water-Equivalent Thickness",
        "(300A,00F4)" : "Block Sequence",
        "(300A,00F5)" : "Block Tray ID",
        "(300A,00F6)" : "Source to Block Tray Distance",
        "(300A,00F7)" : "Isocenter to Block Tray Distance",
        "(300A,00F8)" : "Block Type",
        "(300A,00F9)" : "Accessory Code",
        "(300A,00FA)" : "Block Divergence",
        "(300A,00FB)" : "Block Mounting Position",
        "(300A,00FC)" : "Block Number",
        "(300A,00FE)" : "Block Name",
        "(300A,0100)" : "Block Thickness",
        "(300A,0102)" : "Block Transmission",
        "(300A,0104)" : "Block Number of Points",
        "(300A,0106)" : "Block Data",
        "(300A,0107)" : "Applicator Sequence",
        "(300A,0108)" : "Applicator ID",
        "(300A,0109)" : "Applicator Type",
        "(300A,010A)" : "Applicator Description",
        "(300A,010C)" : "Cumulative Dose Reference Coefficient",
        "(300A,010E)" : "Final Cumulative Meterset Weight",
        "(300A,0110)" : "Number of Control Points",
        "(300A,0111)" : "Control Point Sequence",
        "(300A,0112)" : "Control Point Index",
        "(300A,0114)" : "Nominal Beam Energy",
        "(300A,0115)" : "Dose Rate Set",
        "(300A,0116)" : "Wedge Position Sequence",
        "(300A,0118)" : "Wedge Position",
        "(300A,011A)" : "Beam Limiting Device Position Sequence",
        "(300A,011C)" : "Leaf/Jaw Positions",
        "(300A,011E)" : "Gantry Angle",
        "(300A,011F)" : "Gantry Rotation Direction",
        "(300A,0120)" : "Beam Limiting Device Angle",
        "(300A,0121)" : "Beam Limiting Device Rotation Direction",
        "(300A,0122)" : "Patient Support Angle",
        "(300A,0123)" : "Patient Support Rotation Direction",
        "(300A,0124)" : "Table Top Eccentric Axis Distance",
        "(300A,0125)" : "Table Top Eccentric Angle",
        "(300A,0126)" : "Table Top Eccentric Rotation Direction",
        "(300A,0128)" : "Table Top Vertical Position",
        "(300A,0129)" : "Table Top Longitudinal Position",
        "(300A,012A)" : "Table Top Lateral Position",
        "(300A,012C)" : "Isocenter Position",
        "(300A,012E)" : "Surface Entry Point",
        "(300A,0130)" : "Source to Surface Distance",
        "(300A,0134)" : "Cumulative Meterset Weight",
        "(300A,0140)" : "Table Top Pitch Angle",
        "(300A,0142)" : "Table Top Pitch Rotation Direction",
        "(300A,0144)" : "Table Top Roll Angle",
        "(300A,0146)" : "Table Top Roll Rotation Direction",
        "(300A,0148)" : "Head Fixation Angle",
        "(300A,014A)" : "Gantry Pitch Angle",
        "(300A,014C)" : "Gantry Pitch Rotation Direction",
        "(300A,014E)" : "Gantry Pitch Angle Tolerance",
        "(300A,0180)" : "Patient Setup Sequence",
        "(300A,0182)" : "Patient Setup Number",
        "(300A,0183)" : "Patient Setup Label",
        "(300A,0184)" : "Patient Additional Position",
        "(300A,0190)" : "Fixation Device Sequence",
        "(300A,0192)" : "Fixation Device Type",
        "(300A,0194)" : "Fixation Device Label",
        "(300A,0196)" : "Fixation Device Description",
        "(300A,0198)" : "Fixation Device Position",
        "(300A,0199)" : "Fixation Device Pitch Angle",
        "(300A,019A)" : "Fixation Device Roll Angle",
        "(300A,01A0)" : "Shielding Device Sequence",
        "(300A,01A2)" : "Shielding Device Type",
        "(300A,01A4)" : "Shielding Device Label",
        "(300A,01A6)" : "Shielding Device Description",
        "(300A,01A8)" : "Shielding Device Position",
        "(300A,01B0)" : "Setup Technique",
        "(300A,01B2)" : "Setup Technique Description",
        "(300A,01B4)" : "Setup Device Sequence",
        "(300A,01B6)" : "Setup Device Type",
        "(300A,01B8)" : "Setup Device Label",
        "(300A,01BA)" : "Setup Device Description",
        "(300A,01BC)" : "Setup Device Parameter",
        "(300A,01D0)" : "Setup Reference Description",
        "(300A,01D2)" : "Table Top Vertical Setup Displacement",
        "(300A,01D4)" : "Table Top Longitudinal Setup Displacement",
        "(300A,01D6)" : "Table Top Lateral Setup Displacement",
        "(300A,0200)" : "Brachy Treatment Technique",
        "(300A,0202)" : "Brachy Treatment Type",
        "(300A,0206)" : "Treatment Machine Sequence",
        "(300A,0210)" : "Source Sequence",
        "(300A,0212)" : "Source Number",
        "(300A,0214)" : "Source Type",
        "(300A,0216)" : "Source Manufacturer",
        "(300A,0218)" : "Active Source Diameter",
        "(300A,021A)" : "Active Source Length",
        "(300A,0222)" : "Source Encapsulation Nominal Thickness",
        "(300A,0224)" : "Source Encapsulation Nominal Transmission",
        "(300A,0226)" : "Source Isotope Name",
        "(300A,0228)" : "Source Isotope Half Life",
        "(300A,0229)" : "Source Strength Units",
        "(300A,022A)" : "Reference Air Kerma Rate",
        "(300A,022B)" : "Source Strength",
        "(300A,022C)" : "Source Strength Reference Date",
        "(300A,022E)" : "Source Strength Reference Time",
        "(300A,0230)" : "Application Setup Sequence",
        "(300A,0232)" : "Application Setup Type",
        "(300A,0234)" : "Application Setup Number",
        "(300A,0236)" : "Application Setup Name",
        "(300A,0238)" : "Application Setup Manufacturer",
        "(300A,0240)" : "Template Number",
        "(300A,0242)" : "Template Type",
        "(300A,0244)" : "Template Name",
        "(300A,0250)" : "Total Reference Air Kerma",
        "(300A,0260)" : "Brachy Accessory Device Sequence",
        "(300A,0262)" : "Brachy Accessory Device Number",
        "(300A,0263)" : "Brachy Accessory Device ID",
        "(300A,0264)" : "Brachy Accessory Device Type",
        "(300A,0266)" : "Brachy Accessory Device Name",
        "(300A,026A)" : "Brachy Accessory Device Nominal Thickness",
        "(300A,026C)" : "Brachy Accessory Device Nominal Transmission",
        "(300A,0280)" : "Channel Sequence",
        "(300A,0282)" : "Channel Number",
        "(300A,0284)" : "Channel Length",
        "(300A,0286)" : "Channel Total Time",
        "(300A,0288)" : "Source Movement Type",
        "(300A,028A)" : "Number of Pulses",
        "(300A,028C)" : "Pulse Repetition Interval",
        "(300A,0290)" : "Source Applicator Number",
        "(300A,0291)" : "Source Applicator ID",
        "(300A,0292)" : "Source Applicator Type",
        "(300A,0294)" : "Source Applicator Name",
        "(300A,0296)" : "Source Applicator Length",
        "(300A,0298)" : "Source Applicator Manufacturer",
        "(300A,029C)" : "Source Applicator Wall Nominal Thickness",
        "(300A,029E)" : "Source Applicator Wall Nominal Transmission",
        "(300A,02A0)" : "Source Applicator Step Size",
        "(300A,02A2)" : "Transfer Tube Number",
        "(300A,02A4)" : "Transfer Tube Length",
        "(300A,02B0)" : "Channel Shield Sequence",
        "(300A,02B2)" : "Channel Shield Number",
        "(300A,02B3)" : "Channel Shield ID",
        "(300A,02B4)" : "Channel Shield Name",
        "(300A,02B8)" : "Channel Shield Nominal Thickness",
        "(300A,02BA)" : "Channel Shield Nominal Transmission",
        "(300A,02C8)" : "Final Cumulative Time Weight",
        "(300A,02D0)" : "Brachy Control Point Sequence",
        "(300A,02D2)" : "Control Point Relative Position",
        "(300A,02D4)" : "Control Point 3D Position",
        "(300A,02D6)" : "Cumulative Time Weight",
        "(300A,02E0)" : "Compensator Divergence",
        "(300A,02E1)" : "Compensator Mounting Position",
        "(300A,02E2)" : "Source to Compensator Distance",
        "(300A,02E3)" : "Total Compensator Tray Water-Equivalent Thickness",
        "(300A,02E4)" : "Isocenter to Compensator Tray Distance",
        "(300A,02E5)" : "Compensator Column Offset",
        "(300A,02E6)" : "Isocenter to Compensator Distances",
        "(300A,02E7)" : "Compensator Relative Stopping Power Ratio",
        "(300A,02E8)" : "Compensator Milling Tool Diameter",
        "(300A,02EA)" : "Ion Range Compensator Sequence",
        "(300A,02EB)" : "Compensator Description",
        "(300A,0302)" : "Radiation Mass Number",
        "(300A,0304)" : "Radiation Atomic Number",
        "(300A,0306)" : "Radiation Charge State",
        "(300A,0308)" : "Scan Mode",
        "(300A,030A)" : "Virtual Source-Axis Distances",
        "(300A,030C)" : "Snout Sequence",
        "(300A,030D)" : "Snout Position",
        "(300A,030F)" : "Snout ID",
        "(300A,0312)" : "Number of Range Shifters",
        "(300A,0314)" : "Range Shifter Sequence",
        "(300A,0316)" : "Range Shifter Number",
        "(300A,0318)" : "Range Shifter ID",
        "(300A,0320)" : "Range Shifter Type",
        "(300A,0322)" : "Range Shifter Description",
        "(300A,0330)" : "Number of Lateral Spreading Devices",
        "(300A,0332)" : "Lateral Spreading Device Sequence",
        "(300A,0334)" : "Lateral Spreading Device Number",
        "(300A,0336)" : "Lateral Spreading Device ID",
        "(300A,0338)" : "Lateral Spreading Device Type",
        "(300A,033A)" : "Lateral Spreading Device Description",
        "(300A,033C)" : "Lateral Spreading Device Water Equivalent Thickness",
        "(300A,0340)" : "Number of Range Modulators",
        "(300A,0342)" : "Range Modulator Sequence",
        "(300A,0344)" : "Range Modulator Number",
        "(300A,0346)" : "Range Modulator ID",
        "(300A,0348)" : "Range Modulator Type",
        "(300A,034A)" : "Range Modulator Description",
        "(300A,034C)" : "Beam Current Modulation ID",
        "(300A,0350)" : "Patient Support Type",
        "(300A,0352)" : "Patient Support ID",
        "(300A,0354)" : "Patient Support Accessory Code",
        "(300A,0356)" : "Fixation Light Azimuthal Angle",
        "(300A,0358)" : "Fixation Light Polar Angle",
        "(300A,035A)" : "Meterset Rate",
        "(300A,0360)" : "Range Shifter Settings Sequence",
        "(300A,0362)" : "Range Shifter Setting",
        "(300A,0364)" : "Isocenter to Range Shifter Distance",
        "(300A,0366)" : "Range Shifter Water Equivalent Thickness",
        "(300A,0370)" : "Lateral Spreading Device Settings Sequence",
        "(300A,0372)" : "Lateral Spreading Device Setting",
        "(300A,0374)" : "Isocenter to Lateral Spreading Device Distance",
        "(300A,0380)" : "Range Modulator Settings Sequence",
        "(300A,0382)" : "Range Modulator Gating Start Value",
        "(300A,0384)" : "Range Modulator Gating Stop Value",
        "(300A,0386)" : "Range Modulator Gating Start Water Equivalent Thickness",
        "(300A,0388)" : "Range Modulator Gating Stop Water Equivalent Thickness",
        "(300A,038A)" : "Isocenter to Range Modulator Distance",
        "(300A,0390)" : "Scan Spot Tune ID",
        "(300A,0392)" : "Number of Scan Spot Positions",
        "(300A,0394)" : "Scan Spot Position Map",
        "(300A,0396)" : "Scan Spot Meterset Weights",
        "(300A,0398)" : "Scanning Spot Size",
        "(300A,039A)" : "Number of Paintings",
        "(300A,03A0)" : "Ion Tolerance Table Sequence",
        "(300A,03A2)" : "Ion Beam Sequence",
        "(300A,03A4)" : "Ion Beam Limiting Device Sequence",
        "(300A,03A6)" : "Ion Block Sequence",
        "(300A,03A8)" : "Ion Control Point Sequence",
        "(300A,03AA)" : "Ion Wedge Sequence",
        "(300A,03AC)" : "Ion Wedge Position Sequence",
        "(300A,0401)" : "Referenced Setup Image Sequence",
        "(300A,0402)" : "Setup Image Comment",
        "(300A,0410)" : "Motion Synchronization Sequence",
        "(300A,0412)" : "Control Point Orientation",
        "(300A,0420)" : "General Accessory Sequence",
        "(300A,0421)" : "General Accessory ID",
        "(300A,0422)" : "General Accessory Description",
        "(300A,0423)" : "General Accessory Type",
        "(300A,0424)" : "General Accessory Number",
        "(300C,0002)" : "Referenced RT Plan Sequence",
        "(300C,0004)" : "Referenced Beam Sequence",
        "(300C,0006)" : "Referenced Beam Number",
        "(300C,0007)" : "Referenced Reference Image Number",
        "(300C,0008)" : "Start Cumulative Meterset Weight",
        "(300C,0009)" : "End Cumulative Meterset Weight",
        "(300C,000A)" : "Referenced Brachy Application Setup Sequence",
        "(300C,000C)" : "Referenced Brachy Application Setup Number",
        "(300C,000E)" : "Referenced Source Number",
        "(300C,0020)" : "Referenced Fraction Group Sequence",
        "(300C,0022)" : "Referenced Fraction Group Number",
        "(300C,0040)" : "Referenced Verification Image Sequence",
        "(300C,0042)" : "Referenced Reference Image Sequence",
        "(300C,0050)" : "Referenced Dose Reference Sequence",
        "(300C,0051)" : "Referenced Dose Reference Number",
        "(300C,0055)" : "Brachy Referenced Dose Reference Sequence",
        "(300C,0060)" : "Referenced Structure Set Sequence",
        "(300C,006A)" : "Referenced Patient Setup Number",
        "(300C,0080)" : "Referenced Dose Sequence",
        "(300C,00A0)" : "Referenced Tolerance Table Number",
        "(300C,00B0)" : "Referenced Bolus Sequence",
        "(300C,00C0)" : "Referenced Wedge Number",
        "(300C,00D0)" : "Referenced Compensator Number",
        "(300C,00E0)" : "Referenced Block Number",
        "(300C,00F0)" : "Referenced Control Point Index",
        "(300C,00F2)" : "Referenced Control Point Sequence",
        "(300C,00F4)" : "Referenced Start Control Point Index",
        "(300C,00F6)" : "Referenced Stop Control Point Index",
        "(300C,0100)" : "Referenced Range Shifter Number",
        "(300C,0102)" : "Referenced Lateral Spreading Device Number",
        "(300C,0104)" : "Referenced Range Modulator Number",
        "(300E,0002)" : "Approval Status",
        "(300E,0004)" : "Review Date",
        "(300E,0005)" : "Review Time",
        "(300E,0008)" : "Reviewer Name",
        "(4000,0010)" : ku,
        "(4000,4000)" : LO,
        "(4008,0040)" : uR,
        "(4008,0042)" : xq,
        "(4008,0050)" : rI,
        "(4008,0100)" : Az,
        "(4008,0101)" : uT,
        "(4008,0102)" : qE,
        "(4008,0103)" : nw,
        "(4008,0108)" : Fk,
        "(4008,0109)" : vN,
        "(4008,010A)" : "Interpretation Transcriber",
        "(4008,010B)" : "Interpretation Text",
        "(4008,010C)" : "Interpretation Author",
        "(4008,0111)" : Ld,
        "(4008,0112)" : wT,
        "(4008,0113)" : hc,
        "(4008,0114)" : bT,
        "(4008,0115)" : MO,
        "(4008,0117)" : vX,
        "(4008,0118)" : nU,
        "(4008,0119)" : RX,
        "(4008,011A)" : "Distribution Address",
        "(4008,0200)" : sO,
        "(4008,0202)" : PR,
        "(4008,0210)" : yO,
        "(4008,0212)" : SN,
        "(4008,0300)" : DS,
        "(4008,4000)" : JU,
        "(4FFE,0001)" : "MAC Parameters Sequence",
        "(50xx,0005)" : kd,
        "(50xx,0010)" : MC,
        "(50xx,0020)" : DY,
        "(50xx,0022)" : hJ,
        "(50xx,0030)" : of,
        "(50xx,0040)" : nV,
        "(50xx,0103)" : QK,
        "(50xx,0104)" : uy,
        "(50xx,0105)" : qL,
        "(50xx,0106)" : im,
        "(50xx,0110)" : pL,
        "(50xx,0112)" : Qn,
        "(50xx,0114)" : Oi,
        "(50xx,1001)" : Pz,
        "(50xx,2000)" : hh,
        "(50xx,2002)" : bf,
        "(50xx,2004)" : lM,
        "(50xx,2006)" : jV,
        "(50xx,2008)" : zH,
        "(50xx,200A)" : EY,
        "(50xx,200C)" : bN,
        "(50xx,200E)" : ro,
        "(50xx,2500)" : Du,
        "(50xx,2600)" : mQ,
        "(50xx,2610)" : lc,
        "(50xx,3000)" : uL,
        "(5200,9229)" : ht,
        "(5200,9230)" : zK,
        "(5400,0100)" : yo,
        "(5400,0110)" : Ac,
        "(5400,0112)" : IF,
        "(5400,1004)" : fj,
        "(5400,1006)" : yG,
        "(5400,100A)" : "Waveform Padding Value",
        "(5400,1010)" : KK,
        "(5600,0010)" : mw,
        "(5600,0020)" : Fg,
        "(60xx,0010)" : Dq,
        "(60xx,0011)" : fK,
        "(60xx,0012)" : QG,
        "(60xx,0015)" : Fa,
        "(60xx,0022)" : da,
        "(60xx,0040)" : xd,
        "(60xx,0045)" : a,
        "(60xx,0050)" : cd,
        "(60xx,0051)" : wm,
        "(60xx,0052)" : bz,
        "(60xx,0060)" : Gw,
        "(60xx,0061)" : EL,
        "(60xx,0062)" : xS,
        "(60xx,0063)" : ww,
        "(60xx,0066)" : IB,
        "(60xx,0068)" : Bo,
        "(60xx,0069)" : cg,
        "(60xx,0100)" : ps,
        "(60xx,0102)" : B,
        "(60xx,0110)" : BU,
        "(60xx,0200)" : Mi,
        "(60xx,0800)" : ow,
        "(60xx,0802)" : Md,
        "(60xx,0803)" : Ig,
        "(60xx,0804)" : zi,
        "(60xx,1001)" : Fj,
        "(60xx,1100)" : MQ,
        "(60xx,1101)" : lI,
        "(60xx,1102)" : rk,
        "(60xx,1103)" : wN,
        "(60xx,1200)" : wv,
        "(60xx,1201)" : cn,
        "(60xx,1202)" : jR,
        "(60xx,1203)" : dQ,
        "(60xx,1301)" : wk,
        "(60xx,1302)" : QF,
        "(60xx,1303)" : DA,
        "(60xx,1500)" : jc,
        "(60xx,3000)" : wt,
        "(60xx,4000)" : dh,
        "(7FE0,0010)" : "Pixel Data",
        "(7FE0,0020)" : "Coefficients SDVN",
        "(7FE0,0030)" : "Coefficients SDHN",
        "(7FE0,0040)" : "Coefficients SDDN",
        "(7Fxx,0010)" : nm,
        "(7Fxx,0011)" : BE,
        "(7Fxx,0020)" : dE,
        "(7Fxx,0030)" : AD,
        "(7Fxx,0040)" : Ie,
        "(FFFA,FFFA)" : "Digital Signatures Sequence",
        "(FFFC,FFFC)" : "Data Set Trailing Padding",
        "(FFFE,E000)" : "Item",
        "(FFFE,E00D)" : "Item Delimitation Item",
        "(FFFE,E0DD)" : "Sequence Delimitation Item"
      },
      /**
       * Tags that should be visible when the tag table is rendered.
       * Initially selected by the CNDA team.
       */
      defaultVisibleTags : [KO, xj, bi, yS, PV, Ng, wE, y, IT]
    }
  });
})();
(function(){

  var j = "css.inlineblock",i = "repeat",h = "scale",g = "_identifyImage is abstract",f = "string",e = "static",d = "'",c = "qx.ui.table.cellrenderer.AbstractImage",b = "}",a = "  text-align:center;",x = "scale-x",w = "repeat-y",v = ".qooxdoo-table-cell-icon {",u = "",t = "<div></div>",s = "top",r = "abstract",q = " qooxdoo-table-cell-icon",p = "repeat-x",o = "  padding-top:1px;",m = "title='",n = "scale-y",k = "px",l = "no-repeat";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */
  /**
   * A template class for cell renderer, which display images. Concrete
   * implementations must implement the method {@link #_identifyImage}.
   */
  qx.Class.define(c, {
    extend : qx.ui.table.cellrenderer.Abstract,
    type : r,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.table.cellrenderer.Abstract.call(this);
      var y = this.self(arguments);
      if(!y.stylesheet){

        y.stylesheet = qx.bom.Stylesheet.createElement(v + a + o + b);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Whether to repeat or scale the image.
       *
       * @param repeat {String}
       *   One of
       *     <code>scale</code>,
       *     <code>scale-x</code>,
       *     <code>scale-y</code>,
       *     <code>repeat</code>,
       *     <code>repeat-x</code>,
       *     <code>repeat-y</code>,
       *     <code>no-repeat</code>
      */
      repeat : {
        check : function(z){

          var A = [h, x, n, i, p, w, l];
          return qx.lang.Array.contains(A, z);
        },
        init : l
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __defaultWidth : 16,
      __defaultHeight : 16,
      __imageData : null,
      // overridden
      _insetY : 2,
      /**
       * Identifies the Image to show. This is a template method, which must be
       * implemented by sub classes.
       *
       * @abstract
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} A map having the following attributes:
       *           <ul>
       *           <li>
       *             "url": (type string) must be the URL of the image to show.
       *             The url given must either be managed by the {@link qx.util.ResourceManager}
       *             or pre-loaded with {@link qx.io.ImageLoader}. This is to make sure that
       *             the renderer knows the dimensions and the format of the image.
       *           </li>
       *           <li>"imageWidth": (type int) the width of the image in pixels.</li>
       *           <li>"imageHeight": (type int) the height of the image in pixels.</li>
       *           <li>"tooltip": (type string) must be the image tooltip text.</li>
       *           </ul>
       * @throws the abstract function warning.
       */
      _identifyImage : function(B){

        throw new Error(g);
      },
      /**
       * Retrieves the image infos.
       *
       * @param cellInfo {Map} The information about the cell.
       *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
       * @return {Map} Map with an "url" attribute (type string)
       *                 holding the URL of the image to show
       *                 and a "tooltip" attribute
       *                 (type string) being the tooltip text (or null if none was specified)
       */
      _getImageInfos : function(C){

        // Query the subclass about image and tooltip
        var D = this._identifyImage(C);
        // If subclass refuses to give map, construct it with required properties
        // If no map is given, but instead a string, assume that this string is
        // the URL of the image [BUG #4289]
        if(D == null || typeof D == f){

          D = {
            url : D,
            tooltip : null
          };
        };
        // If sizes are not included in map given by subclass,
        // fall-back to calculated image size
        if(!D.imageWidth || !D.imageHeight){

          var E = this.__getImageSize(D.url);
          D.imageWidth = E.width;
          D.imageHeight = E.height;
        };
        // Add width and height keys to map [BUG #4289]
        // - [width|height] is read by _getContentHtml()
        // - [imageWidth|imageHeight] is possibly read in legacy applications
        D.width = D.imageWidth;
        D.height = D.imageHeight;
        return D;
      },
      /**
       * Compute the size of the given image
       *
       * @param source {String} the image URL
       * @return {Map} A map containing the image's <code>width</code> and
       *    <code>height</code>
       */
      __getImageSize : function(F){

        var I = qx.util.ResourceManager.getInstance();
        var H = qx.io.ImageLoader;
        var G,J;
        // Detect if the image registry knows this image
        if(I.has(F)){

          G = I.getImageWidth(F);
          J = I.getImageHeight(F);
        } else if(H.isLoaded(F)){

          G = H.getWidth(F);
          J = H.getHeight(F);
        } else {

          G = this.__defaultWidth;
          J = this.__defaultHeight;
        };
        return {
          width : G,
          height : J
        };
      },
      // overridden
      createDataCellHtml : function(K, L){

        this.__imageData = this._getImageInfos(K);
        return qx.ui.table.cellrenderer.Abstract.prototype.createDataCellHtml.call(this, K, L);
      },
      // overridden
      _getCellClass : function(M){

        return qx.ui.table.cellrenderer.Abstract.prototype._getCellClass.call(this) + q;
      },
      // overridden
      _getContentHtml : function(N){

        var content = t;
        // set image
        if(this.__imageData.url){

          content = qx.bom.element.Decoration.create(this.__imageData.url, this.getRepeat(), {
            width : this.__imageData.width + k,
            height : this.__imageData.height + k,
            display : qx.core.Environment.get(j),
            verticalAlign : s,
            position : e
          });
        };
        return content;
      },
      // overridden
      _getCellAttributes : function(O){

        var P = this.__imageData.tooltip;
        if(P){

          return m + P + d;
        } else {

          return u;
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__imageData = null;
    }
  });
})();
(function(){

  var g = "_applyIconTrue",f = "decoration/table/boolean-true.png",e = "qx.ui.table.cellrenderer.Boolean",d = ";padding-top:4px;",c = "decoration/table/boolean-false.png",b = "_applyIconFalse",a = "String";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Til Schneider (til132)
       * Carsten Lergenmueller (carstenl)
  
  ************************************************************************ */
  /**
   * A data cell renderer for boolean values.
   */
  qx.Class.define(e, {
    extend : qx.ui.table.cellrenderer.AbstractImage,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct : function(){

      qx.ui.table.cellrenderer.AbstractImage.call(this);
      this.__aliasManager = qx.util.AliasManager.getInstance();
      this.initIconTrue();
      this.initIconFalse();
    },
    /*
     *****************************************************************************
       PROPERTIES
     *****************************************************************************
     */
    properties : {
      /**
       * The icon used to indicate the true state
       */
      iconTrue : {
        check : a,
        init : f,
        apply : g
      },
      /**
      * The icon used to indicate the false state
      */
      iconFalse : {
        check : a,
        init : c,
        apply : b
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __iconUrlTrue : null,
      __iconUrlFalse : false,
      __aliasManager : null,
      // property apply
      _applyIconTrue : function(h){

        this.__iconUrlTrue = this.__aliasManager.resolve(h);
      },
      // property apply
      _applyIconFalse : function(i){

        this.__iconUrlFalse = this.__aliasManager.resolve(i);
      },
      // overridden
      _insetY : 5,
      // overridden
      _getCellStyle : function(j){

        return qx.ui.table.cellrenderer.AbstractImage.prototype._getCellStyle.call(this, j) + d;
      },
      // overridden
      _identifyImage : function(k){

        var l = {
          imageWidth : 11,
          imageHeight : 11
        };
        switch(k.value){case true:
        l.url = this.__iconUrlTrue;
        break;case false:
        l.url = this.__iconUrlFalse;
        break;default:
        l.url = null;
        break;};
        return l;
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__aliasManager = null;
    }
  });
})();
(function(){

  var i = "keypress",h = "Enter",g = "qx.ui.table.celleditor.CheckBox",f = "focus",d = "center",c = "keydown",b = "middle",a = "activate";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 David Perez
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * David Perez (david-perez)
  
  ************************************************************************ */
  /**
   * For editing boolean data in a checkbox. It is advisable to use this in
   * conjunction with {@link qx.ui.table.cellrenderer.Boolean}.
   */
  qx.Class.define(g, {
    extend : qx.core.Object,
    implement : qx.ui.table.ICellEditorFactory,
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      // interface implementation
      createCellEditor : function(j){

        var l = new qx.ui.container.Composite(new qx.ui.layout.HBox().set({
          alignX : d,
          alignY : b
        })).set({
          focusable : true
        });
        var k = new qx.ui.form.CheckBox().set({
          value : j.value
        });
        l.add(k);
        // propagate focus
        l.addListener(f, function(){

          k.focus();
        });
        // propagate active state
        l.addListener(a, function(){

          k.activate();
        });
        // propagate stopped enter key press to the editor
        k.addListener(c, function(e){

          if(e.getKeyIdentifier() == h){

            var m = qx.event.Pool.getInstance().getObject(qx.event.type.KeySequence);
            var n = l.getContainerElement().getDomElement();
            m.init(e.getNativeEvent(), n, e.getKeyIdentifier());
            m.setType(i);
            qx.event.Registration.dispatchEvent(n, m);
          };
        }, this);
        return l;
      },
      // interface implementation
      getCellEditorValue : function(o){

        return o.getChildren()[0].getValue();
      }
    }
  });
})();
(function(){

  var b = "qx.ui.form.IRadioItem",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Each object, which should be managed by a {@link RadioGroup} have to
   * implement this interface.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the item was checked or unchecked */
      "changeValue" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Set whether the item is checked
       *
       * @param value {Boolean} whether the item should be checked
       */
      setValue : function(c){
      },
      /**
       * Get whether the item is checked
       *
       * @return {Boolean} whether the item it checked
       */
      getValue : function(){
      },
      /**
       * Set the radiogroup, which manages this item
       *
       * @param value {qx.ui.form.RadioGroup} The radiogroup, which should
       *     manage the item.
       */
      setGroup : function(d){

        this.assertInstance(d, qx.ui.form.RadioGroup);
      },
      /**
       * Get the radiogroup, which manages this item
       *
       * @return {qx.ui.form.RadioGroup} The radiogroup, which manages the item.
       */
      getGroup : function(){
      }
    }
  });
})();
(function(){

  var i = " array contains ",h = "__manager",g = "qx.ui.core.MSingleSelectionHandling",f = " items!",d = "changeSelection",c = "changeSelected",b = "Could only select one item, but the selection",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * This mixin links all methods to manage the single selection.
   *
   * The class which includes the mixin has to implements two methods:
   *
   * <ul>
   * <li><code>_getItems</code>, this method has to return a <code>Array</code>
   *    of <code>qx.ui.core.Widget</code> that should be managed from the manager.
   * </li>
   * <li><code>_isAllowEmptySelection</code>, this method has to return a
   *    <code>Boolean</code> value for allowing empty selection or not.
   * </li>
   * </ul>
   */
  qx.Mixin.define(g, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fires after the selection was modified */
      "changeSelection" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {qx.ui.core.SingleSelectionManager} the single selection manager */
      __manager : null,
      /*
      ---------------------------------------------------------------------------
        PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection : function(){

        var j = this.__getManager().getSelected();
        if(j){

          return [j];
        } else {

          return [];
        };
      },
      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws an exception if one of the items is not a child element and if
       *    items contains more than one elements.
       */
      setSelection : function(k){

        switch(k.length){case 0:
        this.resetSelection();
        break;case 1:
        this.__getManager().setSelected(k[0]);
        break;default:
        throw new Error(b + i + k.length + f);};
      },
      /**
       * Clears the whole selection at once.
       */
      resetSelection : function(){

        this.__getManager().resetSelected();
      },
      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item.
       * @return {Boolean} Whether the item is selected.
       * @throws an exception if one of the items is not a child element.
       */
      isSelected : function(l){

        return this.__getManager().isSelected(l);
      },
      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty : function(){

        return this.__getManager().isSelectionEmpty();
      },
      /**
       * Returns all elements which are selectable.
       *
       * @param all {boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables : function(m){

        return this.__getManager().getSelectables(m);
      },
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for <code>changeSelected</code> event on single
       * selection manager.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      _onChangeSelected : function(e){

        var o = e.getData();
        var n = e.getOldData();
        o == null ? o = [] : o = [o];
        n == null ? n = [] : n = [n];
        this.fireDataEvent(d, o, n);
      },
      /**
       * Return the selection manager if it is already exists, otherwise creates
       * the manager.
       *
       * @return {qx.ui.core.SingleSelectionManager} Single selection manager.
       */
      __getManager : function(){

        if(this.__manager == null){

          var p = this;
          this.__manager = new qx.ui.core.SingleSelectionManager({
            getItems : function(){

              return p._getItems();
            },
            isItemSelectable : function(q){

              if(p._isItemSelectable){

                return p._isItemSelectable(q);
              } else {

                return q.isVisible();
              };
            }
          });
          this.__manager.addListener(c, this._onChangeSelected, this);
        };
        this.__manager.setAllowEmptySelection(this._isAllowEmptySelection());
        return this.__manager;
      }
    },
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeObjects(h);
    }
  });
})();
(function(){

  var o = ", because it is not a child element!",n = "__selected",m = "Boolean",l = "qx.ui.core.SingleSelectionManager",k = "__selectionProvider",j = "qx.debug",h = "Invalid selectionProvider!",g = "Could not check if ",f = " is selected,",e = "Could not select ",b = "changeSelected",d = " because it is not a child element!",c = "__applyAllowEmptySelection",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * Responsible for the single selection management.
   *
   * The class manage a list of {@link qx.ui.core.Widget} which are returned from
   * {@link qx.ui.core.ISingleSelectionProvider#getItems}.
   *
   * @internal
   */
  qx.Class.define(l, {
    extend : qx.core.Object,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Construct the single selection manager.
     *
     * @param selectionProvider {qx.ui.core.ISingleSelectionProvider} The provider
     * for selection.
     */
    construct : function(p){

      qx.core.Object.call(this);
      if(qx.core.Environment.get(j)){

        qx.core.Assert.assertInterface(p, qx.ui.core.ISingleSelectionProvider, h);
      };
      this.__selectionProvider = p;
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fires after the selection was modified */
      "changeSelected" : a
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * If the value is <code>true</code> the manager allows an empty selection,
       * otherwise the first selectable element returned from the
       * <code>qx.ui.core.ISingleSelectionProvider</code> will be selected.
       */
      allowEmptySelection : {
        check : m,
        init : true,
        apply : c
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {qx.ui.core.Widget} The selected widget. */
      __selected : null,
      /** {qx.ui.core.ISingleSelectionProvider} The provider for selection management */
      __selectionProvider : null,
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the current selected element.
       *
       * @return {qx.ui.core.Widget | null} The current selected widget or
       *    <code>null</code> if the selection is empty.
       */
      getSelected : function(){

        return this.__selected;
      },
      /**
       * Selects the passed element.
       *
       * @param item {qx.ui.core.Widget} Element to select.
       * @throws Error if the element is not a child element.
       */
      setSelected : function(q){

        if(!this.__isChildElement(q)){

          throw new Error(e + q + o);
        };
        this.__setSelected(q);
      },
      /**
       * Reset the current selection. If {@link #allowEmptySelection} is set to
       * <code>true</code> the first element will be selected.
       */
      resetSelected : function(){

        this.__setSelected(null);
      },
      /**
       * Return <code>true</code> if the passed element is selected.
       *
       * @param item {qx.ui.core.Widget} Element to check if selected.
       * @return {Boolean} <code>true</code> if passed element is selected,
       *    <code>false</code> otherwise.
       * @throws Error if the element is not a child element.
       */
      isSelected : function(r){

        if(!this.__isChildElement(r)){

          throw new Error(g + r + f + d);
        };
        return this.__selected === r;
      },
      /**
       * Returns <code>true</code> if selection is empty.
       *
       * @return {Boolean} <code>true</code> if selection is empty,
       *    <code>false</code> otherwise.
       */
      isSelectionEmpty : function(){

        return this.__selected == null;
      },
      /**
       * Returns all elements which are selectable.
       *
       * @param all {boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables : function(s){

        var t = this.__selectionProvider.getItems();
        var u = [];
        for(var i = 0;i < t.length;i++){

          if(this.__selectionProvider.isItemSelectable(t[i])){

            u.push(t[i]);
          };
        };
        // in case of an user selecable list, remove the enabled items
        if(!s){

          for(var i = u.length - 1;i >= 0;i--){

            if(!u[i].getEnabled()){

              u.splice(i, 1);
            };
          };
        };
        return u;
      },
      /*
      ---------------------------------------------------------------------------
         APPLY METHODS
      ---------------------------------------------------------------------------
      */
      // apply method
      __applyAllowEmptySelection : function(v, w){

        if(!v){

          this.__setSelected(this.__selected);
        };
      },
      /*
      ---------------------------------------------------------------------------
         HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Set selected element.
       *
       * If passes value is <code>null</code>, the selection will be reseted.
       *
       * @param item {qx.ui.core.Widget | null} element to select, or
       *    <code>null</code> to reset selection.
       */
      __setSelected : function(x){

        var A = this.__selected;
        var z = x;
        if(z != null && A === z){

          return;
        };
        if(!this.isAllowEmptySelection() && z == null){

          var y = this.getSelectables(true)[0];
          if(y){

            z = y;
          };
        };
        this.__selected = z;
        this.fireDataEvent(b, z, A);
      },
      /**
       * Checks if passed element is a child element.
       *
       * @param item {qx.ui.core.Widget} Element to check if child element.
       * @return {Boolean} <code>true</code> if element is child element,
       *    <code>false</code> otherwise.
       */
      __isChildElement : function(B){

        var C = this.__selectionProvider.getItems();
        for(var i = 0;i < C.length;i++){

          if(C[i] === B){

            return true;
          };
        };
        return false;
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct : function(){

      if(this.__selectionProvider.toHashCode){

        this._disposeObjects(k);
      } else {

        this.__selectionProvider = null;
      };
      this._disposeObjects(n);
    }
  });
})();
(function(){

  var a = "qx.ui.core.ISingleSelectionProvider";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
  
  ************************************************************************ */
  /**
   * Defines the callback for the single selection manager.
   *
   * @internal
   */
  qx.Interface.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Returns the elements which are part of the selection.
       *
       * @return {qx.ui.core.Widget[]} The widgets for the selection.
       */
      getItems : function(){
      },
      /**
       * Returns whether the given item is selectable.
       *
       * @param item {qx.ui.core.Widget} The item to be checked
       * @return {Boolean} Whether the given item is selectable
       */
      isItemSelectable : function(b){
      }
    }
  });
})();
(function(){

  var k = "Please use an array as parameter.",h = "qx.ui.form.MModelSelection",g = "__modelSelection",f = "change",d = "qx.debug",c = "Could not set the model selection. Maybe your models are not unique?",b = "changeSelection",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This mixin offers the selection of the model properties.
   * It can only be included if the object including it implements the
   * {@link qx.ui.core.ISingleSelection} interface and the selectables implement
   * the {@link qx.ui.form.IModel} interface.
   */
  qx.Mixin.define(h, {
    construct : function(){

      // create the selection array
      this.__modelSelection = new qx.data.Array();
      // listen to the changes
      this.__modelSelection.addListener(f, this.__onModelSelectionArrayChange, this);
      this.addListener(b, this.__onModelSelectionChange, this);
    },
    events : {
      /**
       * Pseudo event. It will never be fired because the array itself can not
       * be changed. But the event description is needed for the data binding.
       */
      changeModelSelection : a
    },
    members : {
      __modelSelection : null,
      __inSelectionChange : false,
      /**
       * Handler for the selection change of the including class e.g. SelectBox,
       * List, ...
       * It sets the new modelSelection via {@link #setModelSelection}.
       */
      __onModelSelectionChange : function(){

        if(this.__inSelectionChange){

          return;
        };
        var n = this.getSelection();
        // create the array with the modes inside
        var l = [];
        for(var i = 0;i < n.length;i++){

          var o = n[i];
          // fallback if getModel is not implemented
          var m = o.getModel ? o.getModel() : null;
          if(m !== null){

            l.push(m);
          };
        };
        // only change the selection if you are sure that its correct [BUG #3748]
        if(l.length === n.length){

          try{

            this.setModelSelection(l);
          } catch(e) {

            throw new Error(c);
          };
        };
      },
      /**
       * Listener for the change of the internal model selection data array.
       */
      __onModelSelectionArrayChange : function(){

        this.__inSelectionChange = true;
        var q = this.getSelectables(true);
        var s = [];
        var r = this.__modelSelection.toArray();
        for(var i = 0;i < r.length;i++){

          var u = r[i];
          for(var j = 0;j < q.length;j++){

            var v = q[j];
            // fallback if getModel is not implemented
            var p = v.getModel ? v.getModel() : null;
            if(u === p){

              s.push(v);
              break;
            };
          };
        };
        this.setSelection(s);
        this.__inSelectionChange = false;
        // check if the setting has worked
        var t = this.getSelection();
        if(!qx.lang.Array.equals(t, s)){

          // if not, set the actual selection
          this.__onModelSelectionChange();
        };
      },
      /**
       * Returns always an array of the models of the selected items. If no
       * item is selected or no model is given, the array will be empty.
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @return {qx.data.Array} An array of the models of the selected items.
       */
      getModelSelection : function(){

        return this.__modelSelection;
      },
      /**
       * Takes the given models in the array and searches for the corresponding
       * selectables. If an selectable does have that model attached, it will be
       * selected.
       *
       * *Attention:* This method can have a time complexity of O(n^2)!
       *
       * *CAREFUL!* The model selection can only work if every item item in the
       * selection providing widget has a model property!
       *
       * @param modelSelection {Array} An array of models, which should be
       *   selected.
       */
      setModelSelection : function(w){

        // check for null values
        if(!w){

          this.__modelSelection.removeAll();
          return;
        };
        if(qx.core.Environment.get(d)){

          this.assertArray(w, k);
        };
        // add the first two parameter
        w.unshift(this.__modelSelection.getLength());
        // remove index
        w.unshift(0);
        // start index
        var x = this.__modelSelection.splice.apply(this.__modelSelection, w);
        x.dispose();
      }
    },
    destruct : function(){

      this._disposeObjects(g);
    }
  });
})();
(function(){

  var j = "qx.data.marshal.MEventBubbling",h = "",g = "qx.event.type.Data",f = "changeBubble",d = ".",c = "]",b = "idBubble-",a = "[";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin used for the bubbling events. If you want to use this in your own model
   * classes, be sure that every property will call the
   * {@link #_applyEventPropagation} function on every change.
   */
  qx.Mixin.define(j, {
    events : {
      /**
       * The change event which will be fired on every change in the model no
       * matter what property changes. This event bubbles so the root model will
       * fire a change event on every change of its children properties too.
       *
       * Note that properties are required to call
       * {@link #_applyEventPropagation} on apply for changes to be tracked as
       * desired. It is already taken care of that properties created with the
       * {@link qx.data.marshal.Json} marshaler call this method.
       *
       * The data will contain a map with the following three keys
       *   <li>value: The new value of the property</li>
       *   <li>old: The old value of the property.</li>
       *   <li>name: The name of the property changed including its parent
       *     properties separated by dots.</li>
       *   <li>item: The item which has the changed property.</li>
       * Due to that, the <code>getOldData</code> method will always return null
       * because the old data is contained in the map.
       */
      "changeBubble" : g
    },
    members : {
      /**
       * Apply function for every property created with the
       * {@link qx.data.marshal.Json} marshaler. It fires and
       * {@link #changeBubble} event on every change. It also adds the chaining
       * listener if possible which is necessary for the bubbling of the events.
       *
       * @param value {var} The new value of the property.
       * @param old {var} The old value of the property.
       * @param name {String} The name of the changed property.
       */
      _applyEventPropagation : function(k, l, name){

        this.fireDataEvent(f, {
          value : k,
          name : name,
          old : l,
          item : this
        });
        this._registerEventChaining(k, l, name);
      },
      /**
       * Registers for the given parameters the changeBubble listener, if
       * possible. It also removes the old listener, if an old item with
       * a changeBubble event is given.
       *
       * @param value {var} The new value of the property.
       * @param old {var} The old value of the property.
       * @param name {String} The name of the changed property.
       */
      _registerEventChaining : function(m, n, name){

        // if an old value is given, remove the old listener if possible
        if(n != null && n.getUserData && n.getUserData(b + this.$$hash) != null){

          var p = n.getUserData(b + this.$$hash);
          for(var i = 0;i < p.length;i++){

            n.removeListenerById(p[i]);
          };
          n.setUserData(b + this.$$hash, null);
        };
        // if the child supports chaining
        if((m instanceof qx.core.Object) && qx.Class.hasMixin(m.constructor, qx.data.marshal.MEventBubbling)){

          // create the listener
          var o = qx.lang.Function.bind(this.__changePropertyListener, this, name);
          // add the listener
          var q = m.addListener(f, o, this);
          var p = m.getUserData(b + this.$$hash);
          if(p == null){

            p = [];
            m.setUserData(b + this.$$hash, p);
          };
          p.push(q);
        };
      },
      /**
       * Listener responsible for formating the name and firing the change event
       * for the changed property.
       *
       * @param name {String} The name of the former properties.
       * @param e {qx.event.type.Data} The date event fired by the property
       *   change.
       */
      __changePropertyListener : function(name, e){

        var y = e.getData();
        var u = y.value;
        var s = y.old;
        // if the target is an array
        if(qx.Class.hasInterface(e.getTarget().constructor, qx.data.IListData)){

          if(y.name.indexOf){

            var x = y.name.indexOf(d) != -1 ? y.name.indexOf(d) : y.name.length;
            var v = y.name.indexOf(a) != -1 ? y.name.indexOf(a) : y.name.length;
            // braktes in the first spot is ok [BUG #5985]
            if(v == 0){

              var t = name + y.name;
            } else if(x < v){

              var r = y.name.substring(0, x);
              var w = y.name.substring(x + 1, y.name.length);
              if(w[0] != a){

                w = d + w;
              };
              var t = name + a + r + c + w;
            } else if(v < x){

              var r = y.name.substring(0, v);
              var w = y.name.substring(v, y.name.length);
              var t = name + a + r + c + w;
            } else {

              var t = name + a + y.name + c;
            };;
          } else {

            var t = name + a + y.name + c;
          };
        } else {

          // special case for array as first element of the chain [BUG #5985]
          if(parseInt(name) == name && name !== h){

            name = a + name + c;
          };
          var t = name + d + y.name;
        };
        this.fireDataEvent(f, {
          value : u,
          name : t,
          old : s,
          item : y.item || e.getTarget()
        });
      }
    }
  });
})();
(function(){

  var s = "Boolean",r = "Please use 'toArray()' to see the content.",q = "qx.data.Array",p = "Type of the parameter not supported!",o = "The parameter must be an array.",n = "number",m = "changeLength",l = "-",k = "qx.debug",j = "0",c = "qx.event.type.Data",h = "order",f = "0-",b = "remove",a = "add",e = "",d = "change",g = "changeBubble";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * The data array is a special array used in the data binding context of
   * qooxdoo. It does not extend the native array of JavaScript but its a wrapper
   * for it. All the native methods are included in the implementation and it
   * also fires events if the content or the length of the array changes in
   * any way. Also the <code>.length</code> property is available on the array.
   */
  qx.Class.define(q, {
    extend : qx.core.Object,
    include : qx.data.marshal.MEventBubbling,
    implement : [qx.data.IListData],
    /**
     * Creates a new instance of an array.
     *
     * @param param {var} The parameter can be some types.<br/>
     *   Without a parameter a new blank array will be created.<br/>
     *   If there is more than one parameter is given, the parameter will be
     *   added directly to the new array.<br/>
     *   If the parameter is a number, a new Array with the given length will be
     *   created.<br/>
     *   If the parameter is a JavaScript array, a new array containing the given
     *   elements will be created.
     */
    construct : function(t){

      qx.core.Object.call(this);
      // if no argument is given
      if(t == undefined){

        this.__array = [];
      } else if(arguments.length > 1){

        // create an empty array and go through every argument and push it
        this.__array = [];
        for(var i = 0;i < arguments.length;i++){

          this.__array.push(arguments[i]);
        };
      } else if(typeof t == n){

        this.__array = new Array(t);
      } else if(t instanceof Array){

        this.__array = qx.lang.Array.clone(t);
      } else {

        this.__array = [];
        this.dispose();
        throw new Error(p);
      };;;
      // propagate changes
      for(var i = 0;i < this.__array.length;i++){

        this._applyEventPropagation(this.__array[i], null, i);
      };
      // update the length at startup
      this.__updateLength();
      // work against the console printout of the array
      if(qx.core.Environment.get(k)){

        this[0] = r;
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Flag to set the dispose behavior of the array. If the property is set to
       * <code>true</code>, the array will dispose its content on dispose, too.
       */
      autoDisposeItems : {
        check : s,
        init : false
      }
    },
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /**
       * The change event which will be fired if there is a change in the array.
       * The data contains a map with three key value pairs:
       * <li>start: The start index of the change.</li>
       * <li>end: The end index of the change.</li>
       * <li>type: The type of the change as a String. This can be 'add',
       * 'remove' or 'order'</li>
       * <li>items: The items which has been changed (as a JavaScript array).</li>
       */
      "change" : c,
      /**
       * The changeLength event will be fired every time the length of the
       * array changes.
       */
      "changeLength" : c
    },
    members : {
      // private members
      __array : null,
      /**
       * Concatenates the current and the given array into a new one.
       *
       * @param array {Array} The javaScript array which should be concatenated
       *   to the current array.
       *
       * @return {qx.data.Array} A new array containing the values of both former
       *   arrays.
       */
      concat : function(u){

        if(u){

          var v = this.__array.concat(u);
        } else {

          var v = this.__array.concat();
        };
        return new qx.data.Array(v);
      },
      /**
       * Returns the array as a string using the given connector string to
       * connect the values.
       *
       * @param connector {String} the string which should be used to past in
       *  between of the array values.
       *
       * @return {String} The array as a string.
       */
      join : function(w){

        return this.__array.join(w);
      },
      /**
       * Removes and returns the last element of the array.
       * An change event will be fired.
       *
       * @return {var} The last element of the array.
       */
      pop : function(){

        var x = this.__array.pop();
        this.__updateLength();
        // remove the possible added event listener
        this._registerEventChaining(null, x, this.length - 1);
        // fire change bubble event
        this.fireDataEvent(g, {
          value : [],
          name : this.length + e,
          old : [x],
          item : this
        });
        this.fireDataEvent(d, {
          start : this.length - 1,
          end : this.length - 1,
          type : b,
          items : [x]
        }, null);
        return x;
      },
      /**
       * Adds an element at the end of the array.
       *
       * @param varargs {var} Multiple elements. Every element will be added to
       *   the end of the array. An change event will be fired.
       *
       * @return {Number} The new length of the array.
       */
      push : function(y){

        for(var i = 0;i < arguments.length;i++){

          this.__array.push(arguments[i]);
          this.__updateLength();
          // apply to every pushed item an event listener for the bubbling
          this._registerEventChaining(arguments[i], null, this.length - 1);
          // fire change bubbles event
          this.fireDataEvent(g, {
            value : [arguments[i]],
            name : (this.length - 1) + e,
            old : [],
            item : this
          });
          // fire change event
          this.fireDataEvent(d, {
            start : this.length - 1,
            end : this.length - 1,
            type : a,
            items : [arguments[i]]
          }, null);
        };
        return this.length;
      },
      /**
       * Reverses the order of the array. An change event will be fired.
       */
      reverse : function(){

        // ignore on empty arrays
        if(this.length == 0){

          return;
        };
        var z = this.__array.concat();
        this.__array.reverse();
        this.__updateEventPropagation(0, this.length);
        this.fireDataEvent(d, {
          start : 0,
          end : this.length - 1,
          type : h,
          items : null
        }, null);
        // fire change bubbles event
        this.fireDataEvent(g, {
          value : this.__array,
          name : f + (this.__array.length - 1),
          old : z,
          item : this
        });
      },
      /**
       * Removes the first element of the array and returns it. An change event
       * will be fired.
       *
       * @return {var} the former first element.
       */
      shift : function(){

        // ignore on empty arrays
        if(this.length == 0){

          return;
        };
        var A = this.__array.shift();
        this.__updateLength();
        // remove the possible added event listener
        this._registerEventChaining(null, A, this.length - 1);
        // as every item has changed its position, we need to update the event bubbling
        this.__updateEventPropagation(0, this.length);
        // fire change bubbles event
        this.fireDataEvent(g, {
          value : [],
          name : j,
          old : [A],
          item : this
        });
        // fire change event
        this.fireDataEvent(d, {
          start : 0,
          end : this.length - 1,
          type : b,
          items : [A]
        }, null);
        return A;
      },
      /**
       * Returns a new array based on the range specified by the parameters.
       *
       * @param from {Number} The start index.
       * @param to {Number?null} The end index. If omitted, slice extracts to the
       *   end of the array.
       *
       * @return {qx.data.Array} A new array containing the given range of values.
       */
      slice : function(B, C){

        return new qx.data.Array(this.__array.slice(B, C));
      },
      /**
       * Method to remove and add new elements to the array. For every remove or
       * add an event will be fired.
       *
       * @param startIndex {Integer} The index where the splice should start
       * @param amount {Integer} Defines number of elements which will be removed
       *   at the given position.
       * @param varargs {var} All following parameters will be added at the given
       *   position to the array.
       * @return {qx.data.Array} An data array containing the removed elements.
       *   Keep in to dispose this one, even if you don't use it!
       */
      splice : function(D, E, F){

        // store the old length
        var N = this.__array.length;
        // invoke the slice on the array
        var J = this.__array.splice.apply(this.__array, arguments);
        // fire a change event for the length
        if(this.__array.length != N){

          this.__updateLength();
        };
        // fire an event for the change
        var L = E > 0;
        var H = arguments.length > 2;
        var I = null;
        if(L || H){

          if(this.__array.length > N){

            var M = a;
            I = qx.lang.Array.fromArguments(arguments, 2);
          } else if(this.__array.length < N){

            var M = b;
            I = J;
          } else {

            var M = h;
          };
          this.fireDataEvent(d, {
            start : D,
            end : this.length - 1,
            type : M,
            items : I
          }, null);
        };
        // add listeners
        for(var i = 2;i < arguments.length;i++){

          this._registerEventChaining(arguments[i], null, D + i);
        };
        // apply event chaining for every item moved
        this.__updateEventPropagation(D + arguments.length - 2, this.length);
        // fire the changeBubble event
        var K = [];
        for(var i = 2;i < arguments.length;i++){

          K[i - 2] = arguments[i];
        };
        var G = (D + Math.max(arguments.length - 3, E - 1));
        var name = D == G ? G : D + l + G;
        this.fireDataEvent(g, {
          value : K,
          name : name + e,
          old : J,
          item : this
        });
        // remove the listeners
        for(var i = 0;i < J.length;i++){

          this._registerEventChaining(null, J[i], i);
        };
        return (new qx.data.Array(J));
      },
      /**
       * Sorts the array. If a function is given, this will be used to
       * compare the items. <code>changeBubble</code> event will only be fired,
       * if sorting result differs from original array.
       *
       * @param func {Function} A compare function comparing two parameters and
       *   should return a number.
       */
      sort : function(O){

        // ignore if the array is empty
        if(this.length == 0){

          return;
        };
        var P = this.__array.concat();
        this.__array.sort.apply(this.__array, arguments);
        // prevent changeBubble event if nothing has been changed
        if(qx.lang.Array.equals(this.__array, P) === true){

          return;
        };
        this.__updateEventPropagation(0, this.length);
        this.fireDataEvent(d, {
          start : 0,
          end : this.length - 1,
          type : h,
          items : null
        }, null);
        // fire change bubbles event
        this.fireDataEvent(g, {
          value : this.__array,
          name : f + (this.length - 1),
          old : P,
          item : this
        });
      },
      /**
       * Adds the given items to the beginning of the array. For every element,
       * a change event will be fired.
       *
       * @param varargs {var} As many elements as you want to add to the beginning.
       */
      unshift : function(Q){

        for(var i = arguments.length - 1;i >= 0;i--){

          this.__array.unshift(arguments[i]);
          this.__updateLength();
          // apply to every item an event listener for the bubbling
          this.__updateEventPropagation(0, this.length);
          // fire change bubbles event
          this.fireDataEvent(g, {
            value : [this.__array[0]],
            name : j,
            old : [this.__array[1]],
            item : this
          });
          // fire change event
          this.fireDataEvent(d, {
            start : 0,
            end : this.length - 1,
            type : a,
            items : [arguments[i]]
          }, null);
        };
        return this.length;
      },
      /**
       * Returns the list data as native array. Beware of the fact that the
       * internal representation will be returnd and any manipulation of that
       * can cause a misbehavior of the array. This method should only be used for
       * debugging purposes.
       *
       * @return {Array} The native array.
       */
      toArray : function(){

        return this.__array;
      },
      /**
       * Replacement function for the getting of the array value.
       * array[0] should be array.getItem(0).
       *
       * @param index {Number} The index requested of the array element.
       *
       * @return {var} The element at the given index.
       */
      getItem : function(R){

        return this.__array[R];
      },
      /**
       * Replacement function for the setting of an array value.
       * array[0] = "a" should be array.setItem(0, "a").
       * A change event will be fired if the value changes. Setting the same
       * value again will not lead to a change event.
       *
       * @param index {Number} The index of the array element.
       * @param item {var} The new item to set.
       */
      setItem : function(S, T){

        var U = this.__array[S];
        // ignore settings of already set items [BUG #4106]
        if(U === T){

          return;
        };
        this.__array[S] = T;
        // set an event listener for the bubbling
        this._registerEventChaining(T, U, S);
        // only update the length if its changed
        if(this.length != this.__array.length){

          this.__updateLength();
        };
        // fire change bubbles event
        this.fireDataEvent(g, {
          value : [T],
          name : S + e,
          old : [U],
          item : this
        });
        // fire change event
        this.fireDataEvent(d, {
          start : S,
          end : S,
          type : a,
          items : [T]
        }, null);
      },
      /**
       * This method returns the current length stored under .length on each
       * array.
       *
       * @return {Number} The current length of the array.
       */
      getLength : function(){

        return this.length;
      },
      /**
       * Returns the index of the item in the array. If the item is not in the
       * array, -1 will be returned.
       *
       * @param item {var} The item of which the index should be returned.
       * @return {Number} The Index of the given item.
       */
      indexOf : function(V){

        return this.__array.indexOf(V);
      },
      /**
       * Returns the toString of the original Array
       * @return {String} The array as a string.
       */
      toString : function(){

        if(this.__array != null){

          return this.__array.toString();
        };
        return e;
      },
      /*
      ---------------------------------------------------------------------------
         IMPLEMENTATION OF THE QX.LANG.ARRAY METHODS
      ---------------------------------------------------------------------------
      */
      /**
       * Check if the given item is in the current array.
       *
       * @param item {var} The item which is possibly in the array.
       * @return {boolean} true, if the array contains the given item.
       */
      contains : function(W){

        return this.__array.indexOf(W) !== -1;
      },
      /**
       * Return a copy of the given arr
       *
       * @return {qx.data.Array} copy of this
       */
      copy : function(){

        return this.concat();
      },
      /**
       * Insert an element at a given position.
       *
       * @param index {Integer} Position where to insert the item.
       * @param item {var} The element to insert.
       */
      insertAt : function(X, Y){

        this.splice(X, 0, Y).dispose();
      },
      /**
       * Insert an item into the array before a given item.
       *
       * @param before {var} Insert item before this object.
       * @param item {var} The item to be inserted.
       */
      insertBefore : function(ba, bb){

        var bc = this.indexOf(ba);
        if(bc == -1){

          this.push(bb);
        } else {

          this.splice(bc, 0, bb).dispose();
        };
      },
      /**
       * Insert an element into the array after a given item.
       *
       * @param after {var} Insert item after this object.
       * @param item {var} Object to be inserted.
       */
      insertAfter : function(bd, be){

        var bf = this.indexOf(bd);
        if(bf == -1 || bf == (this.length - 1)){

          this.push(be);
        } else {

          this.splice(bf + 1, 0, be).dispose();
        };
      },
      /**
       * Remove an element from the array at the given index.
       *
       * @param index {Integer} Index of the item to be removed.
       * @return {var} The removed item.
       */
      removeAt : function(bg){

        var bi = this.splice(bg, 1);
        var bh = bi.getItem(0);
        bi.dispose();
        return bh;
      },
      /**
       * Remove all elements from the array.
       *
       * @return {Array} A native array containing the removed elements.
       */
      removeAll : function(){

        // remove all possible added event listeners
        for(var i = 0;i < this.__array.length;i++){

          this._registerEventChaining(null, this.__array[i], i);
        };
        // ignore if array is empty
        if(this.getLength() == 0){

          return;
        };
        // store the old data
        var bk = this.getLength();
        var bj = this.__array.concat();
        // change the length
        this.__array.length = 0;
        this.__updateLength();
        // fire change bubbles event
        this.fireDataEvent(g, {
          value : [],
          name : f + (bk - 1),
          old : bj,
          item : this
        });
        // fire the change event
        this.fireDataEvent(d, {
          start : 0,
          end : bk - 1,
          type : b,
          items : bj
        }, null);
        return bj;
      },
      /**
       * Append the items of the given array.
       *
       * @param array {Array|qx.data.IListData} The items of this array will
       * be appended.
       * @throws An exception if the second argument is not an array.
       */
      append : function(bl){

        // qooxdoo array support
        if(bl instanceof qx.data.Array){

          bl = bl.toArray();
        };
        // this check is important because opera throws an uncatchable error if
        // apply is called without an array as argument.
        if(qx.core.Environment.get(k)){

          qx.core.Assert.assertArray(bl, o);
        };
        Array.prototype.push.apply(this.__array, bl);
        // add a listener to the new items
        for(var i = 0;i < bl.length;i++){

          this._registerEventChaining(bl[i], null, this.__array.length + i);
        };
        var bm = this.length;
        this.__updateLength();
        // fire change bubbles
        var name = bm == (this.length - 1) ? bm : bm + l + (this.length - 1);
        this.fireDataEvent(g, {
          value : bl,
          name : name + e,
          old : [],
          item : this
        });
        // fire the change event
        this.fireDataEvent(d, {
          start : bm,
          end : this.length - 1,
          type : a,
          items : bl
        }, null);
      },
      /**
       * Remove the given item.
       *
       * @param item {var} Item to be removed from the array.
       * @return {var} The removed item.
       */
      remove : function(bn){

        var bo = this.indexOf(bn);
        if(bo != -1){

          this.splice(bo, 1).dispose();
          return bn;
        };
      },
      /**
       * Check whether the given array has the same content as this.
       * Checks only the equality of the arrays' content.
       *
       * @param array {qx.data.Array} The array to check.
       * @return {Boolean} Whether the two arrays are equal.
       */
      equals : function(bp){

        if(this.length !== bp.length){

          return false;
        };
        for(var i = 0;i < this.length;i++){

          if(this.getItem(i) !== bp.getItem(i)){

            return false;
          };
        };
        return true;
      },
      /**
       * Returns the sum of all values in the array. Supports
       * numeric values only.
       *
       * @return {Number} The sum of all values.
       */
      sum : function(){

        var bq = 0;
        for(var i = 0;i < this.length;i++){

          bq += this.getItem(i);
        };
        return bq;
      },
      /**
       * Returns the highest value in the given array.
       * Supports numeric values only.
       *
       * @return {Number | null} The highest of all values or undefined if the
       *   array is empty.
       */
      max : function(){

        var br = this.getItem(0);
        for(var i = 1;i < this.length;i++){

          if(this.getItem(i) > br){

            br = this.getItem(i);
          };
        };
        return br === undefined ? null : br;
      },
      /**
       * Returns the lowest value in the array. Supports
       * numeric values only.
       *
       * @return {Number | null} The lowest of all values or undefined
       *   if the array is empty.
       */
      min : function(){

        var bs = this.getItem(0);
        for(var i = 1;i < this.length;i++){

          if(this.getItem(i) < bs){

            bs = this.getItem(i);
          };
        };
        return bs === undefined ? null : bs;
      },
      /**
       * Invokes the given function for every item in the array.
       *
       * @param callback {Function} The function which will be call for every
       *   item in the array. It will be invoked with three parameters:
       *   the item, the index and the array itself.
       * @param context {var} The context in which the callback will be invoked.
       */
      forEach : function(bt, bu){

        for(var i = 0;i < this.__array.length;i++){

          bt.call(bu, this.__array[i], i, this);
        };
      },
      /*
      ---------------------------------------------------------------------------
        INTERNAL HELPERS
      ---------------------------------------------------------------------------
      */
      /**
       * Internal function which updates the length property of the array.
       * Every time the length will be updated, a {@link #changeLength} data
       * event will be fired.
       */
      __updateLength : function(){

        var bv = this.length;
        this.length = this.__array.length;
        this.fireDataEvent(m, this.length, bv);
      },
      /**
       * Helper to update the event propagation for a range of items.
       * @param from {Number} Start index.
       * @param to {Number} End index.
       */
      __updateEventPropagation : function(bw, bx){

        for(var i = bw;i < bx;i++){

          this._registerEventChaining(this.__array[i], this.__array[i], i);
        };
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
    */
    destruct : function(){

      for(var i = 0;i < this.__array.length;i++){

        var by = this.__array[i];
        this._applyEventPropagation(null, by, i);
        // dispose the items on auto dispose
        if(this.isAutoDisposeItems() && by && by instanceof qx.core.Object){

          by.dispose();
        };
      };
      this.__array = null;
    }
  });
})();
(function(){

  var b = "qx.ui.core.ISingleSelection",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Each object, which should support single selection have to
   * implement this interface.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fires after the selection was modified */
      "changeSelection" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Returns an array of currently selected items.
       *
       * Note: The result is only a set of selected items, so the order can
       * differ from the sequence in which the items were added.
       *
       * @return {qx.ui.core.Widget[]} List of items.
       */
      getSelection : function(){

        return true;
      },
      /**
       * Replaces current selection with the given items.
       *
       * @param items {qx.ui.core.Widget[]} Items to select.
       * @throws an exception if the item is not a child element.
       */
      setSelection : function(c){

        return arguments.length == 1;
      },
      /**
       * Clears the whole selection at once.
       */
      resetSelection : function(){

        return true;
      },
      /**
       * Detects whether the given item is currently selected.
       *
       * @param item {qx.ui.core.Widget} Any valid selectable item
       * @return {Boolean} Whether the item is selected.
       * @throws an exception if the item is not a child element.
       */
      isSelected : function(d){

        return arguments.length == 1;
      },
      /**
       * Whether the selection is empty.
       *
       * @return {Boolean} Whether the selection is empty.
       */
      isSelectionEmpty : function(){

        return true;
      },
      /**
       * Returns all elements which are selectable.
       *
       * @param all {boolean} true for all selectables, false for the
       *   selectables the user can interactively select
       * @return {qx.ui.core.Widget[]} The contained items.
       */
      getSelectables : function(e){

        return arguments.length == 1;
      }
    }
  });
})();
(function(){

  var a = "qx.ui.form.IModelSelection";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * This interface should be used in all objects managing a set of items
   * implementing {@link qx.ui.form.IModel}.
   */
  qx.Interface.define(a, {
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Tries to set the selection using the given array containing the
       * representative models for the selectables.
       *
       * @param value {Array} An array of models.
       */
      setModelSelection : function(b){
      },
      /**
       * Returns an array of the selected models.
       *
       * @return {Array} An array containing the models of the currently selected
       *   items.
       */
      getModelSelection : function(){
      }
    }
  });
})();
(function(){

  var r = "_applyAllowEmptySelection",q = "_applyInvalidMessage",p = "qx.ui.form.RadioGroup",o = "_applyValid",n = "",m = "changeRequired",k = "changeValid",j = "changeEnabled",h = "__items",g = "changeSelection",c = "_applyEnabled",f = "changeInvalidMessage",d = "changeValue",b = "String",a = "Boolean";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * The radio group handles a collection of items from which only one item
   * can be selected. Selection another item will deselect the previously selected
   * item.
   *
   * This class is e.g. used to create radio groups or {@link qx.ui.form.RadioButton}
   * or {@link qx.ui.toolbar.RadioButton} instances.
   *
   * We also offer a widget for the same purpose which uses this class. So if
   * you like to act with a widget instead of a pure logic coupling of the
   * widgets, take a look at the {@link qx.ui.form.RadioButtonGroup} widget.
   */
  qx.Class.define(p, {
    extend : qx.core.Object,
    implement : [qx.ui.core.ISingleSelection, qx.ui.form.IForm, qx.ui.form.IModelSelection],
    include : [qx.ui.core.MSingleSelectionHandling, qx.ui.form.MModelSelection],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param varargs {qx.core.Object} A variable number of items, which are
     *     initially added to the radio group, the first item will be selected.
     */
    construct : function(s){

      qx.core.Object.call(this);
      // create item array
      this.__items = [];
      // add listener before call add!!!
      this.addListener(g, this.__onChangeSelection, this);
      if(s != null){

        this.add.apply(this, arguments);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Whether the radio group is enabled
       */
      enabled : {
        check : a,
        apply : c,
        event : j,
        init : true
      },
      /**
       * Whether the selection should wrap around. This means that the successor of
       * the last item is the first item.
       */
      wrap : {
        check : a,
        init : true
      },
      /**
       * If is set to <code>true</code> the selection could be empty,
       * otherwise is always one <code>RadioButton</code> selected.
       */
      allowEmptySelection : {
        check : a,
        init : false,
        apply : r
      },
      /**
       * Flag signaling if the group at all is valid. All children will have the
       * same state.
       */
      valid : {
        check : a,
        init : true,
        apply : o,
        event : k
      },
      /**
       * Flag signaling if the group is required.
       */
      required : {
        check : a,
        init : false,
        event : m
      },
      /**
       * Message which is shown in an invalid tooltip.
       */
      invalidMessage : {
        check : b,
        init : n,
        event : f,
        apply : q
      },
      /**
       * Message which is shown in an invalid tooltip if the {@link #required} is
       * set to true.
       */
      requiredInvalidMessage : {
        check : b,
        nullable : true,
        event : f
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** {qx.ui.form.IRadioItem[]} The items of the radio group */
      __items : null,
      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */
      /**
       * Get all managed items
       *
       * @return {qx.ui.form.IRadioItem[]} All managed items.
       */
      getItems : function(){

        return this.__items;
      },
      /*
      ---------------------------------------------------------------------------
        REGISTRY
      ---------------------------------------------------------------------------
      */
      /**
       * Add the passed items to the radio group.
       *
       * @param varargs {qx.ui.form.IRadioItem} A variable number of items to add.
       */
      add : function(t){

        var u = this.__items;
        var v;
        for(var i = 0,l = arguments.length;i < l;i++){

          v = arguments[i];
          if(qx.lang.Array.contains(u, v)){

            continue;
          };
          // Register listeners
          v.addListener(d, this._onItemChangeChecked, this);
          // Push RadioButton to array
          u.push(v);
          // Inform radio button about new group
          v.setGroup(this);
          // Need to update internal value?
          if(v.getValue()){

            this.setSelection([v]);
          };
        };
        // Select first item when only one is registered
        if(!this.isAllowEmptySelection() && u.length > 0 && !this.getSelection()[0]){

          this.setSelection([u[0]]);
        };
      },
      /**
       * Remove an item from the radio group.
       *
       * @param item {qx.ui.form.IRadioItem} The item to remove.
       */
      remove : function(w){

        var x = this.__items;
        if(qx.lang.Array.contains(x, w)){

          // Remove RadioButton from array
          qx.lang.Array.remove(x, w);
          // Inform radio button about new group
          if(w.getGroup() === this){

            w.resetGroup();
          };
          // Deregister listeners
          w.removeListener(d, this._onItemChangeChecked, this);
          // if the radio was checked, set internal selection to null
          if(w.getValue()){

            this.resetSelection();
          };
        };
      },
      /**
       * Returns an array containing the group's items.
       *
       * @return {qx.ui.form.IRadioItem[]} The item array
       */
      getChildren : function(){

        return this.__items;
      },
      /*
      ---------------------------------------------------------------------------
        LISTENER FOR ITEM CHANGES
      ---------------------------------------------------------------------------
      */
      /**
       * Event listener for <code>changeValue</code> event of every managed item.
       *
       * @param e {qx.event.type.Data} Data event
       */
      _onItemChangeChecked : function(e){

        var y = e.getTarget();
        if(y.getValue()){

          this.setSelection([y]);
        } else if(this.getSelection()[0] == y){

          this.resetSelection();
        };
      },
      /*
      ---------------------------------------------------------------------------
        APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyInvalidMessage : function(z, A){

        for(var i = 0;i < this.__items.length;i++){

          this.__items[i].setInvalidMessage(z);
        };
      },
      // property apply
      _applyValid : function(B, C){

        for(var i = 0;i < this.__items.length;i++){

          this.__items[i].setValid(B);
        };
      },
      // property apply
      _applyEnabled : function(D, E){

        var F = this.__items;
        if(D == null){

          for(var i = 0,l = F.length;i < l;i++){

            F[i].resetEnabled();
          };
        } else {

          for(var i = 0,l = F.length;i < l;i++){

            F[i].setEnabled(D);
          };
        };
      },
      // property apply
      _applyAllowEmptySelection : function(G, H){

        if(!G && this.isSelectionEmpty()){

          this.resetSelection();
        };
      },
      /*
      ---------------------------------------------------------------------------
        SELECTION
      ---------------------------------------------------------------------------
      */
      /**
       * Select the item following the given item.
       */
      selectNext : function(){

        var I = this.getSelection()[0];
        var K = this.__items;
        var J = K.indexOf(I);
        if(J == -1){

          return;
        };
        var i = 0;
        var length = K.length;
        // Find next enabled item
        if(this.getWrap()){

          J = (J + 1) % length;
        } else {

          J = Math.min(J + 1, length - 1);
        };
        while(i < length && !K[J].getEnabled()){

          J = (J + 1) % length;
          i++;
        };
        this.setSelection([K[J]]);
      },
      /**
       * Select the item previous the given item.
       */
      selectPrevious : function(){

        var L = this.getSelection()[0];
        var N = this.__items;
        var M = N.indexOf(L);
        if(M == -1){

          return;
        };
        var i = 0;
        var length = N.length;
        // Find previous enabled item
        if(this.getWrap()){

          M = (M - 1 + length) % length;
        } else {

          M = Math.max(M - 1, 0);
        };
        while(i < length && !N[M].getEnabled()){

          M = (M - 1 + length) % length;
          i++;
        };
        this.setSelection([N[M]]);
      },
      /*
      ---------------------------------------------------------------------------
        HELPER METHODS FOR SELECTION API
      ---------------------------------------------------------------------------
      */
      /**
       * Returns the items for the selection.
       *
       * @return {qx.ui.form.IRadioItem[]} Items to select.
       */
      _getItems : function(){

        return this.getItems();
      },
      /**
       * Returns if the selection could be empty or not.
       *
       * @return {Boolean} <code>true</code> If selection could be empty,
       *    <code>false</code> otherwise.
       */
      _isAllowEmptySelection : function(){

        return this.isAllowEmptySelection();
      },
      /**
       * Returns whether the item is selectable. In opposite to the default
       * implementation (which checks for visible items) every radio button
       * which is part of the group is selected even if it is currently not visible.
       *
       * @param item {qx.ui.form.IRadioItem} The item to check if its selectable.
       * @return {Boolean} <code>true</code> if the item is part of the radio group
       *    <code>false</code> otherwise.
       */
      _isItemSelectable : function(O){

        return this.__items.indexOf(O) != -1;
      },
      /**
       * Event handler for <code>changeSelection</code>.
       *
       * @param e {qx.event.type.Data} Data event.
       */
      __onChangeSelection : function(e){

        var Q = e.getData()[0];
        var P = e.getOldData()[0];
        if(P){

          P.setValue(false);
        };
        if(Q){

          Q.setValue(true);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._disposeArray(h);
    }
  });
})();
(function(){

  var k = "mousedown",j = "_applyTriState",i = "mouseout",h = "changeValue",g = "keydown",f = "_applyGroup",d = "button",c = "execute",b = "qx.ui.form.RadioGroup",a = "_applyValue",w = "qx.ui.form.ToggleButton",v = "mouseover",u = "keyup",t = "mouseup",s = "hovered",r = "Boolean",q = "Space",p = "undetermined",o = "Enter",n = "checked",l = "abandoned",m = "pressed";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * A toggle Button widget
   *
   * If the user presses the button by clicking on it pressing the enter or
   * space key, the button toggles between the pressed an not pressed states.
   * There is no execute event, only a {@link qx.ui.form.ToggleButton#changeValue}
   * event.
   */
  qx.Class.define(w, {
    extend : qx.ui.basic.Atom,
    include : [qx.ui.core.MExecutable],
    implement : [qx.ui.form.IBooleanForm, qx.ui.form.IExecutable, qx.ui.form.IRadioItem],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * Creates a ToggleButton.
     *
     * @param label {String} The text on the button.
     * @param icon {String} An URI to the icon of the button.
     */
    construct : function(x, y){

      qx.ui.basic.Atom.call(this, x, y);
      // register mouse events
      this.addListener(v, this._onMouseOver);
      this.addListener(i, this._onMouseOut);
      this.addListener(k, this._onMouseDown);
      this.addListener(t, this._onMouseUp);
      // register keyboard events
      this.addListener(g, this._onKeyDown);
      this.addListener(u, this._onKeyUp);
      // register execute event
      this.addListener(c, this._onExecute, this);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : d
      },
      // overridden
      focusable : {
        refine : true,
        init : true
      },
      /** The value of the widget. True, if the widget is checked. */
      value : {
        check : r,
        nullable : true,
        event : h,
        apply : a,
        init : false
      },
      /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons. */
      group : {
        check : b,
        nullable : true,
        apply : f
      },
      /**
      * Whether the button has a third state. Use this for tri-state checkboxes.
      *
      * When enabled, the value null of the property value stands for "undetermined",
      * while true is mapped to "enabled" and false to "disabled" as usual. Note
      * that the value property is set to false initially.
      *
      */
      triState : {
        check : r,
        apply : j,
        nullable : true,
        init : null
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
      _applyGroup : function(z, A){

        if(A){

          A.remove(this);
        };
        if(z){

          z.add(this);
        };
      },
      /**
       * Changes the state of the button dependent on the checked value.
       *
       * @param value {Boolean} Current value
       * @param old {Boolean} Previous value
       */
      _applyValue : function(B, C){

        B ? this.addState(n) : this.removeState(n);
        if(this.isTriState()){

          if(B === null){

            this.addState(p);
          } else if(C === null){

            this.removeState(p);
          };
        };
      },
      /**
      * Apply value property when triState property is modified.
      *
      * @param value {Boolean} Current value
      * @param old {Boolean} Previous value
      */
      _applyTriState : function(D, E){

        this._applyValue(this.getValue());
      },
      /**
       * Handler for the execute event.
       *
       * @param e {qx.event.type.Event} The execute event.
       */
      _onExecute : function(e){

        this.toggleValue();
      },
      /**
       * Listener method for "mouseover" event.
       * <ul>
       * <li>Adds state "hovered"</li>
       * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOver : function(e){

        if(e.getTarget() !== this){

          return;
        };
        this.addState(s);
        if(this.hasState(l)){

          this.removeState(l);
          this.addState(m);
        };
      },
      /**
       * Listener method for "mouseout" event.
       * <ul>
       * <li>Removes "hovered" state</li>
       * <li>Adds "abandoned" state (if "pressed" state is set)</li>
       * <li>Removes "pressed" state (if "pressed" state is set and button is not checked)
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseOut : function(e){

        if(e.getTarget() !== this){

          return;
        };
        this.removeState(s);
        if(this.hasState(m)){

          if(!this.getValue()){

            this.removeState(m);
          };
          this.addState(l);
        };
      },
      /**
       * Listener method for "mousedown" event.
       * <ul>
       * <li>Activates capturing</li>
       * <li>Removes "abandoned" state</li>
       * <li>Adds "pressed" state</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseDown : function(e){

        if(!e.isLeftPressed()){

          return;
        };
        // Activate capturing if the button get a mouseout while
        // the button is pressed.
        this.capture();
        this.removeState(l);
        this.addState(m);
        e.stopPropagation();
      },
      /**
       * Listener method for "mouseup" event.
       * <ul>
       * <li>Releases capturing</li>
       * <li>Removes "pressed" state (if not "abandoned" state is set and "pressed" state is set)</li>
       * <li>Removes "abandoned" state (if set)</li>
       * <li>Toggles {@link #value} (if state "abandoned" is not set and state "pressed" is set)</li>
       * </ul>
       *
       * @param e {Event} Mouse event
       * @return {void}
       */
      _onMouseUp : function(e){

        this.releaseCapture();
        if(this.hasState(l)){

          this.removeState(l);
        } else if(this.hasState(m)){

          this.execute();
        };
        this.removeState(m);
        e.stopPropagation();
      },
      /**
       * Listener method for "keydown" event.<br/>
       * Removes "abandoned" and adds "pressed" state
       * for the keys "Enter" or "Space"
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyDown : function(e){

        switch(e.getKeyIdentifier()){case o:case q:
        this.removeState(l);
        this.addState(m);
        e.stopPropagation();};
      },
      /**
       * Listener method for "keyup" event.<br/>
       * Removes "abandoned" and "pressed" state (if "pressed" state is set)
       * for the keys "Enter" or "Space". It also toggles the {@link #value} property.
       *
       * @param e {Event} Key event
       * @return {void}
       */
      _onKeyUp : function(e){

        if(!this.hasState(m)){

          return;
        };
        switch(e.getKeyIdentifier()){case o:case q:
        this.removeState(l);
        this.execute();
        this.removeState(m);
        e.stopPropagation();};
      }
    }
  });
})();
(function(){

  var b = "changeModel",a = "qx.ui.form.MModelProperty";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Can be included for implementing {@link qx.ui.form.IModel}. It only contains
   * a nullable property named 'model' with a 'changeModel' event.
   */
  qx.Mixin.define(a, {
    properties : {
      /**
       * Model property for storing additional information for the including
       * object. It can act as value property on form items for example.
       *
       * Be careful using that property as this is used for the
       * {@link qx.ui.form.MModelSelection} it has some restrictions:
       *
       * * Don't use equal models in one widget using the
       *     {@link qx.ui.form.MModelSelection}.
       *
       * * Avoid setting only some model properties if the widgets are added to
       *     a {@link qx.ui.form.MModelSelection} widge.
       *
       * Both restrictions result of the fact, that the set models are deputies
       * for their widget.
       */
      model : {
        nullable : true,
        event : b,
        dereference : true
      }
    }
  });
})();
(function(){

  var b = "qx.ui.form.IModel",a = "qx.event.type.Data";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Each object which wants to store data representative for the real item
   * should implement this interface.
   */
  qx.Interface.define(b, {
    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events : {
      /** Fired when the model data changes */
      "changeModel" : a
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      /**
       * Set the representative data for the item.
       *
       * @param value {var} The data.
       */
      setModel : function(c){
      },
      /**
       * Returns the representative data for the item
       *
       * @return {var} The data.
       */
      getModel : function(){
      },
      /**
       * Sets the representative data to null.
       */
      resetModel : function(){
      }
    }
  });
})();
(function(){

  var h = "label",g = "qx.debug",f = "checkbox",e = "qx.ui.form.CheckBox",d = "value",c = "toolTipText",b = "enabled",a = "menu";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * A check box widget with an optional label.
   */
  qx.Class.define(e, {
    extend : qx.ui.form.ToggleButton,
    include : [qx.ui.form.MForm, qx.ui.form.MModelProperty],
    implement : [qx.ui.form.IForm, qx.ui.form.IModel],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param label {String?null} An optional label for the check box.
     */
    construct : function(i){

      if(qx.core.Environment.get(g)){

        this.assertArgumentsCount(arguments, 0, 1);
      };
      qx.ui.form.ToggleButton.call(this, i);
      // Initialize the checkbox to a valid value (the default is null which
      // is invalid)
      this.setValue(false);
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      // overridden
      appearance : {
        refine : true,
        init : f
      },
      // overridden
      allowGrowX : {
        refine : true,
        init : false
      }
    },
    /**
     * @lint ignoreReferenceField(_forwardStates,_bindableProperties)
     */
    members : {
      // overridden
      _forwardStates : {
        invalid : true,
        focused : true,
        undetermined : true,
        checked : true,
        hovered : true
      },
      // overridden (from MExecutable to keet the icon out of the binding)
      _bindableProperties : [b, h, c, d, a]
    }
  });
})();
(function(){

  var t = "monospace",s = "Courier New",r = "Lucida Console",q = "Monaco",p = "qx.theme.modern.Font",o = "DejaVu Sans Mono",n = "Consolas",m = "Liberation Sans",l = "Tahoma",k = "sans-serif",d = "Arial",j = "Lucida Grande",g = "Candara",c = "Segoe UI",b = "osx",f = "win",e = "7",h = "vista",a = "os.name",i = "os.version";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
  
  ************************************************************************* */
  /**
   * The modern font theme.
   */
  qx.Theme.define(p, {
    fonts : {
      "default" : {
        size : (qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h)) ? 12 : 11,
        lineHeight : 1.4,
        family : qx.core.Environment.get(a) == b ? [j] : ((qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h))) ? [c, g] : [l, m, d, k]
      },
      "bold" : {
        size : (qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h)) ? 12 : 11,
        lineHeight : 1.4,
        family : qx.core.Environment.get(a) == b ? [j] : ((qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h))) ? [c, g] : [l, m, d, k],
        bold : true
      },
      "small" : {
        size : (qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h)) ? 11 : 10,
        lineHeight : 1.4,
        family : qx.core.Environment.get(a) == b ? [j] : ((qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h))) ? [c, g] : [l, m, d, k]
      },
      "monospace" : {
        size : 11,
        lineHeight : 1.4,
        family : qx.core.Environment.get(a) == b ? [r, q] : ((qx.core.Environment.get(a) == f && (qx.core.Environment.get(i) == e || qx.core.Environment.get(i) == h))) ? [n] : [n, o, s, t]
      }
    }
  });
})();
(function(){

  var a = "dicomheaderview.theme.Font";
  /* ************************************************************************
  
     Copyright:
  
     License:
  
     Authors:
  
  ************************************************************************ */
  qx.Theme.define(a, {
    extend : qx.theme.modern.Font,
    fonts : {
    }
  });
})();
(function(){

  var c = "Tango",b = "qx/icon/Tango",a = "qx.theme.icon.Tango";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */
  /**
   * Tango icons
   */
  qx.Theme.define(a, {
    title : c,
    aliases : {
      "icon" : b
    }
  });
})();
(function(){

  var bB = "black",bA = "#ffffdd",bz = "#b6b6b6",by = "#004DAD",bx = "#BABABA",bw = "#005BC3",bv = "#334866",bu = "#CECECE",bt = "#D9D9D9",bs = "#D8D8D8",bh = "#99C3FE",bg = "#001533",bf = "#B3B3B3",be = "#D5D5D5",bd = "#C3C3C3",bc = "#DDDDDD",bb = "#FF9999",ba = "css.rgba",Y = "#E8E8E9",X = "#084FAA",bI = "#C5C5C5",bJ = "rgba(0, 0, 0, 0.4)",bG = "#DBDBDB",bH = "#4a4a4a",bE = "#83BAEA",bF = "#D7E7F4",bC = "#07125A",bD = "#FAF2F2",bK = "#87AFE7",bL = "#F7EAEA",bl = "#777D8D",bk = "#FBFBFB",bn = "#CACACA",bm = "#909090",bp = "#9B9B9B",bo = "#F0F9FE",br = "#314a6e",bq = "#B4B4B4",bj = "#787878",bi = "qx.theme.modern.Color",a = "#000000",b = "#26364D",c = "#A7A7A7",d = "#D1E4FF",e = "#5CB0FD",f = "#EAEAEA",g = "#003B91",h = "#80B4EF",i = "#FF6B78",j = "#949494",bP = "#808080",bO = "#930000",bN = "#7B7B7B",bM = "#C82C2C",bT = "#DFDFDF",bS = "#B6B6B6",bR = "#0880EF",bQ = "#4d4d4d",bV = "#f4f4f4",bU = "#7B7A7E",H = "#D0D0D0",I = "#f8f8f8",F = "#404955",G = "#959595",L = "#AAAAAA",M = "#F7E9E9",J = "#314A6E",K = "#C72B2B",D = "#FAFAFA",E = "#FBFCFB",r = "#B2D2FF",q = "#666666",t = "#CBC8CD",s = "#999999",n = "#8EB8D6",m = "#b8b8b8",p = "#727272",o = "#33508D",l = "#F1F1F1",k = "#990000",R = "#00368A",S = "#1a1a1a",T = "#00204D",U = "gray",N = "#F4F4F4",O = "#fffefe",P = "#AFAFAF",Q = "#084FAB",V = "#FCFCFC",W = "#CCC",B = "#F2F2F2",A = "#F0F0F0",z = "#E8E8E8",y = "#CCCCCC",x = "#EFEFEF",w = "#EEEEEE",v = "#E4E4E4",u = "#F3F3F3",C = "white";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Alexander Steitz (aback)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Modern color theme
   */
  qx.Theme.define(bi, {
    colors : {
      /*
      ---------------------------------------------------------------------------
        BACKGROUND COLORS
      ---------------------------------------------------------------------------
      */
      // application, desktop, ...
      "background-application" : bT,
      // pane color for windows, splitpanes, ...
      "background-pane" : u,
      // textfields, ...
      "background-light" : V,
      // headers, ...
      "background-medium" : w,
      // splitpane
      "background-splitpane" : P,
      // tooltip, ...
      "background-tip" : bA,
      // error tooltip
      "background-tip-error" : K,
      // tables, ...
      "background-odd" : v,
      // html area
      "htmlarea-background" : C,
      // progress bar
      "progressbar-background" : C,
      /*
      ---------------------------------------------------------------------------
        TEXT COLORS
      ---------------------------------------------------------------------------
      */
      // other types
      "text-light" : bm,
      "text-gray" : bH,
      // labels
      "text-label" : S,
      // group boxes
      "text-title" : br,
      // text fields
      "text-input" : a,
      // states
      "text-hovered" : bg,
      "text-disabled" : bU,
      "text-selected" : O,
      "text-active" : b,
      "text-inactive" : F,
      "text-placeholder" : t,
      /*
      ---------------------------------------------------------------------------
        BORDER COLORS
      ---------------------------------------------------------------------------
      */
      "border-inner-scrollbar" : C,
      // menus, tables, scrollbars, list, etc.
      "border-main" : bQ,
      "menu-separator-top" : bI,
      "menu-separator-bottom" : D,
      // between toolbars
      "border-separator" : bP,
      "border-toolbar-button-outer" : bz,
      "border-toolbar-border-inner" : I,
      "border-toolbar-separator-right" : bV,
      "border-toolbar-separator-left" : m,
      // text fields
      "border-input" : bv,
      "border-inner-input" : C,
      // disabled text fields
      "border-disabled" : bS,
      // tab view, window
      "border-pane" : T,
      // buttons
      "border-button" : q,
      // tables (vertical line)
      "border-column" : y,
      // focus state of text fields
      "border-focused" : bh,
      // invalid form widgets
      "invalid" : k,
      "border-focused-invalid" : bb,
      // drag & drop
      "border-dragover" : o,
      "keyboard-focus" : bB,
      /*
      ---------------------------------------------------------------------------
        TABLE COLORS
      ---------------------------------------------------------------------------
      */
      // equal to "background-pane"
      "table-pane" : u,
      // own table colors
      // "table-row-background-selected" and "table-row-background-focused-selected"
      // are inspired by the colors of the selection decorator
      "table-focus-indicator" : bR,
      "table-row-background-focused-selected" : Q,
      "table-row-background-focused" : h,
      "table-row-background-selected" : Q,
      // equal to "background-pane" and "background-odd"
      "table-row-background-even" : u,
      "table-row-background-odd" : v,
      // equal to "text-selected" and "text-label"
      "table-row-selected" : O,
      "table-row" : S,
      // equal to "border-collumn"
      "table-row-line" : W,
      "table-column-line" : W,
      "table-header-hovered" : C,
      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE TABLE COLORS
      ---------------------------------------------------------------------------
      */
      "progressive-table-header" : L,
      "progressive-table-header-border-right" : B,
      "progressive-table-row-background-even" : N,
      "progressive-table-row-background-odd" : v,
      "progressive-progressbar-background" : U,
      "progressive-progressbar-indicator-done" : y,
      "progressive-progressbar-indicator-undone" : C,
      "progressive-progressbar-percent-background" : U,
      "progressive-progressbar-percent-text" : C,
      /*
      ---------------------------------------------------------------------------
        CSS ONLY COLORS
      ---------------------------------------------------------------------------
      */
      "selected-start" : by,
      "selected-end" : R,
      "tabview-background" : bC,
      "shadow" : qx.core.Environment.get(ba) ? bJ : s,
      "pane-start" : bk,
      "pane-end" : A,
      "group-background" : z,
      "group-border" : bq,
      "radiobutton-background" : x,
      "checkbox-border" : J,
      "checkbox-focus" : bK,
      "checkbox-hovered" : r,
      "checkbox-hovered-inner" : d,
      "checkbox-inner" : w,
      "checkbox-start" : v,
      "checkbox-end" : u,
      "checkbox-disabled-border" : bj,
      "checkbox-disabled-inner" : bn,
      "checkbox-disabled-start" : H,
      "checkbox-disabled-end" : bs,
      "checkbox-hovered-inner-invalid" : bD,
      "checkbox-hovered-invalid" : M,
      "radiobutton-checked" : bw,
      "radiobutton-disabled" : be,
      "radiobutton-checked-disabled" : bN,
      "radiobutton-hovered-invalid" : bL,
      "tooltip-error" : bM,
      "scrollbar-start" : y,
      "scrollbar-end" : l,
      "scrollbar-slider-start" : w,
      "scrollbar-slider-end" : bd,
      "button-border-disabled" : G,
      "button-start" : A,
      "button-end" : P,
      "button-disabled-start" : N,
      "button-disabled-end" : bx,
      "button-hovered-start" : bo,
      "button-hovered-end" : n,
      "button-focused" : bE,
      "border-invalid" : bO,
      "input-start" : A,
      "input-end" : E,
      "input-focused-start" : bF,
      "input-focused-end" : e,
      "input-focused-inner-invalid" : i,
      "input-border-disabled" : bp,
      "input-border-inner" : C,
      "toolbar-start" : x,
      "toolbar-end" : bc,
      "window-border" : T,
      "window-border-caption" : p,
      "window-caption-active-text" : C,
      "window-caption-active-start" : X,
      "window-caption-active-end" : g,
      "window-caption-inactive-start" : B,
      "window-caption-inactive-end" : bG,
      "window-statusbar-background" : x,
      "tabview-start" : V,
      "tabview-end" : w,
      "tabview-inactive" : bl,
      "tabview-inactive-start" : f,
      "tabview-inactive-end" : bu,
      "table-header-start" : z,
      "table-header-end" : bf,
      "menu-start" : Y,
      "menu-end" : bt,
      "menubar-start" : z,
      "groupitem-start" : c,
      "groupitem-end" : j,
      "groupitem-text" : C,
      "virtual-row-layer-background-even" : C,
      "virtual-row-layer-background-odd" : C
    }
  });
})();
(function(){

  var a = "dicomheaderview.theme.Color";
  /* ************************************************************************
  
     Copyright:
  
     License:
  
     Authors:
  
  ************************************************************************ */
  qx.Theme.define(a, {
    extend : qx.theme.modern.Color,
    colors : {
    }
  });
})();
(function(){

  var eq = "button-checked",ep = "decoration/window/maximize-active-hovered.png",eo = "keyboard-focus",en = "menu-css",em = "decoration/cursors/",el = "slidebar",ek = "tooltip-error-arrow",ej = "table-scroller-focus-indicator",ei = "popup-css",eh = "move-frame",cC = "nodrop",cB = "decoration/table/boolean-true.png",cA = "-invalid-css",cz = "menu",cy = "app-header",cx = "row-layer",cw = "text-inactive",cv = "move",cu = "decoration/window/restore-active-hovered.png",ct = "shadow-window",ex = "tree-folder",ey = "window-pane-css",ev = "right.png",ew = "checkbox-undetermined-hovered",et = "window-incl-statusbar-css",eu = "tabview-page-button-bottom-inactive",er = "tooltip-error",es = "window-css",ez = "window-statusbar",eA = "button-hovered",dI = "decoration/scrollbar/scrollbar-",dH = "background-tip",dK = "menubar-css",dJ = "scrollbar-slider-horizontal-disabled",dM = "radiobutton-disabled",dL = "window-resize-frame-css",dO = "button-pressed",dN = "table-pane",dF = "decoration/window/close-active.png",dE = "native",v = "button-invalid-shadow",w = "decoration/window/minimize-active-hovered.png",x = "menubar",y = "icon/16/actions/dialog-cancel.png",z = "tabview-page-button-top-inactive",A = "tabview-page-button-left-inactive",B = "menu-slidebar",C = "toolbar-button-checked",D = "-left",E = "decoration/tree/open-selected.png",eS = "decoration/window/minimize-inactive.png",eR = "icon/16/apps/office-calendar.png",eQ = "group-item-css",eP = "group",eW = "tabview-page-button-right-inactive",eV = "decoration/window/minimize-active.png",eU = "decoration/window/restore-inactive.png",eT = "checkbox-checked-focused",eY = "splitpane",eX = "combobox/textfield",bz = "decoration/window/close-active-hovered.png",bA = "qx/icon/Tango/16/actions/window-close.png",bx = "checkbox-pressed",by = "button-disabled",bD = "selected-dragover",bE = "border-separator",bB = "decoration/window/maximize-inactive.png",bC = "dragover",bv = "scrollarea",bw = "scrollbar-vertical",bb = "decoration/menu/checkbox-invert.gif",ba = "decoration/toolbar/toolbar-handle-knob.gif",bd = "icon/22/mimetypes/office-document.png",bc = "table-header-cell",W = "button-checked-focused",V = "up.png",Y = "best-fit",X = "pane-css",U = "decoration/tree/closed-selected.png",T = "tooltip-error-arrow-left",bK = "qx.theme.modern.Appearance",bL = "text-active",bM = "checkbox-disabled",bN = "toolbar-button-hovered",bG = "window-resize-frame-incl-statusbar-css",bH = "decoration/form/checked.png",bI = "progressive-table-header",bJ = "decoration/table/select-column-order.png",bO = "decoration/menu/radiobutton.gif",bP = "decoration/arrows/forward.png",bo = "decoration/table/descending.png",bn = "decoration/form/undetermined.png",bm = "tree-file",bl = "window-captionbar-active",bk = "checkbox-checked-hovered",bj = "scrollbar-slider-vertical",bi = "toolbar",bh = "alias",bs = "decoration/window/restore-active.png",br = "decoration/table/boolean-false.png",bQ = "icon/32/mimetypes/office-document.png",bR = "text-gray",bS = "mshtml",bT = "tabview-pane",bU = "decoration/arrows/rewind.png",bV = "top",bW = "icon/16/actions/dialog-ok.png",bX = "progressbar-background",bY = "engine.name",ca = "table-header-cell-hovered",cK = "window-statusbar-css",cJ = "window",cI = "browser.documentmode",cH = "decoration/menu/radiobutton-invert.gif",cO = "text-placeholder",cN = "slider",cM = "toolbar-css",cL = "keep-align",cS = "down.png",cR = "groupitem-text",ds = "tabview-page-button-top-active",dt = "icon/22/places/folder.png",dq = "decoration/window/maximize-active.png",dr = "checkbox-checked-pressed",dn = "decoration/window/close-inactive.png",dp = "tabview-page-button-left-active",dl = "toolbar-part",dm = "decoration/splitpane/knob-vertical.png",dA = ".gif",dB = "table-statusbar",dT = "progressive-table-header-cell-css",dS = "window-captionbar-inactive",dV = "copy",dU = "decoration/arrows/down-invert.png",dX = "decoration/menu/checkbox.gif",dW = "window-caption-active-text",ea = "decoration/splitpane/knob-horizontal.png",dY = "group-css",dQ = "icon/32/places/folder.png",dP = "toolbar-separator",eH = "tabview-page-button-bottom-active",eI = "decoration/arrows/up-small.png",eJ = "decoration/table/ascending.png",eK = "decoration/arrows/up-invert.png",eD = "small",eE = "tabview-page-button-right-active",eF = "-disabled",eG = "scrollbar-horizontal",eB = "progressbar",eC = "checkbox-undetermined-focused",k = "progressive-table-header-cell",j = "menu-separator",i = "tabview-pane-css",h = "pane",g = "htmlarea-background",f = "decoration/arrows/right-invert.png",e = "left.png",d = "icon/16/actions/view-refresh.png",c = "radiobutton-hovered",b = "group-item",J = "scrollbar/button",K = "right",H = "combobox/button",I = "virtual-list",N = "icon/16/places/folder.png",O = "radiobutton-checked-focused",L = "text-label",M = "decoration/tree/closed.png",Q = "table-scroller-header",R = "scrollbar-slider-horizontal",cW = "checkbox-hovered",cQ = "checkbox-checked",de = "decoration/arrows/left.png",da = "radiobutton-checked",cF = "button-focused",cD = "text-light",bf = "menu-slidebar-button",cG = "tree",bq = "checkbox-undetermined",bp = "table-scroller-header-css",ck = "text-input",cl = "slidebar/button-forward",cm = "background-splitpane",cn = "text-hovered",co = ".png",cp = "decoration/tree/open.png",cq = "default",cr = "decoration/arrows/down-small.png",ch = "datechooser",ci = "slidebar/button-backward",cE = "radiobutton-checked-disabled",dd = "checkbox-focused",dc = "radiobutton-checked-hovered",db = "treevirtual-folder",di = "shadow-popup",dh = "icon/16/mimetypes/office-document.png",dg = "background-medium",df = "icon/32/places/folder-open.png",cY = "icon/22/places/folder-open.png",cX = "table",P = "decoration/arrows/up.png",bu = "decoration/form/",bt = "radiobutton-focused",cP = "decoration/arrows/right.png",bF = "background-application",cV = "invalid",cU = "right-top",cT = "selectbox",be = "text-title",dk = "icon/16/places/folder-open.png",S = "radiobutton",bg = "list",cb = "tree-item",cc = "combobox",cd = "treevirtual-contract",ce = "scrollbar",cf = "datechooser/nav-button",cg = "center",dD = "checkbox",cj = "treevirtual-expand",ec = "",eb = "textfield",ee = "-invalid",ed = "tooltip",eg = "qx/static/blank.gif",ef = "border-invalid",cs = "input",dR = "input-disabled",dj = "menu-button",dG = "input-focused-invalid",F = "toolbar-button",G = "spinner",dy = "input-focused",dz = "decoration/arrows/down.png",dw = "popup",dx = "cell",du = "image",dv = "middle",a = "selected",dC = "background-light",s = "bold",r = "text-disabled",q = "groupbox",p = "text-selected",o = "label",n = "button",m = "main",l = "css.boxshadow",u = "css.borderradius",t = "button-frame",eL = "atom",eM = "-css",eN = "widget",eO = "css.gradient.linear";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Fabian Jakobs (fjakobs)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */
  /* ************************************************************************
  
  #asset(qx/icon/Tango/16/places/folder-open.png)
  #asset(qx/icon/Tango/16/places/folder.png)
  #asset(qx/icon/Tango/16/mimetypes/office-document.png)
  
  #asset(qx/icon/Tango/16/actions/window-close.png)
  
  #asset(qx/icon/Tango/22/places/folder-open.png)
  #asset(qx/icon/Tango/22/places/folder.png)
  #asset(qx/icon/Tango/22/mimetypes/office-document.png)
  
  #asset(qx/icon/Tango/32/places/folder-open.png)
  #asset(qx/icon/Tango/32/places/folder.png)
  #asset(qx/icon/Tango/32/mimetypes/office-document.png)
  
  #asset(qx/icon/Tango/16/apps/office-calendar.png)
  #asset(qx/icon/Tango/16/apps/utilities-color-chooser.png)
  #asset(qx/icon/Tango/16/actions/view-refresh.png)
  
  #asset(qx/icon/Tango/16/actions/dialog-cancel.png)
  #asset(qx/icon/Tango/16/actions/dialog-ok.png)
  
  #asset(qx/decoration/Modern/*)
  
  ************************************************************************* */
  /**
   * The modern appearance theme.
   */
  qx.Theme.define(bK, {
    appearances : {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget" : {
      },
      "root" : {
        style : function(fa){

          return {
            backgroundColor : bF,
            textColor : L,
            font : cq
          };
        }
      },
      "label" : {
        style : function(fb){

          return {
            textColor : fb.disabled ? r : undefined
          };
        }
      },
      "move-frame" : {
        style : function(fc){

          return {
            decorator : m
          };
        }
      },
      "resize-frame" : eh,
      "dragdrop-cursor" : {
        style : function(fd){

          var fe = cC;
          if(fd.copy){

            fe = dV;
          } else if(fd.move){

            fe = cv;
          } else if(fd.alias){

            fe = bh;
          };;
          return {
            source : em + fe + dA,
            position : cU,
            offset : [2, 16, 2, 6]
          };
        }
      },
      "image" : {
        style : function(ff){

          return {
            opacity : !ff.replacement && ff.disabled ? 0.3 : 1
          };
        }
      },
      "atom" : {
      },
      "atom/label" : o,
      "atom/icon" : du,
      "popup" : {
        style : function(fg){

          var fh = qx.core.Environment.get(l);
          return {
            decorator : fh ? ei : m,
            backgroundColor : dC,
            shadow : fh ? undefined : di
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame" : {
        alias : eL,
        style : function(fi){

          var fm,fl;
          var fj = [3, 9];
          // default padding css-case
          if(fi.checked && fi.focused && !fi.inner){

            fm = W;
            fl = undefined;
            fj = [1, 7];
          } else if(fi.disabled){

            fm = by;
            fl = undefined;
          } else if(fi.pressed){

            fm = dO;
            fl = cn;
          } else if(fi.checked){

            fm = eq;
            fl = undefined;
          } else if(fi.hovered){

            fm = eA;
            fl = cn;
          } else if(fi.focused && !fi.inner){

            fm = cF;
            fl = undefined;
            fj = [1, 7];
          } else {

            fm = n;
            fl = undefined;
          };;;;;
          var fk;
          // feature detect if we should use the CSS decorators
          if(qx.core.Environment.get(u) && qx.core.Environment.get(eO)){

            if(fi.invalid && !fi.disabled){

              fm += cA;
            } else {

              fm += eM;
            };
          } else {

            fk = fi.invalid && !fi.disabled ? v : undefined;
            fj = [2, 8];
          };
          return {
            decorator : fm,
            textColor : fl,
            shadow : fk,
            padding : fj,
            margin : [1, 0]
          };
        }
      },
      "button-frame/image" : {
        style : function(fn){

          return {
            opacity : !fn.replacement && fn.disabled ? 0.5 : 1
          };
        }
      },
      "button" : {
        alias : t,
        include : t,
        style : function(fo){

          return {
            center : true
          };
        }
      },
      "hover-button" : {
        alias : eL,
        include : eL,
        style : function(fp){

          var fq = fp.hovered ? a : undefined;
          if(fq && qx.core.Environment.get(eO)){

            fq += eM;
          };
          return {
            decorator : fq,
            textColor : fp.hovered ? p : undefined
          };
        }
      },
      "splitbutton" : {
      },
      "splitbutton/button" : n,
      "splitbutton/arrow" : {
        alias : n,
        include : n,
        style : function(fr, fs){

          return {
            icon : dz,
            padding : [fs.padding[0], fs.padding[1] - 6],
            marginLeft : 1
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        FORM FIELDS
      ---------------------------------------------------------------------------
      */
      "form-renderer-label" : {
        include : o,
        style : function(){

          return {
            paddingTop : 4
          };
        }
      },
      "checkbox" : {
        alias : eL,
        style : function(ft){

          var fu = qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          var fw;
          if(fu){

            if(ft.checked){

              fw = bH;
            } else if(ft.undetermined){

              fw = bn;
            } else {

              fw = eg;
            };
          } else {

            // The "disabled" icon is set to an icon **without** the -disabled
            // suffix on purpose. This is because the Image widget handles this
            // already by replacing the current image with a disabled version
            // (if available). If no disabled image is found, the opacity style
            // is used.
            // Checked
            if(ft.checked){

              if(ft.disabled){

                fw = cQ;
              } else if(ft.focused){

                fw = eT;
              } else if(ft.pressed){

                fw = dr;
              } else if(ft.hovered){

                fw = bk;
              } else {

                fw = cQ;
              };;;
            } else if(ft.undetermined){

              if(ft.disabled){

                fw = bq;
              } else if(ft.focused){

                fw = eC;
              } else if(ft.hovered){

                fw = ew;
              } else {

                fw = bq;
              };;
            } else if(!ft.disabled){

              if(ft.focused){

                fw = dd;
              } else if(ft.pressed){

                fw = bx;
              } else if(ft.hovered){

                fw = cW;
              };;
            };;
            // Unchecked
            fw = fw || dD;
            var fv = ft.invalid && !ft.disabled ? ee : ec;
            fw = bu + fw + fv + co;
          };
          return {
            icon : fw,
            minWidth : fu ? 14 : undefined,
            // ensure that we have the old padding
            gap : fu ? 8 : 6
          };
        }
      },
      "checkbox/icon" : {
        style : function(fx){

          var fz = qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          if(!fz){

            // same as image
            return {
              opacity : !fx.replacement && fx.disabled ? 0.3 : 1
            };
          };
          var fA;
          if(fx.disabled){

            fA = bM;
          } else if(fx.focused){

            fA = dd;
          } else if(fx.hovered){

            fA = cW;
          } else {

            fA = dD;
          };;
          fA += fx.invalid && !fx.disabled ? ee : ec;
          var fy;
          // Undetermined
          if(fx.undetermined){

            fy = [2, 0];
          };
          return {
            decorator : fA,
            padding : fy,
            width : 12,
            // use 12 to allow the inset of the decorator to be applied
            height : 10
          };
        }
      },
      "radiobutton" : {
        alias : eL,
        style : function(fB){

          var fC = qx.core.Environment.get(u) && qx.core.Environment.get(l);
          var fE;
          if(fC){

            fE = eg;
          } else {

            // "disabled" state is not handled here with purpose. The image widget
            // does handle this already by replacing the current image with a
            // disabled version (if available). If no disabled image is found the
            // opacity style is used.
            if(fB.checked && fB.focused){

              fE = O;
            } else if(fB.checked && fB.disabled){

              fE = cE;
            } else if(fB.checked && fB.hovered){

              fE = dc;
            } else if(fB.checked){

              fE = da;
            } else if(fB.focused){

              fE = bt;
            } else if(fB.hovered){

              fE = c;
            } else {

              fE = S;
            };;;;;
            var fD = fB.invalid && !fB.disabled ? ee : ec;
            fE = bu + fE + fD + co;
          };
          return {
            icon : fE,
            gap : fC ? 8 : 6
          };
        }
      },
      "radiobutton/icon" : {
        style : function(fF){

          var fG = qx.core.Environment.get(u) && qx.core.Environment.get(l);
          if(!fG){

            // same as image
            return {
              opacity : !fF.replacement && fF.disabled ? 0.3 : 1
            };
          };
          var fH;
          if(fF.disabled && !fF.checked){

            fH = dM;
          } else if(fF.checked && fF.focused){

            fH = O;
          } else if(fF.checked && fF.disabled){

            fH = cE;
          } else if(fF.checked && fF.hovered){

            fH = dc;
          } else if(fF.checked){

            fH = da;
          } else if(fF.focused){

            fH = bt;
          } else if(fF.hovered){

            fH = c;
          } else {

            fH = S;
          };;;;;;
          fH += fF.invalid && !fF.disabled ? ee : ec;
          return {
            decorator : fH,
            width : 12,
            // use 12 to allow the inset of the decorator to be applied
            height : 10
          };
        }
      },
      "textfield" : {
        style : function(fI){

          var fN;
          var fL = !!fI.focused;
          var fM = !!fI.invalid;
          var fJ = !!fI.disabled;
          if(fL && fM && !fJ){

            fN = dG;
          } else if(fL && !fM && !fJ){

            fN = dy;
          } else if(fJ){

            fN = dR;
          } else if(!fL && fM && !fJ){

            fN = ef;
          } else {

            fN = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            fN += eM;
          };
          var fK;
          if(fI.disabled){

            fK = r;
          } else if(fI.showingPlaceholder){

            fK = cO;
          } else {

            fK = ck;
          };
          return {
            decorator : fN,
            padding : [2, 4, 1],
            textColor : fK
          };
        }
      },
      "textarea" : {
        include : eb,
        style : function(fO){

          return {
            padding : 4
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner" : {
        style : function(fP){

          var fT;
          var fR = !!fP.focused;
          var fS = !!fP.invalid;
          var fQ = !!fP.disabled;
          if(fR && fS && !fQ){

            fT = dG;
          } else if(fR && !fS && !fQ){

            fT = dy;
          } else if(fQ){

            fT = dR;
          } else if(!fR && fS && !fQ){

            fT = ef;
          } else {

            fT = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            fT += eM;
          };
          return {
            decorator : fT
          };
        }
      },
      "spinner/textfield" : {
        style : function(fU){

          return {
            marginRight : 2,
            padding : [2, 4, 1],
            textColor : fU.disabled ? r : ck
          };
        }
      },
      "spinner/upbutton" : {
        alias : t,
        include : t,
        style : function(fV, fW){

          return {
            icon : eI,
            padding : [fW.padding[0] - 1, fW.padding[1] - 5],
            shadow : undefined,
            margin : 0
          };
        }
      },
      "spinner/downbutton" : {
        alias : t,
        include : t,
        style : function(fX, fY){

          return {
            icon : cr,
            padding : [fY.padding[0] - 1, fY.padding[1] - 5],
            shadow : undefined,
            margin : 0
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield" : cc,
      "datefield/button" : {
        alias : H,
        include : H,
        style : function(ga){

          return {
            icon : eR,
            padding : [0, 3],
            decorator : undefined
          };
        }
      },
      "datefield/textfield" : eX,
      "datefield/list" : {
        alias : ch,
        include : ch,
        style : function(gb){

          return {
            decorator : undefined
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox" : {
        style : function(gc){

          return {
            legendPosition : bV
          };
        }
      },
      "groupbox/legend" : {
        alias : eL,
        style : function(gd){

          return {
            padding : [1, 0, 1, 4],
            textColor : gd.invalid ? cV : be,
            font : s
          };
        }
      },
      "groupbox/frame" : {
        style : function(ge){

          var gf = qx.core.Environment.get(u);
          return {
            padding : gf ? 10 : 12,
            margin : gf ? 1 : undefined,
            decorator : gf ? dY : eP
          };
        }
      },
      "check-groupbox" : q,
      "check-groupbox/legend" : {
        alias : dD,
        include : dD,
        style : function(gg){

          return {
            padding : [1, 0, 1, 4],
            textColor : gg.invalid ? cV : be,
            font : s
          };
        }
      },
      "radio-groupbox" : q,
      "radio-groupbox/legend" : {
        alias : S,
        include : S,
        style : function(gh){

          return {
            padding : [1, 0, 1, 4],
            textColor : gh.invalid ? cV : be,
            font : s
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea" : {
        style : function(gi){

          return {
            // since the scroll container disregards the min size of the scrollbars
            // we have to set the min size of the scroll area to ensure that the
            // scrollbars always have an usable size.
            minWidth : 50,
            minHeight : 50
          };
        }
      },
      "scrollarea/corner" : {
        style : function(gj){

          return {
            backgroundColor : bF
          };
        }
      },
      "scrollarea/pane" : eN,
      "scrollarea/scrollbar-x" : ce,
      "scrollarea/scrollbar-y" : ce,
      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar" : {
        style : function(gk){

          if(gk[dE]){

            return {
            };
          };
          var gl = qx.core.Environment.get(eO);
          var gm = gk.horizontal ? eG : bw;
          if(gl){

            gm += eM;
          };
          return {
            width : gk.horizontal ? undefined : 16,
            height : gk.horizontal ? 16 : undefined,
            decorator : gm,
            padding : 1
          };
        }
      },
      "scrollbar/slider" : {
        alias : cN,
        style : function(gn){

          return {
            padding : gn.horizontal ? [0, 1, 0, 1] : [1, 0, 1, 0]
          };
        }
      },
      "scrollbar/slider/knob" : {
        include : t,
        style : function(go){

          var gp = qx.core.Environment.get(eO);
          var gq = go.horizontal ? R : bj;
          if(go.disabled){

            gq += eF;
          };
          if(gp){

            gq += eM;
          };
          return {
            decorator : gq,
            minHeight : go.horizontal ? undefined : 9,
            minWidth : go.horizontal ? 9 : undefined,
            padding : undefined,
            margin : 0
          };
        }
      },
      "scrollbar/button" : {
        alias : t,
        include : t,
        style : function(gr){

          var gu = dI;
          if(gr.left){

            gu += e;
          } else if(gr.right){

            gu += ev;
          } else if(gr.up){

            gu += V;
          } else {

            gu += cS;
          };;
          var gt = qx.core.Environment.get(eO);
          if(gr.left || gr.right){

            var gs = gr.left ? 3 : 4;
            return {
              padding : gt ? [3, 0, 3, gs] : [2, 0, 2, gs],
              icon : gu,
              width : 15,
              height : 14,
              margin : 0
            };
          } else {

            return {
              padding : gt ? 3 : [3, 2],
              icon : gu,
              width : 14,
              height : 15,
              margin : 0
            };
          };
        }
      },
      "scrollbar/button-begin" : J,
      "scrollbar/button-end" : J,
      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider" : {
        style : function(gv){

          var gz;
          var gx = !!gv.focused;
          var gy = !!gv.invalid;
          var gw = !!gv.disabled;
          if(gx && gy && !gw){

            gz = dG;
          } else if(gx && !gy && !gw){

            gz = dy;
          } else if(gw){

            gz = dR;
          } else if(!gx && gy && !gw){

            gz = ef;
          } else {

            gz = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            gz += eM;
          };
          return {
            decorator : gz
          };
        }
      },
      "slider/knob" : {
        include : t,
        style : function(gA){

          return {
            decorator : gA.disabled ? dJ : R,
            shadow : undefined,
            height : 14,
            width : 14,
            padding : 0
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list" : {
        alias : bv,
        style : function(gB){

          var gF;
          var gD = !!gB.focused;
          var gE = !!gB.invalid;
          var gC = !!gB.disabled;
          if(gD && gE && !gC){

            gF = dG;
          } else if(gD && !gE && !gC){

            gF = dy;
          } else if(gC){

            gF = dR;
          } else if(!gD && gE && !gC){

            gF = ef;
          } else {

            gF = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            gF += eM;
          };
          return {
            backgroundColor : dC,
            decorator : gF
          };
        }
      },
      "list/pane" : eN,
      "listitem" : {
        alias : eL,
        style : function(gG){

          var gH;
          if(gG.dragover){

            gH = gG.selected ? bD : bC;
          } else {

            gH = gG.selected ? a : undefined;
            if(gH && qx.core.Environment.get(eO)){

              gH += eM;
            };
          };
          return {
            padding : gG.dragover ? [4, 4, 2, 4] : 4,
            textColor : gG.selected ? p : undefined,
            decorator : gH
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar" : {
      },
      "slidebar/scrollpane" : {
      },
      "slidebar/content" : {
      },
      "slidebar/button-forward" : {
        alias : t,
        include : t,
        style : function(gI){

          return {
            padding : 5,
            center : true,
            icon : gI.vertical ? dz : cP
          };
        }
      },
      "slidebar/button-backward" : {
        alias : t,
        include : t,
        style : function(gJ){

          return {
            padding : 5,
            center : true,
            icon : gJ.vertical ? P : de
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview" : {
        style : function(gK){

          return {
            contentPadding : 16
          };
        }
      },
      "tabview/bar" : {
        alias : el,
        style : function(gL){

          var gM = qx.core.Environment.get(u) && qx.core.Environment.get(l) && qx.core.Environment.get(eO);
          var gN = {
            marginBottom : gL.barTop ? -1 : 0,
            marginTop : gL.barBottom ? gM ? -4 : -7 : 0,
            marginLeft : gL.barRight ? gM ? -3 : -5 : 0,
            marginRight : gL.barLeft ? -1 : 0,
            paddingTop : 0,
            paddingRight : 0,
            paddingBottom : 0,
            paddingLeft : 0
          };
          if(gL.barTop || gL.barBottom){

            gN.paddingLeft = 5;
            gN.paddingRight = 7;
          } else {

            gN.paddingTop = 5;
            gN.paddingBottom = 7;
          };
          return gN;
        }
      },
      "tabview/bar/button-forward" : {
        include : cl,
        alias : cl,
        style : function(gO){

          if(gO.barTop || gO.barBottom){

            return {
              marginTop : 2,
              marginBottom : 2
            };
          } else {

            return {
              marginLeft : 2,
              marginRight : 2
            };
          };
        }
      },
      "tabview/bar/button-backward" : {
        include : ci,
        alias : ci,
        style : function(gP){

          if(gP.barTop || gP.barBottom){

            return {
              marginTop : 2,
              marginBottom : 2
            };
          } else {

            return {
              marginLeft : 2,
              marginRight : 2
            };
          };
        }
      },
      "tabview/bar/scrollpane" : {
      },
      "tabview/pane" : {
        style : function(gQ){

          var gR = qx.core.Environment.get(eO) && qx.core.Environment.get(u);
          return {
            decorator : gR ? i : bT,
            minHeight : 100,
            marginBottom : gQ.barBottom ? -1 : 0,
            marginTop : gQ.barTop ? -1 : 0,
            marginLeft : gQ.barLeft ? -1 : 0,
            marginRight : gQ.barRight ? -1 : 0
          };
        }
      },
      "tabview-page" : {
        alias : eN,
        include : eN,
        style : function(gS){

          // is used for the padding of the pane
          var gT = qx.core.Environment.get(eO) && qx.core.Environment.get(u);
          return {
            padding : gT ? [4, 3] : undefined
          };
        }
      },
      "tabview-page/button" : {
        alias : eL,
        style : function(gU){

          var hc,gX = 0;
          var hb = 0,gV = 0,gY = 0,ha = 0;
          var gW = qx.core.Environment.get(u) && qx.core.Environment.get(l) && qx.core.Environment.get(eO);
          if(gU.checked){

            if(gU.barTop){

              hc = ds;
              gX = gW ? [5, 11] : [6, 14];
              gY = gU.firstTab ? 0 : -5;
              ha = gU.lastTab ? 0 : -5;
            } else if(gU.barBottom){

              hc = eH;
              gX = gW ? [5, 11] : [6, 14];
              gY = gU.firstTab ? 0 : -5;
              ha = gU.lastTab ? 0 : -5;
              hb = 3;
            } else if(gU.barRight){

              hc = eE;
              gX = gW ? [5, 10] : [6, 13];
              hb = gU.firstTab ? 0 : -5;
              gV = gU.lastTab ? 0 : -5;
              gY = 2;
            } else {

              hc = dp;
              gX = gW ? [5, 10] : [6, 13];
              hb = gU.firstTab ? 0 : -5;
              gV = gU.lastTab ? 0 : -5;
            };;
          } else {

            if(gU.barTop){

              hc = z;
              gX = gW ? [3, 9] : [4, 10];
              hb = 4;
              gY = gU.firstTab ? 5 : 1;
              ha = 1;
            } else if(gU.barBottom){

              hc = eu;
              gX = gW ? [3, 9] : [4, 10];
              gV = 4;
              gY = gU.firstTab ? 5 : 1;
              ha = 1;
              hb = 3;
            } else if(gU.barRight){

              hc = eW;
              gX = gW ? [3, 9] : [4, 10];
              ha = 5;
              hb = gU.firstTab ? 5 : 1;
              gV = 1;
              gY = 3;
            } else {

              hc = A;
              gX = gW ? [3, 9] : [4, 10];
              gY = 5;
              hb = gU.firstTab ? 5 : 1;
              gV = 1;
              ha = 1;
            };;
          };
          if(hc && gW){

            hc += eM;
          };
          return {
            zIndex : gU.checked ? 10 : 5,
            decorator : hc,
            padding : gX,
            marginTop : hb,
            marginBottom : gV,
            marginLeft : gY,
            marginRight : ha,
            textColor : gU.disabled ? r : gU.checked ? bL : cw
          };
        }
      },
      "tabview-page/button/label" : {
        alias : o,
        style : function(hd){

          return {
            padding : [0, 1, 0, 1],
            margin : hd.focused ? 0 : 1,
            decorator : hd.focused ? eo : undefined
          };
        }
      },
      "tabview-page/button/close-button" : {
        alias : eL,
        style : function(he){

          return {
            icon : bA
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar" : {
        style : function(hf){

          var hg = qx.core.Environment.get(eO);
          return {
            decorator : hg ? cM : bi,
            spacing : 2
          };
        }
      },
      "toolbar/part" : {
        style : function(hh){

          return {
            decorator : dl,
            spacing : 2
          };
        }
      },
      "toolbar/part/container" : {
        style : function(hi){

          return {
            paddingLeft : 2,
            paddingRight : 2
          };
        }
      },
      "toolbar/part/handle" : {
        style : function(hj){

          return {
            source : ba,
            marginLeft : 3,
            marginRight : 3
          };
        }
      },
      "toolbar-button" : {
        alias : eL,
        style : function(hk){

          var hm;
          if(hk.pressed || (hk.checked && !hk.hovered) || (hk.checked && hk.disabled)){

            hm = C;
          } else if(hk.hovered && !hk.disabled){

            hm = bN;
          };
          var hl = qx.core.Environment.get(eO) && qx.core.Environment.get(u);
          if(hl && hm){

            hm += eM;
          };
          return {
            marginTop : 2,
            marginBottom : 2,
            padding : (hk.pressed || hk.checked || hk.hovered) && !hk.disabled || (hk.disabled && hk.checked) ? 3 : 5,
            decorator : hm
          };
        }
      },
      "toolbar-menubutton" : {
        alias : F,
        include : F,
        style : function(hn){

          return {
            showArrow : true
          };
        }
      },
      "toolbar-menubutton/arrow" : {
        alias : du,
        include : du,
        style : function(ho){

          return {
            source : cr
          };
        }
      },
      "toolbar-splitbutton" : {
        style : function(hp){

          return {
            marginTop : 2,
            marginBottom : 2
          };
        }
      },
      "toolbar-splitbutton/button" : {
        alias : F,
        include : F,
        style : function(hq){

          return {
            icon : dz,
            marginTop : undefined,
            marginBottom : undefined
          };
        }
      },
      "toolbar-splitbutton/arrow" : {
        alias : F,
        include : F,
        style : function(hr){

          if(hr.pressed || hr.checked || (hr.hovered && !hr.disabled)){

            var hs = 1;
          } else {

            var hs = 3;
          };
          return {
            padding : hs,
            icon : dz,
            marginTop : undefined,
            marginBottom : undefined
          };
        }
      },
      "toolbar-separator" : {
        style : function(ht){

          return {
            decorator : dP,
            margin : 7
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree" : bg,
      "tree-item" : {
        style : function(hu){

          var hv = hu.selected ? a : undefined;
          if(hv && qx.core.Environment.get(eO)){

            hv += eM;
          };
          return {
            padding : [2, 6],
            textColor : hu.selected ? p : undefined,
            decorator : hv
          };
        }
      },
      "tree-item/icon" : {
        include : du,
        style : function(hw){

          return {
            paddingRight : 5
          };
        }
      },
      "tree-item/label" : o,
      "tree-item/open" : {
        include : du,
        style : function(hx){

          var hy;
          if(hx.selected && hx.opened){

            hy = E;
          } else if(hx.selected && !hx.opened){

            hy = U;
          } else if(hx.opened){

            hy = cp;
          } else {

            hy = M;
          };;
          return {
            padding : [0, 5, 0, 2],
            source : hy
          };
        }
      },
      "tree-folder" : {
        include : cb,
        alias : cb,
        style : function(hz){

          var hB,hA;
          if(hz.small){

            hB = hz.opened ? dk : N;
            hA = dk;
          } else if(hz.large){

            hB = hz.opened ? df : dQ;
            hA = df;
          } else {

            hB = hz.opened ? cY : dt;
            hA = cY;
          };
          return {
            icon : hB,
            iconOpened : hA
          };
        }
      },
      "tree-file" : {
        include : cb,
        alias : cb,
        style : function(hC){

          return {
            icon : hC.small ? dh : hC.large ? bQ : bd
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual" : cX,
      "treevirtual-folder" : {
        style : function(hD){

          return {
            icon : hD.opened ? dk : N
          };
        }
      },
      "treevirtual-file" : {
        include : db,
        alias : db,
        style : function(hE){

          return {
            icon : dh
          };
        }
      },
      "treevirtual-line" : {
        style : function(hF){

          return {
            icon : eg
          };
        }
      },
      "treevirtual-contract" : {
        style : function(hG){

          return {
            icon : cp,
            paddingLeft : 5,
            paddingTop : 2
          };
        }
      },
      "treevirtual-expand" : {
        style : function(hH){

          return {
            icon : M,
            paddingLeft : 5,
            paddingTop : 2
          };
        }
      },
      "treevirtual-only-contract" : cd,
      "treevirtual-only-expand" : cj,
      "treevirtual-start-contract" : cd,
      "treevirtual-start-expand" : cj,
      "treevirtual-end-contract" : cd,
      "treevirtual-end-expand" : cj,
      "treevirtual-cross-contract" : cd,
      "treevirtual-cross-expand" : cj,
      "treevirtual-end" : {
        style : function(hI){

          return {
            icon : eg
          };
        }
      },
      "treevirtual-cross" : {
        style : function(hJ){

          return {
            icon : eg
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip" : {
        include : dw,
        style : function(hK){

          return {
            backgroundColor : dH,
            padding : [1, 3, 2, 3],
            offset : [15, 5, 5, 5]
          };
        }
      },
      "tooltip/atom" : eL,
      "tooltip-error" : {
        include : ed,
        style : function(hL){

          var hO = qx.core.Environment.get(u) && qx.core.Environment.get(l);
          var hN = er;
          if(hO){

            hN += eM;
          };
          if(hL.placementLeft){

            hN += D;
          };
          var hP = ek;
          if(hL.placementLeft){

            hP = T;
            if(hO){

              hP += eM;
            };
          };
          // padding
          if(hO){

            if(hL.placementLeft){

              var hM = [9, 20, 3, 6];
            } else {

              var hM = [6, 6, 7, -8];
            };
          } else {

            if(hL.placementLeft){

              var hM = [6, 20, 3, 4];
            } else {

              var hM = [6, 10, 6, -10];
            };
          };
          // disable the right arrow in case of non CSS and alpah image loader
          if(!hO && hL.placementLeft && qx.core.Environment.get(bY) == bS && qx.core.Environment.get(cI) < 9){

            hP = undefined;
            hM = [5, 10];
          };
          return {
            textColor : p,
            backgroundColor : undefined,
            placeMethod : eN,
            offset : [0, 14, 0, 14],
            marginTop : -2,
            position : cU,
            showTimeout : 100,
            hideTimeout : 10000,
            shadow : hN,
            decorator : hP,
            font : s,
            padding : hM,
            maxWidth : 333
          };
        }
      },
      "tooltip-error/atom" : eL,
      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window" : {
        style : function(hQ){

          var hS = qx.core.Environment.get(u) && qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          var hT;
          var hR;
          if(hS){

            if(hQ.showStatusbar){

              hT = et;
            } else {

              hT = es;
            };
          } else {

            hR = ct;
          };
          return {
            decorator : hT,
            shadow : hR,
            contentPadding : [10, 10, 10, 10],
            margin : hQ.maximized ? 0 : [0, 5, 5, 0]
          };
        }
      },
      "window-resize-frame" : {
        style : function(hU){

          var hV = qx.core.Environment.get(u);
          var hW;
          if(hV){

            if(hU.showStatusbar){

              hW = bG;
            } else {

              hW = dL;
            };
          } else {

            hW = m;
          };
          return {
            decorator : hW
          };
        }
      },
      "window/pane" : {
        style : function(hX){

          var hY = qx.core.Environment.get(u) && qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          return {
            decorator : hY ? ey : cJ
          };
        }
      },
      "window/captionbar" : {
        style : function(ia){

          var ib = qx.core.Environment.get(u) && qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          var ic = ia.active ? bl : dS;
          if(ib){

            ic += eM;
          };
          return {
            decorator : ic,
            textColor : ia.active ? dW : bR,
            minHeight : 26,
            paddingRight : 2
          };
        }
      },
      "window/icon" : {
        style : function(id){

          return {
            margin : [5, 0, 3, 6]
          };
        }
      },
      "window/title" : {
        style : function(ie){

          return {
            alignY : dv,
            font : s,
            marginLeft : 6,
            marginRight : 12
          };
        }
      },
      "window/minimize-button" : {
        alias : eL,
        style : function(ig){

          return {
            icon : ig.active ? ig.hovered ? w : eV : eS,
            margin : [4, 8, 2, 0]
          };
        }
      },
      "window/restore-button" : {
        alias : eL,
        style : function(ih){

          return {
            icon : ih.active ? ih.hovered ? cu : bs : eU,
            margin : [5, 8, 2, 0]
          };
        }
      },
      "window/maximize-button" : {
        alias : eL,
        style : function(ii){

          return {
            icon : ii.active ? ii.hovered ? ep : dq : bB,
            margin : [4, 8, 2, 0]
          };
        }
      },
      "window/close-button" : {
        alias : eL,
        style : function(ij){

          return {
            icon : ij.active ? ij.hovered ? bz : dF : dn,
            margin : [4, 8, 2, 0]
          };
        }
      },
      "window/statusbar" : {
        style : function(ik){

          var il = qx.core.Environment.get(u) && qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          return {
            padding : [2, 6],
            decorator : il ? cK : ez,
            minHeight : 18
          };
        }
      },
      "window/statusbar-text" : {
        style : function(im){

          return {
            font : eD
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        IFRAME
      ---------------------------------------------------------------------------
      */
      "iframe" : {
        style : function(io){

          return {
            decorator : m
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer" : {
        style : function(ip){

          var iq = qx.core.Environment.get(l) && qx.core.Environment.get(u) && qx.core.Environment.get(eO);
          return {
            decorator : iq ? X : h
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane" : {
        style : function(ir){

          return {
            decorator : eY
          };
        }
      },
      "splitpane/splitter" : {
        style : function(is){

          return {
            width : is.horizontal ? 3 : undefined,
            height : is.vertical ? 3 : undefined,
            backgroundColor : cm
          };
        }
      },
      "splitpane/splitter/knob" : {
        style : function(it){

          return {
            source : it.horizontal ? ea : dm
          };
        }
      },
      "splitpane/slider" : {
        style : function(iu){

          return {
            width : iu.horizontal ? 3 : undefined,
            height : iu.vertical ? 3 : undefined,
            backgroundColor : cm
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox" : t,
      "selectbox/atom" : eL,
      "selectbox/popup" : dw,
      "selectbox/list" : {
        alias : bg
      },
      "selectbox/arrow" : {
        include : du,
        style : function(iv){

          return {
            source : dz,
            paddingLeft : 5
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser" : {
        style : function(iw){

          var iA;
          var iy = !!iw.focused;
          var iz = !!iw.invalid;
          var ix = !!iw.disabled;
          if(iy && iz && !ix){

            iA = dG;
          } else if(iy && !iz && !ix){

            iA = dy;
          } else if(ix){

            iA = dR;
          } else if(!iy && iz && !ix){

            iA = ef;
          } else {

            iA = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            iA += eM;
          };
          return {
            padding : 2,
            decorator : iA,
            backgroundColor : dC
          };
        }
      },
      "datechooser/navigation-bar" : {
      },
      "datechooser/nav-button" : {
        include : t,
        alias : t,
        style : function(iB){

          var iC = {
            padding : [2, 4],
            shadow : undefined
          };
          if(iB.lastYear){

            iC.icon = bU;
            iC.marginRight = 1;
          } else if(iB.lastMonth){

            iC.icon = de;
          } else if(iB.nextYear){

            iC.icon = bP;
            iC.marginLeft = 1;
          } else if(iB.nextMonth){

            iC.icon = cP;
          };;;
          return iC;
        }
      },
      "datechooser/last-year-button-tooltip" : ed,
      "datechooser/last-month-button-tooltip" : ed,
      "datechooser/next-year-button-tooltip" : ed,
      "datechooser/next-month-button-tooltip" : ed,
      "datechooser/last-year-button" : cf,
      "datechooser/last-month-button" : cf,
      "datechooser/next-month-button" : cf,
      "datechooser/next-year-button" : cf,
      "datechooser/month-year-label" : {
        style : function(iD){

          return {
            font : s,
            textAlign : cg,
            textColor : iD.disabled ? r : undefined
          };
        }
      },
      "datechooser/date-pane" : {
        style : function(iE){

          return {
            textColor : iE.disabled ? r : undefined,
            marginTop : 2
          };
        }
      },
      "datechooser/weekday" : {
        style : function(iF){

          return {
            textColor : iF.disabled ? r : iF.weekend ? cD : undefined,
            textAlign : cg,
            paddingTop : 2,
            backgroundColor : dg
          };
        }
      },
      "datechooser/week" : {
        style : function(iG){

          return {
            textAlign : cg,
            padding : [2, 4],
            backgroundColor : dg
          };
        }
      },
      "datechooser/day" : {
        style : function(iH){

          var iI = iH.disabled ? undefined : iH.selected ? a : undefined;
          if(iI && qx.core.Environment.get(eO)){

            iI += eM;
          };
          return {
            textAlign : cg,
            decorator : iI,
            textColor : iH.disabled ? r : iH.selected ? p : iH.otherMonth ? cD : undefined,
            font : iH.today ? s : undefined,
            padding : [2, 4]
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        COMBOBOX
      ---------------------------------------------------------------------------
      */
      "combobox" : {
        style : function(iJ){

          var iN;
          var iL = !!iJ.focused;
          var iM = !!iJ.invalid;
          var iK = !!iJ.disabled;
          if(iL && iM && !iK){

            iN = dG;
          } else if(iL && !iM && !iK){

            iN = dy;
          } else if(iK){

            iN = dR;
          } else if(!iL && iM && !iK){

            iN = ef;
          } else {

            iN = cs;
          };;;
          if(qx.core.Environment.get(eO)){

            iN += eM;
          };
          return {
            decorator : iN
          };
        }
      },
      "combobox/popup" : dw,
      "combobox/list" : {
        alias : bg
      },
      "combobox/button" : {
        include : t,
        alias : t,
        style : function(iO, iP){

          var iQ = {
            icon : dz,
            padding : [iP.padding[0], iP.padding[1] - 6],
            shadow : undefined,
            margin : undefined
          };
          if(iO.selected){

            iQ.decorator = cF;
          };
          return iQ;
        }
      },
      "combobox/textfield" : {
        include : eb,
        style : function(iR){

          return {
            decorator : undefined
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu" : {
        style : function(iS){

          var iT = qx.core.Environment.get(eO) && qx.core.Environment.get(l);
          var iU = {
            decorator : iT ? en : cz,
            shadow : iT ? undefined : di,
            spacingX : 6,
            spacingY : 1,
            iconColumnWidth : 16,
            arrowColumnWidth : 4,
            placementModeY : iS.submenu || iS.contextmenu ? Y : cL
          };
          if(iS.submenu){

            iU.position = cU;
            iU.offset = [-2, -3];
          };
          return iU;
        }
      },
      "menu/slidebar" : B,
      "menu-slidebar" : eN,
      "menu-slidebar-button" : {
        style : function(iV){

          var iW = iV.hovered ? a : undefined;
          if(iW && qx.core.Environment.get(eO)){

            iW += eM;
          };
          return {
            decorator : iW,
            padding : 7,
            center : true
          };
        }
      },
      "menu-slidebar/button-backward" : {
        include : bf,
        style : function(iX){

          return {
            icon : iX.hovered ? eK : P
          };
        }
      },
      "menu-slidebar/button-forward" : {
        include : bf,
        style : function(iY){

          return {
            icon : iY.hovered ? dU : dz
          };
        }
      },
      "menu-separator" : {
        style : function(ja){

          return {
            height : 0,
            decorator : j,
            margin : [4, 2]
          };
        }
      },
      "menu-button" : {
        alias : eL,
        style : function(jb){

          var jc = jb.selected ? a : undefined;
          if(jc && qx.core.Environment.get(eO)){

            jc += eM;
          };
          return {
            decorator : jc,
            textColor : jb.selected ? p : undefined,
            padding : [4, 6]
          };
        }
      },
      "menu-button/icon" : {
        include : du,
        style : function(jd){

          return {
            alignY : dv
          };
        }
      },
      "menu-button/label" : {
        include : o,
        style : function(je){

          return {
            alignY : dv,
            padding : 1
          };
        }
      },
      "menu-button/shortcut" : {
        include : o,
        style : function(jf){

          return {
            alignY : dv,
            marginLeft : 14,
            padding : 1
          };
        }
      },
      "menu-button/arrow" : {
        include : du,
        style : function(jg){

          return {
            source : jg.selected ? f : cP,
            alignY : dv
          };
        }
      },
      "menu-checkbox" : {
        alias : dj,
        include : dj,
        style : function(jh){

          return {
            icon : !jh.checked ? undefined : jh.selected ? bb : dX
          };
        }
      },
      "menu-radiobutton" : {
        alias : dj,
        include : dj,
        style : function(ji){

          return {
            icon : !ji.checked ? undefined : ji.selected ? cH : bO
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar" : {
        style : function(jj){

          var jk = qx.core.Environment.get(eO);
          return {
            decorator : jk ? dK : x
          };
        }
      },
      "menubar-button" : {
        alias : eL,
        style : function(jl){

          var jm = (jl.pressed || jl.hovered) && !jl.disabled ? a : undefined;
          if(jm && qx.core.Environment.get(eO)){

            jm += eM;
          };
          return {
            decorator : jm,
            textColor : jl.pressed || jl.hovered ? p : undefined,
            padding : [3, 8]
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector" : eN,
      "colorselector/control-bar" : eN,
      "colorselector/control-pane" : eN,
      "colorselector/visual-pane" : q,
      "colorselector/preset-grid" : eN,
      "colorselector/colorbucket" : {
        style : function(jn){

          return {
            decorator : m,
            width : 16,
            height : 16
          };
        }
      },
      "colorselector/preset-field-set" : q,
      "colorselector/input-field-set" : {
        include : q,
        alias : q,
        style : function(){

          return {
            paddingTop : 20
          };
        }
      },
      "colorselector/preview-field-set" : {
        include : q,
        alias : q,
        style : function(){

          return {
            paddingTop : 20
          };
        }
      },
      "colorselector/hex-field-composite" : eN,
      "colorselector/hex-field" : eb,
      "colorselector/rgb-spinner-composite" : eN,
      "colorselector/rgb-spinner-red" : G,
      "colorselector/rgb-spinner-green" : G,
      "colorselector/rgb-spinner-blue" : G,
      "colorselector/hsb-spinner-composite" : eN,
      "colorselector/hsb-spinner-hue" : G,
      "colorselector/hsb-spinner-saturation" : G,
      "colorselector/hsb-spinner-brightness" : G,
      "colorselector/preview-content-old" : {
        style : function(jo){

          return {
            decorator : m,
            width : 50,
            height : 10
          };
        }
      },
      "colorselector/preview-content-new" : {
        style : function(jp){

          return {
            decorator : m,
            backgroundColor : dC,
            width : 50,
            height : 10
          };
        }
      },
      "colorselector/hue-saturation-field" : {
        style : function(jq){

          return {
            decorator : m,
            margin : 5
          };
        }
      },
      "colorselector/brightness-field" : {
        style : function(jr){

          return {
            decorator : m,
            margin : [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane" : eN,
      "colorselector/hue-saturation-handle" : eN,
      "colorselector/brightness-pane" : eN,
      "colorselector/brightness-handle" : eN,
      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup" : {
        alias : dw,
        include : dw,
        style : function(js){

          return {
            padding : 5,
            backgroundColor : bF
          };
        }
      },
      "colorpopup/field" : {
        style : function(jt){

          return {
            decorator : m,
            margin : 2,
            width : 14,
            height : 14,
            backgroundColor : dC
          };
        }
      },
      "colorpopup/selector-button" : n,
      "colorpopup/auto-button" : n,
      "colorpopup/preview-pane" : q,
      "colorpopup/current-preview" : {
        style : function(ju){

          return {
            height : 20,
            padding : 4,
            marginLeft : 4,
            decorator : m,
            allowGrowX : true
          };
        }
      },
      "colorpopup/selected-preview" : {
        style : function(jv){

          return {
            height : 20,
            padding : 4,
            marginRight : 4,
            decorator : m,
            allowGrowX : true
          };
        }
      },
      "colorpopup/colorselector-okbutton" : {
        alias : n,
        include : n,
        style : function(jw){

          return {
            icon : bW
          };
        }
      },
      "colorpopup/colorselector-cancelbutton" : {
        alias : n,
        include : n,
        style : function(jx){

          return {
            icon : y
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table" : {
        alias : eN,
        style : function(jy){

          return {
            decorator : cX
          };
        }
      },
      "table/statusbar" : {
        style : function(jz){

          return {
            decorator : dB,
            padding : [0, 2]
          };
        }
      },
      "table/column-button" : {
        alias : t,
        style : function(jA){

          var jB = qx.core.Environment.get(eO);
          return {
            decorator : jB ? bp : Q,
            padding : 3,
            icon : bJ
          };
        }
      },
      "table-column-reset-button" : {
        include : dj,
        alias : dj,
        style : function(){

          return {
            icon : d
          };
        }
      },
      "table-scroller" : eN,
      "table-scroller/scrollbar-x" : ce,
      "table-scroller/scrollbar-y" : ce,
      "table-scroller/header" : {
        style : function(jC){

          var jD = qx.core.Environment.get(eO);
          return {
            decorator : jD ? bp : Q,
            textColor : jC.disabled ? r : undefined
          };
        }
      },
      "table-scroller/pane" : {
        style : function(jE){

          return {
            backgroundColor : dN
          };
        }
      },
      "table-scroller/focus-indicator" : {
        style : function(jF){

          return {
            decorator : ej
          };
        }
      },
      "table-scroller/resize-line" : {
        style : function(jG){

          return {
            backgroundColor : bE,
            width : 2
          };
        }
      },
      "table-header-cell" : {
        alias : eL,
        style : function(jH){

          return {
            minWidth : 13,
            minHeight : 20,
            padding : jH.hovered ? [3, 4, 2, 4] : [3, 4],
            decorator : jH.hovered ? ca : bc,
            sortIcon : jH.sorted ? (jH.sortedAscending ? eJ : bo) : undefined
          };
        }
      },
      "table-header-cell/label" : {
        style : function(jI){

          return {
            minWidth : 0,
            alignY : dv,
            paddingRight : 5
          };
        }
      },
      "table-header-cell/sort-icon" : {
        style : function(jJ){

          return {
            alignY : dv,
            alignX : K,
            opacity : jJ.disabled ? 0.3 : 1
          };
        }
      },
      "table-header-cell/icon" : {
        style : function(jK){

          return {
            minWidth : 0,
            alignY : dv,
            paddingRight : 5,
            opacity : jK.disabled ? 0.3 : 1
          };
        }
      },
      "table-editor-textfield" : {
        include : eb,
        style : function(jL){

          return {
            decorator : undefined,
            padding : [2, 2],
            backgroundColor : dC
          };
        }
      },
      "table-editor-selectbox" : {
        include : cT,
        alias : cT,
        style : function(jM){

          return {
            padding : [0, 2],
            backgroundColor : dC
          };
        }
      },
      "table-editor-combobox" : {
        include : cc,
        alias : cc,
        style : function(jN){

          return {
            decorator : undefined,
            backgroundColor : dC
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header" : {
        alias : eN,
        style : function(jO){

          return {
            decorator : bI
          };
        }
      },
      "progressive-table-header-cell" : {
        alias : eL,
        style : function(jP){

          var jQ = qx.core.Environment.get(eO);
          return {
            minWidth : 40,
            minHeight : 25,
            paddingLeft : 6,
            decorator : jQ ? dT : k
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header" : {
        style : function(jR){

          return {
            font : s,
            textColor : p,
            padding : [8, 12],
            decorator : cy
          };
        }
      },
      "app-header-label" : o,
      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list" : bg,
      "virtual-list/row-layer" : cx,
      "row-layer" : eN,
      "group-item" : {
        include : o,
        alias : o,
        style : function(jS){

          return {
            padding : 4,
            decorator : qx.core.Environment.get(eO) ? eQ : b,
            textColor : cR,
            font : s
          };
        }
      },
      "virtual-selectbox" : cT,
      "virtual-selectbox/dropdown" : dw,
      "virtual-selectbox/dropdown/list" : {
        alias : I
      },
      "virtual-combobox" : cc,
      "virtual-combobox/dropdown" : dw,
      "virtual-combobox/dropdown/list" : {
        alias : I
      },
      "virtual-tree" : {
        include : cG,
        alias : cG,
        style : function(jT){

          return {
            itemHeight : 26
          };
        }
      },
      "virtual-tree-folder" : ex,
      "virtual-tree-file" : bm,
      "column-layer" : eN,
      "cell" : {
        style : function(jU){

          return {
            textColor : jU.selected ? p : L,
            padding : [3, 6],
            font : cq
          };
        }
      },
      "cell-string" : dx,
      "cell-number" : {
        include : dx,
        style : function(jV){

          return {
            textAlign : K
          };
        }
      },
      "cell-image" : dx,
      "cell-boolean" : {
        include : dx,
        style : function(jW){

          return {
            iconTrue : cB,
            iconFalse : br
          };
        }
      },
      "cell-atom" : dx,
      "cell-date" : dx,
      "cell-html" : dx,
      /*
      ---------------------------------------------------------------------------
        HTMLAREA
      ---------------------------------------------------------------------------
      */
      "htmlarea" : {
        "include" : eN,
        style : function(jX){

          return {
            backgroundColor : g
          };
        }
      },
      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar" : {
        style : function(jY){

          return {
            decorator : eB,
            padding : [1],
            backgroundColor : bX,
            width : 200,
            height : 20
          };
        }
      },
      "progressbar/progress" : {
        style : function(ka){

          var kb = ka.disabled ? b : a;
          if(qx.core.Environment.get(eO)){

            kb += eM;
          };
          return {
            decorator : kb
          };
        }
      }
    }
  });
})();
(function(){

  var a = "dicomheaderview.theme.Appearance";
  /* ************************************************************************
  
     Copyright:
  
     License:
  
     Authors:
  
  ************************************************************************ */
  qx.Theme.define(a, {
    extend : qx.theme.modern.Appearance,
    appearances : {
    }
  });
})();
(function(){

  var g = "",f = "This decorator is already in-use. Modification is not possible anymore!",e = "qx.debug",d = "qx.theme",c = "qx.ui.decoration.MBackgroundColor",b = "Color",a = "_applyBackgroundColor";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin responsible for setting the background color of a widget.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   */
  qx.Mixin.define(c, {
    properties : {
      /** Color of the background */
      backgroundColor : {
        check : b,
        nullable : true,
        apply : a
      }
    },
    members : {
      /**
       * Tint function for the background color. This is suitable for the
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param element {Element} The element which could be resized.
       * @param bgcolor {Color} The new background color.
       * @param styles {Map} A map of styles to apply.
       */
      _tintBackgroundColor : function(h, i, j){

        if(i == null){

          i = this.getBackgroundColor();
        };
        if(qx.core.Environment.get(d)){

          i = qx.theme.manager.Color.getInstance().resolve(i);
        };
        j.backgroundColor = i || g;
      },
      /**
       * Resize function for the background color. This is suitable for the
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param element {Element} The element which could be resized.
       * @param width {Number} The new width.
       * @param height {Number} The new height.
       * @return {Map} A map containing the desired position and dimension
       *   (width, height, top, left).
       */
      _resizeBackgroundColor : function(k, l, m){

        var n = this.getInsets();
        l -= n.left + n.right;
        m -= n.top + n.bottom;
        return {
          left : n.left,
          top : n.top,
          width : l,
          height : m
        };
      },
      // property apply
      _applyBackgroundColor : function(){

        if(qx.core.Environment.get(e)){

          if(this._isInitialized()){

            throw new Error(f);
          };
        };
      }
    }
  });
})();
(function(){

  var j = "radiusTopRight",i = "radiusTopLeft",h = "-webkit-border-bottom-left-radius",g = "-webkit-background-clip",f = "radiusBottomRight",e = "-webkit-border-bottom-right-radius",d = "border-top-left-radius",c = "qx.debug",b = "border-top-right-radius",a = "border-bottom-left-radius",y = "radiusBottomLeft",x = "-webkit-border-top-left-radius",w = "shorthand",v = "-moz-border-radius-bottomright",u = "padding-box",t = "border-bottom-right-radius",s = "qx.ui.decoration.MBorderRadius",r = "-moz-border-radius-topright",q = "This decorator is already in-use. Modification is not possible anymore!",p = "-webkit-border-top-right-radius",n = "-moz-border-radius-topleft",o = "-moz-border-radius-bottomleft",l = "Integer",m = "_applyBorderRadius",k = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin for the border radius CSS property.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   *
   * Keep in mind that this is not supported by all browsers:
   *
   * * Firefox 3,5+
   * * IE9+
   * * Safari 3.0+
   * * Opera 10.5+
   * * Chrome 4.0+
   */
  qx.Mixin.define(s, {
    properties : {
      /** top left corner radius */
      radiusTopLeft : {
        nullable : true,
        check : l,
        apply : m
      },
      /** top right corner radius */
      radiusTopRight : {
        nullable : true,
        check : l,
        apply : m
      },
      /** bottom left corner radius */
      radiusBottomLeft : {
        nullable : true,
        check : l,
        apply : m
      },
      /** bottom right corner radius */
      radiusBottomRight : {
        nullable : true,
        check : l,
        apply : m
      },
      /** Property group to set the corner radius of all sides */
      radius : {
        group : [i, j, f, y],
        mode : w
      }
    },
    members : {
      /**
       * Takes a styles map and adds the border radius styles in place to the
       * given map. This is the needed behavior for
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param styles {Map} A map to add the styles.
       */
      _styleBorderRadius : function(z){

        // Fixing the background bleed in Webkits
        // http://tumble.sneak.co.nz/post/928998513/fixing-the-background-bleed
        z[g] = u;
        // radius handling
        var A = this.getRadiusTopLeft();
        if(A > 0){

          z[n] = A + k;
          z[x] = A + k;
          z[d] = A + k;
        };
        A = this.getRadiusTopRight();
        if(A > 0){

          z[r] = A + k;
          z[p] = A + k;
          z[b] = A + k;
        };
        A = this.getRadiusBottomLeft();
        if(A > 0){

          z[o] = A + k;
          z[h] = A + k;
          z[a] = A + k;
        };
        A = this.getRadiusBottomRight();
        if(A > 0){

          z[v] = A + k;
          z[e] = A + k;
          z[t] = A + k;
        };
      },
      // property apply
      _applyBorderRadius : function(){

        if(qx.core.Environment.get(c)){

          if(this._isInitialized()){

            throw new Error(q);
          };
        };
      }
    }
  });
})();
(function(){

  var j = "backgroundPositionX",i = '</div>',h = "engine.version",g = "scale",f = "browser.quirksmode",e = '<div style="',d = "qx.debug",c = "repeat-y",b = "hidden",a = "qx.ui.decoration.MBackgroundImage",v = "String",u = "backgroundPositionY",t = '">',s = "mshtml",r = "engine.name",q = "This decorator is already in-use. Modification is not possible anymore!",p = "no-repeat",o = " ",n = "repeat-x",m = "repeat",k = "",l = "_applyBackgroundImage";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin for supporting the background images on decorators.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   */
  qx.Mixin.define(a, {
    properties : {
      /** The URL of the background image */
      backgroundImage : {
        check : v,
        nullable : true,
        apply : l
      },
      /** How the background image should be repeated */
      backgroundRepeat : {
        check : [m, n, c, p, g],
        init : m,
        apply : l
      },
      /**
       * Either a string or a number, which defines the horizontal position
       * of the background image.
       *
       * If the value is an integer it is interpreted as a pixel value, otherwise
       * the value is taken to be a CSS value. For CSS, the values are "center",
       * "left" and "right".
       */
      backgroundPositionX : {
        nullable : true,
        apply : l
      },
      /**
       * Either a string or a number, which defines the vertical position
       * of the background image.
       *
       * If the value is an integer it is interpreted as a pixel value, otherwise
       * the value is taken to be a CSS value. For CSS, the values are "top",
       * "center" and "bottom".
       */
      backgroundPositionY : {
        nullable : true,
        apply : l
      },
      /**
       * Property group to define the background position
       */
      backgroundPosition : {
        group : [u, j]
      }
    },
    members : {
      /**
       * Mapping for the dynamic decorator.
       *
       * @param styles {Map} CSS styles as map
       * @param content {String?null} The content of the created div as HTML
       * @return {String} The generated HTML fragment
       */
      _generateMarkup : function(w, content){

        return this._generateBackgroundMarkup(w, content);
      },
      /**
       * Responsible for generating the markup for the background.
       * This method just uses the settings in the properties to generate
       * the markup.
       *
       * @param styles {Map} CSS styles as map
       * @param content {String?null} The content of the created div as HTML
       * @return {String} The generated HTML fragment
       */
      _generateBackgroundMarkup : function(x, content){

        var B = k;
        var A = this.getBackgroundImage();
        var z = this.getBackgroundRepeat();
        var top = this.getBackgroundPositionY();
        if(top == null){

          top = 0;
        };
        var C = this.getBackgroundPositionX();
        if(C == null){

          C = 0;
        };
        x.backgroundPosition = C + o + top;
        // Support for images
        if(A){

          var y = qx.util.AliasManager.getInstance().resolve(A);
          B = qx.bom.element.Decoration.create(y, z, x);
        } else {

          if((qx.core.Environment.get(r) == s)){

            /*
             * Internet Explorer as of version 6 for quirks and standards mode,
             * or version 7 in quirks mode adds an empty string to the "div"
             * node. This behavior causes rendering problems, because the node
             * would then have a minimum size determined by the font size.
             * To be able to set the "div" node height to a certain (small)
             * value independent of the minimum font size, an "overflow:hidden"
             * style is added.
             * */
            if(parseFloat(qx.core.Environment.get(h)) < 7 || qx.core.Environment.get(f)){

              // Add additionally style
              x.overflow = b;
            };
          };
          if(!content){

            content = k;
          };
          B = e + qx.bom.element.Style.compile(x) + t + content + i;
        };
        return B;
      },
      // property apply
      _applyBackgroundImage : function(){

        if(qx.core.Environment.get(d)){

          if(this._isInitialized()){

            throw new Error(q);
          };
        };
      }
    }
  });
})();
(function(){

  var c = "qx.ui.decoration.Background",b = "absolute",a = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A very simple decorator featuring background images and colors. No
   * border is supported.
   */
  qx.Class.define(c, {
    extend : qx.ui.decoration.Abstract,
    include : [qx.ui.decoration.MBackgroundImage, qx.ui.decoration.MBackgroundColor],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param backgroundColor {Color} Initialize with background color
     */
    construct : function(d){

      qx.ui.decoration.Abstract.call(this);
      if(d != null){

        this.setBackgroundColor(d);
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __markup : null,
      // overridden
      _getDefaultInsets : function(){

        return {
          top : 0,
          right : 0,
          bottom : 0,
          left : 0
        };
      },
      // overridden
      _isInitialized : function(){

        return !!this.__markup;
      },
      /*
      ---------------------------------------------------------------------------
        INTERFACE IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getMarkup : function(){

        if(this.__markup){

          return this.__markup;
        };
        var e = {
          position : b,
          top : 0,
          left : 0
        };
        var f = this._generateBackgroundMarkup(e);
        // Store
        return this.__markup = f;
      },
      // interface implementation
      resize : function(g, h, i){

        var j = this.getInsets();
        g.style.width = (h - j.left - j.right) + a;
        g.style.height = (i - j.top - j.bottom) + a;
        g.style.left = -j.left + a;
        g.style.top = -j.top + a;
      },
      // interface implementation
      tint : function(k, l){

        this._tintBackgroundColor(k, l, k.style);
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct : function(){

      this.__markup = null;
    }
  });
})();
(function(){

  var j = "qx.theme",i = "border-top",h = "border-left",g = "border-right",f = "qx.ui.decoration.MSingleBorder",e = "border-bottom",d = "This decorator is already in-use. Modification is not possible anymore!",c = "Invalid Single decorator (zero border width). Use qx.ui.decorator.Background instead!",b = "absolute",a = "widthTop",H = "styleRight",G = "styleBottom",F = "qx.debug",E = "widthBottom",D = "widthLeft",C = "styleTop",B = "colorBottom",A = "styleLeft",z = "widthRight",y = "colorLeft",q = "colorRight",r = "colorTop",o = "shorthand",p = "double",m = "px ",n = "dotted",k = "_applyWidth",l = "Color",s = "",t = "dashed",v = "Number",u = " ",x = "solid",w = "_applyStyle";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * A basic decorator featuring simple borders based on CSS styles.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   */
  qx.Mixin.define(f, {
    properties : {
      /*
      ---------------------------------------------------------------------------
        PROPERTY: WIDTH
      ---------------------------------------------------------------------------
      */
      /** top width of border */
      widthTop : {
        check : v,
        init : 0,
        apply : k
      },
      /** right width of border */
      widthRight : {
        check : v,
        init : 0,
        apply : k
      },
      /** bottom width of border */
      widthBottom : {
        check : v,
        init : 0,
        apply : k
      },
      /** left width of border */
      widthLeft : {
        check : v,
        init : 0,
        apply : k
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY: STYLE
      ---------------------------------------------------------------------------
      */
      /** top style of border */
      styleTop : {
        nullable : true,
        check : [x, n, t, p],
        init : x,
        apply : w
      },
      /** right style of border */
      styleRight : {
        nullable : true,
        check : [x, n, t, p],
        init : x,
        apply : w
      },
      /** bottom style of border */
      styleBottom : {
        nullable : true,
        check : [x, n, t, p],
        init : x,
        apply : w
      },
      /** left style of border */
      styleLeft : {
        nullable : true,
        check : [x, n, t, p],
        init : x,
        apply : w
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY: COLOR
      ---------------------------------------------------------------------------
      */
      /** top color of border */
      colorTop : {
        nullable : true,
        check : l,
        apply : w
      },
      /** right color of border */
      colorRight : {
        nullable : true,
        check : l,
        apply : w
      },
      /** bottom color of border */
      colorBottom : {
        nullable : true,
        check : l,
        apply : w
      },
      /** left color of border */
      colorLeft : {
        nullable : true,
        check : l,
        apply : w
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY GROUP: EDGE
      ---------------------------------------------------------------------------
      */
      /** Property group to configure the left border */
      left : {
        group : [D, A, y]
      },
      /** Property group to configure the right border */
      right : {
        group : [z, H, q]
      },
      /** Property group to configure the top border */
      top : {
        group : [a, C, r]
      },
      /** Property group to configure the bottom border */
      bottom : {
        group : [E, G, B]
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY GROUP: TYPE
      ---------------------------------------------------------------------------
      */
      /** Property group to set the border width of all sides */
      width : {
        group : [a, z, E, D],
        mode : o
      },
      /** Property group to set the border style of all sides */
      style : {
        group : [C, H, G, A],
        mode : o
      },
      /** Property group to set the border color of all sides */
      color : {
        group : [r, q, B, y],
        mode : o
      }
    },
    members : {
      /**
       * Takes a styles map and adds the border styles styles in place
       * to the given map. This is the needed behavior for
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param styles {Map} A map to add the styles.
       */
      _styleBorder : function(I){

        if(qx.core.Environment.get(j)){

          var K = qx.theme.manager.Color.getInstance();
          var O = K.resolve(this.getColorTop());
          var L = K.resolve(this.getColorRight());
          var J = K.resolve(this.getColorBottom());
          var N = K.resolve(this.getColorLeft());
        } else {

          var O = this.getColorTop();
          var L = this.getColorRight();
          var J = this.getColorBottom();
          var N = this.getColorLeft();
        };
        // Add borders
        var M = this.getWidthTop();
        if(M > 0){

          I[i] = M + m + this.getStyleTop() + u + (O || s);
        };
        var M = this.getWidthRight();
        if(M > 0){

          I[g] = M + m + this.getStyleRight() + u + (L || s);
        };
        var M = this.getWidthBottom();
        if(M > 0){

          I[e] = M + m + this.getStyleBottom() + u + (J || s);
        };
        var M = this.getWidthLeft();
        if(M > 0){

          I[h] = M + m + this.getStyleLeft() + u + (N || s);
        };
        // Check if valid
        if(qx.core.Environment.get(F)){

          if(I.length === 0){

            throw new Error(c);
          };
        };
        // Add basic styles
        I.position = b;
        I.top = 0;
        I.left = 0;
      },
      /**
       * Resize function for the decorator. This is suitable for the
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param element {Element} The element which could be resized.
       * @param width {Number} The new width.
       * @param height {Number} The new height.
       * @return {Map} A map containing the desired position and dimension.
       *   (width, height, top, left).
       */
      _resizeBorder : function(P, Q, R){

        var S = this.getInsets();
        Q -= S.left + S.right;
        R -= S.top + S.bottom;
        // Fix to keep applied size above zero
        // Makes issues in IE7 when applying value like '-4px'
        if(Q < 0){

          Q = 0;
        };
        if(R < 0){

          R = 0;
        };
        return {
          left : S.left - this.getWidthLeft(),
          top : S.top - this.getWidthTop(),
          width : Q,
          height : R
        };
      },
      /**
       * Implementation of the interface for the single border.
       *
       * @return {Map} A map containing the default insets.
       *   (top, right, bottom, left)
       */
      _getDefaultInsetsForBorder : function(){

        return {
          top : this.getWidthTop(),
          right : this.getWidthRight(),
          bottom : this.getWidthBottom(),
          left : this.getWidthLeft()
        };
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyWidth : function(){

        this._applyStyle();
        this._resetInsets();
      },
      // property apply
      _applyStyle : function(){

        if(qx.core.Environment.get(F)){

          if(this._markup){

            throw new Error(d);
          };
        };
      }
    }
  });
})();
(function(){

  var b = "qx.ui.decoration.Single",a = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A basic decorator featuring background colors and simple borders based on
   * CSS styles.
   */
  qx.Class.define(b, {
    extend : qx.ui.decoration.Abstract,
    include : [qx.ui.decoration.MBackgroundImage, qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MSingleBorder],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param width {Integer} Width of the border
     * @param style {String} Any supported border style
     * @param color {Color} The border color
     */
    construct : function(c, d, e){

      qx.ui.decoration.Abstract.call(this);
      // Initialize properties
      if(c != null){

        this.setWidth(c);
      };
      if(d != null){

        this.setStyle(d);
      };
      if(e != null){

        this.setColor(e);
      };
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _markup : null,
      /*
      ---------------------------------------------------------------------------
        INTERFACE IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getMarkup : function(){

        if(this._markup){

          return this._markup;
        };
        var f = {
        };
        // get the single border styles
        this._styleBorder(f);
        var g = this._generateBackgroundMarkup(f);
        return this._markup = g;
      },
      // interface implementation
      resize : function(h, i, j){

        // get the width and height of the mixins
        var k = this._resizeBorder(h, i, j);
        h.style.width = k.width + a;
        h.style.height = k.height + a;
        h.style.left = k.left + a;
        h.style.top = k.top + a;
      },
      // interface implementation
      tint : function(l, m){

        this._tintBackgroundColor(l, m, l.style);
      },
      // overridden
      _isInitialized : function(){

        return !!this._markup;
      },
      // overridden
      _getDefaultInsets : function(){

        return this._getDefaultInsetsForBorder();
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._markup = null;
    }
  });
})();
(function(){

  var j = "</div>",i = "),to(",h = "from(",g = "background-image",f = "background",e = "<div style='width: 100%; height: 100%; position: absolute;",d = "StartColorStr='#FF",c = "', ",b = "'></div>",a = "-webkit-gradient(linear,",U = "startColorPosition",T = "qx.debug",S = "deg, ",R = "css.gradient.legacywebkit",Q = "EndColorStr='#FF",P = "startColor",O = "qx.theme",N = "MBoxShadow",M = "<div style=\"position: absolute; width: 100%; height: 100%; ",L = "(GradientType=",q = "qx.ui.decoration.MLinearBackgroundGradient",r = "(",o = "endColorPosition",p = "';)\">",m = "endColor",n = ", ",k = "overflow",l = "hidden",s = "This decorator is already in-use. Modification is not possible anymore!",t = "linear-gradient",A = "filter:progid:DXImageTransform.Microsoft.Gradient",y = " 0",E = "px",C = "0",H = "shorthand",G = "Color",v = "vertical",K = "css.gradient.filter",J = "Number",I = "%",u = ")",w = "",x = "css.gradient.linear",z = ",",B = " ",D = "horizontal",F = "_applyLinearBackgroundGradient";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin for the linear background gradient CSS property.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   *
   * Keep in mind that this is not supported by all browsers:
   *
   * * Safari 4.0+
   * * Chrome 4.0+
   * * Firefox 3.6+
   * * Opera 11.1+
   * * IE 10+
   * * IE 5.5+ (with limitations)
   *
   * For IE 5.5 to IE 9,this class uses the filter rules to create the gradient. This
   * has some limitations: The start and end position property can not be used. For
   * more details, see the original documentation:
   * http://msdn.microsoft.com/en-us/library/ms532997(v=vs.85).aspx
   */
  qx.Mixin.define(q, {
    properties : {
      /** Start start color of the background */
      startColor : {
        check : G,
        nullable : true,
        apply : F
      },
      /** End end color of the background */
      endColor : {
        check : G,
        nullable : true,
        apply : F
      },
      /** The orientation of the gradient. */
      orientation : {
        check : [D, v],
        init : v,
        apply : F
      },
      /** Position in percent where to start the color. */
      startColorPosition : {
        check : J,
        init : 0,
        apply : F
      },
      /** Position in percent where to start the color. */
      endColorPosition : {
        check : J,
        init : 100,
        apply : F
      },
      /** Defines if the given positions are in % or px.*/
      colorPositionUnit : {
        check : [E, I],
        init : I,
        apply : F
      },
      /** Property group to set the start color including its start position. */
      gradientStart : {
        group : [P, U],
        mode : H
      },
      /** Property group to set the end color including its end position. */
      gradientEnd : {
        group : [m, o],
        mode : H
      }
    },
    members : {
      /**
       * Takes a styles map and adds the linear background styles in place to the
       * given map. This is the needed behavior for
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param styles {Map} A map to add the styles.
       */
      _styleLinearBackgroundGradient : function(V){

        var bc = this.__getColors();
        var bg = bc.start;
        var ba = bc.end;
        var bh = this.getColorPositionUnit();
        // new implementation for webkit is available since chrome 10 --> version
        if(qx.core.Environment.get(R)){

          // webkit uses px values if non are given
          bh = bh === E ? w : bh;
          if(this.getOrientation() == D){

            var bf = this.getStartColorPosition() + bh + y + bh;
            var bd = this.getEndColorPosition() + bh + y + bh;
          } else {

            var bf = C + bh + B + this.getStartColorPosition() + bh;
            var bd = C + bh + B + this.getEndColorPosition() + bh;
          };
          var X = h + bg + i + ba + u;
          var Y = a + bf + z + bd + z + X + u;
          V[f] = Y;
        } else if(qx.core.Environment.get(K) && !qx.core.Environment.get(x)){

          // make sure the overflow is hidden for border radius usage [BUG #6318]
          V[k] = l;
        } else {

          // WebKit, Opera and Gecko interpret 0deg as "to right"
          var bi = this.getOrientation() == D ? 0 : 270;
          var bb = bg + B + this.getStartColorPosition() + bh;
          var W = ba + B + this.getEndColorPosition() + bh;
          var be = qx.core.Environment.get(x);
          // Browsers supporting the unprefixed implementation interpret 0deg as
          // "to top" as defined by the spec [BUG #6513]
          if(be === t){

            bi = this.getOrientation() == D ? bi + 90 : bi - 90;
          };
          V[g] = be + r + bi + S + bb + z + W + u;
        };
      },
      /**
       * Helper to get start and end color.
       * @return {Map} A map containing start and end color.
       */
      __getColors : function(){

        if(qx.core.Environment.get(O)){

          var bj = qx.theme.manager.Color.getInstance();
          var bl = bj.resolve(this.getStartColor());
          var bk = bj.resolve(this.getEndColor());
        } else {

          var bl = this.getStartColor();
          var bk = this.getEndColor();
        };
        return {
          start : bl,
          end : bk
        };
      },
      /**
       * Helper for IE which applies the filter used for the gradient to a separate
       * DIV element which will be put into the decorator. This is necessary in case
       * the decorator has rounded corners.
       * @return {String} The HTML for the inner gradient DIV.
       */
      _getContent : function(){

        // IE filter syntax
        // http://msdn.microsoft.com/en-us/library/ms532997(v=vs.85).aspx
        // It needs to be wrapped in a separate div bug #6318
        if(qx.core.Environment.get(K) && !qx.core.Environment.get(x)){

          var bo = this.__getColors();
          var br = this.getOrientation() == D ? 1 : 0;
          // convert all hex3 to hex6
          var bq = qx.util.ColorUtil.hex3StringToHex6String(bo.start);
          var bn = qx.util.ColorUtil.hex3StringToHex6String(bo.end);
          // get rid of the starting '#'
          bq = bq.substring(1, bq.length);
          bn = bn.substring(1, bn.length);
          // filter gradients block the box shadow implementation ->
          // we need to set them explicitly [BUG #6761]
          var bp = w;
          if(this.classname.indexOf(N) != -1){

            var bm = {
            };
            this._styleBoxShadow(bm);
            bp = e + qx.bom.element.Style.compile(bm) + b;
          };
          return M + A + L + br + n + d + bq + c + Q + bn + p + bp + j;
        };
        return w;
      },
      /**
       * Resize function for the background color. This is suitable for the
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param element {Element} The element which could be resized.
       * @param width {Number} The new width.
       * @param height {Number} The new height.
       * @return {Map} A map containing the desired position and dimension
       *   (width, height, top, left).
       */
      _resizeLinearBackgroundGradient : function(bs, bt, bu){

        var bv = this.getInsets();
        bt -= bv.left + bv.right;
        bu -= bv.top + bv.bottom;
        return {
          left : bv.left,
          top : bv.top,
          width : bt,
          height : bu
        };
      },
      // property apply
      _applyLinearBackgroundGradient : function(){

        if(qx.core.Environment.get(T)){

          if(this._isInitialized()){

            throw new Error(s);
          };
        };
      }
    }
  });
})();
(function(){

  var a = "qx.ui.decoration.Uniform";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A simple decorator featuring background images and colors and a simple
   * uniform border based on CSS styles.
   */
  qx.Class.define(a, {
    extend : qx.ui.decoration.Single,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param width {Integer} Width of the border
     * @param style {String} Any supported border style
     * @param color {Color} The border color
     */
    construct : function(b, c, d){

      qx.ui.decoration.Single.call(this);
      // Initialize properties
      if(b != null){

        this.setWidth(b);
      };
      if(c != null){

        this.setStyle(c);
      };
      if(d != null){

        this.setColor(d);
      };
    }
  });
})();
(function(){

  var j = "px",i = '</div>',h = "qx.ui.decoration.Beveled",g = "css.boxmodel",f = "qx.debug",e = '<div style="position:absolute;top:1px;left:1px;',d = 'border-bottom:',c = 'border-right:',b = "",a = "content",z = "Number",y = 'border-left:',x = 'border-top:',w = "This decorator is already in-use. Modification is not possible anymore!",v = '<div style="position:absolute;top:1px;left:0px;',u = 'position:absolute;top:0px;left:1px;',t = '<div style="overflow:hidden;font-size:0;line-height:0;">',s = "absolute",r = "1px",q = '<div style="',o = 'border:',p = "1px solid ",m = "Color",n = ";",k = "_applyStyle",l = '"></div>';
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Beveled is a variant of a rounded decorator which is quite optimal
   * regarding performance and still delivers a good set of features:
   *
   * * One pixel rounded border
   * * Inner glow color with optional transparency
   * * Repeated or scaled background image
   */
  qx.Class.define(h, {
    extend : qx.ui.decoration.Abstract,
    include : [qx.ui.decoration.MBackgroundImage, qx.ui.decoration.MBackgroundColor],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param outerColor {Color} The outer border color
     * @param innerColor {Color} The inner border color
     * @param innerOpacity {Float} Opacity of inner border
     */
    construct : function(A, B, C){

      qx.ui.decoration.Abstract.call(this);
      // Initialize properties
      if(A != null){

        this.setOuterColor(A);
      };
      if(B != null){

        this.setInnerColor(B);
      };
      if(C != null){

        this.setInnerOpacity(C);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * The color of the inner frame.
       */
      innerColor : {
        check : m,
        nullable : true,
        apply : k
      },
      /**
       * The opacity of the inner frame. As this inner frame
       * is rendered above the background image this may be
       * intersting to configure as semi-transparent e.g. <code>0.4</code>.
       */
      innerOpacity : {
        check : z,
        init : 1,
        apply : k
      },
      /**
       * Color of the outer frame. The corners are automatically
       * rendered with a slight opacity to fade into the background
       */
      outerColor : {
        check : m,
        nullable : true,
        apply : k
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __markup : null,
      // overridden
      _getDefaultInsets : function(){

        return {
          top : 2,
          right : 2,
          bottom : 2,
          left : 2
        };
      },
      // overridden
      _isInitialized : function(){

        return !!this.__markup;
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyStyle : function(){

        if(qx.core.Environment.get(f)){

          if(this.__markup){

            throw new Error(w);
          };
        };
      },
      /*
      ---------------------------------------------------------------------------
        INTERFACE IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getMarkup : function(){

        if(this.__markup){

          return this.__markup;
        };
        var D = qx.theme.manager.Color.getInstance();
        var E = [];
        // Prepare border styles
        var H = p + D.resolve(this.getOuterColor()) + n;
        var G = p + D.resolve(this.getInnerColor()) + n;
        // Outer frame
        E.push(t);
        // Background frame
        E.push(q);
        E.push(o, H);
        E.push(qx.bom.element.Opacity.compile(0.35));
        E.push(l);
        // Horizontal frame
        E.push(v);
        E.push(y, H);
        E.push(c, H);
        E.push(qx.bom.element.Opacity.compile(1));
        E.push(l);
        // Vertical frame
        E.push(q);
        E.push(u);
        E.push(x, H);
        E.push(d, H);
        E.push(qx.bom.element.Opacity.compile(1));
        E.push(l);
        // Inner background frame
        var F = {
          position : s,
          top : r,
          left : r,
          opacity : 1
        };
        E.push(this._generateBackgroundMarkup(F));
        // Inner overlay frame
        E.push(e);
        E.push(o, G);
        E.push(qx.bom.element.Opacity.compile(this.getInnerOpacity()));
        E.push(l);
        // Outer frame
        E.push(i);
        // Store
        return this.__markup = E.join(b);
      },
      // interface implementation
      resize : function(I, J, K){

        // Fix to keep applied size above zero
        // Makes issues in IE7 when applying value like '-4px'
        if(J < 4){

          J = 4;
        };
        if(K < 4){

          K = 4;
        };
        // Fix box model
        if(qx.core.Environment.get(g) == a){

          var outerWidth = J - 2;
          var outerHeight = K - 2;
          var Q = outerWidth;
          var P = outerHeight;
          var innerWidth = J - 4;
          var innerHeight = K - 4;
        } else {

          var outerWidth = J;
          var outerHeight = K;
          var Q = J - 2;
          var P = K - 2;
          var innerWidth = Q;
          var innerHeight = P;
        };
        var S = j;
        var O = I.childNodes[0].style;
        O.width = outerWidth + S;
        O.height = outerHeight + S;
        var N = I.childNodes[1].style;
        N.width = outerWidth + S;
        N.height = P + S;
        var M = I.childNodes[2].style;
        M.width = Q + S;
        M.height = outerHeight + S;
        var L = I.childNodes[3].style;
        L.width = Q + S;
        L.height = P + S;
        var R = I.childNodes[4].style;
        R.width = innerWidth + S;
        R.height = innerHeight + S;
      },
      // interface implementation
      tint : function(T, U){

        this._tintBackgroundColor(T, U, T.childNodes[3].style);
      }
    },
    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
     */
    destruct : function(){

      this.__markup = null;
    }
  });
})();
(function(){

  var j = "qx.debug.dispose",i = "insetTop",h = "insetBottom",g = "sliceBottom",f = "_applyFill",e = "The value of the property 'rightSlice' is null! ",d = "qx.debug",c = "sliceLeft",b = "_applyBaseImage",a = "sliceRight",C = "The value of the property 'bottomSlice' is null! ",B = "String",A = "The value of the property 'leftSlice' is null! ",z = "insetRight",y = "sliceTop",x = "The value of the property 'topSlice' is null! ",w = "insetLeft",v = "qx.ui.decoration.Grid",u = "-l",t = "set",q = "-t",r = "-r",o = "-b",p = "shorthand",m = "_applySlices",n = "Please verify the image '",k = "_applyInsets",l = "' is present.",s = "Number";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A very complex decoration using two, partly combined and clipped images
   * to render a graphically impressive borders with gradients.
   *
   * The decoration supports all forms of vertical gradients. The gradients must
   * be stretchable to support different heights.
   *
   * The edges could use different styles of rounded borders. Even different
   * edge sizes are supported. The sizes are automatically detected by
   * the build system using the image meta data.
   *
   * The decoration uses clipped images to reduce the number of external
   * resources to load.
   */
  qx.Class.define(v, {
    extend : qx.core.Object,
    implement : [qx.ui.decoration.IDecorator],
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param baseImage {String} Base image to use
     * @param insets {Integer|Array} Insets for the grid
     */
    construct : function(D, E){

      qx.core.Object.call(this);
      if(qx.ui.decoration.css3.BorderImage.IS_SUPPORTED){

        this.__impl = new qx.ui.decoration.css3.BorderImage();
        if(D){

          this.__setBorderImage(D);
        };
      } else {

        this.__impl = new qx.ui.decoration.GridDiv(D);
      };
      if(E != null){

        this.__impl.setInsets(E);
      };
      // ignore the internal used implementation in the dispose debugging [BUG #5343]
      if(qx.core.Environment.get(j)){

        this.__impl.$$ignoreDisposeWarning = true;
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Base image URL. There must be an image with this name and the sliced
       * and the nine sliced images. The sliced images must be named according to
       * the following scheme:
       *
       * ${baseImageWithoutExtension}-${imageName}.${baseImageExtension}
       *
       * These image names are used:
       *
       * * tl (top-left edge)
       * * t (top side)
       * * tr (top-right edge)
      
       * * bl (bottom-left edge)
       * * b (bottom side)
       * * br (bottom-right edge)
       *
       * * l (left side)
       * * c (center image)
       * * r (right side)
       */
      baseImage : {
        check : B,
        nullable : true,
        apply : b
      },
      /** Width of the left inset (keep this margin to the outer box) */
      insetLeft : {
        check : s,
        nullable : true,
        apply : k
      },
      /** Width of the right inset (keep this margin to the outer box) */
      insetRight : {
        check : s,
        nullable : true,
        apply : k
      },
      /** Width of the bottom inset (keep this margin to the outer box) */
      insetBottom : {
        check : s,
        nullable : true,
        apply : k
      },
      /** Width of the top inset (keep this margin to the outer box) */
      insetTop : {
        check : s,
        nullable : true,
        apply : k
      },
      /** Property group for insets */
      insets : {
        group : [i, z, h, w],
        mode : p
      },
      /** Width of the left slice */
      sliceLeft : {
        check : s,
        nullable : true,
        apply : m
      },
      /** Width of the right slice */
      sliceRight : {
        check : s,
        nullable : true,
        apply : m
      },
      /** Width of the bottom slice */
      sliceBottom : {
        check : s,
        nullable : true,
        apply : m
      },
      /** Width of the top slice */
      sliceTop : {
        check : s,
        nullable : true,
        apply : m
      },
      /** Property group for slices */
      slices : {
        group : [y, a, g, c],
        mode : p
      },
      /** Only used for the CSS3 implementation, see {@link qx.ui.decoration.css3.BorderImage#fill} **/
      fill : {
        apply : f
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      __impl : null,
      // interface implementation
      getMarkup : function(){

        return this.__impl.getMarkup();
      },
      // interface implementation
      resize : function(F, G, H){

        this.__impl.resize(F, G, H);
      },
      // interface implementation
      tint : function(I, J){
      },
      // interface implementation
      getInsets : function(){

        return this.__impl.getInsets();
      },
      // property apply
      _applyInsets : function(K, L, name){

        var M = t + qx.lang.String.firstUp(name);
        this.__impl[M](K);
      },
      // property apply
      _applySlices : function(N, O, name){

        var P = t + qx.lang.String.firstUp(name);
        // The GridDiv implementation doesn't have slice properties,
        // slices are obtained from the sizes of the images instead
        if(this.__impl[P]){

          this.__impl[P](N);
        };
      },
      //property apply
      _applyFill : function(Q, R, name){

        if(this.__impl.setFill){

          this.__impl.setFill(Q);
        };
      },
      // property apply
      _applyBaseImage : function(S, T){

        if(this.__impl instanceof qx.ui.decoration.GridDiv){

          this.__impl.setBaseImage(S);
        } else {

          this.__setBorderImage(S);
        };
      },
      /**
       * Configures the border image decorator
       *
       * @param baseImage {String} URL of the base image
       */
      __setBorderImage : function(U){

        this.__impl.setBorderImage(U);
        var bf = qx.util.AliasManager.getInstance().resolve(U);
        var bg = /(.*)(\.[a-z]+)$/.exec(bf);
        var bb = bg[1];
        var be = bg[2];
        var X = qx.util.ResourceManager.getInstance();
        var bh = X.getImageHeight(bb + q + be);
        var V = X.getImageWidth(bb + r + be);
        var W = X.getImageHeight(bb + o + be);
        var bi = X.getImageWidth(bb + u + be);
        if(qx.core.Environment.get(d) && !this.__impl instanceof qx.ui.decoration.css3.BorderImage){

          var Y = x + n + bb + q + be + l;
          var ba = e + n + bb + r + be + l;
          var bd = C + n + bb + o + be + l;
          var bc = A + n + bb + u + be + l;
          qx.core.Assert.assertNotNull(bh, Y);
          qx.core.Assert.assertNotNull(V, ba);
          qx.core.Assert.assertNotNull(W, bd);
          qx.core.Assert.assertNotNull(bi, bc);
        };
        if(bh && V && W && bi){

          this.__impl.setSlice([bh, V, W, bi]);
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this.__impl.dispose();
      this.__impl = null;
    }
  });
})();
(function(){

  var j = "css.borderimage.standardsyntax",i = "Boolean",h = "px ",g = "sliceBottom",f = "solid",e = ";'></div>",d = "<div style='",c = "qx.debug",b = "sliceLeft",a = "sliceRight",F = "repeatX",E = " fill",D = "String",C = "qx.ui.decoration.css3.BorderImage",B = "border-box",A = "transparent",z = '") ',y = "sliceTop",x = "This decorator is already in-use. Modification is not possible anymore!",w = 'url("',q = "hidden",r = "repeatY",o = "absolute",p = "repeat",m = "",n = "round",k = "shorthand",l = "px",s = " ",t = "stretch",v = "Integer",u = "_applyStyle";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * Decorator, which uses the CSS3 border image properties.
   *
   * This decorator can be used as replacement for {@link qx.ui.layout.Grid},
   * {@link qx.ui.layout.HBox} and {@link qx.ui.layout.VBox} decorators in
   * browsers, which support it.
   *
   * Supported browsers are:
   * <ul>
   *   <li>Firefox >= 3.5</li>
   *   <li>Safari >= 4</li>
   *   <li>Chrome >= 3</li>
   * <ul>
   */
  qx.Class.define(C, {
    extend : qx.ui.decoration.Abstract,
    /**
     * @param borderImage {String} Base image to use
     * @param slice {Integer|Array} Sets the {@link #slice} property
     */
    construct : function(G, H){

      qx.ui.decoration.Abstract.call(this);
      // Initialize properties
      if(G != null){

        this.setBorderImage(G);
      };
      if(H != null){

        this.setSlice(H);
      };
    },
    statics : {
      /**
       * Whether the browser supports this decorator
       */
      IS_SUPPORTED : qx.bom.element.Style.isPropertySupported("borderImage")
    },
    properties : {
      /**
       * Base image URL.
       */
      borderImage : {
        check : D,
        nullable : true,
        apply : u
      },
      /**
       * The top slice line of the base image. The slice properties divide the
       * image into nine regions, which define the corner, edge and the center
       * images.
       */
      sliceTop : {
        check : v,
        init : 0,
        apply : u
      },
      /**
       * The right slice line of the base image. The slice properties divide the
       * image into nine regions, which define the corner, edge and the center
       * images.
       */
      sliceRight : {
        check : v,
        init : 0,
        apply : u
      },
      /**
       * The bottom slice line of the base image. The slice properties divide the
       * image into nine regions, which define the corner, edge and the center
       * images.
       */
      sliceBottom : {
        check : v,
        init : 0,
        apply : u
      },
      /**
       * The left slice line of the base image. The slice properties divide the
       * image into nine regions, which define the corner, edge and the center
       * images.
       */
      sliceLeft : {
        check : v,
        init : 0,
        apply : u
      },
      /**
       * The slice properties divide the image into nine regions, which define the
       * corner, edge and the center images.
       */
      slice : {
        group : [y, a, g, b],
        mode : k
      },
      /**
       * This property specifies how the images for the sides and the middle part
       * of the border image are scaled and tiled horizontally.
       *
       * Values have the following meanings:
       * <ul>
       *   <li><strong>stretch</strong>: The image is stretched to fill the area.</li>
       *   <li><strong>repeat</strong>: The image is tiled (repeated) to fill the area.</li>
       *   <li><strong>round</strong>: The image is tiled (repeated) to fill the area. If it does not
       *    fill the area with a whole number of tiles, the image is rescaled so
       *    that it does.</li>
       * </ul>
       */
      repeatX : {
        check : [t, p, n],
        init : t,
        apply : u
      },
      /**
       * This property specifies how the images for the sides and the middle part
       * of the border image are scaled and tiled vertically.
       *
       * Values have the following meanings:
       * <ul>
       *   <li><strong>stretch</strong>: The image is stretched to fill the area.</li>
       *   <li><strong>repeat</strong>: The image is tiled (repeated) to fill the area.</li>
       *   <li><strong>round</strong>: The image is tiled (repeated) to fill the area. If it does not
       *    fill the area with a whole number of tiles, the image is rescaled so
       *    that it does.</li>
       * </ul>
       */
      repeatY : {
        check : [t, p, n],
        init : t,
        apply : u
      },
      /**
       * This property specifies how the images for the sides and the middle part
       * of the border image are scaled and tiled.
       */
      repeat : {
        group : [F, r],
        mode : k
      },
      /**
       * If set to <code>false</code>, the center image will be omitted and only
       * the border will be drawn.
       */
      fill : {
        check : i,
        init : true
      }
    },
    members : {
      __markup : null,
      // overridden
      _getDefaultInsets : function(){

        return {
          top : 0,
          right : 0,
          bottom : 0,
          left : 0
        };
      },
      // overridden
      _isInitialized : function(){

        return !!this.__markup;
      },
      /*
      ---------------------------------------------------------------------------
        INTERFACE IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getMarkup : function(){

        if(this.__markup){

          return this.__markup;
        };
        var I = this._resolveImageUrl(this.getBorderImage());
        var J = [this.getSliceTop(), this.getSliceRight(), this.getSliceBottom(), this.getSliceLeft()];
        var K = [this.getRepeatX(), this.getRepeatY()].join(s);
        var L = this.getFill() && qx.core.Environment.get(j) ? E : m;
        this.__markup = [d, qx.bom.element.Style.compile({
          "borderImage" : w + I + z + J.join(s) + L + s + K,
          "borderStyle" : f,
          "borderColor" : A,
          position : o,
          lineHeight : 0,
          fontSize : 0,
          overflow : q,
          boxSizing : B,
          borderWidth : J.join(h) + l
        }), e].join(m);
        // Store
        return this.__markup;
      },
      // interface implementation
      resize : function(M, N, O){

        M.style.width = N + l;
        M.style.height = O + l;
      },
      // interface implementation
      tint : function(P, Q){
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyStyle : function(R, S, name){

        if(qx.core.Environment.get(c)){

          if(this._isInitialized()){

            throw new Error(x);
          };
        };
      },
      /**
       * Resolve the url of the given image
       *
       * @param image {String} base image URL
       * @return {String} the resolved image URL
       */
      _resolveImageUrl : function(T){

        return qx.util.ResourceManager.getInstance().toUri(qx.util.AliasManager.getInstance().resolve(T));
      }
    },
    destruct : function(){

      this.__markup = null;
    }
  });
})();
(function(){

  var j = "-tr",i = "-l",h = '</div>',g = "scale",f = "-br",e = "-t",d = "browser.quirksmode",c = "-tl",b = "-r",a = '<div style="position:absolute;top:0;left:0;overflow:hidden;font-size:0;line-height:0;">',B = "qx.debug",A = "_applyBaseImage",z = "-b",y = "String",x = "",w = "-bl",v = "qx.ui.decoration.GridDiv",u = "-c",t = "mshtml",s = "engine.name",q = "This decorator is already in-use. Modification is not possible anymore!",r = "engine.version",o = "scale-x",p = "scale-y",m = "no-repeat",n = "0px",k = "-1px",l = "px";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */
  /**
   * A very complex decoration using two, partly combined and clipped images
   * to render a graphically impressive borders with gradients.
   *
   * The decoration supports all forms of vertical gradients. The gradients must
   * be stretchable to support different heights.
   *
   * The edges could use different styles of rounded borders. Even different
   * edge sizes are supported. The sizes are automatically detected by
   * the build system using the image meta data.
   *
   * The decoration uses clipped images to reduce the number of external
   * resources to load.
   */
  qx.Class.define(v, {
    extend : qx.ui.decoration.Abstract,
    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    /**
     * @param baseImage {String} Base image to use
     * @param insets {Integer|Array} Insets for the grid
     */
    construct : function(C, D){

      qx.ui.decoration.Abstract.call(this);
      // Initialize properties
      if(C != null){

        this.setBaseImage(C);
      };
      if(D != null){

        this.setInsets(D);
      };
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /**
       * Base image URL. All the different images needed are named by the default
       * naming scheme:
       *
       * ${baseImageWithoutExtension}-${imageName}.${baseImageExtension}
       *
       * These image names are used:
       *
       * * tl (top-left edge)
       * * t (top side)
       * * tr (top-right edge)
      
       * * bl (bottom-left edge)
       * * b (bottom side)
       * * br (bottom-right edge)
       *
       * * l (left side)
       * * c (center image)
       * * r (right side)
       */
      baseImage : {
        check : y,
        nullable : true,
        apply : A
      }
    },
    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members : {
      _markup : null,
      _images : null,
      _edges : null,
      // overridden
      _getDefaultInsets : function(){

        return {
          top : 0,
          right : 0,
          bottom : 0,
          left : 0
        };
      },
      // overridden
      _isInitialized : function(){

        return !!this._markup;
      },
      /*
      ---------------------------------------------------------------------------
        INTERFACE IMPLEMENTATION
      ---------------------------------------------------------------------------
      */
      // interface implementation
      getMarkup : function(){

        if(this._markup){

          return this._markup;
        };
        var E = qx.bom.element.Decoration;
        var F = this._images;
        var G = this._edges;
        // Create edges and vertical sides
        // Order: tl, t, tr, bl, b, bt, l, c, r
        var H = [];
        // Outer frame
        // Note: Overflow=hidden is needed for Safari 3.1 to omit scrolling through
        // dragging when the cursor is in the text field in Spinners etc.
        H.push(a);
        // Top: left, center, right
        H.push(E.create(F.tl, m, {
          top : 0,
          left : 0
        }));
        H.push(E.create(F.t, o, {
          top : 0,
          left : G.left + l
        }));
        H.push(E.create(F.tr, m, {
          top : 0,
          right : 0
        }));
        // Bottom: left, center, right
        H.push(E.create(F.bl, m, {
          bottom : 0,
          left : 0
        }));
        H.push(E.create(F.b, o, {
          bottom : 0,
          left : G.left + l
        }));
        H.push(E.create(F.br, m, {
          bottom : 0,
          right : 0
        }));
        // Middle: left, center, right
        H.push(E.create(F.l, p, {
          top : G.top + l,
          left : 0
        }));
        H.push(E.create(F.c, g, {
          top : G.top + l,
          left : G.left + l
        }));
        H.push(E.create(F.r, p, {
          top : G.top + l,
          right : 0
        }));
        // Outer frame
        H.push(h);
        // Store
        return this._markup = H.join(x);
      },
      // interface implementation
      resize : function(I, J, K){

        // Compute inner sizes
        var L = this._edges;
        var innerWidth = J - L.left - L.right;
        var innerHeight = K - L.top - L.bottom;
        // Set the inner width or height to zero if negative
        if(innerWidth < 0){

          innerWidth = 0;
        };
        if(innerHeight < 0){

          innerHeight = 0;
        };
        // Update nodes
        I.style.width = J + l;
        I.style.height = K + l;
        I.childNodes[1].style.width = innerWidth + l;
        I.childNodes[4].style.width = innerWidth + l;
        I.childNodes[7].style.width = innerWidth + l;
        I.childNodes[6].style.height = innerHeight + l;
        I.childNodes[7].style.height = innerHeight + l;
        I.childNodes[8].style.height = innerHeight + l;
        if((qx.core.Environment.get(s) == t)){

          // Internet Explorer as of version 6 or version 7 in quirks mode
          // have rounding issues when working with odd dimensions:
          // right and bottom positioned elements are rendered with a
          // one pixel negative offset which results into some ugly
          // render effects.
          if(parseFloat(qx.core.Environment.get(r)) < 7 || (qx.core.Environment.get(d) && parseFloat(qx.core.Environment.get(r)) < 8)){

            if(J % 2 == 1){

              I.childNodes[2].style.marginRight = k;
              I.childNodes[5].style.marginRight = k;
              I.childNodes[8].style.marginRight = k;
            } else {

              I.childNodes[2].style.marginRight = n;
              I.childNodes[5].style.marginRight = n;
              I.childNodes[8].style.marginRight = n;
            };
            if(K % 2 == 1){

              I.childNodes[3].style.marginBottom = k;
              I.childNodes[4].style.marginBottom = k;
              I.childNodes[5].style.marginBottom = k;
            } else {

              I.childNodes[3].style.marginBottom = n;
              I.childNodes[4].style.marginBottom = n;
              I.childNodes[5].style.marginBottom = n;
            };
          };
        };
      },
      // interface implementation
      tint : function(M, N){
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY APPLY ROUTINES
      ---------------------------------------------------------------------------
      */
      // property apply
      _applyBaseImage : function(O, P){

        if(qx.core.Environment.get(B)){

          if(this._markup){

            throw new Error(q);
          };
        };
        if(O){

          var T = this._resolveImageUrl(O);
          var U = /(.*)(\.[a-z]+)$/.exec(T);
          var S = U[1];
          var R = U[2];
          // Store images
          var Q = this._images = {
            tl : S + c + R,
            t : S + e + R,
            tr : S + j + R,
            bl : S + w + R,
            b : S + z + R,
            br : S + f + R,
            l : S + i + R,
            c : S + u + R,
            r : S + b + R
          };
          // Store edges
          this._edges = this._computeEdgeSizes(Q);
        };
      },
      /**
       * Resolve the url of the given image
       *
       * @param image {String} base image URL
       * @return {String} the resolved image URL
       */
      _resolveImageUrl : function(V){

        return qx.util.AliasManager.getInstance().resolve(V);
      },
      /**
       * Returns the sizes of the "top" and "bottom" heights and the "left" and
       * "right" widths of the grid.
       *
       * @param images {Map} Map of image URLs
       * @return {Map} the edge sizes
       */
      _computeEdgeSizes : function(W){

        var X = qx.util.ResourceManager.getInstance();
        return {
          top : X.getImageHeight(W.t),
          bottom : X.getImageHeight(W.b),
          left : X.getImageWidth(W.l),
          right : X.getImageWidth(W.r)
        };
      }
    },
    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct : function(){

      this._markup = this._images = this._edges = null;
    }
  });
})();
(function(){

  var j = "innerWidthRight",i = "top",h = "innerColorBottom",g = "innerWidthTop",f = "innerColorRight",e = "innerColorTop",d = "relative",c = "browser.documentmode",b = "innerColorLeft",a = "",H = "qx.ui.decoration.MDoubleBorder",G = "left",F = "Invalid Double decorator (zero inner border width). Use qx.ui.decoration.Single instead!",E = "engine.version",D = "innerWidthBottom",C = "innerWidthLeft",B = "position",A = "Invalid Double decorator (zero outer border width). Use qx.ui.decoration.Single instead!",z = "absolute",y = "qx.theme",q = "qx.debug",r = "shorthand",o = "line-height",p = "engine.name",m = "mshtml",n = "Color",k = "Number",l = "border-top",s = "border-left",t = "border-bottom",v = "border-right",u = "px ",x = " ",w = '';
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Border implementation with two CSS borders. Both borders can be styled
   * independent of each other.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   */
  qx.Mixin.define(H, {
    include : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBackgroundImage],
    construct : function(){

      // override the methods of single border and background image
      this._getDefaultInsetsForBorder = this.__getDefaultInsetsForDoubleBorder;
      this._resizeBorder = this.__resizeDoubleBorder;
      this._styleBorder = this.__styleDoubleBorder;
      this._generateMarkup = this.__generateMarkupDoubleBorder;
    },
    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties : {
      /*
      ---------------------------------------------------------------------------
        PROPERTY: INNER WIDTH
      ---------------------------------------------------------------------------
      */
      /** top width of border */
      innerWidthTop : {
        check : k,
        init : 0
      },
      /** right width of border */
      innerWidthRight : {
        check : k,
        init : 0
      },
      /** bottom width of border */
      innerWidthBottom : {
        check : k,
        init : 0
      },
      /** left width of border */
      innerWidthLeft : {
        check : k,
        init : 0
      },
      /** Property group to set the inner border width of all sides */
      innerWidth : {
        group : [g, j, D, C],
        mode : r
      },
      /*
      ---------------------------------------------------------------------------
        PROPERTY: INNER COLOR
      ---------------------------------------------------------------------------
      */
      /** top inner color of border */
      innerColorTop : {
        nullable : true,
        check : n
      },
      /** right inner color of border */
      innerColorRight : {
        nullable : true,
        check : n
      },
      /** bottom inner color of border */
      innerColorBottom : {
        nullable : true,
        check : n
      },
      /** left inner color of border */
      innerColorLeft : {
        nullable : true,
        check : n
      },
      /**
       * Property group for the inner color properties.
       */
      innerColor : {
        group : [e, f, h, b],
        mode : r
      }
    },
    members : {
      __ownMarkup : null,
      /**
       * Takes a styles map and adds the inner border styles styles in place
       * to the given map. This is the needed behavior for
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param styles {Map} A map to add the styles.
       */
      __styleDoubleBorder : function(I){

        if(qx.core.Environment.get(y)){

          var K = qx.theme.manager.Color.getInstance();
          var L = K.resolve(this.getInnerColorTop());
          var O = K.resolve(this.getInnerColorRight());
          var M = K.resolve(this.getInnerColorBottom());
          var N = K.resolve(this.getInnerColorLeft());
        } else {

          var L = this.getInnerColorTop();
          var O = this.getInnerColorRight();
          var M = this.getInnerColorBottom();
          var N = this.getInnerColorLeft();
        };
        // Inner styles
        // Inner image must be relative to be compatible with qooxdoo 0.8.x
        // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3450 for details
        I.position = d;
        // Add inner borders
        var J = this.getInnerWidthTop();
        if(J > 0){

          I[l] = J + u + this.getStyleTop() + x + L;
        };
        var J = this.getInnerWidthRight();
        if(J > 0){

          I[v] = J + u + this.getStyleRight() + x + O;
        };
        var J = this.getInnerWidthBottom();
        if(J > 0){

          I[t] = J + u + this.getStyleBottom() + x + M;
        };
        var J = this.getInnerWidthLeft();
        if(J > 0){

          I[s] = J + u + this.getStyleLeft() + x + N;
        };
        if(qx.core.Environment.get(q)){

          if(!I[l] && !I[v] && !I[t] && !I[s]){

            throw new Error(F);
          };
        };
      },
      /**
       * Special generator for the markup which creates the containing div and
       * the sourrounding div as well.
       *
       * @param styles {Map} The styles for the inner
       * @return {String} The generated decorator HTML.
       */
      __generateMarkupDoubleBorder : function(P){

        var T = this._generateBackgroundMarkup(P, this._getContent ? this._getContent() : a);
        if(qx.core.Environment.get(y)){

          var R = qx.theme.manager.Color.getInstance();
          var W = R.resolve(this.getColorTop());
          var S = R.resolve(this.getColorRight());
          var Q = R.resolve(this.getColorBottom());
          var V = R.resolve(this.getColorLeft());
        } else {

          var W = this.getColorTop();
          var S = this.getColorRight();
          var Q = this.getColorBottom();
          var V = this.getColorLeft();
        };
        // get rid of the old borders
        P[l] = w;
        P[v] = w;
        P[t] = w;
        P[s] = w;
        // Generate outer HTML
        P[o] = 0;
        // Do not set the line-height on IE6, IE7, IE8 in Quirks Mode and IE8 in IE7 Standard Mode
        // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3450 for details
        if((qx.core.Environment.get(p) == m && parseFloat(qx.core.Environment.get(E)) < 8) || (qx.core.Environment.get(p) == m && qx.core.Environment.get(c) < 8)){

          P[o] = w;
        };
        var U = this.getWidthTop();
        if(U > 0){

          P[l] = U + u + this.getStyleTop() + x + W;
        };
        var U = this.getWidthRight();
        if(U > 0){

          P[v] = U + u + this.getStyleRight() + x + S;
        };
        var U = this.getWidthBottom();
        if(U > 0){

          P[t] = U + u + this.getStyleBottom() + x + Q;
        };
        var U = this.getWidthLeft();
        if(U > 0){

          P[s] = U + u + this.getStyleLeft() + x + V;
        };
        if(qx.core.Environment.get(q)){

          if(P[l] == w && P[v] == w && P[t] == w && P[s] == w){

            throw new Error(A);
          };
        };
        // final default styles
        P[B] = z;
        P[i] = 0;
        P[G] = 0;
        // Store
        return this.__ownMarkup = this._generateBackgroundMarkup(P, T);
      },
      /**
       * Resize function for the decorator. This is suitable for the
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param element {Element} The element which could be resized.
       * @param width {Number} The new width.
       * @param height {Number} The new height.
       * @return {Map} A map containing the desired position and dimension and a
       *   emelent to resize.
       *   (width, height, top, left, elementToApplyDimensions).
       */
      __resizeDoubleBorder : function(X, Y, ba){

        var bb = this.getInsets();
        Y -= bb.left + bb.right;
        ba -= bb.top + bb.bottom;
        var bc = bb.left - this.getWidthLeft() - this.getInnerWidthLeft();
        var top = bb.top - this.getWidthTop() - this.getInnerWidthTop();
        return {
          left : bc,
          top : top,
          width : Y,
          height : ba,
          elementToApplyDimensions : X.firstChild
        };
      },
      /**
       * Implementation of the interface for the double border.
       *
       * @return {Map} A map containing the default insets.
       *   (top, right, bottom, left)
       */
      __getDefaultInsetsForDoubleBorder : function(){

        return {
          top : this.getWidthTop() + this.getInnerWidthTop(),
          right : this.getWidthRight() + this.getInnerWidthRight(),
          bottom : this.getWidthBottom() + this.getInnerWidthBottom(),
          left : this.getWidthLeft() + this.getInnerWidthLeft()
        };
      }
    }
  });
})();
(function(){

  var q = "box-shadow",p = "This decorator is already in-use. Modification is not possible anymore!",o = "shadowHorizontalLength",n = "Boolean",m = "",l = "-webkit-box-shadow",k = "qx.debug",j = "-moz-box-shadow",i = "qx.theme",h = "shadowVerticalLength",c = "inset ",g = "shorthand",f = "qx.ui.decoration.MBoxShadow",b = "Color",a = "px ",e = "Integer",d = "_applyBoxShadow";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */
  /**
   * Mixin for the box shadow CSS property.
   * This mixin is usually used by {@link qx.ui.decoration.DynamicDecorator}.
   *
   * Keep in mind that this is not supported by all browsers:
   *
   * * Firefox 3,5+
   * * IE9+
   * * Safari 3.0+
   * * Opera 10.5+
   * * Chrome 4.0+
   */
  qx.Mixin.define(f, {
    properties : {
      /** Horizontal length of the shadow. */
      shadowHorizontalLength : {
        nullable : true,
        check : e,
        apply : d
      },
      /** Vertical length of the shadow. */
      shadowVerticalLength : {
        nullable : true,
        check : e,
        apply : d
      },
      /** The blur radius of the shadow. */
      shadowBlurRadius : {
        nullable : true,
        check : e,
        apply : d
      },
      /** The spread radius of the shadow. */
      shadowSpreadRadius : {
        nullable : true,
        check : e,
        apply : d
      },
      /** The color of the shadow. */
      shadowColor : {
        nullable : true,
        check : b,
        apply : d
      },
      /** Inset shadows are drawn inside the border. */
      inset : {
        init : false,
        check : n,
        apply : d
      },
      /** Property group to set the shadow length. */
      shadowLength : {
        group : [o, h],
        mode : g
      }
    },
    members : {
      /**
       * Takes a styles map and adds the box shadow styles in place to the
       * given map. This is the needed behavior for
       * {@link qx.ui.decoration.DynamicDecorator}.
       *
       * @param styles {Map} A map to add the styles.
       */
      _styleBoxShadow : function(r){

        if(qx.core.Environment.get(i)){

          var s = qx.theme.manager.Color.getInstance();
          var v = s.resolve(this.getShadowColor());
        } else {

          var v = this.getShadowColor();
        };
        if(v != null){

          var y = this.getShadowVerticalLength() || 0;
          var t = this.getShadowHorizontalLength() || 0;
          var blur = this.getShadowBlurRadius() || 0;
          var x = this.getShadowSpreadRadius() || 0;
          var w = this.getInset() ? c : m;
          var u = w + t + a + y + a + blur + a + x + a + v;
          r[j] = u;
          r[l] = u;
          r[q] = u;
        };
      },
      // property apply
      _applyBoxShadow : function(){

        if(qx.core.Environment.get(k)){

          if(this._isInitialized()){

            throw new Error(p);
          };
        };
      }
    }
  });
})();
(function(){

  var cM = "checkbox-start",cL = "decoration/tabview/tab-button-top-active.png",cK = "group-background",cJ = "decoration/form/button-c.png",cI = "keyboard-focus",cH = "button-disabled-start",cG = "selected-end",cF = "table-header-hovered",cE = "decoration/groupbox/groupbox.png",cD = "decoration/pane/pane.png",bM = "decoration/menu/background.png",bL = "decoration/tabview/tabview-pane.png",bK = "decoration/toolbar/toolbar-part.gif",bJ = "input-focused-css",bI = "decoration/menu/bar-background.png",bH = "window-border-caption",bG = "radiobutton-hovered",bF = "tooltip-error-css",bE = "radiobutton-checked-focused",bD = "groupitem-end",cT = "button-disabled-css",cU = "group-border",cR = "scrollbar-slider-vertical-css",cS = "window-css",cP = "selected-start",cQ = "window-resize-frame-css",cN = "tabview-end",cO = "window-statusbar-background",cV = "decoration/scrollbar/scrollbar-bg-vertical.png",cW = "button-pressed-css",cm = "toolbar-button-hovered-css",cl = "window-caption-active-end",co = "dotted",cn = "checkbox-disabled-end",cq = "window-caption-active-start",cp = "button-focused",cs = "menu-start",cr = "decoration/form/tooltip-error.png",ck = "window-captionbar-active-css",cj = "qx/decoration/Modern",k = "decoration/tabview/tab-button-right-inactive.png",l = "border-toolbar-separator-left",m = "decoration/form/button-checked.png",n = "decoration/scrollbar/scrollbar-bg-horizontal.png",o = "decoration/tabview/tab-button-left-active.png",p = "decoration/tabview/tab-button-bottom-active.png",q = "decoration/tabview/tab-button-bottom-inactive.png",r = "decoration/form/button-disabled.png",s = "decoration/form/button-pressed.png",t = "background-splitpane",dl = "decoration/form/button-checked-focused.png",dk = "px",dj = "decoration/window/statusbar.png",di = "input-border-disabled",dq = "checkbox-inner",dp = "scrollbar-horizontal-css",dn = "button-disabled-end",dm = "toolbar-end",ds = "groupitem-start",dr = "decoration/form/button-hovered.png",bd = "checkbox-hovered-inner",be = "input-focused-start",bb = "scrollbar-start",bc = "scrollbar-slider-start",bh = "radiobutton-checked-disabled",bi = "checkbox-focused",bf = "qx.theme.modern.Decoration",bg = "decoration/form/button.png",Y = "decoration/app-header.png",ba = "decoration/form/button-focused.png",L = "radiobutton-checked-hovered",K = "button-hovered-css",N = "checkbox-disabled-inner",M = "border-toolbar-separator-right",H = "border-focused",G = "decoration/shadow/shadow.png",J = "scrollbar-end",I = "decoration/group-item.png",F = "window-caption-inactive-end",E = "checkbox-end",bn = "tabview-inactive-end",bo = "input-end",bp = "button-checked-focused-css",bq = "decoration/tabview/tab-button-left-inactive.png",bj = "input-focused-inner-invalid",bk = "menu-separator-top",bl = "window-caption-inactive-start",bm = "scrollbar-slider-end",br = "decoration/window/captionbar-inactive.png",bs = "decoration/tabview/tab-button-top-inactive.png",V = "pane-end",U = "input-focused-end",T = "decoration/form/tooltip-error-arrow.png",S = "menubar-start",R = "toolbar-start",Q = "checkbox-disabled-start",P = "radiobutton-focused",O = "pane-start",X = "table-focus-indicator",W = "button-checked-css",bt = "decoration/form/button-checked-c.png",bu = "menu-separator-bottom",bv = "decoration/shadow/shadow-small.png",bw = "input-start",bx = "decoration/window/captionbar-active.png",by = "decoration/tabview/tab-button-right-active.png",bz = "decoration/toolbar/toolbar-gradient.png",bA = "checkbox-hovered-inner-invalid",bB = "checkbox-disabled-border",bC = "button-hovered-end",bQ = "repeat-y",bP = "border-dragover",bO = "button-hovered-start",bN = "tooltip-error",bU = "progressive-table-header-border-right",bT = "decoration/scrollbar/scrollbar-button-bg-vertical.png",bS = "radiobutton-background",bR = "decoration/form/tooltip-error-arrow-right.png",bW = "checkbox-focus",bV = "scrollbar-slider-horizontal-css",cf = "menu-end",cg = "decoration/selection.png",cd = "horizontal",ce = "table-header-start",cb = "decoration/scrollbar/scrollbar-button-bg-horizontal.png",cc = "decoration/form/input-focused.png",bY = "right",ca = "checkbox-hovered-invalid",ch = "decoration/table/header-cell.png",ci = "tabview-inactive-start",cw = "table-header-end",cv = "border-button",cy = "border-focused-invalid",cx = "button-focused-css",cA = "checkbox-border",cz = "tabview-start",cC = "radiobutton-disabled",cB = "radiobutton-hovered-invalid",cu = "tabview-page-button-top-active-css",ct = "button-border-disabled",de = "tabview-page-button-top-inactive-css",df = "decoration/form/input.png",dg = "border-toolbar-border-inner",dh = "input-css",da = "border-toolbar-button-outer",db = "top",dc = "border-disabled",dd = "background-pane",cX = "no-repeat",cY = "border-input",j = "border-inner-input",i = "border-inner-scrollbar",h = "radiobutton-checked",g = "window-border",f = "tabview-inactive",e = "checkbox",d = "radiobutton",c = "button-css",b = "border-separator",a = "checkbox-hovered",w = "button-start",x = "button-end",u = "background-light",v = "tabview-background",A = "repeat-x",B = "shadow",y = "border-invalid",z = "border-main",C = "scale",D = "solid",bX = "invalid";
  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
       2006 STZ-IDA, Germany, http://www.stz-ida.de
  
     License:
       LGPL: http://www.gnu.org/licenses/lgpl.html
       EPL: http://www.eclipse.org/org/documents/epl-v10.php
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Fabian Jakobs (fjakobs)
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Alexander Steitz (aback)
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */
  /* ************************************************************************
  
  #asset(qx/decoration/Modern/*)
  
  ************************************************************************ */
  /**
   * The modern decoration theme.
   */
  qx.Theme.define(bf, {
    aliases : {
      decoration : cj
    },
    decorations : {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "main" : {
        decorator : qx.ui.decoration.Uniform,
        style : {
          width : 1,
          color : z
        }
      },
      "selected" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : cg,
          backgroundRepeat : C
        }
      },
      "selected-css" : {
        decorator : [qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          startColorPosition : 0,
          endColorPosition : 100,
          startColor : cP,
          endColor : cG
        }
      },
      "selected-dragover" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundImage : cg,
          backgroundRepeat : C,
          bottom : [2, D, bP]
        }
      },
      "dragover" : {
        decorator : qx.ui.decoration.Single,
        style : {
          bottom : [2, D, bP]
        }
      },
      "pane" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : cD,
          insets : [0, 2, 3, 0]
        }
      },
      "pane-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MBoxShadow, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          width : 1,
          color : v,
          radius : 3,
          shadowColor : B,
          shadowBlurRadius : 2,
          shadowLength : 0,
          gradientStart : [O, 0],
          gradientEnd : [V, 100]
        }
      },
      "group" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : cE
        }
      },
      "group-css" : {
        decorator : [qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MSingleBorder],
        style : {
          backgroundColor : cK,
          radius : 4,
          color : cU,
          width : 1
        }
      },
      "border-invalid" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : bX,
          innerColor : j,
          innerOpacity : 0.5,
          backgroundImage : df,
          backgroundRepeat : A,
          backgroundColor : u
        }
      },
      "keyboard-focus" : {
        decorator : qx.ui.decoration.Single,
        style : {
          width : 1,
          color : cI,
          style : co
        }
      },
      /*
      ---------------------------------------------------------------------------
        CSS RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton" : {
        decorator : [qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MBoxShadow],
        style : {
          backgroundColor : bS,
          radius : 5,
          width : 1,
          innerWidth : 2,
          color : cA,
          innerColor : bS,
          shadowLength : 0,
          shadowBlurRadius : 0,
          shadowColor : bW,
          insetLeft : 5
        }
      },
      "radiobutton-checked" : {
        include : d,
        style : {
          backgroundColor : h
        }
      },
      "radiobutton-checked-focused" : {
        include : h,
        style : {
          shadowBlurRadius : 4
        }
      },
      "radiobutton-checked-hovered" : {
        include : h,
        style : {
          innerColor : a
        }
      },
      "radiobutton-focused" : {
        include : d,
        style : {
          shadowBlurRadius : 4
        }
      },
      "radiobutton-hovered" : {
        include : d,
        style : {
          backgroundColor : a,
          innerColor : a
        }
      },
      "radiobutton-disabled" : {
        include : d,
        style : {
          innerColor : cC,
          backgroundColor : cC,
          color : bB
        }
      },
      "radiobutton-checked-disabled" : {
        include : cC,
        style : {
          backgroundColor : bh
        }
      },
      "radiobutton-invalid" : {
        include : d,
        style : {
          color : bX
        }
      },
      "radiobutton-checked-invalid" : {
        include : h,
        style : {
          color : bX
        }
      },
      "radiobutton-checked-focused-invalid" : {
        include : bE,
        style : {
          color : bX,
          shadowColor : bX
        }
      },
      "radiobutton-checked-hovered-invalid" : {
        include : L,
        style : {
          color : bX,
          innerColor : cB
        }
      },
      "radiobutton-focused-invalid" : {
        include : P,
        style : {
          color : bX,
          shadowColor : bX
        }
      },
      "radiobutton-hovered-invalid" : {
        include : bG,
        style : {
          color : bX,
          innerColor : cB,
          backgroundColor : cB
        }
      },
      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthLeft : 1,
          colorLeft : b
        }
      },
      "separator-vertical" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthTop : 1,
          colorTop : b
        }
      },
      /*
      ---------------------------------------------------------------------------
        TOOLTIP
      ---------------------------------------------------------------------------
      */
      "tooltip-error" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : cr,
          insets : [2, 0, 2, 2]
        }
      },
      "tooltip-error-css" : {
        decorator : [qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MBoxShadow],
        style : {
          backgroundColor : bN,
          radius : 4,
          shadowColor : B,
          shadowBlurRadius : 2,
          shadowLength : 1,
          insets : [2, 0, 0, 2]
        }
      },
      "tooltip-error-left" : {
        include : bN,
        style : {
          insets : [2, 5, 5, 2]
        }
      },
      "tooltip-error-css-left" : {
        include : bF,
        style : {
          insets : [-1, 0, 0, -2]
        }
      },
      "tooltip-error-arrow" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : T,
          backgroundPositionY : db,
          backgroundRepeat : cX,
          insets : [-4, 0, 0, 13]
        }
      },
      "tooltip-error-arrow-left" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : bR,
          backgroundPositionY : db,
          backgroundPositionX : bY,
          backgroundRepeat : cX,
          insets : [-4, -13, 0, 0]
        }
      },
      "tooltip-error-arrow-left-css" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : bR,
          backgroundPositionY : db,
          backgroundPositionX : bY,
          backgroundRepeat : cX,
          insets : [-6, -13, 0, 0]
        }
      },
      /*
      ---------------------------------------------------------------------------
        SHADOWS
      ---------------------------------------------------------------------------
      */
      "shadow-window" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : G,
          insets : [0, 8, 8, 0]
        }
      },
      "shadow-window-css" : {
        decorator : [qx.ui.decoration.MBoxShadow, qx.ui.decoration.MBackgroundColor],
        style : {
          shadowColor : B,
          shadowBlurRadius : 2,
          shadowLength : 1
        }
      },
      "shadow-popup" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bv,
          insets : [0, 3, 3, 0]
        }
      },
      "popup-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBoxShadow, qx.ui.decoration.MBackgroundColor],
        style : {
          width : 1,
          color : z,
          shadowColor : B,
          shadowBlurRadius : 3,
          shadowLength : 1
        }
      },
      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar-horizontal" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : n,
          backgroundRepeat : A
        }
      },
      "scrollbar-vertical" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : cV,
          backgroundRepeat : bQ
        }
      },
      "scrollbar-slider-horizontal" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          backgroundImage : cb,
          backgroundRepeat : C,
          outerColor : z,
          innerColor : i,
          innerOpacity : 0.5
        }
      },
      "scrollbar-slider-horizontal-disabled" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          backgroundImage : cb,
          backgroundRepeat : C,
          outerColor : dc,
          innerColor : i,
          innerOpacity : 0.3
        }
      },
      "scrollbar-slider-vertical" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          backgroundImage : bT,
          backgroundRepeat : C,
          outerColor : z,
          innerColor : i,
          innerOpacity : 0.5
        }
      },
      "scrollbar-slider-vertical-disabled" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          backgroundImage : bT,
          backgroundRepeat : C,
          outerColor : dc,
          innerColor : i,
          innerOpacity : 0.3
        }
      },
      // PLAIN CSS SCROLLBAR
      "scrollbar-horizontal-css" : {
        decorator : [qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          gradientStart : [bb, 0],
          gradientEnd : [J, 100]
        }
      },
      "scrollbar-vertical-css" : {
        include : dp,
        style : {
          orientation : cd
        }
      },
      "scrollbar-slider-horizontal-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          gradientStart : [bc, 0],
          gradientEnd : [bm, 100],
          color : z,
          width : 1
        }
      },
      "scrollbar-slider-vertical-css" : {
        include : bV,
        style : {
          orientation : cd
        }
      },
      "scrollbar-slider-horizontal-disabled-css" : {
        include : bV,
        style : {
          color : ct
        }
      },
      "scrollbar-slider-vertical-disabled-css" : {
        include : cR,
        style : {
          color : ct
        }
      },
      /*
      ---------------------------------------------------------------------------
        PLAIN CSS BUTTON
      ---------------------------------------------------------------------------
      */
      "button-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBorderRadius],
        style : {
          radius : 3,
          color : cv,
          width : 1,
          startColor : w,
          endColor : x,
          startColorPosition : 35,
          endColorPosition : 100
        }
      },
      "button-disabled-css" : {
        include : c,
        style : {
          color : ct,
          startColor : cH,
          endColor : dn
        }
      },
      "button-hovered-css" : {
        include : c,
        style : {
          startColor : bO,
          endColor : bC
        }
      },
      "button-checked-css" : {
        include : c,
        style : {
          endColor : w,
          startColor : x
        }
      },
      "button-pressed-css" : {
        include : c,
        style : {
          endColor : bO,
          startColor : bC
        }
      },
      "button-focused-css" : {
        decorator : [qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBorderRadius],
        style : {
          radius : 3,
          color : cv,
          width : 1,
          innerColor : cp,
          innerWidth : 2,
          startColor : w,
          endColor : x,
          startColorPosition : 30,
          endColorPosition : 100
        }
      },
      "button-checked-focused-css" : {
        include : cx,
        style : {
          endColor : w,
          startColor : x
        }
      },
      // invalid
      "button-invalid-css" : {
        include : c,
        style : {
          color : y
        }
      },
      "button-disabled-invalid-css" : {
        include : cT,
        style : {
          color : y
        }
      },
      "button-hovered-invalid-css" : {
        include : K,
        style : {
          color : y
        }
      },
      "button-checked-invalid-css" : {
        include : W,
        style : {
          color : y
        }
      },
      "button-pressed-invalid-css" : {
        include : cW,
        style : {
          color : y
        }
      },
      "button-focused-invalid-css" : {
        include : cx,
        style : {
          color : y
        }
      },
      "button-checked-focused-invalid-css" : {
        include : bp,
        style : {
          color : y
        }
      },
      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bg,
          insets : 2
        }
      },
      "button-disabled" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : r,
          insets : 2
        }
      },
      "button-focused" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : ba,
          insets : 2
        }
      },
      "button-hovered" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : dr,
          insets : 2
        }
      },
      "button-pressed" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : s,
          insets : 2
        }
      },
      "button-checked" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : m,
          insets : 2
        }
      },
      "button-checked-focused" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : dl,
          insets : 2
        }
      },
      "button-invalid-shadow" : {
        decorator : qx.ui.decoration.Single,
        style : {
          color : bX,
          width : 1,
          insets : 0
        }
      },
      /*
      ---------------------------------------------------------------------------
        CHECKBOX
      ---------------------------------------------------------------------------
      */
      "checkbox-invalid-shadow" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : bX,
          innerColor : cy,
          insets : [0]
        }
      },
      /*
      ---------------------------------------------------------------------------
        PLAIN CSS CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox" : {
        decorator : [qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBoxShadow],
        style : {
          width : 1,
          color : cA,
          innerWidth : 1,
          innerColor : dq,
          gradientStart : [cM, 0],
          gradientEnd : [E, 100],
          shadowLength : 0,
          shadowBlurRadius : 0,
          shadowColor : bW,
          insetLeft : 4
        }
      },
      "checkbox-hovered" : {
        include : e,
        style : {
          innerColor : bd,
          // use the same color to get a single colored background
          gradientStart : [a, 0],
          gradientEnd : [a, 100]
        }
      },
      "checkbox-focused" : {
        include : e,
        style : {
          shadowBlurRadius : 4
        }
      },
      "checkbox-disabled" : {
        include : e,
        style : {
          color : bB,
          innerColor : N,
          gradientStart : [Q, 0],
          gradientEnd : [cn, 100]
        }
      },
      "checkbox-invalid" : {
        include : e,
        style : {
          color : bX
        }
      },
      "checkbox-hovered-invalid" : {
        include : a,
        style : {
          color : bX,
          innerColor : bA,
          gradientStart : [ca, 0],
          gradientEnd : [ca, 100]
        }
      },
      "checkbox-focused-invalid" : {
        include : bi,
        style : {
          color : bX,
          shadowColor : bX
        }
      },
      /*
      ---------------------------------------------------------------------------
        PLAIN CSS TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "input-css" : {
        decorator : [qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBackgroundColor],
        style : {
          color : cY,
          innerColor : j,
          innerWidth : 1,
          width : 1,
          backgroundColor : u,
          startColor : bw,
          endColor : bo,
          startColorPosition : 0,
          endColorPosition : 12,
          colorPositionUnit : dk
        }
      },
      "border-invalid-css" : {
        include : dh,
        style : {
          color : y
        }
      },
      "input-focused-css" : {
        include : dh,
        style : {
          startColor : be,
          innerColor : U,
          endColorPosition : 4
        }
      },
      "input-focused-invalid-css" : {
        include : bJ,
        style : {
          innerColor : bj,
          color : y
        }
      },
      "input-disabled-css" : {
        include : dh,
        style : {
          color : di
        }
      },
      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "input" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : cY,
          innerColor : j,
          innerOpacity : 0.5,
          backgroundImage : df,
          backgroundRepeat : A,
          backgroundColor : u
        }
      },
      "input-focused" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : cY,
          innerColor : H,
          backgroundImage : cc,
          backgroundRepeat : A,
          backgroundColor : u
        }
      },
      "input-focused-invalid" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : bX,
          innerColor : cy,
          backgroundImage : cc,
          backgroundRepeat : A,
          backgroundColor : u,
          insets : [2]
        }
      },
      "input-disabled" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : dc,
          innerColor : j,
          innerOpacity : 0.5,
          backgroundImage : df,
          backgroundRepeat : A,
          backgroundColor : u
        }
      },
      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : bz,
          backgroundRepeat : C
        }
      },
      "toolbar-css" : {
        decorator : [qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          startColorPosition : 40,
          endColorPosition : 60,
          startColor : R,
          endColor : dm
        }
      },
      "toolbar-button-hovered" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : da,
          innerColor : dg,
          backgroundImage : cJ,
          backgroundRepeat : C
        }
      },
      "toolbar-button-checked" : {
        decorator : qx.ui.decoration.Beveled,
        style : {
          outerColor : da,
          innerColor : dg,
          backgroundImage : bt,
          backgroundRepeat : C
        }
      },
      "toolbar-button-hovered-css" : {
        decorator : [qx.ui.decoration.MDoubleBorder, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBorderRadius],
        style : {
          color : da,
          width : 1,
          innerWidth : 1,
          innerColor : dg,
          radius : 2,
          gradientStart : [w, 30],
          gradientEnd : [x, 100]
        }
      },
      "toolbar-button-checked-css" : {
        include : cm,
        style : {
          gradientStart : [x, 30],
          gradientEnd : [w, 100]
        }
      },
      "toolbar-separator" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthLeft : 1,
          widthRight : 1,
          colorLeft : l,
          colorRight : M,
          styleLeft : D,
          styleRight : D
        }
      },
      "toolbar-part" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : bK,
          backgroundRepeat : bQ
        }
      },
      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview-pane" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bL,
          insets : [4, 6, 7, 4]
        }
      },
      "tabview-pane-css" : {
        decorator : [qx.ui.decoration.MBorderRadius, qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MSingleBorder],
        style : {
          width : 1,
          color : g,
          radius : 3,
          gradientStart : [cz, 90],
          gradientEnd : [cN, 100]
        }
      },
      "tabview-page-button-top-active" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : cL
        }
      },
      "tabview-page-button-top-inactive" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bs
        }
      },
      "tabview-page-button-bottom-active" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : p
        }
      },
      "tabview-page-button-bottom-inactive" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : q
        }
      },
      "tabview-page-button-left-active" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : o
        }
      },
      "tabview-page-button-left-inactive" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bq
        }
      },
      "tabview-page-button-right-active" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : by
        }
      },
      "tabview-page-button-right-inactive" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : k
        }
      },
      // CSS TABVIEW BUTTONS
      "tabview-page-button-top-active-css" : {
        decorator : [qx.ui.decoration.MBorderRadius, qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MBoxShadow],
        style : {
          radius : [3, 3, 0, 0],
          width : [1, 1, 0, 1],
          color : v,
          backgroundColor : cz,
          shadowLength : 1,
          shadowColor : B,
          shadowBlurRadius : 2
        }
      },
      "tabview-page-button-top-inactive-css" : {
        decorator : [qx.ui.decoration.MBorderRadius, qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          radius : [3, 3, 0, 0],
          color : f,
          colorBottom : v,
          width : 1,
          gradientStart : [ci, 0],
          gradientEnd : [bn, 100]
        }
      },
      "tabview-page-button-bottom-active-css" : {
        include : cu,
        style : {
          radius : [0, 0, 3, 3],
          width : [0, 1, 1, 1],
          backgroundColor : ci
        }
      },
      "tabview-page-button-bottom-inactive-css" : {
        include : de,
        style : {
          radius : [0, 0, 3, 3],
          width : [0, 1, 1, 1],
          colorBottom : f,
          colorTop : v
        }
      },
      "tabview-page-button-left-active-css" : {
        include : cu,
        style : {
          radius : [3, 0, 0, 3],
          width : [1, 0, 1, 1],
          shadowLength : 0,
          shadowBlurRadius : 0
        }
      },
      "tabview-page-button-left-inactive-css" : {
        include : de,
        style : {
          radius : [3, 0, 0, 3],
          width : [1, 0, 1, 1],
          colorBottom : f,
          colorRight : v
        }
      },
      "tabview-page-button-right-active-css" : {
        include : cu,
        style : {
          radius : [0, 3, 3, 0],
          width : [1, 1, 1, 0],
          shadowLength : 0,
          shadowBlurRadius : 0
        }
      },
      "tabview-page-button-right-inactive-css" : {
        include : de,
        style : {
          radius : [0, 3, 3, 0],
          width : [1, 1, 1, 0],
          colorBottom : f,
          colorLeft : v
        }
      },
      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane" : {
        decorator : qx.ui.decoration.Uniform,
        style : {
          backgroundColor : dd,
          width : 3,
          color : t,
          style : D
        }
      },
      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundColor : dd,
          width : 1,
          color : z,
          widthTop : 0
        }
      },
      "window-captionbar-active" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : bx
        }
      },
      "window-captionbar-inactive" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : br
        }
      },
      "window-statusbar" : {
        decorator : qx.ui.decoration.Grid,
        style : {
          baseImage : dj
        }
      },
      // CSS WINDOW
      "window-css" : {
        decorator : [qx.ui.decoration.MBorderRadius, qx.ui.decoration.MBoxShadow, qx.ui.decoration.MSingleBorder],
        style : {
          radius : [5, 5, 0, 0],
          shadowBlurRadius : 4,
          shadowLength : 2,
          shadowColor : B
        }
      },
      "window-incl-statusbar-css" : {
        include : cS,
        style : {
          radius : [5, 5, 5, 5]
        }
      },
      "window-resize-frame-css" : {
        decorator : [qx.ui.decoration.MBorderRadius, qx.ui.decoration.MSingleBorder],
        style : {
          radius : [5, 5, 0, 0],
          width : 1,
          color : z
        }
      },
      "window-resize-frame-incl-statusbar-css" : {
        include : cQ,
        style : {
          radius : [5, 5, 5, 5]
        }
      },
      "window-captionbar-active-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBorderRadius, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          width : 1,
          color : g,
          colorBottom : bH,
          radius : [5, 5, 0, 0],
          gradientStart : [cq, 30],
          gradientEnd : [cl, 70]
        }
      },
      "window-captionbar-inactive-css" : {
        include : ck,
        style : {
          gradientStart : [bl, 30],
          gradientEnd : [F, 70]
        }
      },
      "window-statusbar-css" : {
        decorator : [qx.ui.decoration.MBackgroundColor, qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBorderRadius],
        style : {
          backgroundColor : cO,
          width : [0, 1, 1, 1],
          color : g,
          radius : [0, 0, 5, 5]
        }
      },
      "window-pane-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MBackgroundColor],
        style : {
          backgroundColor : dd,
          width : 1,
          color : g,
          widthTop : 0
        }
      },
      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table" : {
        decorator : qx.ui.decoration.Single,
        style : {
          width : 1,
          color : z,
          style : D
        }
      },
      "table-statusbar" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthTop : 1,
          colorTop : z,
          style : D
        }
      },
      "table-scroller-header" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundImage : ch,
          backgroundRepeat : C,
          widthBottom : 1,
          colorBottom : z,
          style : D
        }
      },
      "table-scroller-header-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          gradientStart : [ce, 10],
          gradientEnd : [cw, 90],
          widthBottom : 1,
          colorBottom : z
        }
      },
      "table-header-cell" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthRight : 1,
          colorRight : b,
          styleRight : D
        }
      },
      "table-header-cell-hovered" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthRight : 1,
          colorRight : b,
          styleRight : D,
          widthBottom : 1,
          colorBottom : cF,
          styleBottom : D
        }
      },
      "table-scroller-focus-indicator" : {
        decorator : qx.ui.decoration.Single,
        style : {
          width : 2,
          color : X,
          style : D
        }
      },
      /*
      ---------------------------------------------------------------------------
        PROGRESSIVE
      ---------------------------------------------------------------------------
      */
      "progressive-table-header" : {
        decorator : qx.ui.decoration.Single,
        style : {
          width : 1,
          color : z,
          style : D
        }
      },
      "progressive-table-header-cell" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundImage : ch,
          backgroundRepeat : C,
          widthRight : 1,
          colorRight : bU,
          style : D
        }
      },
      "progressive-table-header-cell-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          gradientStart : [ce, 10],
          gradientEnd : [cw, 90],
          widthRight : 1,
          colorRight : bU
        }
      },
      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundImage : bM,
          backgroundRepeat : C,
          width : 1,
          color : z,
          style : D
        }
      },
      "menu-css" : {
        decorator : [qx.ui.decoration.MLinearBackgroundGradient, qx.ui.decoration.MBoxShadow, qx.ui.decoration.MSingleBorder],
        style : {
          gradientStart : [cs, 0],
          gradientEnd : [cf, 100],
          shadowColor : B,
          shadowBlurRadius : 2,
          shadowLength : 1,
          width : 1,
          color : z
        }
      },
      "menu-separator" : {
        decorator : qx.ui.decoration.Single,
        style : {
          widthTop : 1,
          colorTop : bk,
          widthBottom : 1,
          colorBottom : bu
        }
      },
      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar" : {
        decorator : qx.ui.decoration.Single,
        style : {
          backgroundImage : bI,
          backgroundRepeat : C,
          width : 1,
          color : b,
          style : D
        }
      },
      "menubar-css" : {
        decorator : [qx.ui.decoration.MSingleBorder, qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          gradientStart : [S, 0],
          gradientEnd : [cf, 100],
          width : 1,
          color : b
        }
      },
      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : Y,
          backgroundRepeat : C
        }
      },
      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar" : {
        decorator : qx.ui.decoration.Single,
        style : {
          width : 1,
          color : cY
        }
      },
      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "group-item" : {
        decorator : qx.ui.decoration.Background,
        style : {
          backgroundImage : I,
          backgroundRepeat : C
        }
      },
      "group-item-css" : {
        decorator : [qx.ui.decoration.MLinearBackgroundGradient],
        style : {
          startColorPosition : 0,
          endColorPosition : 100,
          startColor : ds,
          endColor : bD
        }
      }
    }
  });
})();
(function(){

  var a = "dicomheaderview.theme.Decoration";
  /* ************************************************************************
  
     Copyright:
  
     License:
  
     Authors:
  
  ************************************************************************ */
  qx.Theme.define(a, {
    extend : qx.theme.modern.Decoration,
    decorations : {
    }
  });
})();
(function(){

  var a = "dicomheaderview.theme.Theme";
  /* ************************************************************************
  
     Copyright:
  
     License:
  
     Authors:
  
  ************************************************************************ */
  qx.Theme.define(a, {
    meta : {
      color : dicomheaderview.theme.Color,
      decoration : dicomheaderview.theme.Decoration,
      font : dicomheaderview.theme.Font,
      icon : qx.theme.icon.Tango,
      appearance : dicomheaderview.theme.Appearance
    }
  });
})();

qx.$$loader.init();

